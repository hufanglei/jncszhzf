window.Geo = {
    checkAKUrl: "http://localhost:8080/userlicense/checkLicense.do",//验证appkey的接口地址
    useAK: false,//是否启用验证appkey
    singleFile: true
};


//装载GeoSurfJSAPI库文件
(function(){
    /**
     * Namespace: Geo
     * Geo 是整个 GeoGlobeSDK 地图 API 的命名空间，本手册中介绍的所有类和对象都通过 Geo.XXX 的方式调用。
     * 如创建一个 LonLat 对象：new Geo.LonLat(121.123458,34.534227)。
     */
    window.Geo = window.Geo || {};
    window.Geo.Service = {};
    window.Geo.Query = {};
    window.Geo.Tdt = {};	
    window.Geo.Math = {};
    window.Geo.Analysis = {};
    window.Geo.View2D = {};
    window.Geo.View2D.Control = OpenLayers.Control;    
    window.Geo.View3D = {};
    window.Geo.View3D.Event = {};
    //基本类型对象
    window.Geo.Bounds = OpenLayers.Bounds;
    window.Geo.Class = OpenLayers.Class;
    window.Geo.LonLat = OpenLayers.LonLat;
    window.Geo.Pixel = OpenLayers.Pixel;
    window.Geo.Size = OpenLayers.Size;
    window.Geo.Element = OpenLayers.Element;
	window.Geo.Date = OpenLayers.Date;
	//基类
    window.Geo.Feature = OpenLayers.Feature;
    window.Geo.Filter = OpenLayers.Filter;
    window.Geo.Format = OpenLayers.Format;
    window.Geo.Geometry = OpenLayers.Geometry;
    window.Geo.View2D.Handler = OpenLayers.Handler;
    window.Geo.View2D.Layer = OpenLayers.Layer;
    window.Geo.View2D.Popup = OpenLayers.Popup;
    window.Geo.Protocol = OpenLayers.Protocol;
    window.Geo.Request = OpenLayers.Request;
    window.Geo.Strategy = OpenLayers.Strategy;
    window.Geo.Symbolizer = OpenLayers.Symbolizer;
    window.Geo.View2D.Tile = OpenLayers.Tile;
    window.Geo.View2D.Icon = OpenLayers.Icon;
    window.Geo.Projection = OpenLayers.Projection;
    window.Geo.Rule = OpenLayers.Rule;
    window.Geo.Style = OpenLayers.Style;
    window.Geo.Style2 = OpenLayers.Style2;
    window.Geo.StyleMap = OpenLayers.StyleMap;
	window.Geo.Marker = OpenLayers.Marker;
	window.Geo.Event  = OpenLayers.Event;
	window.Geo.Events  = OpenLayers.Events;
	window.Geo.Util  = OpenLayers.Util;
	window.Geo.Console  = OpenLayers.Console;
	window.Geo.Lang  = OpenLayers.Lang;
	window.Geo.Kinetic  = OpenLayers.Kinetic;
	//Geo.View2D.Event已废弃，由Geo.Event取代
    window.Geo.View2D.Event = OpenLayers.Event;
	//Geo.View2D.Events已废弃，由Geo.Events取代
    window.Geo.View2D.Events = OpenLayers.Events;
	//BaseTypes.js中的基本对象类
	window.Geo.String = OpenLayers.String;
	window.Geo.Number = OpenLayers.Number;
	window.Geo.Function = OpenLayers.Function;
	window.Geo.Array = OpenLayers.Array;
	
	/**
	 * Method: getScriptArg
	 * 获取script src的参数。
	 * 
	 * Parameters:
	 * key - {String} 参数键。
	 * 
	 * Returns:
	 * {String} 参数键对应的值。
	 */
	Geo.getScriptArg = function(key){
	    var scripts = document.getElementsByTagName("script");
	    var script = scripts[scripts.length-1];
	    var src = script.src;
	    return (src.match(new RegExp("(?:\\?|&)"+key+"=(.*?)(?=&|$)"))||['',null])[1];
	};
	
	/**
	 * Method: checkAppKey
	 * 获取GeoGlobeJSAPI脚本文件名库脚本文件所在路径。
	 * 
	 * Parameters:
	 * appSrvUrl - {String} 应用服务器。
	 * appKey - {String} 24位授权码。
	 * 
	 * Returns:
	 * {String} GeoGlobeJSAPI脚本文件所在路径。
	 */
	Geo.checkAppKey = function(deployinfo, appKey){
		var result = null;
		//检测服务地址 checkLicense.do
		var url = Geo.checkAKUrl;//"http://localhost:8080/userlicense/checkLicense.do";
		var params = {
			appkey: appKey,
			deployinfo: deployinfo
		};
		var xhr = OpenLayers.Request.GET({
            url: url,
			params: params,
            scope: this,
			async: false,
            success: function(json){
				result = new OpenLayers.Format.JSON().read(json.responseText);
            }
        });
        return result;
	};
	
	
	//是否检测授权码。
	if(Geo.useAK === undefined){
		Geo.useAK = false;
	}
	//获取script src的参数appkey
	Geo.appkey = Geo.getScriptArg("appkey");
	if(Geo.useAK && Geo.appkey !== "skeletonkey"){
		var appSrvUrl = window.location.protocol + "//" + window.location.host + window.location.pathname;//"http://192.168.42.146/datace/"; 
		var appKey = Geo.appkey;//"az92KtDk7S9ZC6bm8qd08V81";
		var result = Geo.checkAppKey(appSrvUrl, appKey);
		//检测失败，提示授权失败，API不可用。
		if(result.result === false){
			window.OpenLayers = null;
			window.Geo = null;
			alert(result.msg);
			return;
		}
	}
	
    if (!Geo.singleFile) {
	    //导入js文件库
	    var scriptName = "GeoGlobeJSAPI.js";
	    var jsfiles = [
			"Animator.js",
			"AnimateZoomer.js",
	        "Util.js", 
			"Pyramid.js", 
			"SymbolizerManager.js", 
			"GeoMarker.js", 
			"hotfix_ol2_13.js",
			"Util/Uuid.js",
			"Util/Heatmap.js",
			"Util/Format/BusCapabilities.js",
			"Util/Format/GlobeTileCapabilities.js",
			"Util/Format/Pyramid.js",
	        "Util/Format/XML2JSON.js",
	        "Util/Format/X2JS.js",
	        "Util/Format/VwmtsGetVersionInfo.js",
	        "Util/Format/VwmtsGetVersions.js",
			"Util/Format/VWMTSCapabilities.v1_0_0.js",
			"Util/Format/MapServiceQuery.js",
			"Util/Format/GeoTextFeatures.js",
			"Util/Format/WMTS.js",
			"Util/Format/WMS.js",
			"Util/Format/GeoWMTS.js",
			"Util/GeoAvoidObject.js",
			"Util/GeoPreAvoidContainer.js",
			"Util/ConfigHanlder.js",
			
			"View2D/Map.js", 
			"View2D/Tile/TileFeature.js",
			"View2D/Layer/CWMS.js",
			"View2D/Layer/GlobeTile.js",
			"View2D/Layer/GeoWMTS.js",
			"View2D/Layer/DynamicMapService.js",
			"View2D/Layer/TileMapService.js",
			"View2D/Layer/GeoMarkers.js",
			"View2D/Layer/ArcGISTileLayer.js",
			"View2D/Layer/Buildings.js",
			"View2D/Layer/GeoThematicLayer.js",
			"View2D/Layer/HeatMapLayer.js",
			"View2D/Layer/ThematicTile.js",
			"View2D/Layer/GeoText.js",
			"View2D/Layer/HotareaWMTS.js",
			"ZRender/zrender.js",
			"View2D/Layer/HoneycombLayer.js",
	        "View2D/BaseLayerGroup.js", 
			"View2D/LayerGroup.js", 
			"View2D/FeatureManager.js", 
			"View2D/MarkerTag.js", 
			"View2D/Control/DrawCircle.js", 
			"View2D/Control/DrawPath.js", 
			"View2D/Control/DrawPoint.js", 
			"View2D/Control/DrawPolygon.js", 
			"View2D/Control/DrawRectangle.js",
			"View2D/Control/MagnifyingGlass.js",
			"View2D/Control/GeoPanZoom.js",
			"View2D/Control/PanZoomBarTitle.js",
			"View2D/Control/GeoOverviewMap.js",
			"View2D/Control/GeoSelectFeature.js",
			"View2D/Control/ZoomBar.js",
			"View2D/Control/MouseClick.js",
			"View2D/Control/MouseDrag.js",
			"View2D/Control/Measure/AreaMeasure.js",
			"View2D/Control/Measure/DistanceMeasure.js",
			"View2D/Control/Measure/Angle.js",
			"View2D/Control/Measure/AngleMeasure.js",
			"View2D/Control/MapContextMenu.js",
			"View2D/Control/TimeSlider.js",
			"View2D/Control/PrintMap.js",
			"View2D/Control/ShutterView.js",
			"View2D/MenuItem.js",
			"View2D/TemporalRenderer.js",
			"View2D/ChartContainer.js",
			"View2D/Popup/GeoFrameCloud.js",
		/*
	        "ViewFl/swfobject.js",
	        "ViewFl/Map.js",
	        "ViewFl/Layer.js",
	        "ViewFl/Layer/GlobeTile.js",
			"ViewFl/Layer/WMTS.js",
			"ViewFl/Layer/WMS.js",
	        "ViewFl/Layer/Vector.js",
	        "ViewFl/BaseLayerGroup.js",
			"ViewFl/Handler.js",
	        "ViewFl/Handler/Point.js",
	        "ViewFl/Handler/Path.js",
	        "ViewFl/Handler/Polygon.js",
			"ViewFl/Handler/Click.js",
	        "ViewFl/Control.js",
	        "ViewFl/Control/Navigation.js",
	        "ViewFl/Control/PanZoom.js",
	        "ViewFl/Control/PanZoomBar.js",
	        "ViewFl/Control/ScaleLine.js",
	        "ViewFl/Control/MousePosition.js",
	        "ViewFl/Control/OverviewMap.js",
	        "ViewFl/Control/DrawFeature.js",
	        "ViewFl/Control/LayerScroll.js",
	        "ViewFl/Control/Measure.js",
	        "ViewFl/Control/SelectFeature.js",
	        "ViewFl/Control/ModifyFeature.js",
			"ViewFl/Control/ZoomBox.js",
			"ViewFl/Control/Mouse.js",
			"ViewFl/Control/SituationControl.js",
			"ViewFl/Control/GeoLayerManager.js",
			"ViewFl/Control/MeasureToolControl.js",
	        "ViewFl/Popup.js",
			"ViewFl/PopupFl.js",
			"ViewFl/Popup/Anchored.js",
			"ViewFl/Popup/AnchoredBubble.js",
			"ViewFl/Popup/Framed.js",
	        "ViewFl/Popup/FramedCloud.js",
			"ViewFl/Popup/FramedCloudFl.js",
		*/
			"View3D/Map.js", 
			"View3D/Layer.js", 
	        "View3D/BaseLayerGroup.js",
			"View3D/LayerGroup.js", 
			"View3D/Layer/GlobeTile.js", 
			"View3D/Layer/ArcgisRest.js",
			"View3D/Layer/Shape.js", 
			"View3D/Layer/Terrain.js", 
			"View3D/Layer/Vector.js", 
			"View3D/Layer/WMS.js", 
			"View3D/Layer/WMTS.js", 
			"View3D/Layer/WFS.js", 
			"View3D/Layer/WTFS.js", 
	        "View3D/Layer/Solid.js", 
	        "View3D/Layer/WCS.js", 
	        "View3D/Layer/Grid.js", 
	        "View3D/Layer/Model.js", 
			"View3D/Event/MouseEvent.js", 
			"View3D/Event/KeyEvent.js", 
			"View3D/Handler.js", 
			"View3D/Handler/KeybordDefaults.js", 
			"View3D/Handler/Mouse.js", 
			"View3D/Handler/Point.js", 
			"View3D/Handler/Path.js",
			"View3D/Handler/Polygon.js",
			"View3D/Handler/Box.js",
			"View3D/Handler/ModelChoose.js",
			"View3D/Handler/Feature.js",
			"View3D/Handler/Keyboard.js",
			"View3D/Control.js", 
			"View3D/Control/KeyboardDefaults.js", 
			"View3D/Control/Measure.js", 
			"View3D/Control/DrawPath.js", 
			"View3D/Control/DrawPoint.js", 
			"View3D/Control/DrawPolygon.js", 
			"View3D/Control/DrawFeature.js",
			"View3D/Control/SelectFeature.js", 
			"View3D/Control/Attribution.js",
			"View3D/Control/Box.js",
			"View3D/Control/Mouse.js",
			"View3D/Control/ModelChoose.js",
			"View3D/Control/Analysis.js",
			"View3D/Control/Keyboard.js",
			"View3D/Control/DrawBox.js", 
			"View3D/Fly.js", 
			"View3D/Popup.js", 
			"View3D/Popup/FramedCloud.js", 
			"View3D/FeatureManager.js", 
			"View3D/Control/Measure/PointInfo.js", 
			"View3D/Control/Measure/Distance.js", 
			"View3D/Control/Measure/Area.js", 
			"View3D/Control/Measure/Volume.js", 
			"View3D/Control/Measure/Excavate.js", 
			"View3D/Control/Measure/Flood.js", 
			"View3D/Control/Measure/Profile.js", 
			"View3D/Control/Measure/TwoPointThrough.js", 
			"CombineView.js", 
			"LayerManager.js", 
			"Request.js",
			"Analysis/AreasAndLengthsParameters.js", 
			"Analysis/BufferAnalysis.js",
			"Analysis/BufferParameters.js",
			"Analysis/DensifyParameters.js",
			"Analysis/DistanceParameters.js",
			"Analysis/GeneralizeParameters.js",
			"Analysis/GeometryService.js",
			"Analysis/LengthsParameters.js",
			"Analysis/OffsetParameters.js",
			"Analysis/ProjectParameters.js",
			"Analysis/RelationParameters.js",
			"Analysis/SuperposeAnalysis.js",
			"Analysis/TrimExtendParameters.js",
			"Analysis/Util.js", 
			"Query/WFSQuery.js", 
			"Query/WFSQueryForPage.js", 
			"Query/CatalogQuery.js", 
			"Query/ModelQuery.js", 
			"Query/MapServiceQuery.js",
			"Query/MapServiceQueryParameters.js",
			"Query/MapServiceQueryResult.js",
			"Query/MapServiceIdentify.js",
			"Query/MapServiceIdentifyParameters.js",
			"Query/MapServiceIdentifyResult.js",
			"Query/MapServiceDataFeatures.js",
			"Query/MapServiceDataFeaturesParameters.js",
			"Query/MapServiceDataFeaturesResult.js",
			"Query/MapServiceFind.js",
			"Query/MapServiceFindParameters.js",
			"Query/MapServiceFindResult.js",
			"Query/GeoCodingQuery.js",
			"Query/GeoCodingQuery/v1.js",
			"Query/GeoCodingQuery/v1_0_0.js",
			"Query/GeoCodingQuery/v1_1_0.js",
			"Query/GEFSQuery.js",
			"Query/GEFSQuery/v1.js",
			"Query/GEFSQuery/v1_0_0.js",
			
			"Tdt/Busline.js",
			"Tdt/BuslineQuery.js",
			"Tdt/BuslineQueryResult.js",
			"Tdt/BuslineSegment.js",
			"Tdt/ChangeCity.js",
			"Tdt/DriveQuery.js",
			"Tdt/DriveQueryResult.js",
			"Tdt/PlaceQuery.js",
			"Tdt/PlaceQueryResultPios.js",
			"Tdt/PlaceQueryResultStatistics.js",
			"Tdt/Util.js",
			"Tdt/Weather.js",
			
			"Strategy/AttributeCluster.js",
			"Strategy/GeoTextXYZ.js",
			
			"Service.js", 
			"Service/GlobeTile.js", 
			"Service/Bus.js", 
			"Service/Plot.js", 
			"Service/ShortestPath.js", 
			"Service/Route.js", 
			"Service/TAS.js", 
			"Service/WPS.js",
			"Service/WFS.js",  
			"Service/WFST.js",  
			"Service/WMS.js",
			"Service/WMTS.js",
			"Service/GeoWMTS.js",
			"Service/WCS.js",  
			"Service/CSW.js",
			"Service/CWMS.js",
	 		"Service/MapService.js",
			"Service/MapServiceLayerDetail.js",
			"Service/GeoCoding.js",
			"Service/GeoRoute.js",
			"Service/GeoRouteInfoResult.js",
			"Service/GeoRoutesResult.js",
			"Service/GeoText.js",
			"Service/Thematic.js"			
		];
	    
	    var scriptLocation = "";
	    var isGlb = new RegExp("(^|(.*?\\/))(" + scriptName + ")(\\?|$)");
	    
	    var scripts = document.getElementsByTagName('script');
	    for (var i = 0, len = scripts.length; i < len; i++) {
	        var src = scripts[i].getAttribute('src');
	        if (src) {
	            var match = src.match(isGlb);
	            if (match) {
	                scriptLocation = match[1];
	                break;
	            }
	        }
	    }
	    
        var allScriptTags = new Array(jsfiles.length);
        for (var i = 0, len = jsfiles.length; i < len; i++) {
            allScriptTags[i] = "<script src='" + scriptLocation + jsfiles[i] + "'></script>";
        }
        if (allScriptTags.length > 0) {
            document.write(allScriptTags.join(""));
        }
		/*
	    var agent = navigator.userAgent;
	    var docWrite = (agent.match("MSIE") || agent.match("Safari"));
	    if (docWrite) {
	        var allScriptTags = new Array(jsfiles.length);
	    }
	    
	    for (var i = 0, len = jsfiles.length; i < len; i++) {
	        if (docWrite) {
	            allScriptTags[i] = "<script src='" + scriptLocation + jsfiles[i] +
	            "'></script>";
	        }
	        else {
	            var s = document.createElement("script");
	            s.src = scriptLocation + jsfiles[i];
	            var h = document.getElementsByTagName("head").length ? document.getElementsByTagName("head")[0] : document.body;
	            h.appendChild(s);
	        }
	    }
	    if (docWrite) {
	        document.write(allScriptTags.join(""));
	    }
	    */
	}


	/**
	 * Property: scriptName
	 * {String} GeoGlobeJSAPI脚本文件名，默认值为"GeoGlobeJSAPI.js"。当前使用Geo.getScriptLocation方法
	 * 时，该方法将依据本属性值获取GeoGlobeJSAPI所在目录路径。如果引入GeoGlobeJSAPI所用的脚本文件名
	 * 不为默认值"GeoGlobeJSAPI.js"，用户可以根据实际情况自己修改。
	 */
	Geo.scriptName = (!Geo.singleFile) ? "GeoGlobeJSAPI/GeoGlobeJSAPI.js" : "GeoGlobeJS.min.js";
	
	/**
	 * Method: getScriptLocation
	 * 获取GeoGlobeJSAPI脚本文件名库脚本文件所在路径。
	 *
	 * Returns:
	 * {String} GeoGlobeJSAPI脚本文件所在路径。
	 */
	Geo.getScriptLocation = function () {
		var scriptLocation = "";            
		var isGV = new RegExp("(^|(.*?\\/))(" + Geo.scriptName + ")(\\?|$)");
	 
		var scripts = document.getElementsByTagName('script');
		for (var i=0, len=scripts.length; i<len; i++) {
			var src = scripts[i].getAttribute('src');
			if (src) {
				var match = src.match(isGV);
				if(match) {
					scriptLocation = match[1];
					break;
				}
			}
		}
		return scriptLocation;
	};
	
	/**
	 * Property: imagesPath
	 * {String} 指定图片所在路径,三维插件只能接受绝对地址的图片，此处图片路径如:http:www.geostar.com.cn/images/ 或 c:\\images\\。
	 */
	Geo.imagesPath = "";
	
	/**
	 * Method: createNS
	 * 创建名字空间,如果指定名字空间中的某一级已经存在不会覆盖已有内容。
	 * 
	 * Parameters:
	 * ns - {String} 名称空间。
	 * 
	 */		
	Geo.createNS = function(ns){
		var nsArr = ns.split(".");
		var currObj = window;
		for(var i=0; i<nsArr.length; i++){
			if(!currObj[nsArr[i]]){
				currObj[nsArr[i]] = {};
			}
			currObj = currObj[nsArr[i]];
		}
	}
	
	//此方法已废弃，更换为Geo.Request.setProxyHost
	Geo.setProxyHost = function(proxyHost){
		OpenLayers.ProxyHost = proxyHost;
	}
	
	//此方法已废弃，更换为Geo.Request.getProxyHost
	Geo.getProxyHost = function(){
		return OpenLayers.ProxyHost;
	}
	
    /**
	 * APIProperty: setDPI
	 * 设置DPI。即屏幕上的地图图片中，多少个屏幕像素点代表一英寸的距离。
	 * 
	 * Parameters:
	 * dpi - {Number} 一英寸的像素点个数。
	 */
	Geo.setDPI = function(dpi){
		if(!dpi){
			return;
		}
		OpenLayers.DOTS_PER_INCH = dpi;
	}
	
    /**
	 * Property: VERSION_NUMBER
	 * GeoGlobeSDK JS API的版本号。
	 */
	Geo.VERSION_NUMBER = "GeoGlobeJSAPI 6.2 -- $Version: 1.00.20 build-20161118 $";
	
	// 减少地图上一屏范围内对瓦片服务访问的次数。
	OpenLayers.Layer.WMTS.prototype.buffer = 0;
	OpenLayers.Layer.WMS.prototype.buffer = 0;
	// 修改拖拽地图时的“动能”滑动效果的摩擦系数，默认值设置为0.0035。值越大，摩擦力越大，滑动距离越小。
	OpenLayers.Kinetic.prototype.deceleration = 0.0033;
	//修改显示比例尺的单位
	OpenLayers.INCHES_PER_UNIT["公里"] = OpenLayers.INCHES_PER_UNIT["km"];
	OpenLayers.INCHES_PER_UNIT["米"] = OpenLayers.INCHES_PER_UNIT["m"];
	OpenLayers.INCHES_PER_UNIT["英里"] = OpenLayers.INCHES_PER_UNIT["mi"];
	OpenLayers.INCHES_PER_UNIT["英寸"] = OpenLayers.INCHES_PER_UNIT["ft"];
	//设置ol的国际化语言为中文
	OpenLayers.Lang.setCode("zh-CN");
})()


/**
 * Class: Geo.Animator
 * 矢量要素移动动画类。可以实现点要素在指定线要素上的移动，并且能控制移动的速度。
 */
Geo.Animator = Geo.Class({

    /**
     * APIProperty: id
     * {String} 唯一标识。
     */
    id: null,
    
    //动画队列
    _queue:null,
    
    //当前播放索引
    _currentIndex:0,

    /**
     * APIProperty: feature
     * {<Geo.Feature.Vector>} 动画要素。
     */    
    feature: null,

    /**
     * Property: isRepeat
     * {Boolean} 是否重复播放动画，默认为值true。
     */     
    isRepeat: true,


    /**
     * APIProperty: frequence
     * {Boolean} 刷新频率，默认值为5（单位：毫秒）。
     */      
    frequence: 5,
    
    /**
     * Constructor: Geo.Animator
     * 构造函数。矢量要素动画类实例。
     *
     * Parameters:
     * options - {Object} 对象相关选项设置。
     */
    initialize: function(options){
        this.id = OpenLayers.Util.createUniqueID("Geo.Animater_");
        this._queue = [];
    },
	
    /**
     * APIMethod: isPlaying
     * 是否在播放动画。
     * 
     * Returns:
     * {Boolean} 返回播放状态，true表示正在播放，false表示停止播放。
     */     
    isPlaying: function(){
		var length = this._queue.length;
		if(this._currentIndex == (length - 1)){
			return false;
		}else{
			return true;
		}
	},
	
    /**
     * APIMethod: isAtStart
     * 是否在起点。
     * 
     * Returns:
     * {Boolean} 返回是否在起点的状态，true表示在起点，false表示不在。
     */     
	isAtStart: function(){
		if(this._currentIndex == 0){
			return true;
		}else{
			return false;
		}
	},	
	
    /**
     * APIMethod: isAtEnd
     * 是否在终点。
     * 
     * Returns:
     * {Boolean} 返回是否在终点的状态，true表示在终点，false表示不在。
     */     
	isAtEnd: function(){
		var length = this._queue.length;
		if(this._currentIndex == (length - 1)){
			return true;
		}else{
			return false;
		}
	},	
    
	/**
     * APIMethod: setFeature
     * 添加动画要素。
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 被移动的要素。
     */	
    setFeature:function(feature){
        this.feature = feature;
    },  
    
	/**
     * APIMethod: start
     * 开始播放动画。
     */	
    start: function(){
        var item = this._queue[this._currentIndex];
        if(item){
            var fn = OpenLayers.Function.bind(function(){
                this._stepRun(item);
            },this);
            item.interval = window.setInterval(fn, this.frequence);
        }
    }, 
    
	/**
     * APIMethod: stop
     * 停止播放动画。
     */	
    stop: function(){
        this._currentIndex = 0;
        
        //清掉队列中所有的计数器
        for(var i=0; i<this._queue.length; i++){
            var item = this._queue[i];
            window.clearInterval(item.interval);
            item.counter = 0;
        }
    },
    
	/**
     * APIMethod: pause
     * 暂停播放动画。
     */	
    pause: function(){
        var item = this._queue[this._currentIndex];
        window.clearInterval(item.interval);
    },
    
    _getQueueItem: function(){
        return {
            counter: 0,
            isStop: false,
			moveType:"velocity",
            doFn: function(){},
            checkStopFn: function(){
                return false;
            },
            interval: null,
            options: {}
        };
    },
    
    _addItem: function(doFn,checkStopFn,options){
        var item = this._getQueueItem();
        if(doFn){
            item.doFn = OpenLayers.Function.bind(doFn,this);
        }
        
        if(checkStopFn){
            item.checkStopFn = OpenLayers.Function.bind(checkStopFn,this);
        }
        item.options = options;
        this._queue.push(item);
    },
    
    _stepRun: function(item){
        
        
        var isStop = item.checkStopFn();
        if(!isStop){
            item.doFn(item);
            item.counter++;
        } else {
            window.clearInterval(item.interval);
            item.counter = 0;
            
            var next = OpenLayers.Util.indexOf(this._queue,item) + 1;
            var nextItem = this._queue[next];
            if(next !== 0 && nextItem){
                var fn = OpenLayers.Function.bind(function(){
                    this._stepRun(nextItem);
                },this);
                nextItem.interval = window.setInterval(fn,5);
                this._currentIndex = next;
            } else {
                this._currentIndex = 0;
                this.onStop();
            }
        }
        
    },
    
    onStop: function(){},
    
    onChange: function(feature,type){},
    
	/**
     * APIMethod: moveTo
     * 移动到指定位置。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 坐标对象。
     * options - {Object} json格式的参数。
     * 
     * Returns:
     * {<Geo.Animator>}  矢量要素动画类对象。
     */	
    moveTo: function(lonlat,options){
        
        var feature = this.feature;
        var featureLonlat = new Geo.LonLat(feature.geometry.x,
                                                  feature.geometry.y);
        
        options = options || {};
		//默认步长是0.01
        var moveRatio = options.ratio || 0.01;
		var moveType = options.moveType || "velocity";
        options = {
            from: null,
            to: lonlat,
            currentPosition: null, //featureLonlat,
            moveType:moveType,
            step: moveRatio
        };
        
        var doFn = function(item){
            var feature = this.feature;
            var item = this._queue[this._currentIndex];
            this._moveFeature(feature,item);
            this.onChange(feature,"move");
        };
        
        var checkStopFn = function(){
            var item = this._queue[this._currentIndex];
            var currentPosition = new Geo.LonLat(feature.geometry.x,
                                                        feature.geometry.y);
            var options = item.options;
            options.from = options.from || currentPosition;
            options.currentPosition = currentPosition;
            
            var from = options.from;
            var to = options.to;
            
            return this._checkIsOver(from, to, currentPosition);
        }
        
        this._addItem(doFn, checkStopFn, options);
        return this;
    },
    
	/**
     * APIMethod: moveAlong
     * 沿路径移动。
     * 
     * Parameters:
     * path - {<Geo.Feature.Vector>} 路径线要素对象。
     * options - {Object} json格式的参数。
     * > ratio - {Number} 可选值，表示移动速度，缺省值是0.01。
     * > moveType - {String} 可选值，表示移动的方式，缺省值是"velocity"，可选值为："velocity"、"same_step"。
     * > "velocity"表示要素以ratio度的速度做匀速运动；"same_step"表示要素以ratio值的步长单位匀速运动。
     *
     * Examples:
	 * (code)
	 *      //设置路线以及速度
	 *  	animator.moveAlong(roadLine,{
	 *			ratio : 0.01 ,
	 *     		moveType : "velocity"
	 *		});
	 * (end)
     */	
    moveAlong: function(path,options){
        var nodes;
        if(path.CLASS_NAME == "OpenLayers.Feature.Vector"){
            nodes = this._getLonLatFromGeometry(path.geometry);
        }
        
        
        for(var i=0; i<nodes.length; i++){
            var newOptions = OpenLayers.Util.extend({},options);
            if(i==0){
                newOptions.ratio = 1;
            }
            this.moveTo(nodes[i],newOptions);
            
        }

    },
    
    _getLonLatFromGeometry: function(geometry){

        var points = geometry.components;
        var lonlats = [];
        for(var i=0; i<points.length; i++){
            lonlats.push(new Geo.LonLat(points[i].x,
                                               points[i].y));
        }
        return lonlats;
    },
    
    _moveFeature: function(feature,item){

        var options = item.options;
        var to = options.to;
        if(item.counter == 0){
            options.from = new Geo.LonLat(feature.geometry.x,
                                             feature.geometry.y);
        }
        var from = options.from;

        var percent = options.step;
        var lonlat = this._getMoveLonLat[options.moveType](from, to, percent * item.counter, percent);
        var angle = this._getMoveDirection(from, to);
        feature.style.rotation = angle;
        feature.move(lonlat);
        options.currentPosition = lonlat;

    },
    
    //检查是否过了
    _checkIsOver: function(from,to,middle){
        if(middle.lon == to.lon && middle.lat == to.lat){
            return true;
        }
        var isXOver = false, isYOver = false;
        var big, small;
        
        if(from.lon < to.lon){
            big = to.lon;
            small = from.lon;
        } else {
            small = to.lon;
            big = from.lon;
        }
        isXOver = (middle.lon > big) || (middle.lon < small);
        
        if(from.lat < to.lat){
            big = to.lat;
            small = from.lat;
        } else {
            small = to.lat;
            big = from.lat;
        }        
        isYOver = (middle.lat > big) || (middle.lat < small);
        
        return (isYOver && isYOver);
    },
    
    animate:function(){},
    
    fadeIn:function(){},
    
    fadeOut:function(){},
    
    hide:function(){},
    
    show:function(){},

    
    /**
     * 该方法用于返回一条线上的某一点的X坐标或Y坐标。
     * parameters:
     * from - {Number} 表示x或y。
     * to - {Number}表示x或y。
     *     当v1为某一点的x 坐标时，v2为另一点的x坐标。
     *     当v1为某一点的y 坐标时，v2为另一点的y坐标。
     *
     * percent表示步长。
     */
    _getMoveLonLat: {
		//匀速运动
		"same_step" : function(from, to, percent, step){
	        if(percent > 1){
	            percent = 1;
	        }
	        var lon, lat;
	        if(from.lon === to.lon ){
	            lon = from.lon;
	        } else {
	            lon = from.lon + percent * (to.lon - from.lon);
	        }
	        if (from.lat === to.lat) {
	            lat = from.lat;
	        } else {
	            lat = from.lat + percent * (to.lat - from.lat);
	        }
	        
	        if(from.lon < to.lon){
	            lon = (lon > to.lon) ? to.lon : lon;
	            lon = (lon < from.lon) ? from.lon : lon;
	        } 
	        if(from.lon > to.lon){
	            lon = (lon < to.lon) ? to.lon : lon;
	            lon = (lon > from.lon) ? from.lon : lon;
	        }
	        if(from.lat < to.lat){
	            lat = (lat > to.lat) ? to.lat : lat;
	            lat = (lat < from.lat) ? from.lat : lat;
	        } 
	        if(from.lat > to.lat){
	            lat = (lat < to.lat) ? to.lat : lat;
	            lat = (lat > from.lat) ? from.lat : lat;
	        }
	        return new Geo.LonLat(lon,lat);
	    },
		//相同的步长
		"velocity"	:	function(from, to, percent, step){
			var geo = (new OpenLayers.Geometry.Point(from.lon, from.lat)).distanceTo(new OpenLayers.Geometry.Point(to.lon, to.lat));
			var stepX = (to.lon - from.lon) / geo * step;
			var stepY = (to.lat - from.lat) / geo * step;
	        var lon, lat;
	        if(from.lon === to.lon ){
	            lon = from.lon;
	        } else {
	            lon = from.lon + stepX * percent;
	        }
	        if (from.lat === to.lat) {
	            lat = from.lat;
	        } else {
	            lat = from.lat + stepY * percent;
	        }
	        
	        if(from.lon < to.lon){
	            lon = (lon > to.lon) ? to.lon : lon;
	            lon = (lon < from.lon) ? from.lon : lon;
	        } 
	        if(from.lon > to.lon){
	            lon = (lon < to.lon) ? to.lon : lon;
	            lon = (lon > from.lon) ? from.lon : lon;
	        }
	        if(from.lat < to.lat){
	            lat = (lat > to.lat) ? to.lat : lat;
	            lat = (lat < from.lat) ? from.lat : lat;
	        } 
	        if(from.lat > to.lat){
	            lat = (lat < to.lat) ? to.lat : lat;
	            lat = (lat > from.lat) ? from.lat : lat;
	        }
	        return new Geo.LonLat(lon,lat);
	    }
	},
    
    
    /**
     * 该方法用于得到一条线的上的坐标，返回的坐标个数由用户输入的pointNum决定。
     * parameters:
     * from - {Object} 表示点坐标 例如:{x:10,y:10}。
     * to - {Object} 表示点坐标  例如:{x:5,y:5}。
     * pointNum {Number} 表示在该线上取多少个临时点。
     */
    _getPointsByNum: function(from, to, pointNum){
        var x1 = from.x;
        var y1 = from.y;
        var x0;
        var y0;
        var x2 = to.x;
        var y2 = to.y;
        var points = [];
        percentX = (x2 - x1) / (pointNum - 1);
        percentY = (y2 - y1) / (pointNum - 1);
        for (var i = 0; i < pointNum; i++) {
            x0 = x1 + percentX * i;
            y0 = y1 + percentY * i;
            points.push([x0, y0]);
        }
        return points;
    },
    
    /**
     * 该方法根据步长得到临时点。
     * parameters:
     * from - {Object} 表示线的一端。
     * to - {Object} 表示线的另一端。
     * percent 表示步长。
     */
    _getAllTempPointByPercent: function(from, to, percent){
        var tempPointArr = [];
        var i = 0;
        while (i < 1) {
            var x = getXorY(from.x, to.x, i);
            var y = getXorY(from.y, to.y, i);
            tempPointArr.push([x, y]);
            i += percent;
        }
        if (i >= 1) {
            tempPointArr.push([to.x, to.y]);
        }
        return tempPointArr;
    },
    
    //获取两点间线的角度
    _getMoveDirection: function(from, to){
        //以浮点型表示角度
        var dRotateAngle = Math.atan2(Math.abs(from.lon - to.lon), Math.abs(from.lat - to.lat));
        if (to.lon >= from.lon) {
            //第一象限
            if (to.lat >= from.lat) {
                dRotateAngle = dRotateAngle;
            }
            else {
                //第四象限
                dRotateAngle = Math.PI - dRotateAngle;
            }
            
        }
        else {
            //第二象限
            if (to.lat >= from.lat) {
                dRotateAngle = 2 * Math.PI - dRotateAngle;
            }
            else {
                //第四象限
                dRotateAngle = Math.PI + dRotateAngle;
            }
        }
        var angle = (dRotateAngle * 180) / Math.PI;
        return angle;
        
    },
    
    CLASS_NAME: "Geo.Animator"
});

/**
 * Class: Geo.AnimateZoomer
 * 地图图层的平滑缩放效果类。
 */
Geo.AnimateZoomer = Geo.Class({

    /**
     * Property: map
     * {<Geo.View2D.Map>} 二维地图对象。
     */
    map: null,
    
    /**
     * Property: currentStep
     * 动画当前帧号。
     */
    currentStep: 0,
    
    /**
     * APIProperty: totalStep
     * 动画帧数。
     */
    totalStep: 4,
    
    /**
     * APIProperty: intervalTime
     * 每帧间隔时间。
     */
    intervalTime: 90,
    
    /**
     * Property: animateIntervalId
     * 动画IntervalId。
     */
    animateIntervalId: null,
    
    /**
     * Property: bufferLayerContainer
     * 缓存图层容器，用于放置实现平滑效果的临时缓存图层。
     */
    bufferLayerContainer: null,
    
    /**
     * Property: zoomStep
     * 目标级别和当前级别的级别差。
     */
    zoomStep: null,
    
    /**
     * Property: layerLoaded
     * 当前平滑缩放的图层是否马上清除。
     */
    layerLoaded: false,
    
	/**
	 * Property: oraginPoint
	 * 原点位置。
	 */
    oraginPoint: null,
    
    /**
     * Constructor: Geo.AnimateZoomer
     * 构造函数。生成一个地图图层的平滑缩放效果对象。
     * 
     * Parameters:
     * map - {<Geo.View2D.Map>} 二维地图对象。
     * options - {Object} 相关选项设置。
     */
    initialize: function(map, options){
		this.handlers = {};
        if (map) {
            this.setMap(map);
        }
		OpenLayers.Util.extend(this, options);
		if (this.id == null) {
            this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        }
    },
    
	/**
     * Method: setMap
     * 关联地图。
     * 
     * Parameters:
     * map - {<Geo.View2D.Map>} 二维地图对象。
	 */
    setMap: function(map){
        this.map = map;
        this.map.baseLayer.events.register("loadend", this, function(){
            this.layerLoaded = true;
            if (!this.isZoomAnimating()) {
                this.clearBufferLayer();
            }
        });
        
        this.handlers.wheel = new OpenLayers.Handler.MouseWheel(this, {
            "up": this.wheelUp,
            "down": this.wheelDown
        }, this.mouseWheelOptions);
		this.handlers.wheel.activate();
		
		var navs = this.map.getControlsByClass("OpenLayers.Control.Navigation");
		if(navs.length != 0){
			navs[0].disableZoomWheel();
		}

    },
	
    /** 
     * Method: wheelUp
     * 鼠标滚轮向上滚动。
     * 
     * Parameters:
     * evt - {Event}
     * delta - {Integer}
     */
    wheelUp: function(evt, delta) {
		var zoom = this.map.getZoom() + 1;
		if (!this.map.isValidZoomLevel(zoom)) {
            return;
        }
		if (this.map.enableAnimateZoomer) {
			this.playZoomAnimate(zoom, true);
		}
		this.wheelChange(evt, delta || 1);
    },

    /** 
     * Method: wheelDown
     * 鼠标滚轮向下滚动。
     * 
     * Parameters:
     * evt - {Event}
     * delta - {Integer}
     */
    wheelDown: function(evt, delta) {
		var zoom = this.map.getZoom() -1;
        if (!this.map.isValidZoomLevel(zoom)) {
            return;
        }
        if (this.map.enableAnimateZoomer) {
            this.playZoomAnimate(zoom, true);
        }
		this.wheelChange(evt, delta || -1);
    },
	
	/**
     * APIMethod: zoomIn
     * 地图放大一级。
	 */
    zoomIn: function(){
        this.zoomTo(this.map.getZoom() + 1);
    },
	
	/**
     * APIMethod: zoomOut
     * 地图缩小一级。
	 */
    zoomOut: function(){
        this.zoomTo(this.map.getZoom() - 1);
    },
    
    /** 
     * APIMethod: zoom
     * 平滑缩放至指定的级别。
     *
     * Parameters:
     * zoom - {Integer}
     */
    zoomTo: function(zoom){
        if (!this.map.isValidZoomLevel(zoom)) {
            return;
        }
		if (this.map.enableAnimateZoomer) {
			//this.layerLoaded = false;
        	this.playZoomAnimate(zoom);
		}
        this.map.zoomTo(zoom);
    },
    
    /** 
     * APIMethod: zoom
     * 地图缩放 zoomStep 级别。
     * 
     * Parameters:
     * zoomStep - {Integer} 目标级别和当前级别的级别差。
     */
    zoom: function(zoomStep){
        var map = this.map
        var zoom = map.getZoom() + zoomStep;
        
        if (!this.map.isValidZoomLevel(zoom)) {
            return;
        }
        this.playZoomAnimate(zoom);
        this.map.zoomTo(zoom);
    },
    
	/** 
     * APIMethod: playZoomAnimate
     * 开始播放动画。
     * 
     * Parameters:
     * zoom - {Integer} 目标级别。
     * lonlat - {<Geo.LonLat>} 平滑缩放的中心点，如果为null，则为地图的中心点。
     */
    playZoomAnimate: function(zoom, lonlat){
        if (lonlat) {
            // 设置为true。则鼠标滚轮滚动时，以鼠标光标为中心点扩散平滑缩放。
            this.zoomAnimateWheelEnabled = true;
        }
        else {
            // 设置为false。则级别平滑缩放，以地图中心点扩散平滑缩放。
            this.zoomAnimateWheelEnabled = false;
        }
        
        this.currentStep = 0;
        this.currentStep++;
        
        if (this.isZoomAnimating()) {
            this.stopZoomAnimate();
        }
        
        this.clearBufferLayer();
        
        //var layer = this.map.baseLayer;layer
        
        this.cloneLayersTile();
        
        if (this.bufferLayerContainer.childNodes.length == 0) {
            return;
        }
        
        this.hiddenAllLayers();
        
        var currentZoom, targetZoom;
        currentZoom = this.map.getZoom();
        targetZoom = zoom;
        this.zoomStep = targetZoom - currentZoom;
        
        this.oraginPoint = {
            top: parseInt(this.map.layerContainerDiv.style.top),
            left: parseInt(this.map.layerContainerDiv.style.left)
        }
		
		this.mousePosition = this.handlers.wheel.mousePosition;
		
        var zoomAnimateStep = OpenLayers.Function.bind(this.zoomAnimateStep, this);
		zoomAnimateStep();
        this.animateIntervalId = setInterval(zoomAnimateStep, this.intervalTime);
    },
    
	/** 
     * Method: zoomAnimateStep
     * 单步动画。
     */
    zoomAnimateStep: function(){
        if (this.shouldEndAnimate()) {
            this.stopZoomAnimate();
            if (this.layerLoaded) {
                this.clearBufferLayer();
            }
            else {
                this.backBufferLayer();
            }
            this.restoreAllLayers();
            return;
        }
        
        var ratioDelta = (Math.pow(2, this.zoomStep) - 1) / this.totalStep;
        var ratio = this.currentStep * ratioDelta;
        
        this.bufferLayerContainer.style.width = Math.round(100 * (1 + ratio)) + "px";
        this.bufferLayerContainer.style.height = Math.round(100 * (1 + ratio)) + "px";
        
        var centerPixel = this.map.getLayerPxFromLonLat(this.map.getCenter());
        //鼠标滚轮滚动时，以鼠标光标为中心点扩散平滑缩放。
        if (this.zoomAnimateWheelEnabled) {
            centerPixel = this.mousePosition || centerPixel;
        }
        centerPixel = centerPixel.add(-this.oraginPoint.left, -this.oraginPoint.top);
        
        var size = new OpenLayers.Size(1024, 512);
        
        var offsetRatioX = centerPixel.x / size.w;
        var offsetRatioY = centerPixel.y / size.h;
        var offsetX = Math.round(size.w * ratio * offsetRatioX);
        var offsetY = Math.round(size.h * ratio * offsetRatioY);
        
        this.bufferLayerContainer.style.left = this.oraginPoint.left - offsetX + "px";//
        this.bufferLayerContainer.style.top = this.oraginPoint.top - offsetY + "px";//
        this.currentStep++;
    },
    
	/** 
     * Method: frontBufferLayer
     * 把缓存图层的html元素容器显示移至地图前端。
     */
    frontBufferLayer: function(){
        this.bufferLayerContainer.style.zIndex = 746;
    },
	
	/** 
     * Method: backBufferLayer
     * 把缓存图层的html元素容器显示移至地图后端。
     */
    backBufferLayer: function(){
        this.bufferLayerContainer.style.zIndex = 99;
    },
    
	/** 
     * Method: stopZoomAnimate
     * 停止缩放动画，清除animateIntervalId。
     */
    stopZoomAnimate: function(){
        if (this.animateIntervalId) {
            clearInterval(this.animateIntervalId);
            this.animateIntervalId = null;
        }
        this.currentStep = 0;
    },
    
	/** 
     * Method: isZoomAnimating
     * 判断是否正处于动画中。
     */
    isZoomAnimating: function(){
        if (this.animateIntervalId) {
            return true;
        }
        return false;
    },
    
	/** 
     * Method: shouldEndAnimate
     * 根据当前帧号，判断是否应该结束动画。
     */
    shouldEndAnimate: function(){
        if (this.currentStep > this.totalStep) {
            return true;
        }
        return false;
    },
	
	/** 
     * Method: prepareAnimate
     */
    prepareAnimate: function(){
    
    },
	
	/** 
     * Method: hiddenAllLayers
     * 隐藏所有的图层。
     */
    hiddenAllLayers: function(){
        var layers = this.map.layers;
        for (var i = 0; i < layers.length; i++) {
            var layer = layers[i];
            layer.div.style.visibility = "hidden";
        }
        
    },
	
	/** 
     * Method: restoreAllLayers
     * 显示所有的图层。
     */
    restoreAllLayers: function(){
        var layers = this.map.layers;
        for (var i = 0; i < layers.length; i++) {
            var layer = layers[i];
            layer.div.style.visibility = "visible";
        }
        
    },
	
	/** 
     * Method: clearBufferLayer
     * 清除缓存的图层。
     */
    clearBufferLayer: function(){
        if (!this.map || !this.bufferLayerContainer) {
            return null;
        }
        
        this.map.layerContainerDiv.removeChild(this.bufferLayerContainer);
        this.bufferLayerContainer = null;
    },
    
	/** 
     * Method: cloneLayersTile
     * 复制当前显示的图层瓦片。
     */
    cloneLayersTile: function(){
    
        var bufferLayerContainer = document.createElement("div");
        bufferLayerContainer.id = "bufferLayerContainer";
        bufferLayerContainer.style.position = "absolute";
        bufferLayerContainer.style.zIndex = 749;
        bufferLayerContainer.style.width = "100px";
        bufferLayerContainer.style.height = "100px";
        
        bufferLayerContainer.style.left = this.map.layerContainerDiv.style.left;
        bufferLayerContainer.style.top = this.map.layerContainerDiv.style.top;
        
        for (var i = this.map.layers.length - 1; i >= 0; i--) {
            var layer = this.map.layers[i];
            // 复制当前显示的图层
            if (layer.div.style.display != "none") {
                if (layer.getVisibility() && layer.transitionEffect == "resize") {
                    var result = this.cloneSingleLayerTile(layer, bufferLayerContainer);
                }
            }
        }
        
        this.bufferLayerContainer = bufferLayerContainer;
        this.map.layerContainerDiv.appendChild(this.bufferLayerContainer);
        
        
    },
    
	/** 
     * Method: cloneSingleLayerTile
     * 复制单个图层瓦片至缓存图层的html元素容器内。
     * 
     * Parameters:
     * layer - {<Geo.View2D.Layer>} 图层对象。
     * bufferLayerContainer - {HTMLDivElement} 放置图层的html元素容器。
     */
    cloneSingleLayerTile: function(layer, bufferLayerContainer){
    
        if (!layer) {
            return;
        }
		
        var map = this.map;
        
        //瓦片图片矩阵
        var tileGrid = [];
        
        var grid = layer.grid;
        
        for (var i = 0, l1 = grid.length; i < l1; i++) {
            var tileGridRow = [];
            for (var j = 0, l2 = grid[i].length; j < l2; j++) {
                var tile = grid[i][j];
                var imgDiv = tile.imgDiv;
                var frame = tile.frame;
                var cloneImg;
                if (imgDiv && tile.shouldDraw) {
                    cloneImg = imgDiv.cloneNode(true);
					//cloneImg.className = "olTileImage1";
                    cloneImg.id = imgDiv.id + "_clone";
                    
                    //复制瓦片外框div样式到图片
					if(frame){
	                    cloneImg.style.position = frame.style.position;
	                    cloneImg.style.left = parseInt(frame.style.left) + "%";
	                    cloneImg.style.top = parseInt(frame.style.top) + "%";
	                    cloneImg.style.width = parseInt(frame.style.width) + "%";
	                    cloneImg.style.height = parseInt(frame.style.height) + "%";
	                    cloneImg.style.display = frame.style.display;
					}else{
						cloneImg.style.left = parseInt(cloneImg.style.left) + "%";
	                    cloneImg.style.top = parseInt(cloneImg.style.top) + "%";
	                    cloneImg.style.width = parseInt(cloneImg.style.width) + "%";
	                    cloneImg.style.height = parseInt(cloneImg.style.height) + "%";
					}
                    
                    cloneImg.style.zIndex = tile.layer.div.style.zIndex;
                    
                    bufferLayerContainer.appendChild(cloneImg);
                    
                    tileGridRow.push(cloneImg);
                }
            }
            tileGridRow.length && tileGrid.push(tileGridRow);
        }
    },
	
	/**
     * Method: wheelChange  
     *
     * Parameters:
     * evt - {Event}
     * deltaZ - {Integer}
     */
    wheelChange: function(evt, deltaZ) {
        var currentZoom = this.map.getZoom();
        var newZoom = this.map.getZoom() + Math.round(deltaZ);
        newZoom = Math.max(newZoom, 0);
        newZoom = Math.min(newZoom, this.map.getNumZoomLevels());
        if (newZoom === currentZoom) {
            return;
        }
        var size    = this.map.getSize();
        var deltaX  = size.w/2 - evt.xy.x;
        var deltaY  = evt.xy.y - size.h/2;
        var newRes  = this.map.baseLayer.getResolutionForZoom(newZoom);
        var zoomPoint = this.map.getLonLatFromPixel(evt.xy);
        var newCenter = new OpenLayers.LonLat(
                            zoomPoint.lon + deltaX * newRes,
                            zoomPoint.lat + deltaY * newRes );
        this.map.setCenter( newCenter, newZoom );
    },
	
	/**
     * Method: destroy
     * 销毁本对象。
     */
    destroy: function(){
        if (this.handler) {
            this.handler.destroy();
            this.handler = null;
        }
        if (this.handlers) {
            for (var key in this.handlers) {
                if (this.handlers.hasOwnProperty(key) &&
                typeof this.handlers[key].destroy == "function") {
                    this.handlers[key].destroy();
                }
            }
            this.handlers = null;
        }
    },
	
    CLASS_NAME: "Geo.AnimateZoomer"
});
	/**
	 * Class: Geo.Util
	 * 常用的一些函数。
	 */
	
	/**
	 * Property:englishColorToOx
	 * {Object} 颜色的英文字母表示法与RGB表示法对照表
	 */
	Geo.Util.englishColorToOx = {
		"black": "#000000",
		"blue":"#0000FF",
		"brown":"#A52A2A",
		"cyan":"#00FFFF",
		"gold":"#FFD700",
		"gray":"#808080",
		"green":"#008000",
		"lime":"#00FF00",
		"orange":"#FFA500",
		"red":"#FF0000",
		"white":"#FFFFFF",
		"yellow":"#FFFF00"
	};
	
	/**
     * Method: ToArgb
     * 
     * Parameters:
     * Rgb - {String} 颜色字符串,比如：#000000
     * Alpha - {Float} 取值范围：[0-1],0表示透明，1表示不透明
     * Returns:
     * {Integer} 
     */
	Geo.Util.ToArgb = function(Rgb, Alpha) {
		//将英文转换为"#"开头的颜色表示法
		var englishColorToOx = Geo.Util.englishColorToOx;
		for(var value in englishColorToOx) {
			if(value === Rgb) {
				Rgb = englishColorToOx[value].replace("#","");
			}
		}
		
        // rgb 颜色值
        var Rgb16 = parseInt(Rgb, 16);
        var strRGB = Rgb16.toString(2);
        var legnt = strRGB.length;
        if(legnt < 24) {
            for(var i = 0; i < 24 - legnt; i++) {
                strRGB = "0" + strRGB;
            }
        }
        // int 值
        var argbStr = Alpha.toString(2) + strRGB;
        var flag = argbStr.substr(0, 1);
        if(flag == "1") {
            argbStr = argbStr.substr(1, 31);
            return 0 - (2147483647 - parseInt(argbStr, 2)) - 1;
        }
        else {
            return parseInt(Alpha.toString(2) + Rgb16.toString(2), 2);
        }
    };
	
	/**
     * APIMethod: getHexColor
     * 获取十六进制色码。
     * 
     * Parameters:
     * color - {String} 颜色字符串
     * 
     * Returns:
     * {String}
     */
	Geo.Util.getHexColor = function(color) {
		var _color = Geo.Util.englishColorToOx[color];
		var index = color.indexOf("#");
		var str = null;
		if(index == 0 && !_color) {
			var substr = color.substr(1);
			if(substr.length == 3) {
				str = substr.charAt(0)+substr.charAt(0)+substr.charAt(1)+substr.charAt(1)+ substr.charAt(2)+ substr.charAt(2);
			}else if(substr.length == 6) {
				str = substr;
			}
		}else if(index == -1 && _color) {
			str = _color.substr(1);
		}
		return "0x" + str;
	}
	
	/**
     * APIMethod: meterToDegree
	 * 根据地理坐标位置，将米转换成经纬度。
	 *
	 * Parameters:
	 * meter - {Number} 要转换的地理坐标。
	 * lonlat - {<Geo.LonLat>} 经纬度。
	 */
	Geo.Util.meterToDegree = function(meter,lonlat){
		var a = 0.00000899; //赤道上的距离1公里=0.000008993220293度
		var templat = lonlat.lat;
		return meter * ( a / Math.cos(OpenLayers.Util.rad(templat)) );
	};
	
	/**
     * APIMethod: webColorToHex
     * 转换颜色字符串为十进制，例如："#0000ff"转换成0x000000ff。
     * 
     * Parameters:
     * webcolor - {String} 颜色字符串
     * 
     * Returns:
     * {Integer} 十进制颜色数
     */
	Geo.Util.webColorToHex = function(webcolor) {
		return new Number("0x00" + webcolor.replace("#",""));
	}
	
	/**
     * APIMethod: replaceAll
     * 在字符串中查找某字符串，并全部替换成另外一个字符串。
     * 
     * Parameters:
     * string - {String} 字符串
     * find - {String} 要查找的字符串
     * replace - {String} 替换目标字符串
     * 
     * Returns:
     * {String} 替换后的结果字符串
     */      
    Geo.Util.replaceAll = function(string, find, replace) {
        replace = replace ? replace : "";
        return string.replace(new RegExp(find, "gm"), replace);
    };
	
	Geo.Util.Format = {};/**
 * Class: Geo.Pyramid
 * 金字塔对象类。
 * 金字塔对象类可以实现地理范围（坐标）与瓦片行、列属性之间的转换。
 * 地图对象必须有一个金字塔属性。本类的实例默认为地理坐标系统360度
 * 顶层瓦片金字塔方案。另外，包含了比例尺，分辨率和级别之间的转换。
 */
Geo.Pyramid = Geo.Class({

	/**
     * APIProperty: name
     * {String} 金字塔名称。
     */
	name : null,
	
	/**
     * APIProperty: pyramidID
     * {String} 金字塔ID。
     */
	pyramidID : null,
	
	/**
     * APIProperty: description
     * {String} 金字塔描述。
     */
	description : null,
	
	/**
     * APIProperty: topLevelIndex
     * {Number} 最顶层级别。
     */
	topLevelIndex : null,
	
	/**
	 * APIProperty: resolutions
	 * 分辨率数组，如果设置了分辨率数组，则maxResolution和minResolution设置了就无效
	 */
	resolutions: null,
	
	/**
     * APIProperty: bottomLevelIndex
     * {Number} 最底层级别。
     */	
	bottomLevelIndex : null,
	
	/**
     * APIProperty: scaleX
     * {Number} X轴放大系数。
     */	
	scaleX : null,
	
	/**
     * APIProperty: scaleY
     * {Number} Y轴放大系数。
     */		
	scaleY : null,
	
	/**
     * APIProperty: tileSize
     * {<Geo.Size>} 瓦片尺寸。
     */			
	tileSize: null,
	
	/**
     * APIProperty: originRowIndex
     * {Number} 瓦片行起始编号。
     */	
	originRowIndex: null,
	
	/**
     * APIProperty: originColIndex
     * {Number} 瓦片列起始编号。
     */		
	originColIndex: null,
	
	/**
     * APIProperty: topTileFromX
     * {Float} 顶层瓦片X轴坐标起点。
     */		
	topTileFromX:null,
	
	/**
     * APIProperty: topTileFromY
     * {Float} 顶层瓦片Y轴坐标起点。
     */	
	topTileFromY: null,
	
	/**
     * APIProperty: topTileToX
     * {Float} 顶层瓦片X轴坐标终点。
     */	
	topTileToX: null,
	
	/**
     * APIProperty: topTileToY
     * {Float} 顶层瓦片Y轴坐标终点。
     */	
	topTileToY: null,
	
	/**
     * APIProperty: units
     * {String} 金字塔的单位优先于地图的单位。默认为'degrees'。
     * 值可能为：'degrees' (or 'dd'), 'm', 'ft', 'km', 'mi', 'inches'.
     */
    units: 'degrees',
	
	/**
	 * Constructor: Geo.Pyramid
	 * 构造函数。
	 * 
	 * Parameters:
	 * options - {object} 金字塔设置选项。
	 */
	initialize : function (options){
		
		if (!options || options ==={}){
			options = Geo.Pyramid.DEFAULT_PYRAMID;
		}
		OpenLayers.Util.extend(this, options);	
	},

	/**
	 * APIMethod: getMaxExtent
	 * 根据根据金字塔对象相关定义获取最大范围。
	 * 
	 * Returns:
	 * {<Geo.Bounds>} 图层最大范围。
	 */	
	getMaxExtent: function(){
		var left,bottom,right,top;
		
		if(this.topTileFromX < this.topTileToX){
			left = this.topTileFromX;
			right = this.topTileToX;
		} else {
			right = this.topTileFromX;
			left = this.topTileToX;
		}
		
		if(this.topTileFromY < this.topTileToY){
			bottom = this.topTileFromY;
			top = this.topTileToY;
		} else {
			top = this.topTileFromY;
			bottom = this.topTileToY;
		}
		return new Geo.Bounds(left,bottom,right,top);
	},
	
	/**
	 * APIMethod: getResolutionForLevel
	 * 根据分辨率获取级别。
	 *
	 * Parameters:
	 * resolution - 指定分辨率。
	 * 
	 * Returns:
	 * {Integer} 级别。
	 */
	getLevelForResolution: function(resolution){
        if (!resolution) {
            return 0;
        }
		var zoom, i, diff;
		var minDiff = Number.POSITIVE_INFINITY;
		var resolutions = this.getResolutions();
		for (i = 0, len = resolutions.length; i < len; i++) {
			//判断当前分辨率与金字塔中分辨率最接近的
	        diff = Math.abs(resolutions[i] - resolution);
	        if (diff > minDiff) {
	            break;
	        }
	        minDiff = diff;
		}
		zoom = Math.max(0, i - 1);//0和(i - 1)中取大数。
		return zoom ;
	},
	
	/**
	 * APIMethod: getLevelForScale
	 * 根据比例尺获取级别。
	 *
	 * Parameters:
	 * scale - 指定比例尺。
	 * 
	 * Returns:
	 * {Integer} 级别。
	 */
	getLevelForScale: function(scale){
		var resolution = OpenLayers.Util.getResolutionFromScale(scale, this.units);
		var zoom = this.getLevelForResolution(resolution);
        return zoom ;
	},
	
	/**
	 * APIMethod: getResolutionForScale
	 * 根据比例尺获取分辨率。
	 *
	 * Parameters:
	 * scale - 指定比例尺。
	 * units - {String} 单位。
	 * 
	 * Returns:
	 * {float} 分辨率。
	 */
	getResolutionForScale: function(scale){
		var level = this.getLevelForScale(scale, this.units);
		var res = this.getResolutionForLevel(level)
        return res;
	},
	
	/**
	 * APIMethod: getResolutionForLevel
	 * 根据级别获取分辨率。
	 * 
	 * Parameters:
	 * level - 图层级别。
	 * 
	 * Returns:
	 * {float} 分辨率。
	 */
	getResolutionForLevel: function(level){
		var maxResolution = (this.getTopTileSize().w / this.tileSize.w) 
		return maxResolution / Math.pow(2, level);		
	},
	
	/**
	 * APIMethod: getMaxResolution
	 * 根据最大级别获取分辨率。
	 * 
	 * Returns:
	 * {float} 分辨率。
	 */
	getMaxResolution: function(){		
		return this.getResolutionForLevel(this.topLevelIndex)	
	},
	
	/**
	 * APIMethod: getResolutionForBottomLevel
	 * 根据最小级别获取分辨率。
	 * 
	 * Returns:
	 * {float} 分辨率。
	 */
	getMinResolution: function(){		
		return this.getResolutionForLevel(this.bottomLevelIndex)	
	},
	
	/**
	 * APIMethod: getResolutions
	 * 获取分辨率数组。
	 * 
	 * Returns:
	 * {Array} 分辨率数组。
	 */
	getResolutions: function(){
		var resolutions = new Array();
		for (var i = this.topLevelIndex; i <= this.bottomLevelIndex; i++) {
			resolutions.push(this.getResolutionForLevel(i));
		}
		return resolutions;
	},
	
	/**
	 * APIMethod: getNumZoomLevels
	 * 获取级别差。
	 * 
	 * Returns:
	 *  {Integer} 级别差。
	 */
	getNumZoomLevels: function(){
		return this.bottomLevelIndex - this.topLevelIndex + 1;
	},
	
	/**
	 * APIMethod: getTopTileSize
	 * 获取顶层瓦片尺寸。
	 * 
	 * Returns:
	 * {<Geo.Size>} 瓦片大小。
	 */	
	getTopTileSize : function(){
		var w = Math.abs(this.topTileToX - this.topTileFromX);
		var h = Math.abs(this.topTileToY - this.topTileFromY);
		return new Geo.Size(w,h);
	},
	
	/**
	 * APIMethod: getTileIndex
	 * 根据坐标和级别，获取瓦片所在行列号。
	 * 
	 * Parameters:
	 * lonlat - 经纬度坐标。
	 * level - 图层级别。
	 * 
	 * Returns:
	 * {Object} 返回瓦片的行列号。
	 */
	getTileIndex: function(lonlat, level){
			
		var lon = lonlat.lon;
		var lat = lonlat.lat;
		var size = this.getTopTileSize()
		var degree = size.w / Math.pow(2,level);
		
		//金字塔宽高
		var width = this.maxExtent.getWidth();
		var height = this.maxExtent.getHeight();
		
		//总行列数
		var totalCol = Math.round(width / degree);
		var totalRow = Math.round(height / degree);
		
		//计算列索引号
		var isStartLeft = (this.topTileFromX < this.topTileToX) ? true : false;
		var colIndex = Math.ceil(Math.abs(lon - this.topTileFromX)/degree) - 1;
		if(!isStartLeft){
			colIndex = totalCol - colIndex;
		}
		
		var isStartTop = (this.topTileFromY > this.topTileToY) ? true : false;
		var rowIndex = Math.ceil(Math.abs(lat - this.topTileFromY)/degree) - 1;
		if (!isStartTop){
			rowIndex = totalRow - rowIndex;
		}
		
		return {
			col: colIndex,
			row: rowIndex
		}

	},
	
	/**
	 * APIMethod: getTileBoundsForGridIndex
	 * 根据行列号和层级计算瓦片范围。
	 * 
	 * Parameters:
	 * row - 行号。
	 * col - 列号。
	 * level - 层级
	 * 
	 * Returns:
	 * {Geo.Bounds} 瓦片范围。
	 */
	getTileBoundsForGridIndex: function(row, col, level) {
		var res = this.getResolutionForLevel(level);
		var leftTopLon = this.topTileFromX + row * this.tileSize.w * res;
		var leftTopLat = this.topTileFromY -  col * this.tileSize.h * res;
		var rightBottomLon = leftTopLon + this.tileSize.w * res;
		var rightBottomLat = leftTopLat - this.tileSize.h * res;
		var tileBounds = new Geo.Bounds(leftTopLon,rightBottomLat,rightBottomLon,leftTopLat);
		return tileBounds;
	},
	
	/**
	 * APIMethod: getTileInfoFromBounds
	 * 根据范围和级别获得最大最小行列号。
	 * 
	 * Parameters:
	 * bounds - 范围。
	 * level - 图层级别。
	 * 
	 * Returns:
	 * {Object} 返回最大最小行列号。
	 */
	getTileInfoFromBounds: function(bounds, level) {
		//判断原点
		var minTileObj = this.getTileIndex(new Geo.LonLat(bounds.left, bounds.top), level);
		var maxTileObj = this.getTileIndex(new Geo.LonLat(bounds.right, bounds.bottom), level);
		return {
			mincol: minTileObj.col,
			minrow: minTileObj.row,
			maxcol: maxTileObj.col,
			maxrow: maxTileObj.row
		}
	},
	
	/**
	 * 
	 */
	getTileInfoFromLonLat: this.getTileIndex,
	
	/**
	 * APIMethod: clone
	 * 复制对象。
	 * 
	 * Returns:
	 * {<Geo.Pyramid>} 金字塔对象。
	 */	
	clone: function(){
		return OpenLayers.Util.extend({},this);
	},
	
	CLASS_NAME : "Geo.Pyramid"
});

/**
 * APIProperty: Degree360
 * 360度金字塔定义。
 */
Geo.Pyramid.Degree360 = {
	//360度金字塔定义
	name : "360DegreePyramid",	
	topLevelIndex : 0,
	bottomLevelIndex : 20,
	scaleX : 2,
	scaleY :2,
	topTileFromX : -180.0,
	topTileFromY : 90.0,
	topTileToX : 180.0,
	topTileToY : -270.0,
	tileSize : new Geo.Size(256,256),
	originRowIndex : 0,
	originColIndex : 0,
	maxExtent : new Geo.Bounds(-180,-90,180,90)
};

/**
 * APIProperty: Degree18
 * 18度金字塔定义。
 */
Geo.Pyramid.Degree18 = {
	//18度金字塔定义
	name : "18DegreePyramid",
	topLevelIndex : 0,
	bottomLevelIndex : 20,
	scaleX : 2,
	scaleY :2,
	topTileFromX : -180.0,
	topTileFromY : -90.0,
	topTileToX : -162.0,
	topTileToY : -72.0,
	tileSize : new Geo.Size(256,256),
	originRowIndex : 0,
	originColIndex : 0,
	maxExtent : new Geo.Bounds(-180,-90,180,90)
};

/**
 * APIProperty: DEFAULT_PYRAMID
 * 默认金字塔定义（360度金字塔定义）。
 */
Geo.Pyramid.DEFAULT_PYRAMID = Geo.Pyramid.Degree360;/**
 * Class: Geo.SymbolizerManager
 * 符号组类。提供符号组的创建、删除和修改功能。默认提供常用的行业符号。
 */
Geo.SymbolizerManager = Geo.Class({

    /** 
     * Constructor: Geo.SymbolizerManager
     * Geo.SymbolizerManager类的构造函数。
     */
    initialize: function(){
    
    },
    
    /**
     * Method: getImagePath
     * 获取图片文件夹的相对路径。
     */
    getImagePath: function(){
        return Geo.getScriptLocation() + "images/";
    },
    
	/**
     * APIMethod: createSymbolizer
     * 创建符号组。
     * 
     * Parameters:
     * newSymbolizerType - {String} 新创建符号组的类型。
     * symbolizerGroup - {Array} 符号组内对象数组。
     * 		name {String} 新创建的符号组内单个符号对象的名称。
     * 		symbolizer {Object} 符号对象。
	 */
    createSymbolizer: function(newSymbolizerType, symbolizerGroup){
        Geo.SymbolizerManager.symbolizerGroup[newSymbolizerType] = {};
        for (var i = 0; i < symbolizerGroup.length; i++) {
			Geo.SymbolizerManager.symbolizerGroup[newSymbolizerType][symbolizerGroup[i].name] = symbolizerGroup[i].symbolizer;
        };
    },
    
	/**
     * APIMethod: updateSymbolizer
     * 根据符号组类型和符号名称，修改符号组内符号对象。
     * 
     * Parameters:
     * newSymbolizerType - {String} 符号组的类型。
     * name - {String} 被修改的符号组内单个符号对象的名称。
     * symbolizer - {Object} 新的符号对象。
	 */
    updateSymbolizer: function(symbolizerType, name, symbolizer){
        OpenLayers.Util.extend(Geo.SymbolizerManager.symbolizerGroup[symbolizerType][name], symbolizer);
    },
    
	/**
     * APIMethod: removeSymbolizer
     * 根据符号组类型和符号名称，删除符号组内符号对象。
     * 
     * Parameters:
     * symbolizerType - {String} 符号组的类型。
     * name - {String} 被删除的符号组内单个符号对象的名称。
	 */
    removeSymbolizer: function(symbolizerType, name){
        Geo.SymbolizerManager.symbolizerGroup[symbolizerType][name] = null;
        delete Geo.SymbolizerManager.symbolizerGroup[symbolizerType][name];
    },
    
	/**
     * APIMethod: getSymbolizerGroup
     * 获取符号组。
	 */
    getSymbolizerGroup: function(){
        return Geo.SymbolizerManager.symbolizerGroup;
    },
    
    CLASS_NAME: "Geo.SymbolizerManager"
});

/**
 * APIProperty: Geo.SymbolizerManager.symbolizerGroup
 * {Object} 符号组对象。
 */
Geo.SymbolizerManager.symbolizerGroup = {
    "COMMON": {
        "A": {
            externalGraphic: Geo.getScriptLocation() + "images/common/" + "0.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "B": {
            externalGraphic: Geo.getScriptLocation() + "images/common/" + "1.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "C": {
            externalGraphic: Geo.getScriptLocation() + "images/common/" + "2.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "D": {
            externalGraphic: Geo.getScriptLocation() + "images/common/" + "3.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "E": {
            externalGraphic: Geo.getScriptLocation() + "images/common/" + "4.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "F": {
            externalGraphic: Geo.getScriptLocation() + "images/common/" + "5.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "G": {
            externalGraphic: Geo.getScriptLocation() + "images/common/" + "6.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "H": {
            externalGraphic: Geo.getScriptLocation() + "images/common/" + "7.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "I": {
            externalGraphic: Geo.getScriptLocation() + "images/common/" + "8.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        },
        "J": {
            externalGraphic: Geo.getScriptLocation() + "images/common/" + "9.png",
            graphicWidth: 32,
            graphicHeight: 32,
            graphicXOffset: -15,
            graphicYOffset: -16
        }
    }
};
/**
 * Class: Geo.GeoMarker
 * 吉奥标注类。可设置动画效果，自定义标签的标注类。
 */
Geo.GeoMarker = Geo.Class(Geo.Marker, {
    
    /** 
     * Constructor: Geo.GeoMarker
     * Geo.GeoMarker对象构造函数。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 标注的地理坐标。
     * icon - {<Geo.View2D.Icon>}  标注的显示小图标对象。
     * tag - {<Geo.View2D.MarkerTag>}  标注的自定义标签对象。
     */
    initialize: function(lonlat, icon, tag) {
		this.tag = tag;
		Geo.Marker.prototype.initialize.apply(this, arguments);
    },
	
	/**
     * APIMethod: setAnimation
	 * 设置标注点的动画效果。
	 * 
     * Parameters:
     * animationType - {Integer} 动画效果的标识。有坠落动画(Geo.GeoMarker.ANIMATION_DROP)和跳动动画(Geo.GeoMarker.ANIMATION_BOUNCE)。
     * height - {Integer} 跳动的像素高度值。默认值为20。
     * ga - {Integer} 加速度，单位是px/s^2(像素每平方秒)。默认值为500。
	 */
	setAnimation: function(animationType, height, ga) {
		if(animationType !== Geo.GeoMarker.ANIMATION_DROP && animationType !== Geo.GeoMarker.ANIMATION_BOUNCE){
			return;
		}
		//跳动的像素高度值。
		var height = height ? height : 20;
		height = (height < 0) ? 0 : height;
		if(height == 0){
			return;
		}
		//动画的频率，每多少毫秒一帧。
		var ga = ga ? ga : 500;
		ga = (ga < 0) ? 0 : ga;
		if(ga == 0){
			return;
		}
		
        this.timerId && clearInterval(this.timerId);
		var size = this.icon.size;
		var icon = this.icon;
		
		//加速度
        var g = ga;
        var t = 0;
        var y0 = -size.h - height;
		//设置动画效果后，标注小图标会从距离坐标位置height个像素高度开始坠落。
		icon.offset.y = y0;
        //icon.moveTo();
		var b = false;
        var timerCallback = function(){
            if (b && animationType === Geo.GeoMarker.ANIMATION_DROP) {
                clearInterval(this.timerId);
				this.timerId = null;
                return;
            }
            t += 0.01;
            //t秒之后，物体下落的高度
            var s = g * t * t / 2;
            //物体实际的高度
            var y = y0 + s;
            if (y > -size.h) {
                y = -size.h;
                if (animationType === Geo.GeoMarker.ANIMATION_BOUNCE) {
                    t = -t;
                }
                b = true;
            }
            icon.offset.y = y;
            icon.moveTo();
        };
		
		this.timerId = window.setInterval(
            OpenLayers.Function.bind(timerCallback, this),
            10);
		
    },
	
    /**
     * Method: setContentHTML
     * 更改标签内容。
     * 
     * html - {String} 
     */
    setContentHTML: function(html) {
		if(this.tag){
			this.tag.setContentHTML(html);
		}
    },
	
    /** 
    * Method: drawTag
    * 绘制标签div。
    * 
    * Parameters:
    * px - {<Geo.Pixel>}
    * 
    * Returns:
    * {DOMElement} 返回一个新的标签的DOM div。
    */
    drawTag: function(px) {
        if(this.tag){
			return this.tag.draw(px);
		}
		return null;
    }, 

    /**
     * APIMethod: isDrawnTag
     * 是否已经绘制。
     * 
     * Returns:
     * {Boolean} 是否已经绘制，返回值为布尔类型。
     */
    isDrawnTag: function() {
        var isDrawn = (this.tag && this.tag.isDrawn());
        return isDrawn;   
    },
	
    /**
     * APIMethod: destroy
     * 销毁本对象。
     */
    destroy: function() {
        // erase any drawn features
        this.erase();

        this.map = null;

        this.events.destroy();
        this.events = null;

        if (this.icon != null) {
            this.icon.destroy();
            this.icon = null;
        }
        if (this.tag != null) {
            this.tag.destroy();
            this.tag = null;
        }
    },
	
	/** 
    * Method: erase
    * Erases any drawn elements for this marker.
    */
    erase: function() {
        if (this.icon != null) {
            this.icon.erase();
        }
        if (this.tag != null) {
            this.tag.erase();
        }
    },
	
    CLASS_NAME: "Geo.GeoMarker"
});

/**
 * Constant: ANIMATION_DROP
 * {Integer} 坠落动画。
 */
Geo.GeoMarker.ANIMATION_DROP = 1;

/**
 * Constant: ANIMATION_BOUNCE
 * {Integer} 跳动动画。 
 */
Geo.GeoMarker.ANIMATION_BOUNCE = 2;﻿    OpenLayers.Renderer.Canvas.prototype.drawText = function(location, style) {
        style = OpenLayers.Util.extend({
            fontColor: "#000000",
            labelAlign: "cm"
        }, style);

        //==========================修正Canvas视图无文本偏移问题
        if(style.labelXOffset || style.labelYOffset) {
            var xOffset = isNaN(style.labelXOffset) ? 0 : style.labelXOffset;
            var yOffset = isNaN(style.labelYOffset) ? 0 : style.labelYOffset;
            var res = this.getResolution();
            location.move(xOffset*res, yOffset*res);
        }
        //======================================================

        var pt = this.getLocalXY(location);

        this.setCanvasStyle("reset");
        this.canvas.fillStyle = style.fontColor;
        this.canvas.globalAlpha = style.fontOpacity || 1.0;
        var fontStyle = [style.fontStyle ? style.fontStyle : "normal",
                         "normal", // "font-variant" not supported
                         style.fontWeight ? style.fontWeight : "normal",
                         style.fontSize ? style.fontSize : "1em",
                         style.fontFamily ? style.fontFamily : "sans-serif"].join(" ");
        var labelRows = style.label.split('\n');
        var numRows = labelRows.length;






        if (this.canvas.fillText) {
            // HTML5
            this.canvas.font = fontStyle;




            this.canvas.textAlign =
                OpenLayers.Renderer.Canvas.LABEL_ALIGN[style.labelAlign[0]] ||
                "center";
            this.canvas.textBaseline =
                OpenLayers.Renderer.Canvas.LABEL_ALIGN[style.labelAlign[1]] ||
                "middle";
            var vfactor =
                OpenLayers.Renderer.Canvas.LABEL_FACTOR[style.labelAlign[1]];
            if (vfactor == null) {
                vfactor = -.5;
            }
            var lineHeight =
                this.canvas.measureText('Mg').height ||
                this.canvas.measureText('Mx').width;
            pt[1] += lineHeight*vfactor*(numRows-1);

            var degrees = style.labelRotation;//0;parseFloat();
            if(degrees){
                //debugger;
                this.canvas.save();
                this.canvas.translate(pt[0], pt[1]);
                this.canvas.rotate(degrees*Math.PI/180);
                this.canvas.fillText(labelRows[0],0,0);
                this.canvas.restore();
            } else{
                for (var i = 0; i < numRows; i++) {
                    this.canvas.fillText(labelRows[i], pt[0], pt[1] + (lineHeight*i));
                }
            }





        } else if (this.canvas.mozDrawText) {
            // Mozilla pre-Gecko1.9.1 (<FF3.1)
            this.canvas.mozTextStyle = fontStyle;
            // No built-in text alignment, so we measure and adjust the position
            var hfactor =
                OpenLayers.Renderer.Canvas.LABEL_FACTOR[style.labelAlign[0]];
            if (hfactor == null) {
                hfactor = -.5;
            }
            var vfactor =
                OpenLayers.Renderer.Canvas.LABEL_FACTOR[style.labelAlign[1]];
            if (vfactor == null) {
                vfactor = -.5;
            }
            var lineHeight = this.canvas.mozMeasureText('xx');
            pt[1] += lineHeight*(1 + (vfactor*numRows));
            for (var i = 0; i < numRows; i++) {
                var x = pt[0] + (hfactor*this.canvas.mozMeasureText(labelRows[i]));
                var y = pt[1] + (i*lineHeight);
                this.canvas.translate(x, y);
                this.canvas.mozDrawText(labelRows[i]);
                this.canvas.translate(-x, -y);
            }
        }
        this.setCanvasStyle("reset");
    }
	
	//解决地图定位到第0级后添加图层，地图级别自动跳转到最大一级的bug。
	OpenLayers.Map.prototype.zoom = null;/**
 * Class: Geo.Uuid
 * 包含Geo.Math.uuid()方法，用于生成一个随机的uuid。
 */

/*!
Math.uuid.js (v1.4)
http://www.broofa.com
mailto:robert@broofa.com

Copyright (c) 2010 Robert Kieffer
Dual licensed under the MIT and GPL licenses.
*/

/*
 * Generate a random uuid.
 *
 * USAGE: Math.uuid(length, radix)
 *   length - the desired number of characters
 *   radix  - the number of allowable values for each character.
 *
 * EXAMPLES:
 *   // No arguments  - returns RFC4122, version 4 ID
 *   >>> Math.uuid()
 *   "92329D39-6F5C-4520-ABFC-AAB64544E172"
 * 
 *   // One argument - returns ID of the specified length
 *   >>> Math.uuid(15)     // 15 character ID (default base=62)
 *   "VcydxgltxrVZSTV"
 *
 *   // Two arguments - returns ID of the specified length, and radix. (Radix must be <= 62)
 *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)
 *   "01001010"
 *   >>> Math.uuid(8, 10) // 8 character ID (base=10)
 *   "47473046"
 *   >>> Math.uuid(8, 16) // 8 character ID (base=16)
 *   "098F4D35"
 */
(function() {
  // Private array of chars to use
  var CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split(''); 

  Geo.Math.uuid = function (len, radix) {
    var chars = CHARS, uuid = [];
    radix = radix || chars.length;

    if (len) {
      // Compact form
      for (var i = 0; i < len; i++) uuid[i] = chars[0 | Math.random()*radix];
    } else {
      // rfc4122, version 4 form
      var r;

      // rfc4122 requires these characters
      uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';
      uuid[14] = '4';

      // Fill in random data.  At i==19 set the high bits of clock sequence as
      // per rfc4122, sec. 4.1.5
      for (var i = 0; i < 36; i++) {
        if (!uuid[i]) {
          r = 0 | Math.random()*16;
          uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
        }
      }
    }

    return uuid.join('');
  };

  // A more performant, but slightly bulkier, RFC4122v4 solution.  We boost performance
  // by minimizing calls to random()
  Geo.Math.uuidFast = function() {
    var chars = CHARS, uuid = new Array(36), rnd=0, r;
    for (var i = 0; i < 36; i++) {
      if (i==8 || i==13 ||  i==18 || i==23) {
        uuid[i] = '-';
      } else if (i==14) {
        uuid[i] = '4';
      } else {
        if (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;
        r = rnd & 0xf;
        rnd = rnd >> 4;
        uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];
      }
    }
    return uuid.join('');
  };

  // A more compact, but less performant, RFC4122v4 solution:
  Geo.Math.uuidCompact = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);
      return v.toString(16);
    }).toUpperCase();
  };
})();
﻿/*
 * heatmap.js 1.0 -    JavaScript Heatmap Library
 *
 * Copyright (c) 2011, Patrick Wied (http://www.patrick-wied.at)
 * Dual-licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and the Beerware (http://en.wikipedia.org/wiki/Beerware) license.
 */

(function(w){
    // the heatmapFactory creates heatmap instances
    var heatmapFactory = (function(){

    // store object constructor
    // a heatmap contains a store
    // the store has to know about the heatmap in order to trigger heatmap updates when datapoints get added
    var store = function store(hmap){

        var _ = {
            // data is a two dimensional array
            // a datapoint gets saved as data[point-x-value][point-y-value]
            // the value at [point-x-value][point-y-value] is the occurrence of the datapoint
            data: [],
            // tight coupling of the heatmap object
            heatmap: hmap
        };
        // the max occurrence - the heatmaps radial gradient alpha transition is based on it
        this.max = 1;

        this.get = function(key){
            return _[key];
        };
        this.set = function(key, value){
            _[key] = value;
        };
    }

    store.prototype = {
        // function for adding datapoints to the store
        // datapoints are usually defined by x and y but could also contain a third parameter which represents the occurrence
        addDataPoint: function(x, y){
            if(x < 0 || y < 0)
                return;

            var me = this,
                heatmap = me.get("heatmap"),
                data = me.get("data");

            if(!data[x])
                data[x] = [];

            if(!data[x][y])
                data[x][y] = 0;

            // if count parameter is set increment by count otherwise by 1
            data[x][y]+=(arguments.length<3)?1:arguments[2];
            
            me.set("data", data);
            // do we have a new maximum?
            if(me.max < data[x][y]){
                // max changed, we need to redraw all existing(lower) datapoints
                heatmap.get("actx").clearRect(0,0,heatmap.get("width"),heatmap.get("height"));
                me.setDataSet({ max: data[x][y], data: data }, true);
                return;
            }
            heatmap.drawAlpha(x, y, data[x][y], true);
        },
        setDataSet: function(obj, internal){
            var me = this,
                heatmap = me.get("heatmap"),
                data = [],
                d = obj.data,
                dlen = d.length;
            // clear the heatmap before the data set gets drawn
            heatmap.clear();
            this.max = obj.max;
            // if a legend is set, update it
            heatmap.get("legend") && heatmap.get("legend").update(obj.max);
            
            if(internal != null && internal){
                for(var one in d){
                    // jump over undefined indexes
                    if(one === undefined)
                        continue;
                    for(var two in d[one]){
                        if(two === undefined)
                            continue;
                        // if both indexes are defined, push the values into the array
                        heatmap.drawAlpha(one, two, d[one][two], false);   
                    }
                }
            }else{
                while(dlen--){
                    var point = d[dlen];
                    heatmap.drawAlpha(point.x, point.y, point.count, false);
                    if(!data[point.x])
                        data[point.x] = [];

                    if(!data[point.x][point.y])
                        data[point.x][point.y] = 0;

                    data[point.x][point.y] = point.count;
                }
            }
            heatmap.colorize();
            this.set("data", d);
        },
        exportDataSet: function(){
            var me = this,
                data = me.get("data"),
                exportData = [];

            for(var one in data){
                // jump over undefined indexes
                if(one === undefined)
                    continue;
                for(var two in data[one]){
                    if(two === undefined)
                        continue;
                    // if both indexes are defined, push the values into the array
                    exportData.push({x: parseInt(one, 10), y: parseInt(two, 10), count: data[one][two]});
                }
            }

            return { max: me.max, data: exportData };
        },
        generateRandomDataSet: function(points){
            var heatmap = this.get("heatmap"),
            w = heatmap.get("width"),
            h = heatmap.get("height");
            var randomset = {},
            max = Math.floor(Math.random()*1000+1);
            randomset.max = max;
            var data = [];
            while(points--){
                data.push({x: Math.floor(Math.random()*w+1), y: Math.floor(Math.random()*h+1), count: Math.floor(Math.random()*max+1)});
            }
            randomset.data = data;
            this.setDataSet(randomset);
        }
    };

    var legend = function legend(config){
        this.config = config;

        var _ = {
            element: null,
            labelsEl: null,
            gradientCfg: null,
            ctx: null
        };
        this.get = function(key){
            return _[key];
        };
        this.set = function(key, value){
            _[key] = value;
        };
        this.init();
    };
    legend.prototype = {
        init: function(){
            var me = this,
                config = me.config,
                title = config.title || "Legend",
                position = config.position,
                offset = config.offset || 10,
                gconfig = config.gradient,
                labelsEl = document.createElement("ul"),
                labelsHtml = "",
                grad, element, gradient, positionCss = "";
 
            me.processGradientObject();
            
            // Positioning

            // top or bottom
            if(position.indexOf('t') > -1){
                positionCss += 'top:'+offset+'px;';
            }else{
                positionCss += 'bottom:'+offset+'px;';
            }

            // left or right
            if(position.indexOf('l') > -1){
                positionCss += 'left:'+offset+'px;';
            }else{
                positionCss += 'right:'+offset+'px;';
            }

            element = document.createElement("div");
            element.style.cssText = "border-radius:5px;position:absolute;"+positionCss+"font-family:Helvetica; width:256px;z-index:10000000000; background:rgba(255,255,255,1);padding:10px;border:1px solid black;margin:0;";
            element.innerHTML = "<h3 style='padding:0;margin:0;text-align:center;font-size:16px;'>"+title+"</h3>";
            // create gradient in canvas
            labelsEl.style.cssText = "position:relative;font-size:12px;display:block;list-style:none;list-style-type:none;margin:0;height:15px;";
            

            // create gradient element
            gradient = document.createElement("div");
            gradient.style.cssText = ["position:relative;display:block;width:256px;height:15px;border-bottom:1px solid black; background-image:url(",me.createGradientImage(),");"].join("");

            element.appendChild(labelsEl);
            element.appendChild(gradient);
            
            me.set("element", element);
            me.set("labelsEl", labelsEl);

            me.update(1);
        },
        processGradientObject: function(){
            // create array and sort it
            var me = this,
                gradientConfig = this.config.gradient,
                gradientArr = [];

            for(var key in gradientConfig){
                if(gradientConfig.hasOwnProperty(key)){
                    gradientArr.push({ stop: key, value: gradientConfig[key] });
                }
            }
            gradientArr.sort(function(a, b){
                return (a.stop - b.stop);
            });
            gradientArr.unshift({ stop: 0, value: 'rgba(0,0,0,0)' });

            me.set("gradientArr", gradientArr);
        },
        createGradientImage: function(){
            var me = this,
                gradArr = me.get("gradientArr"),
                length = gradArr.length,
                canvas = document.createElement("canvas"),
                ctx = canvas.getContext("2d"),
                grad;
            // the gradient in the legend including the ticks will be 256x15px
            canvas.width = "256";
            canvas.height = "15";

            grad = ctx.createLinearGradient(0,5,256,10);

            for(var i = 0; i < length; i++){
                grad.addColorStop(1/(length-1) * i, gradArr[i].value);
            }

            ctx.fillStyle = grad;
            ctx.fillRect(0,5,256,10);
            ctx.strokeStyle = "black";
            ctx.beginPath();
 
            for(var i = 0; i < length; i++){
                ctx.moveTo(((1/(length-1)*i*256) >> 0)+.5, 0);
                ctx.lineTo(((1/(length-1)*i*256) >> 0)+.5, (i==0)?15:5);
            }
            ctx.moveTo(255.5, 0);
            ctx.lineTo(255.5, 15);
            ctx.moveTo(255.5, 4.5);
            ctx.lineTo(0, 4.5);
            
            ctx.stroke();

            // we re-use the context for measuring the legends label widths
            me.set("ctx", ctx);

            return canvas.toDataURL();
        },
        getElement: function(){
            return this.get("element");
        },
        update: function(max){
            var me = this,
                gradient = me.get("gradientArr"),
                ctx = me.get("ctx"),
                labels = me.get("labelsEl"),
                labelText, labelsHtml = "", offset;

            for(var i = 0; i < gradient.length; i++){

                labelText = max*gradient[i].stop >> 0;
                offset = (ctx.measureText(labelText).width/2) >> 0;

                if(i == 0){
                    offset = 0;
                }
                if(i == gradient.length-1){
                    offset *= 2;
                }
                labelsHtml += '<li style="position:absolute;left:'+(((((1/(gradient.length-1)*i*256) || 0)) >> 0)-offset+.5)+'px">'+labelText+'</li>';
            }       
            labels.innerHTML = labelsHtml;
        }
    };

    // heatmap object constructor
    var heatmap = function heatmap(config){
        // private variables
        var _ = {
            radius : 40,
            element : {},
            canvas : {},
            acanvas: {},
            ctx : {},
            actx : {},
            legend: null,
            visible : true,
            width : 0,
            height : 0,
            max : false,
            gradient : false,
            opacity: 180,
            premultiplyAlpha: false,
            bounds: {
                l: 1000,
                r: 0,
                t: 1000,
                b: 0
            },
            debug: false
        };
        // heatmap store containing the datapoints and information about the maximum
        // accessible via instance.store
        this.store = new store(this);

        this.get = function(key){
            return _[key];
        };
        this.set = function(key, value){
            _[key] = value;
        };
        // configure the heatmap when an instance gets created
        this.configure(config);
        // and initialize it
        this.init();
    };

    // public functions
    heatmap.prototype = {
        configure: function(config){
                var me = this,
                    rout, rin;

                me.set("radius", config["radius"] || 40);
                me.set("element", (config.element instanceof Object)?config.element:document.getElementById(config.element));
                me.set("visible", (config.visible != null)?config.visible:true);
                me.set("max", config.max || false);
                me.set("gradient", config.gradient || { 0.45: "rgb(0,0,255)", 0.55: "rgb(0,255,255)", 0.65: "rgb(0,255,0)", 0.95: "yellow", 1.0: "rgb(255,0,0)"});    // default is the common blue to red gradient
                me.set("opacity", parseInt(255/(100/config.opacity), 10) || 180);
                me.set("width", config.width || 0);
                me.set("height", config.height || 0);
                me.set("debug", config.debug);

                if(config.legend){
                    var legendCfg = config.legend;
                    legendCfg.gradient = me.get("gradient");
                    me.set("legend", new legend(legendCfg));
                }
				me.set("map", config.map);
                
        },
        resize: function () {
                var me = this,
                    element = me.get("element"),
                    canvas = me.get("canvas"),
                    acanvas = me.get("acanvas");
                canvas.width = acanvas.width = me.get("width") || element.style.width.replace(/px/, "") || me.getWidth(element);
                this.set("width", canvas.width);
                canvas.height = acanvas.height = me.get("height") || element.style.height.replace(/px/, "") || me.getHeight(element);
                this.set("height", canvas.height);
        },

        init: function(){
                var me = this,
                    canvas = document.createElement("canvas"),
                    acanvas = document.createElement("canvas"),
                    ctx = canvas.getContext("2d"),
                    actx = acanvas.getContext("2d"),
                    element = me.get("element");

                
                me.initColorPalette();

                me.set("canvas", canvas);
                me.set("ctx", ctx);
                me.set("acanvas", acanvas);
                me.set("actx", actx);

                me.resize();
                canvas.style.cssText = acanvas.style.cssText = "position:absolute;top:0;left:0;z-index:10000000;";
                
                if(!me.get("visible"))
                    canvas.style.display = "none";

                element.appendChild(canvas);
                if(me.get("legend")){
					if(me.get("map")){
						me.get("map").viewPortDiv.appendChild(me.get("legend").getElement());
					}else{
						element.appendChild(me.get("legend").getElement());
					}
                }
                
                // debugging purposes only
                if(me.get("debug"))
                    document.body.appendChild(acanvas);
                
                actx.shadowOffsetX = 15000; 
                actx.shadowOffsetY = 15000; 
                actx.shadowBlur = 15; 
        },
        initColorPalette: function(){

            var me = this,
                canvas = document.createElement("canvas"),
                gradient = me.get("gradient"),
                ctx, grad, testData;

            canvas.width = "1";
            canvas.height = "256";
            ctx = canvas.getContext("2d");
            grad = ctx.createLinearGradient(0,0,1,256);

            // Test how the browser renders alpha by setting a partially transparent pixel
            // and reading the result.  A good browser will return a value reasonably close
            // to what was set.  Some browsers (e.g. on Android) will return a ridiculously wrong value.
            testData = ctx.getImageData(0,0,1,1);
            testData.data[0] = testData.data[3] = 64; // 25% red & alpha
            testData.data[1] = testData.data[2] = 0; // 0% blue & green
            ctx.putImageData(testData, 0, 0);
            testData = ctx.getImageData(0,0,1,1);
            me.set("premultiplyAlpha", (testData.data[0] < 60 || testData.data[0] > 70));
            
            for(var x in gradient){
                grad.addColorStop(x, gradient[x]);
            }

            ctx.fillStyle = grad;
            ctx.fillRect(0,0,1,256);

            me.set("gradient", ctx.getImageData(0,0,1,256).data);
        },
        getWidth: function(element){
            var width = element.offsetWidth;
            if(element.style.paddingLeft){
                width+=element.style.paddingLeft;
            }
            if(element.style.paddingRight){
                width+=element.style.paddingRight;
            }

            return width;
        },
        getHeight: function(element){
            var height = element.offsetHeight;
            if(element.style.paddingTop){
                height+=element.style.paddingTop;
            }
            if(element.style.paddingBottom){
                height+=element.style.paddingBottom;
            }

            return height;
        },
        colorize: function(x, y){
                // get the private variables
                var me = this,
                    width = me.get("width"),
                    radius = me.get("radius"),
                    height = me.get("height"),
                    actx = me.get("actx"),
                    ctx = me.get("ctx"),
                    x2 = radius * 3,
                    premultiplyAlpha = me.get("premultiplyAlpha"),
                    palette = me.get("gradient"),
                    opacity = me.get("opacity"),
                    bounds = me.get("bounds"),
                    left, top, bottom, right, 
                    image, imageData, length, alpha, offset, finalAlpha;
                
                if(x != null && y != null){
                    if(x+x2>width){
                        x=width-x2;
                    }
                    if(x<0){
                        x=0;
                    }
                    if(y<0){
                        y=0;
                    }
                    if(y+x2>height){
                        y=height-x2;
                    }
                    left = x;
                    top = y;
                    right = x + x2;
                    bottom = y + x2;

                }else{
                    if(bounds['l'] < 0){
                        left = 0;
                    }else{
                        left = bounds['l'];
                    }
                    if(bounds['r'] > width){
                        right = width;
                    }else{
                        right = bounds['r'];
                    }
                    if(bounds['t'] < 0){
                        top = 0;
                    }else{
                        top = bounds['t'];
                    }
                    if(bounds['b'] > height){
                        bottom = height;
                    }else{
                        bottom = bounds['b'];
                    }    
                }

                image = actx.getImageData(left, top, right-left, bottom-top);
                imageData = image.data;
                length = imageData.length;
                // loop thru the area
                for(var i=3; i < length; i+=4){

                    // [0] -> r, [1] -> g, [2] -> b, [3] -> alpha
                    alpha = imageData[i],
                    offset = alpha*4;

                    if(!offset)
                        continue;

                    // we ve started with i=3
                    // set the new r, g and b values
                    finalAlpha = (alpha < opacity)?alpha:opacity;
                    imageData[i-3]=palette[offset];
                    imageData[i-2]=palette[offset+1];
                    imageData[i-1]=palette[offset+2];
                    
                    if (premultiplyAlpha) {
                    	// To fix browsers that premultiply incorrectly, we'll pass in a value scaled
                    	// appropriately so when the multiplication happens the correct value will result.
                    	imageData[i-3] /= 255/finalAlpha;
                    	imageData[i-2] /= 255/finalAlpha;
                    	imageData[i-1] /= 255/finalAlpha;
                    }
                    
                    // we want the heatmap to have a gradient from transparent to the colors
                    // as long as alpha is lower than the defined opacity (maximum), we'll use the alpha value
                    imageData[i] = finalAlpha;
                }
                // the rgb data manipulation didn't affect the ImageData object(defined on the top)
                // after the manipulation process we have to set the manipulated data to the ImageData object
                image.data = imageData;
                ctx.putImageData(image, left, top);
        },
        drawAlpha: function(x, y, count, colorize){
                // storing the variables because they will be often used
                var me = this,
                    radius = me.get("radius"),
                    ctx = me.get("actx"),
                    max = me.get("max"),
                    bounds = me.get("bounds"),
                    xb = x - (1.5 * radius) >> 0, yb = y - (1.5 * radius) >> 0,
                    xc = x + (1.5 * radius) >> 0, yc = y + (1.5 * radius) >> 0;

                ctx.shadowColor = ('rgba(0,0,0,'+((count)?(count/me.store.max):'0.1')+')');

                ctx.shadowOffsetX = 15000; 
                ctx.shadowOffsetY = 15000; 
                ctx.shadowBlur = 15; 

                ctx.beginPath();
                ctx.arc(x - 15000, y - 15000, radius, 0, Math.PI * 2, true);
                ctx.closePath();
                ctx.fill();
                if(colorize){
                    // finally colorize the area
                    me.colorize(xb,yb);
                }else{
                    // or update the boundaries for the area that then should be colorized
                    if(xb < bounds["l"]){
                        bounds["l"] = xb;
                    }
                    if(yb < bounds["t"]){
                        bounds["t"] = yb;
                    }
                    if(xc > bounds['r']){
                        bounds['r'] = xc;
                    }
                    if(yc > bounds['b']){
                        bounds['b'] = yc;
                    }
                }
        },
        toggleDisplay: function(){
                var me = this,
                    visible = me.get("visible"),
                canvas = me.get("canvas");

                if(!visible)
                    canvas.style.display = "block";
                else
                    canvas.style.display = "none";

                me.set("visible", !visible);
        },
        // dataURL export
        getImageData: function(){
                return this.get("canvas").toDataURL();
        },
        clear: function(){
            var me = this,
                w = me.get("width"),
                h = me.get("height");

            me.store.set("data",[]);
            // @TODO: reset stores max to 1
            //me.store.max = 1;
            me.get("ctx").clearRect(0,0,w,h);
            me.get("actx").clearRect(0,0,w,h);
        },
        cleanup: function(){
            var me = this;
            me.get("element").removeChild(me.get("canvas"));
        }
    };

    return {
            create: function(config){
                return new heatmap(config);
            }, 
            util: {
                mousePosition: function(ev){
                    // this doesn't work right
                    // rather use
                    /*
                        // this = element to observe
                        var x = ev.pageX - this.offsetLeft;
                        var y = ev.pageY - this.offsetTop;

                    */
                    var x, y;

                    if (ev.layerX) { // Firefox
                        x = ev.layerX;
                        y = ev.layerY;
                    } else if (ev.offsetX) { // Opera
                        x = ev.offsetX;
                        y = ev.offsetY;
                    }
                    if(typeof(x)=='undefined')
                        return;

                    return [x,y];
                }
            }
        };
    })();
    w.h337 = w.heatmapFactory = heatmapFactory;
})(window);
/**
 * Class: Geo.Util.Format.BusCapabilities
 * 公交换乘服务Capabilities操作解析类，继承自Geo.Format.XML类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.Format.XML>
 */
Geo.Util.Format.BusCapabilities = Geo.Class(Geo.Format.XML,{
	
    /**
     * APIProperty: tagName
     * {String} 常量"NETWORK_Capabilities" ,根据该服务的getCapabilities请求返回而定。
     */
	tagName: "NETWORK_Capabilities",

	 /**
     * APIMethod: read
     * 解析一个XML串并返回capabilitiesObj｛Object｝对象。
     *
     * Parameters:
     * data - {String} 一个XML字符串。
     *
     * Returns:
     * ｛Object｝- capabilitiesObj
     */
    read: function(data){
		if(typeof data == "string") {
            data = Geo.Format.XML.prototype.read.apply(this, [data]);
        }
		
		var capabilitiesNode;
		if(data.nodeName != this.tagName){
			capabilitiesNode = data.getElementsByTagName(this.tagName);
		} else {
			capabilitiesNode = [data];
		}
		
		var capabilitiesObj = {};
		if(capabilitiesNode.length > 0){
			this.runChildNodes(capabilitiesObj, capabilitiesNode[0]);
		}
		return capabilitiesObj;
	},

	/**
     * Method: runChildNodes
     * 解析每一个节点字符串并把相对应值赋给传入最终返回的对象obj。
     *
     * Parameters:
     * obj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     * parentPath - {String}解析方法拼去，这里使用"capabilities"。
     * 
     */	
	runChildNodes: function(obj, node, parentPath) {
        var children = node.childNodes;
        var childNode, processor;
        for(var i=0; i<children.length; ++i) {
            childNode = children[i];
            if(childNode.nodeType == 1) {
				if(parentPath){
					processor = this["read_" + parentPath + "_" + childNode.nodeName];
				} else{
					processor = this["read_" + childNode.nodeName];
				}
                
                if(processor) {
                    processor.apply(this, [obj, childNode]);
                }
            }
        }
    },

	/**
     * Method: read_Service
     * 解析节点Service的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Service: function(capabilitiesObj, node){
		var serviceObj = {};
		this.runChildNodes(serviceObj, node, "Service");
		capabilitiesObj.service = serviceObj;
	},

	/**
     * Method: read_Service_Name
     * 解析节点为Name的节点。
     *
     * Parameters:
     * servcieObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Service_Name: function(servcieObj,node){
		var name = this.getChildValue(node);
		if(name) {
            servcieObj.name = name;
        }
	},

	/**
     * Method: read_Service_Title
     * 解析节点为Title的节点。
     *
     * Parameters:
     * servcieObj - {Object} 最终返回的对象
     * node - ｛DOMElement｝ 需要解析的节点对象
     */		
	read_Service_Title: function(servcieObj,node){
		var title = this.getChildValue(node);
		if(title) {
            servcieObj.title = title;
        }
	},

	/**
     * Method: read_Service_Abstract
     * 解析节点为Abstract的节点。
     *
     * Parameters:
     * servcieObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Service_Abstract: function(servcieObj,node){
		var serviceAbstract = this.getChildValue(node);
		if(serviceAbstract) {
            servcieObj.serviceAbstract = serviceAbstract;
        }
	},

	/**
     * Method: read_Service_KeywordList
     * 解析节点为KeywordList的节点。
     *
     * Parameters:
     * userScenarioObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Service_KeywordList: function(userScenarioObj,node){
	},

	/**
     * Method: read_Service_OnlineResource
     * 解析节点为OnlineResource的节点。
     *
     * Parameters:
     * servcieObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Service_OnlineResource: function(servcieObj,node){
		var onlineResource = this.getChildValue(node);
		if(servcieObj) {
            servcieObj.onlineResource = onlineResource;
        }
	},

	/**
     * Method: read_Capability
     * 解析节点为Capability的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability: function(capabilitiesObj,node){
		var capaObj = {};
		this.runChildNodes(capaObj, node, "Capability");
		capabilitiesObj.capability = capaObj;
	},

	/**
     * Method: read_Capability_Request
     * 解析节点为Request的节点。
     *
     * Parameters:
     * capaObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request: function(capaObj,node){
		var requestObj = {};
		this.runChildNodes(requestObj, node, "Capability_Request");
		capaObj.request = requestObj;
	},

	/**
     * Method: read_Capability_Request_GetCapabilities
     * 解析节点为GetCapabilities的节点。
     *
     * Parameters:
     * requestObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_GetCapabilities: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var getCapaObj ={};
		if(httpNode[0]){
			this.runChildNodes(getCapaObj, httpNode[0], "Capability_Request_GetCapabilities_DCPType_HTTP");
		}
		requestObj.getCapabilities = getCapaObj;
		
	},

	/**
     * Method: read_Capability_Request_GetCapabilities_DCPType_HTTP_Get
     * 解析节点为DCPType_HTTP_Get的节点。
     *
     * Parameters:
     * getCapaObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Capability_Request_GetCapabilities_DCPType_HTTP_Get: function(getCapaObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            getCapaObj.getUrl = getUrl;
        }
	},

	/**
     * Method: read_Capability_Request_GetCapabilities_DCPType_HTTP_Post
     * 解析节点为DCPType_HTTP_Post的节点。
     *
     * Parameters:
     * getCapaObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Capability_Request_GetCapabilities_DCPType_HTTP_Post: function(getCapaObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            getCapaObj.postUrl = postUrl;
        }
	},
	
	/**
     * Method: read_Capability_Request_queryStation
     * 解析节点为queryStation的节点。
     *
     * Parameters:
     * requestObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryStation: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var queryStationObj = {};
		if(httpNode[0]){
			this.runChildNodes(queryStationObj, httpNode[0], "Capability_Request_queryStation_DCPType_HTTP");
		}
		requestObj.queryStation = queryStationObj;
		
	},

	/**
     * Method: read_Capability_Request_queryStation_DCPType_HTTP_Get
     * 解析节点为DCPType_HTTP_Get的节点。
     *
     * Parameters:
     * queryStationObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */	
	read_Capability_Request_queryStation_DCPType_HTTP_Get: function(queryStationObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            queryStationObj.getUrl = getUrl;
        }
	},
	
	read_Capability_Request_queryStation_DCPType_HTTP_Post: function(queryStationObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            queryStationObj.postUrl = postUrl;
        }
	},

	/**
     * Method: read_Capability_Request_queryLine
     * 解析节点为queryLine的节点。
     *
     * Parameters:
     * requestObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryLine: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var queryLineObj = {};
		if(httpNode[0]){
			this.runChildNodes(queryLineObj, httpNode[0], "Capability_Request_queryLine_DCPType_HTTP");
		}
		requestObj.queryLine = queryLineObj;
		
	},

	/**
     * Method: read_Capability_Request_queryLine_DCPType_HTTP_Get
     * 解析节点为DCPType_HTTP_Get的节点。
     *
     * Parameters:
     * queryLineObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */			
	read_Capability_Request_queryLine_DCPType_HTTP_Get: function(queryLineObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            queryLineObj.getUrl = getUrl;
        }
	},

	/**
     * Method: read_Capability_Request_queryLine_DCPType_HTTP_Post
     * 解析节点为DCPType_HTTP_Post的节点。
     *
     * Parameters:
     * queryLineObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryLine_DCPType_HTTP_Post: function(queryLineObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            queryLineObj.postUrl = postUrl;
        }	
	},

	/**
     * Method: read_Capability_Request_queryChange
     * 解析节点为queryChange的节点。
     *
     * Parameters:
     * requestObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryChange: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var queryChangeObj = {};
		if(httpNode[0]){
			this.runChildNodes(queryChangeObj, httpNode[0], "Capability_Request_queryChange_DCPType_HTTP");
		}
		
	},

	/**
     * Method: read_Capability_Request_queryChange_DCPType_HTTP_Get
     * 解析节点为DCPType_HTTP_Get的节点。
     *
     * Parameters:
     * queryChangeObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryChange_DCPType_HTTP_Get: function(queryChangeObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            queryChangeObj.getUrl = getUrl;
        }
	},

	/**
     * Parameters: read_Capability_Request_queryChange_DCPType_HTTP_Post
     * 解析节点为DCPType_HTTP_Post的节点。
     *
     * Method:
     * queryChangeObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Request_queryChange_DCPType_HTTP_Post: function(queryChangeObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            queryChangeObj.postUrl = postUrl;
        }	
	},

	/**
     * Method: read_Capability_Networks
     * 解析节点为Networks的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - ｛DOMElement｝ 需要解析的节点对象。
     */		
	read_Capability_Networks: function(capabilitiesObj,node){		
		var networkNodes = node.getElementsByTagName("Name");
		var networks = [];
		for(var i=0; i<networkNodes.length; i++){
			var network = this.getChildValue(networkNodes[i]);
			if(network){
				networks.push(network);
			}			
		}
		capabilitiesObj.networks = networks;
	},
	
	CLASS_NAME:"Geo.Util.Format.BusCapabilities"
});/**
 * Class: Geo.Util.Format.GlobeTileCapabilities
 * GlobeTile服务getCapabilities操作请求结果的XML解析器，继承自Geo.Format.XML类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.Format.XML>
 */
Geo.Util.Format.GlobeTileCapabilities = Geo.Class(Geo.Format.XML,{
	
   /**
     * APIProperty: tagName
     * {String} 常量"ServiceCapabilities" ,根据该服务的getCapabilities请求返回而定。
     */
	tagName: "ServiceCapabilities",

	 /**
     * APIMethod: read
     * 解析一个XML串并返回capabilitiesObj{Object}对象。
     *
     * Parameters:
     * data - {String} 一个XML字符串。
     *
     * Returns:
     * {Object}- capabilitiesObj
     */
    read: function(data){
		if(typeof data == "string") {
            data = Geo.Format.XML.prototype.read.apply(this, [data]);
        }
		
		var capabilitiesNode;
		if(data.nodeName != this.tagName){
			capabilitiesNode = data.getElementsByTagName(this.tagName);
		} else {
			capabilitiesNode = [data];
		}
		
		var capabilitiesObj = null;
		if(capabilitiesNode.length > 0){
			capabilitiesObj = {};
			this.runChildNodes(capabilitiesObj, capabilitiesNode[0], "capabilities");
		}
		return capabilitiesObj;
	},
	
	/**
     * Method: runChildNodes
     * 解析每一个节点字符串并把相对应值赋给传入最终返回的对象obj。
     *
     * Parameters:
     * obj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     * parentPath - {String}解析方法拼去，这里使用"capabilities"。
     * 
     */
	runChildNodes: function(obj, node, parentPath) {
        var children = node.childNodes;
        var childNode, processor;
        for(var i=0; i<children.length; ++i) {
            childNode = children[i];
            if(childNode.nodeType == 1) {
                processor = this["read_" + parentPath + "_" + childNode.nodeName];
                if(processor) {
                    processor.apply(this, [obj, childNode]);
                }
            }
        }
    },
	
	/**
     * Method: read_capabilities_Name
     * 解析节点为Name的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Name: function(capabilitiesObj, node){
		var name = this.getChildValue(node);
        if(name) {
            capabilitiesObj.name = name;
        }
	},
	
	/**
     * Method: read_capabilities_Service
     * 解析节点为Service的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Service: function(capabilitiesObj, node){
		var service = this.getChildValue(node);
        if(service) {
            capabilitiesObj.service = service;
        }
	},
	
	/**
     * Method: read_capabilities_Version
     * 解析节点为Version的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Version: function(capabilitiesObj, node){
		var version = this.getChildValue(node);
        if(version) {
            capabilitiesObj.version = version;
        }
	},
	
	/**
     * Method: read_capabilities_Abstract
     * 解析节点为Abstract的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Abstract: function(capabilitiesObj, node){
		var abstractValue = this.getChildValue(node);
        if(abstractValue) {
            capabilitiesObj.abstractValue = abstractValue;
        }
	},
	
	/**
     * Method: read_capabilities_ServerAddress
     * 解析节点为ServerAddress的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_ServerAddress: function(capabilitiesObj, node){
		var serverAddress = this.getChildValue(node);
        if(serverAddress) {
            capabilitiesObj.serverAddress = serverAddress;
        }
	},
	
	/**
     * Method: read_capabilities_OperationList
     * 解析节点为OperationList的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_OperationList: function(capabilitiesObj, node){
		var operationsNode = node.getElementsByTagName("Operations");
		if(operationsNode.length > 0){
			this.read_capabilities_OperationList_Operations(capabilitiesObj, operationsNode[0]);
		}
	},	
	
	/**
     * Method: read_capabilities_OperationList_Operations
     * 解析节点为Operations的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_OperationList_Operations: function(capabilitiesObj, node){
		var operationList = {};
		var operations = {};
		this.runChildNodes(operations, node, "capabilities_OperationList_Operations");
		operationList.operations = operations;
		capabilitiesObj.operationList = operationList;
	},	
	
	/**
     * Method: read_capabilities_OperationList_Operations_GetTile
     * 解析节点为GetTile的节点。
     *
     * Parameters:
     * operations - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_OperationList_Operations_GetTile: function(operations, node){
		var getTile = {};
		var format = [];
		var formatNode = node.getElementsByTagName("Format");
		if (formatNode.length > 0) {
			for(var i = 0; i < formatNode.length; i++){
				var formatValue = this.getChildValue(formatNode[i]);
				format.push(formatValue);
			}
			getTile.format = format;
		}
		operations.getTile = getTile;
	},
	
	/**
     * Method: read_capabilities_Data
     * 解析节点为Data的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data: function(capabilitiesObj, node){
		var tileDataNode = node.getElementsByTagName("TileData");
		if(tileDataNode.length > 0){
			this.read_capabilities_Data_TileData(capabilitiesObj, tileDataNode[0]);
		}
	},
	
	/**
     * Method: read_capabilities_Data_TileData
     * 解析节点为Data_TileData的节点。
     *
     * Parameters:
     * capabilitiesObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData: function(capabilitiesObj, node){
		var tileData = {}
		this.runChildNodes(tileData, node, "capabilities_Data_TileData");
		capabilitiesObj.tileData = tileData;
	},
	
	/**
     * Method: read_capabilities_Data_TileData_Tile
     * 解析节点为Tile的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_Tile: function(tileData, node){
		var tile = this.getChildValue(node);
        if(tile) {
            tileData.tile = tile;
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_CRS
     * 解析节点为CRS的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_CRS: function(tileData, node){
		var crs = this.getChildValue(node);
        if(crs) {
            tileData.crs = crs;
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_BoundBox
     * 解析节点为BoundBox的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_BoundBox: function(tileData, node){
		
		var boundBox = new Geo.Bounds(
			parseFloat(node.getAttribute("minx") || node.getAttribute("minX")),
			parseFloat(node.getAttribute("miny") || node.getAttribute("minY")),
			parseFloat(node.getAttribute("maxx") || node.getAttribute("maxX")),
			parseFloat(node.getAttribute("maxy") || node.getAttribute("maxY"))
		);
        tileData.boundBox = boundBox;
        
	},
	
	/**
     * Method: read_capabilities_Data_TileData_LevelZeroTileSizeX
     * 解析节点为LevelZeroTileSizeX的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_LevelZeroTileSizeX: function(tileData, node){
		var levelZeroTileSizeX = this.getChildValue(node);
        if(levelZeroTileSizeX) {
            tileData.levelZeroTileSizeX = parseInt(levelZeroTileSizeX);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_LevelZeroTileSizeY
     * 解析节点为LevelZeroTileSizeY的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_LevelZeroTileSizeY: function(tileData, node){
		var levelZeroTileSizeY = this.getChildValue(node);
        if(levelZeroTileSizeY) {
            tileData.levelZeroTileSizeY = parseInt(levelZeroTileSizeY);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_TopLevel
     * 解析节点为TopLevel的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_TopLevel: function(tileData, node){
		var topLevel = this.getChildValue(node);
        if(topLevel) {
            tileData.topLevel = parseInt(topLevel);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_BottomLevel
     * 解析节点为BottomLevel的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_BottomLevel: function(tileData, node){
		var bottomLevel = this.getChildValue(node);
        if(bottomLevel) {
            tileData.bottomLevel = parseInt(bottomLevel);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_DEMDataType
     * 解析节点为DEMDataType的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_DEMDataType: function(tileData, node){
		var demDataType = this.getChildValue(node);
        if(demDataType) {
            tileData.demDataType = demDataType;
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_TileVersionTime
     * 解析节点为TileVersionTime的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_TileVersionTime: function(tileData, node){
		var tileVerstionTime = this.getChildValue(node);
		if(tileVerstionTime){
			if(!tileData.tileVerstionTime){
				tileData.tileVerstionTime = []
			}
			tileData.tileVerstionTime.push(tileVerstionTime);
		}
	},
	
	/**
     * Method: read_capabilities_Data_TileData_TilePixelsX
     * 解析节点为TilePixelsX的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_TilePixelsX: function(tileData, node){
		var tilePixelsX = this.getChildValue(node);
        if(tilePixelsX) {
            tileData.tilePixelsX = parseInt(tilePixelsX);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_TilePixelsY
     * 解析节点为TilePixelsY的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_TilePixelsY: function(tileData, node){
		var tilePixelsY = this.getChildValue(node);
        if(tilePixelsY) {
            tileData.tilePixelsY = parseInt(tilePixelsY);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_CacheExpireTime
     * 解析节点为CacheExpireTime的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_CacheExpireTime: function(tileData, node){
		var cacheExpireTime = this.getChildValue(node);
        if(cacheExpireTime) {
            tileData.cacheExpireTime = parseInt(cacheExpireTime);
        }
	},
	
	/**
     * Method: read_capabilities_Data_TileData_Pyramid
     * 解析节点为Pyramid的节点。
     *
     * Parameters:
     * tileData - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_capabilities_Data_TileData_Pyramid: function(tileData, node){
        var parser = new Geo.Util.Format.Pyramid();
		var pyramidObj = parser.read(node);
		tileData.pyramid = pyramidObj;
	},
	
	CLASS_NAME:"Geo.Util.Format.GlobeTileCapabilities"
});/**
 * Class: Geo.Util.Format.Pyramid
 * 金字塔XML描述解析器，继承自Geo.Format.XML类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.Format.XML>
 */
Geo.Util.Format.Pyramid = Geo.Class(Geo.Format.XML,{
	
	 /**
     * APIProperty: tagName
     * {String} 金字塔标签名，默认为"Pyramid" 。
     */
	tagName: "Pyramid",

	/**
     * APIMethod: read
     * 解析金字塔XML描述字符串并返回解析后的JavaScript对象。
     *
     * Parameters:
     * data - {String} 一个XML字符串。
     *
     * Returns:
     * {Object}- pyramidObj
     */
    read: function(data){
		if(typeof data == "string") {
            data = Geo.Format.XML.prototype.read.apply(this, [data]);
        }
		
		var pyramidNode;
		if(data.nodeName != this.tagName){
			pyramidNode = data.getElementsByTagName(this.tagName);
		} else {
			pyramidNode = [data];
		}
		var pyramidObj = {};
		if(pyramidNode.length > 0){
			this.runChildNodes(pyramidObj, pyramidNode[0]);
		}
		return pyramidObj;
	},
	
	/**
     * Method: runChildNodes
     * 解析每一个节点字符串并把相对应值赋给传入最终返回的对象obj。
     *
     * Parameters:
     * obj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     * 
     */
	runChildNodes: function(obj, node) {
        var children = node.childNodes;
        var childNode, processor;
        for(var i=0; i<children.length; ++i) {
            childNode = children[i];
            if(childNode.nodeType == 1) {
                processor = this["read_Pyramid_" + childNode.nodeName];
                if(processor) {
                    processor.apply(this, [obj, childNode]);
                }
            }
        }
    },
	
	/**
     * Method: read_Pyramid_Basic
     * 解析节点为Basic的节点。
     *
     * Parameters:
     * pyramidObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_Pyramid_Basic: function(pyramidObj, node){
		var basic = {
			name: node.getAttribute("Name"),
			pyramidID: node.getAttribute("PyramidID"),
			description: node.getAttribute("Description")
		};
		OpenLayers.Util.extend(pyramidObj, basic);
	},
	
	/**
     * Method: read_Pyramid_Level
     * 解析节点为Level的节点。
     *
     * Parameters:
     * pyramidObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_Pyramid_Level: function(pyramidObj, node){
		var level = {
			topLevelIndex: parseInt(node.getAttribute("TopLevelIndex")),
			bottomLevelIndex: parseInt(node.getAttribute("BottomLevelIndex")),
			scaleX: parseInt(node.getAttribute("ScaleX")),
			scaleY: parseInt(node.getAttribute("ScaleY"))
		};
		OpenLayers.Util.extend(pyramidObj, level);
	},
	
	/**
     * Method: read_Pyramid_TileBasic
     * 解析节点为TileBasic的节点。
     *
     * Parameters:
     * pyramidObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_Pyramid_TileBasic: function(pyramidObj, node){
		var tileBasic = {
			tileSizeX: parseFloat(node.getAttribute("TileSizeX")),
			tileSizeY: parseFloat(node.getAttribute("TileSizeY")),
			originRowIndex: parseInt(node.getAttribute("OriginRowIndex")),
			originColIndex: parseInt(node.getAttribute("OriginColIndex"))
		};
		OpenLayers.Util.extend(pyramidObj, tileBasic);
	},
	
	/**
     * Method: read_Pyramid_TopTile
     * 解析节点为TopTile的节点。
     *
     * Parameters:
     * pyramidObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_Pyramid_TopTile: function(pyramidObj, node){
		var topTile = {
			fromX: parseInt(node.getAttribute("FromX")),
			fromY: parseInt(node.getAttribute("FromY")),
			toX: parseInt(node.getAttribute("ToX")),
			toY: parseInt(node.getAttribute("ToY"))
		};
		OpenLayers.Util.extend(pyramidObj, topTile);
	},
	
	//无用，暂时关闭
	/*read_Pyramid_Const: function(pyramidObj, node){
		var constant = {
			pi: parseFloat(node.getAttribute("PI")),
			tolerance: parseFloat(node.getAttribute("Tolerance"))
		};
		OpenLayers.Util.extend(pyramidObj, constant);
	},*/
	
	/**
     * Method: read_Pyramid_Range
     * 解析节点为Range的节点。
     *
     * Parameters:
     * pyramidObj - {Object} 最终返回的对象。
     * node - {DOMElement} 需要解析的节点对象。
     */
	read_Pyramid_Range: function(pyramidObj, node){
		var range = {
			xmin: parseInt(node.getAttribute("XMin")),
			xmax: parseInt(node.getAttribute("XMax")),
			ymin: parseInt(node.getAttribute("YMin")),
			ymax: parseInt(node.getAttribute("YMax"))
		};
		OpenLayers.Util.extend(pyramidObj, range);
	},
	
	CLASS_NAME: "Geo.Util.Format.Pyramid"	
});
/**
 * Class: Geo.Util.Format.XML2JSON
 * 将XML文件解析成Javascript对象。
 */
Geo.Util.Format.XML2JSON = Geo.Class({
	
	/**
	 * Constructor: Geo.Util.Format.XML2JSON
	 * Geo.Util.Format.XML2JSON构造函数。
	 */
	initialize: function(){
		
	},
	
    /**
	 * APIMethod: read
	 * 将传入的XML字符串解析成Javascript对象并返回。
	 *
	 * Parameters: 
	 * xmlcode - {String} XML字符串。
	 */	
	read: function(xmlcode,ignoretags,debug){
		if(!ignoretags){ignoretags=""};
		xmlcode=xmlcode.replace(/\s*\/>/g,'/>');
		xmlcode=xmlcode.replace(/<\?[^>]*>/g,"").replace(/<\![^>]*>/g,"");
		if (!ignoretags.sort){ignoretags=ignoretags.split(",")};
		var x=this.no_fast_endings(xmlcode);
		x=this.attris_to_tags(x);
		x=escape(x);
		x=x.split("%3C").join("<").split("%3E").join(">").split("%3D").join("=").split("%22").join("\"");
		for (var i=0;i<ignoretags.length;i++){
			x=x.replace(new RegExp("<"+ignoretags[i]+">","g"),"*$**"+ignoretags[i]+"**$*");
			x=x.replace(new RegExp("</"+ignoretags[i]+">","g"),"*$***"+ignoretags[i]+"**$*")
		};
		x='<JSONTAGWRAPPER>'+x+'</JSONTAGWRAPPER>';
		this.xmlobject={};
		
		//---------------------修正禁止属性小写后,出现jsontagwrapper变成数组
		var y=this.xml_to_object(x).JSONTAGWRAPPER;
		//var y=this.xml_to_object(x).jsontagwrapper;
		
		if(debug){y=this.show_json_structure(y,debug)};
		return y
	},
	
	xml_to_object:function(xmlcode){
		var x=xmlcode.replace(/<\//g,"?");
		x=x.split("<");
		var y=[];
		var level=0;
		var opentags=[];
		for (var i=1;i<x.length;i++){
			var tagname=x[i].split(">")[0];
			opentags.push(tagname);
			level++
			y.push(level+"<"+x[i].split("?")[0]);
			while(x[i].indexOf("?"+opentags[opentags.length-1]+">")>=0){level--;opentags.pop()}
		};
		var oldniva=-1;
		var objname="this.xmlobject";
		for (var i=0;i<y.length;i++){
			var preeval="";
			var niva=y[i].split("<")[0];
			var tagnamn=y[i].split("<")[1].split(">")[0];
			
			//---------------------修正:禁止将属性和标签统一成小写,并将命名空间的冒号转成下划线
			tagnamn = tagnamn.replace(/%3A/,"_");
			//tagnamn=tagnamn.toLowerCase();
			
			var rest=y[i].split(">")[1];
			if(niva<=oldniva){
				var tabort=oldniva-niva+1;
				for (var j=0;j<tabort;j++){objname=objname.substring(0,objname.lastIndexOf("."))}
			};
			objname+="."+tagnamn;
			var pobject=objname.substring(0,objname.lastIndexOf("."));
			if (eval("typeof "+pobject) != "object"){preeval+=pobject+"={value:"+pobject+"};\n"};
			var objlast=objname.substring(objname.lastIndexOf(".")+1);
			var already=false;
			for (k in eval(pobject)){if(k==objlast){already=true}};
			var onlywhites=true;
			for(var s=0;s<rest.length;s+=3){
				if(rest.charAt(s)!="%"){onlywhites=false}
			};
			if (rest!="" && !onlywhites){
				if(rest/1!=rest){
					rest="'"+rest.replace(/\'/g,"\\'")+"'";
					rest=rest.replace(/\*\$\*\*\*/g,"</");
					rest=rest.replace(/\*\$\*\*/g,"<");
					rest=rest.replace(/\*\*\$\*/g,">")
				}
			} 
			else {rest="{}"};
			if(rest.charAt(0)=="'"){rest='unescape('+rest+')'};
			if (already && !eval(objname+".sort")){preeval+=objname+"=["+objname+"];\n"};
			var before="=";after="";
			if (already){before=".push(";after=")"};
			var toeval=preeval+objname+before+rest+after;
			eval(toeval);
			if(eval(objname+".sort")){objname+="["+eval(objname+".length-1")+"]"};
			oldniva=niva
		};
		return this.xmlobject
	},
	show_json_structure:function(obj,debug,l){
		var x='';
		if (obj.sort){x+="[\n"} else {x+="{\n"};
		for (var i in obj){
			if (!obj.sort){x+=i+":"};
			if (typeof obj[i] == "object"){
				x+=this.show_json_structure(obj[i],false,1)
			}
			else {
				if(typeof obj[i]=="function"){
					var v=obj[i]+"";
					//v=v.replace(/\t/g,"");
					x+=v
				}
				else if(typeof obj[i]!="string"){x+=obj[i]+",\n"}
				else {x+="'"+obj[i].replace(/\'/g,"\\'").replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/\r/g,"\\r")+"',\n"}
			}
		};
		if (obj.sort){x+="],\n"} else {x+="},\n"};
		if (!l){
			x=x.substring(0,x.lastIndexOf(","));
			x=x.replace(new RegExp(",\n}","g"),"\n}");
			x=x.replace(new RegExp(",\n]","g"),"\n]");
			var y=x.split("\n");x="";
			var lvl=0;
			for (var i=0;i<y.length;i++){
				if(y[i].indexOf("}")>=0 || y[i].indexOf("]")>=0){lvl--};
				tabs="";for(var j=0;j<lvl;j++){tabs+="\t"};
				x+=tabs+y[i]+"\n";
				if(y[i].indexOf("{")>=0 || y[i].indexOf("[")>=0){lvl++}
			};
			if(debug=="html"){
				x=x.replace(/</g,"&lt;").replace(/>/g,"&gt;");
				x=x.replace(/\n/g,"<BR>").replace(/\t/g,"&nbsp;&nbsp;&nbsp;&nbsp;")
			};
			if (debug=="compact"){x=x.replace(/\n/g,"").replace(/\t/g,"")}
		};
		return x
	},
	no_fast_endings:function(x){
		x=x.split("/>");
		for (var i=1;i<x.length;i++){
			var t=x[i-1].substring(x[i-1].lastIndexOf("<")+1).split(" ")[0];
			x[i]="></"+t+">"+x[i]
		}	;
		x=x.join("");
		return x
	},
	attris_to_tags: function(x){
		var d=' ="\''.split("");
		x=x.split(">");
		for (var i=0;i<x.length;i++){
			var temp=x[i].split("<");
			for (var r=0;r<4;r++){temp[0]=temp[0].replace(new RegExp(d[r],"g"),"_jsonconvtemp"+r+"_")};
			if(temp[1]){
				temp[1]=temp[1].replace(/'/g,'"');
				temp[1]=temp[1].split('"');
				for (var j=1;j<temp[1].length;j+=2){
					for (var r=0;r<4;r++){temp[1][j]=temp[1][j].replace(new RegExp(d[r],"g"),"_jsonconvtemp"+r+"_")}
				};
				temp[1]=temp[1].join('"')
			};
			x[i]=temp.join("<")
		};
		x=x.join(">");
		x=x.replace(/ ([^=]*)=([^ |>]*)/g,"><$1>$2</$1");
		x=x.replace(/>"/g,">").replace(/"</g,"<");
		for (var r=0;r<4;r++){x=x.replace(new RegExp("_jsonconvtemp"+r+"_","g"),d[r])}	;
		return x
	},
	
    CLASS_NAME: "Geo.Util.Format.XML2JSON"
});/*
 Copyright 2011-2013 Abdulla Abdurakhmanov
 Original sources are available at https://code.google.com/p/x2js/

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

(function (root, factory) {
	/*//标签式引入，不需要这段判断代码
     if (typeof define === "function" && define.amd) {
         define([], factory);
     } else if (typeof exports === "object") {
         module.exports = factory();
     } else {
         root.X2JS = factory();
     }
	 */
	root.Geo.Util.Format.X2JS = factory();
	root.Geo.Util.Format.X2JS.CLASS_NAME = "Geo.Util.Format.X2JS";
 }(this, function () {
	return function (config) {
		'use strict';
			
		var VERSION = "1.2.0";
		
		config = config || {};
		initConfigDefaults();
		initRequiredPolyfills();
		
		function initConfigDefaults() {
			if(config.escapeMode === undefined) {
				config.escapeMode = true;
			}
			
			config.attributePrefix = config.attributePrefix || "_";
			config.arrayAccessForm = config.arrayAccessForm || "none";
			config.emptyNodeForm = config.emptyNodeForm || "text";		
			
			if(config.enableToStringFunc === undefined) {
				config.enableToStringFunc = true; 
			}
			config.arrayAccessFormPaths = config.arrayAccessFormPaths || []; 
			if(config.skipEmptyTextNodesForObj === undefined) {
				config.skipEmptyTextNodesForObj = true;
			}
			if(config.stripWhitespaces === undefined) {
				config.stripWhitespaces = true;
			}
			config.datetimeAccessFormPaths = config.datetimeAccessFormPaths || [];
	
			if(config.useDoubleQuotes === undefined) {
				config.useDoubleQuotes = false;
			}
			
			config.xmlElementsFilter = config.xmlElementsFilter || [];
			config.jsonPropertiesFilter = config.jsonPropertiesFilter || [];
			
			if(config.keepCData === undefined) {
				config.keepCData = false;
			}
		}
	
		var DOMNodeTypes = {
			ELEMENT_NODE 	   : 1,
			TEXT_NODE    	   : 3,
			CDATA_SECTION_NODE : 4,
			COMMENT_NODE	   : 8,
			DOCUMENT_NODE 	   : 9
		};
		
		function initRequiredPolyfills() {		
		}
		
		function getNodeLocalName( node ) {
			var nodeLocalName = node.localName;			
			if(nodeLocalName == null) // Yeah, this is IE!! 
				nodeLocalName = node.baseName;
			if(nodeLocalName == null || nodeLocalName=="") // =="" is IE too
				nodeLocalName = node.nodeName;
			return nodeLocalName;
		}
		
		function getNodePrefix(node) {
			return node.prefix;
		}
			
		function escapeXmlChars(str) {
			if(typeof(str) == "string")
				return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
			else
				return str;
		}
	
		function unescapeXmlChars(str) {
			return str.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&apos;/g, "'").replace(/&amp;/g, '&');
		}
		
		function checkInStdFiltersArrayForm(stdFiltersArrayForm, obj, name, path) {
			var idx = 0;
			for(; idx < stdFiltersArrayForm.length; idx++) {
				var filterPath = stdFiltersArrayForm[idx];
				if( typeof filterPath === "string" ) {
					if(filterPath == path)
						break;
				}
				else
				if( filterPath instanceof RegExp) {
					if(filterPath.test(path))
						break;
				}				
				else
				if( typeof filterPath === "function") {
					if(filterPath(obj, name, path))
						break;
				}
			}
			return idx!=stdFiltersArrayForm.length;
		}
		
		function toArrayAccessForm(obj, childName, path) {
			switch(config.arrayAccessForm) {
				case "property":
					if(!(obj[childName] instanceof Array))
						obj[childName+"_asArray"] = [obj[childName]];
					else
						obj[childName+"_asArray"] = obj[childName];
					break;
				/*case "none":
					break;*/
			}
			
			if(!(obj[childName] instanceof Array) && config.arrayAccessFormPaths.length > 0) {
				if(checkInStdFiltersArrayForm(config.arrayAccessFormPaths, obj, childName, path)) {
					obj[childName] = [obj[childName]];
				}			
			}
		}
		
		function fromXmlDateTime(prop) {
			// Implementation based up on http://stackoverflow.com/questions/8178598/xml-datetime-to-javascript-date-object
			// Improved to support full spec and optional parts
			var bits = prop.split(/[-T:+Z]/g);
			
			var d = new Date(bits[0], bits[1]-1, bits[2]);			
			var secondBits = bits[5].split("\.");
			d.setHours(bits[3], bits[4], secondBits[0]);
			if(secondBits.length>1)
				d.setMilliseconds(secondBits[1]);
	
			// Get supplied time zone offset in minutes
			if(bits[6] && bits[7]) {
				var offsetMinutes = bits[6] * 60 + Number(bits[7]);
				var sign = /\d\d-\d\d:\d\d$/.test(prop)? '-' : '+';
	
				// Apply the sign
				offsetMinutes = 0 + (sign == '-'? -1 * offsetMinutes : offsetMinutes);
	
				// Apply offset and local timezone
				d.setMinutes(d.getMinutes() - offsetMinutes - d.getTimezoneOffset())
			}
			else
				if(prop.indexOf("Z", prop.length - 1) !== -1) {
					d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds()));					
				}
	
			// d is now a local time equivalent to the supplied time
			return d;
		}
		
		function checkFromXmlDateTimePaths(value, childName, fullPath) {
			if(config.datetimeAccessFormPaths.length > 0) {
				var path = fullPath.split("\.#")[0];
				if(checkInStdFiltersArrayForm(config.datetimeAccessFormPaths, value, childName, path)) {
					return fromXmlDateTime(value);
				}
				else
					return value;			
			}
			else
				return value;
		}
		
		function checkXmlElementsFilter(obj, childType, childName, childPath) {
			if( childType == DOMNodeTypes.ELEMENT_NODE && config.xmlElementsFilter.length > 0) {
				return checkInStdFiltersArrayForm(config.xmlElementsFilter, obj, childName, childPath);	
			}
			else
				return true;
		}	
	
		function parseDOMChildren( node, path ) {
			if(node.nodeType == DOMNodeTypes.DOCUMENT_NODE) {
				var result = new Object;
				var nodeChildren = node.childNodes;
				// Alternative for firstElementChild which is not supported in some environments
				for(var cidx=0; cidx <nodeChildren.length; cidx++) {
					var child = nodeChildren.item(cidx);
					if(child.nodeType == DOMNodeTypes.ELEMENT_NODE) {
						var childName = getNodeLocalName(child);
						result[childName] = parseDOMChildren(child, childName);
					}
				}
				return result;
			}
			else
			if(node.nodeType == DOMNodeTypes.ELEMENT_NODE) {
				var result = new Object;
				result.__cnt=0;
				
				var nodeChildren = node.childNodes;
				
				// Children nodes
				for(var cidx=0; cidx <nodeChildren.length; cidx++) {
					var child = nodeChildren.item(cidx); // nodeChildren[cidx];
					var childName = getNodeLocalName(child);
					
					if(child.nodeType!= DOMNodeTypes.COMMENT_NODE) {
						var childPath = path+"."+childName;
						if (checkXmlElementsFilter(result,child.nodeType,childName,childPath)) {
							result.__cnt++;
							if(result[childName] == null) {
								result[childName] = parseDOMChildren(child, childPath);
								toArrayAccessForm(result, childName, childPath);					
							}
							else {
								if(result[childName] != null) {
									if( !(result[childName] instanceof Array)) {
										result[childName] = [result[childName]];
										toArrayAccessForm(result, childName, childPath);
									}
								}
								(result[childName])[result[childName].length] = parseDOMChildren(child, childPath);
							}
						}
					}								
				}
				
				// Attributes
				for(var aidx=0; aidx <node.attributes.length; aidx++) {
					var attr = node.attributes.item(aidx); // [aidx];
					result.__cnt++;
					result[config.attributePrefix+attr.name]=attr.value;
				}
				
				// Node namespace prefix
				var nodePrefix = getNodePrefix(node);
				if(nodePrefix!=null && nodePrefix!="") {
					result.__cnt++;
					result.__prefix=nodePrefix;
				}
				
				if(result["#text"]!=null) {				
					result.__text = result["#text"];
					if(result.__text instanceof Array) {
						result.__text = result.__text.join("\n");
					}
					//if(config.escapeMode)
					//	result.__text = unescapeXmlChars(result.__text);
					if(config.stripWhitespaces)
						result.__text = result.__text.trim();
					delete result["#text"];
					if(config.arrayAccessForm=="property")
						delete result["#text_asArray"];
					result.__text = checkFromXmlDateTimePaths(result.__text, childName, path+"."+childName);
				}
				if(result["#cdata-section"]!=null) {
					result.__cdata = result["#cdata-section"];
					delete result["#cdata-section"];
					if(config.arrayAccessForm=="property")
						delete result["#cdata-section_asArray"];
				}
				
				if( result.__cnt == 0 && config.emptyNodeForm=="text" ) {
					result = '';
				}
				else
				if( result.__cnt == 1 && result.__text!=null  ) {
					result = result.__text;
				}
				else
				if( result.__cnt == 1 && result.__cdata!=null && !config.keepCData  ) {
					result = result.__cdata;
				}			
				else			
				if ( result.__cnt > 1 && result.__text!=null && config.skipEmptyTextNodesForObj) {
					if( (config.stripWhitespaces && result.__text=="") || (result.__text.trim()=="")) {
						delete result.__text;
					}
				}
				delete result.__cnt;			
				
				if( config.enableToStringFunc && (result.__text!=null || result.__cdata!=null )) {
					result.toString = function() {
						return (this.__text!=null? this.__text:'')+( this.__cdata!=null ? this.__cdata:'');
					};
				}
				
				return result;
			}
			else
			if(node.nodeType == DOMNodeTypes.TEXT_NODE || node.nodeType == DOMNodeTypes.CDATA_SECTION_NODE) {
				return node.nodeValue;
			}	
		}
		
		function startTag(jsonObj, element, attrList, closed) {
			var resultStr = "<"+ ( (jsonObj!=null && jsonObj.__prefix!=null)? (jsonObj.__prefix+":"):"") + element;
			if(attrList!=null) {
				for(var aidx = 0; aidx < attrList.length; aidx++) {
					var attrName = attrList[aidx];
					var attrVal = jsonObj[attrName];
					if(config.escapeMode)
						attrVal=escapeXmlChars(attrVal);
					resultStr+=" "+attrName.substr(config.attributePrefix.length)+"=";
					if(config.useDoubleQuotes)
						resultStr+='"'+attrVal+'"';
					else
						resultStr+="'"+attrVal+"'";
				}
			}
			if(!closed)
				resultStr+=">";
			else
				resultStr+="/>";
			return resultStr;
		}
		
		function endTag(jsonObj,elementName) {
			return "</"+ (jsonObj.__prefix!=null? (jsonObj.__prefix+":"):"")+elementName+">";
		}
		
		function endsWith(str, suffix) {
			return str.indexOf(suffix, str.length - suffix.length) !== -1;
		}
		
		function jsonXmlSpecialElem ( jsonObj, jsonObjField ) {
			if((config.arrayAccessForm=="property" && endsWith(jsonObjField.toString(),("_asArray"))) 
					|| jsonObjField.toString().indexOf(config.attributePrefix)==0 
					|| jsonObjField.toString().indexOf("__")==0
					|| (jsonObj[jsonObjField] instanceof Function) )
				return true;
			else
				return false;
		}
		
		function jsonXmlElemCount ( jsonObj ) {
			var elementsCnt = 0;
			if(jsonObj instanceof Object ) {
				for( var it in jsonObj  ) {
					if(jsonXmlSpecialElem ( jsonObj, it) )
						continue;			
					elementsCnt++;
				}
			}
			return elementsCnt;
		}
		
		function checkJsonObjPropertiesFilter(jsonObj, propertyName, jsonObjPath) {
			return config.jsonPropertiesFilter.length == 0
				|| jsonObjPath==""
				|| checkInStdFiltersArrayForm(config.jsonPropertiesFilter, jsonObj, propertyName, jsonObjPath);	
		}
		
		function parseJSONAttributes ( jsonObj ) {
			var attrList = [];
			if(jsonObj instanceof Object ) {
				for( var ait in jsonObj  ) {
					if(ait.toString().indexOf("__")== -1 && ait.toString().indexOf(config.attributePrefix)==0) {
						attrList.push(ait);
					}
				}
			}
			return attrList;
		}
		
		function parseJSONTextAttrs ( jsonTxtObj ) {
			var result ="";
			
			if(jsonTxtObj.__cdata!=null) {										
				result+="<![CDATA["+jsonTxtObj.__cdata+"]]>";					
			}
			
			if(jsonTxtObj.__text!=null) {			
				if(config.escapeMode)
					result+=escapeXmlChars(jsonTxtObj.__text);
				else
					result+=jsonTxtObj.__text;
			}
			return result;
		}
		
		function parseJSONTextObject ( jsonTxtObj ) {
			var result ="";
	
			if( jsonTxtObj instanceof Object ) {
				result+=parseJSONTextAttrs ( jsonTxtObj );
			}
			else
				if(jsonTxtObj!=null) {
					if(config.escapeMode)
						result+=escapeXmlChars(jsonTxtObj);
					else
						result+=jsonTxtObj;
				}
			
			return result;
		}
		
		function getJsonPropertyPath(jsonObjPath, jsonPropName) {
			if (jsonObjPath==="") {
				return jsonPropName;
			}
			else
				return jsonObjPath+"."+jsonPropName;
		}
		
		function parseJSONArray ( jsonArrRoot, jsonArrObj, attrList, jsonObjPath ) {
			var result = ""; 
			if(jsonArrRoot.length == 0) {
				result+=startTag(jsonArrRoot, jsonArrObj, attrList, true);
			}
			else {
				for(var arIdx = 0; arIdx < jsonArrRoot.length; arIdx++) {
					result+=startTag(jsonArrRoot[arIdx], jsonArrObj, parseJSONAttributes(jsonArrRoot[arIdx]), false);
					result+=parseJSONObject(jsonArrRoot[arIdx], getJsonPropertyPath(jsonObjPath,jsonArrObj));
					result+=endTag(jsonArrRoot[arIdx],jsonArrObj);
				}
			}
			return result;
		}
		
		function parseJSONObject ( jsonObj, jsonObjPath ) {
			var result = "";	
	
			var elementsCnt = jsonXmlElemCount ( jsonObj );
			
			if(elementsCnt > 0) {
				for( var it in jsonObj ) {
					
					if(jsonXmlSpecialElem ( jsonObj, it) || (jsonObjPath!="" && !checkJsonObjPropertiesFilter(jsonObj, it, getJsonPropertyPath(jsonObjPath,it))) )
						continue;			
					
					var subObj = jsonObj[it];						
					
					var attrList = parseJSONAttributes( subObj )
					
					if(subObj == null || subObj == undefined) {
						result+=startTag(subObj, it, attrList, true);
					}
					else
					if(subObj instanceof Object) {
						
						if(subObj instanceof Array) {					
							result+=parseJSONArray( subObj, it, attrList, jsonObjPath );					
						}
						else if(subObj instanceof Date) {
							result+=startTag(subObj, it, attrList, false);
							result+=subObj.toISOString();
							result+=endTag(subObj,it);
						}
						else {
							var subObjElementsCnt = jsonXmlElemCount ( subObj );
							if(subObjElementsCnt > 0 || subObj.__text!=null || subObj.__cdata!=null) {
								result+=startTag(subObj, it, attrList, false);
								result+=parseJSONObject(subObj, getJsonPropertyPath(jsonObjPath,it));
								result+=endTag(subObj,it);
							}
							else {
								result+=startTag(subObj, it, attrList, true);
							}
						}
					}
					else {
						result+=startTag(subObj, it, attrList, false);
						result+=parseJSONTextObject(subObj);
						result+=endTag(subObj,it);
					}
				}
			}
			result+=parseJSONTextObject(jsonObj);
			
			return result;
		}
		
		this.parseXmlString = function(xmlDocStr) {
			var isIEParser = window.ActiveXObject || "ActiveXObject" in window;
			if (xmlDocStr === undefined) {
				return null;
			}
			var xmlDoc;
			if (window.DOMParser) {
				var parser=new window.DOMParser();			
				var parsererrorNS = null;
				// IE9+ now is here
				if(!isIEParser) {
					try {
						parsererrorNS = parser.parseFromString("INVALID", "text/xml").getElementsByTagName("parsererror")[0].namespaceURI;
					}
					catch(err) {					
						parsererrorNS = null;
					}
				}
				try {
					xmlDoc = parser.parseFromString( xmlDocStr, "text/xml" );
					if( parsererrorNS!= null && xmlDoc.getElementsByTagNameNS(parsererrorNS, "parsererror").length > 0) {
						//throw new Error('Error parsing XML: '+xmlDocStr);
						xmlDoc = null;
					}
				}
				catch(err) {
					xmlDoc = null;
				}
			}
			else {
				// IE :(
				if(xmlDocStr.indexOf("<?")==0) {
					xmlDocStr = xmlDocStr.substr( xmlDocStr.indexOf("?>") + 2 );
				}
				xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
				xmlDoc.async="false";
				xmlDoc.loadXML(xmlDocStr);
			}
			return xmlDoc;
		};
		
		this.asArray = function(prop) {
			if (prop === undefined || prop == null)
				return [];
			else
			if(prop instanceof Array)
				return prop;
			else
				return [prop];
		};
		
		this.toXmlDateTime = function(dt) {
			if(dt instanceof Date)
				return dt.toISOString();
			else
			if(typeof(dt) === 'number' )
				return new Date(dt).toISOString();
			else	
				return null;
		};
		
		this.asDateTime = function(prop) {
			if(typeof(prop) == "string") {
				return fromXmlDateTime(prop);
			}
			else
				return prop;
		};
	
		this.xml2json = function (xmlDoc) {
			return parseDOMChildren ( xmlDoc );
		};
		
		this.xml_str2json = function (xmlDocStr) {
			var xmlDoc = this.parseXmlString(xmlDocStr);
			if(xmlDoc!=null)
				return this.xml2json(xmlDoc);
			else
				return null;
		};
	
		this.json2xml_str = function (jsonObj) {
			return parseJSONObject ( jsonObj, "" );
		};
	
		this.json2xml = function (jsonObj) {
			var xmlDocStr = this.json2xml_str (jsonObj);
			return this.parseXmlString(xmlDocStr);
		};
		
		this.getVersion = function () {
			return VERSION;
		};	
	}
}));/**
 * Class: Geo.Util.Format.VwmtsGetVersionInfo
 * WMTS多时相服务getCapabilities操作请求结果的XML解析器，继承自Geo.Util.Format.XML2JSON类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.Util.Format.XML2JSON>
 */
Geo.Util.Format.VwmtsGetVersionInfo = Geo.Class(Geo.Util.Format.XML2JSON, {
	
	 /**
     * APIMethod: read
     * 解析一个XML串并返回capabilitiesObj｛Object｝对象。
     *
     * Parameters:
     * xmlcode - {String} 一个XML字符串
     *
     * Returns:
     * ｛Object｝- capabilitiesObj
     */
    read: function(xmlcode){
        if(typeof data == "string") {
            data = Geo.Util.Format.XML2JSON.prototype.read.apply(this, [xmlcode]);
        }
		
		return data;
	},
	
	/**
     * APIProperty: CLASS_NAME
     * 类名标识
     */
	CLASS_NAME:"Geo.Util.Format.VwmtsGetVersionInfo"
});/**
 * Class: Geo.Util.Format.VwmtsGetVersions
 * WMTS多时相服务getCapabilities操作请求结果的XML解析器，继承自Geo.Util.Format.XML2JSON类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.Util.Format.XML2JSON>
 */
Geo.Util.Format.VwmtsGetVersions = Geo.Class(Geo.Util.Format.XML2JSON, {
	
	/**
     * APIMethod: read
     * 解析一个XML串并返回versionsObj｛Object｝对象。
     *
     * Parameters:
     * data - {String} 一个XML字符串
     *
     * Returns:
     * ｛Object｝- versionsObj
     */
    read: function(data){
        if(typeof data == "string") {
            data = Geo.Util.Format.XML2JSON.prototype.read.apply(this, [data]);
        }
		
		return data;
	},
	
	/**
     * APIProperty: CLASS_NAME
     * 类名标识
     */
	CLASS_NAME:"Geo.Util.Format.VwmtsGetVersions"
});/* Copyright (c) 2006-2010 by OpenLayers Contributors (see authors.txt for 
 * full list of contributors). Published under the Clear BSD license.  
 * See http://svn.openlayers.org/trunk/openlayers/license.txt for the
 * full text of the license. */

/**
 * @requires OpenLayers/Format/WMTSCapabilities.v1_0_0
 * @requires OpenLayers/Format/OWSCommon/v1_1_0.js
 */

/**
 * Class: VwmtsGetCapabilities.js
 * Read WMTS Capabilities version 1.0.0.
 * 
 * Inherits from:
 *  - <OpenLayers.Format.WMTSCapabilities.v1_0_0>
 */
OpenLayers.Format.VWMTSCapabilities = {};
OpenLayers.Format.VWMTSCapabilities.v1_0_0 = OpenLayers.Class(
    OpenLayers.Format.WMTSCapabilities.v1_0_0, {

    initialize: function(options) {
        OpenLayers.Format.WMTSCapabilities.v1_0_0.prototype.initialize.apply(this, arguments);
       
    },

    /**
     * Property: readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     */
    readers: {        
        "wmts": {
            "Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Contents": function(node, obj) {
                obj.contents = {};                
                obj.contents.layers = [];
                obj.contents.tileMatrixSets = {};                
                this.readChildNodes(node, obj.contents);
            },
            "Layer": function(node, obj) {
                var layer = {
                    styles: [],
                    formats: [],
                    tileMatrixSetLinks: [],
					dimensions:[]
                };
                layer.layers = [];
                this.readChildNodes(node, layer);
                obj.layers.push(layer);
            },
            "Style": function(node, obj) {
                var style = {};
                style.isDefault = (node.getAttribute("isDefault") === "true");
                this.readChildNodes(node, style);
                obj.styles.push(style);
            },
            "Format": function(node, obj) {
                obj.formats.push(this.getChildValue(node)); 
            },
			//多时相节点解析
			"Dimension": function(node, obj) {
				var dimension = {
					values:[]
				};
                this.readChildNodes(node, dimension);
                obj.dimensions.push(dimension);
            },
			"Value": function(node, obj) {
                obj.values.push(this.getChildValue(node));
            },
            "TileMatrixSetLink": function(node, obj) {
                var tileMatrixSetLink = {};
                this.readChildNodes(node, tileMatrixSetLink);
                obj.tileMatrixSetLinks.push(tileMatrixSetLink);
            },
            "TileMatrixSet": function(node, obj) {
                // node could be child of wmts:Contents or wmts:TileMatrixSetLink
                // duck type wmts:Contents by looking for layers
                if (obj.layers) {
                    // TileMatrixSet as object type in schema
                    var tileMatrixSet = {
                        matrixIds: []
                    };
                    this.readChildNodes(node, tileMatrixSet);
                    obj.tileMatrixSets[tileMatrixSet.identifier] = tileMatrixSet;
                } else {
                    // TileMatrixSet as string type in schema
                    obj.tileMatrixSet = this.getChildValue(node);
                }
            },
            "TileMatrix": function(node, obj) {
                var tileMatrix = {
                    supportedCRS: obj.supportedCRS
                };
                this.readChildNodes(node, tileMatrix);
                obj.matrixIds.push(tileMatrix);
            },
            "ScaleDenominator": function(node, obj) {
                obj.scaleDenominator = parseFloat(this.getChildValue(node)); 
            },
            "TopLeftCorner": function(node, obj) {
                var topLeftCorner = this.getChildValue(node);
                var coords = topLeftCorner.split(" ");
                // decide on axis order for the given CRS
                var yx;
                if (obj.supportedCRS) {
                    // extract out version from URN
                    var crs = obj.supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):.+:(\w+)$/, 
                        "urn:ogc:def:crs:$1::$2"
                    );
					//支持对老服务的判断
					var old = crs.search(/GEOGCS/);
					//新服务
					if(old === -1) {
						var crss = crs.split("urn:ogc:def:crs:");
						var epsg = crss[1].replace(/::/, ":");
						yx = OpenLayers.ProjAxisOrder.AxisOrder[epsg];
					}else {//老服务，老服务使用的是强制东西向的顺序
						yx = true;
					}
                }
				if(this.isReverse === true) {
					//如果是false,则是纬度，经度顺序
					if(yx === false) {
						if (yx) {
							obj.topLeftCorner = new OpenLayers.LonLat(
								coords[0], coords[1]
							);
						} else {
							obj.topLeftCorner = new OpenLayers.LonLat(
		                        coords[1], coords[0]
		                    );
						}
					}else if(yx === true) {//如果是true,则是经度，纬度顺序
						obj.topLeftCorner = new OpenLayers.LonLat(
							coords[1], coords[0]
						);
					}else {//未知投影,按经度，纬度顺序处理
						obj.topLeftCorner = new OpenLayers.LonLat(
							coords[1], coords[0]
						);
					}
				}else if(this.isReverse === false) {
					//如果是false,则表示EPSG号的轴向是纬度，经度顺序。
					if(yx === false) {
						if (yx) {
							obj.topLeftCorner = new OpenLayers.LonLat(
								coords[1], coords[0]
							);
						} else {//如果yx为false,则表示EPSG号的轴向是纬度，经度顺序
							obj.topLeftCorner = new OpenLayers.LonLat(
								coords[0], coords[1]
							);
						}
					}else if(yx === true) {//如果是true,则是经度，纬度顺序
						obj.topLeftCorner = new OpenLayers.LonLat(
							coords[0], coords[1]
						);
					}else {//未知投影,按经度，纬度顺序处理
						obj.topLeftCorner = new OpenLayers.LonLat(
							coords[0], coords[1]
						);
					}
				}
            },
            "TileWidth": function(node, obj) {
                obj.tileWidth = parseInt(this.getChildValue(node)); 
            },
            "TileHeight": function(node, obj) {
                obj.tileHeight = parseInt(this.getChildValue(node)); 
            },
            "MatrixWidth": function(node, obj) {
                obj.matrixWidth = parseInt(this.getChildValue(node)); 
            },
            "MatrixHeight": function(node, obj) {
                obj.matrixHeight = parseInt(this.getChildValue(node)); 
            },        
            "WSDL": function(node, obj) {
                obj.wsdl = {};
                obj.wsdl.href = node.getAttribute("xlink:href");
            },
            "ServiceMetadataURL": function(node, obj) {
                obj.serviceMetadataUrl = {};
                obj.serviceMetadataUrl.href = node.getAttribute("xlink:href");
            }            
        },
        "ows": OpenLayers.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },    
    
    CLASS_NAME: "OpenLayers.Format.WMTSCapabilities.v1_0_0" 

});
/**
 * Class: Geo.Util.Format.MapServiceQuery
 * 解析地图服务query接口的查询结果
 */
Geo.Util.Format.MapServiceQuery = Geo.Class(Geo.Format.JSON, {
    
    /**
     * Constructor: Geo.Util.Format.MapServiceQuery
     * 创建一个地图服务查询接口解析器
     */

    /**
     * APIMethod: read
     * 传入一个json串，将json串转换为要素对象
     *
     * Parameters:
     * json - {String} 解析查询返回的json串
     *    输入参数举例：
     *    点：
     *    {
     *    	features:[{
     *    		attributes:{"NAME":"007"},
	 *		   "geometry": {
	 *		       "x": 116.38094,
	 *		       "y": 39.923614999999998
	 *		   }
     *    	}]
     *    }
     *    线：
     *     {"features": [
	 *		  {
	 *		   "attributes": {
	 *		    "NAME": "ÑÀÁÖÏß"
	 *		   },
	 *		   "geometry": {
	 *		    "paths": [
	 *		     [
	 *		      [
	 *		       122.09497,
	 *		       52.033745000000003
	 *		      ],
	 *		      [
	 *		       120.75324999999999,
	 *		       49.269401999999999
	 *		      ]
	 *		     ]
	 *		    ]
	 *		   }
	 *		  }]}
     *     面：
     *      {"features": [
	 *		  {
	 *		   "attributes": {
	 *		    "NAME": "ºÚÁú½­Ê¡"
	 *		   },
	 *		   "geometry": {
	 *		    "rings": [
	 *		     [
	 *		      [
	 *		       121.48844,
	 *		       53.332649000000004
	 *		      ],
	 *		      [
	 *		       125.62043,
	 *		       53.067318
	 *		      ],
	 *		      [
	 *		       130.99547000000001,
	 *		       47.698345000000003
	 *		      ]
	 *		     ]
	 *		    ]
	 *		   }
	 *		  }}
     * filter - {Function} 过滤查询结果
     *
     * Returns: 
     * {Array} 返回要素对象数组
     */
    read: function(json, filter) {
        var features = [];
        var obj = null;
        if (typeof json == "string") {
            obj = OpenLayers.Format.JSON.prototype.read.apply(this,
                                                              [json, filter]);
        } else { 
            obj = json;
        }    
        if(!obj) {
            return features;
        } else if(!obj.features) {
            OpenLayers.Console.error("Bad GeoJSON - no type: " + json);
        } else if(obj.features.length > 0) {
			for(var i = 0,j = obj.features.length; i < j; i++) {
				features.push(this.parseFeature(obj.features[i]));
			}
        }
        return features;
    },
	
	/**
     * APIMethod: write
     * 将一个要素或一个几何对象或者要素数组转换成json串
     * 
     * Parameters:
     * obj - {Object} 可以传递一个要素对象，一个geometry对象或者一个要素对象。注意:geometry对象只支持point,MultiLineString以及Polygon 
     * pretty - {Boolean} 是否序列号输出结果，默认为false
     *
     * Returns:
     * {String} 根据输入的要素或几何对象或要素数组得到与其对应的json串 
     */
    write: function(obj, pretty) {
      	var json = {};
		var features = [];
        if(OpenLayers.Util.isArray(obj)) {
            for(var i=0; i<obj.length; ++i) {
                var element = obj[i];
                if(!element instanceof OpenLayers.Feature.Vector) {
                    var msg = "该对象在数组中不是要素 " +
                              "" + element;
                    throw msg;
                }
                var geometry = this._getGeometryRepresentation(obj[i].geometry);
				var attributes = obj[i].attributes;
				var ajson = OpenLayers.Util.extend({}, {
					attributes:attributes,
					geometry:geometry
				});
				features.push(ajson);
            }
			json.features = features;
        } else if (obj.CLASS_NAME.indexOf("OpenLayers.Geometry") == 0) {
         	var geometry = this._getGeometryRepresentation(obj);
			json.geometry = geometry;
        } else if (obj instanceof OpenLayers.Feature.Vector) {
			var geometry = this._getGeometryRepresentation(obj.geometry);
			var attributes = obj.attributes;
			OpenLayers.Util.extend(json, {
				attributes:attributes,
				geometry:geometry
			});
        }
        return OpenLayers.Format.JSON.prototype.write.apply(this,
                                                            [json, pretty]);
    },
	
	/**
	 * 得到arcgis可以理解的几何表示法
	 * @param {Object} geometry
	 */
	_getGeometryRepresentation: function(geometry) {
		if(!geometry) {
			return undefined;
		}
		var name = geometry.CLASS_NAME;
		var jsonObj = null;
		switch(name) {
			case "OpenLayers.Geometry.Point":
				jsonObj = {x:geometry.x,y:geometry.y};
				break;
			case "OpenLayers.Geometry.Polygon":
				var json = this.extract['geometry'].apply(this, [geometry]);
				jsonObj = {rings:json.coordinates};
				break;	
			case "OpenLayers.Geometry.MultiLineString":
				var json = this.extract['geometry'].apply(this, [geometry]);
				jsonObj = {paths:json.coordinates};
				break;		
			case "OpenLayers.Geometry.LineString":
				var json = this.extract['geometry'].apply(this, [geometry]);
				jsonObj = {paths:[json.coordinates]};
				break;		
		}
		return jsonObj;
	},
	
    /**
     * Method: parseFeature
     * 将表示要素的json对象转换成要素
     * Parameters:
     * obj - {Object}一个json对象
     *
     * Returns:
     * {<OpenLayers.Feature.Vector>} A feature.
     */
    parseFeature: function(obj) {
		var olGeometry = this._getGeometry(obj.geometry);
		var attributes = this._getAttribute(obj.attributes);
		var f = new OpenLayers.Feature.Vector(olGeometry,attributes);
        return  f;
    },
	
	/**
	 * 得到openlayers几何对象
	 * @param {Object} geometry
	 */
	_getGeometry: function(geometry) {
		for(var pro in geometry) {
			//TODO：服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new OpenLayers.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				 var geometry = new OpenLayers.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
			}else {
				var geometry = this._geometryType[pro](geometry[pro]);
			}
			return geometry;
		}
	},
   
	/**
	 * 得到要素的属性信息
	 * @param {Object} geometry
	 */
	_getAttribute: function(attrs) {
		var attributes = {};
		if(attrs && !(Geo.Util.isArray(attrs))) {
			attrs = [attrs];
		}
		if(Geo.Util.isArray(attrs)) {
			for(var i = 0; i < attrs.length; i++) {
				 OpenLayers.Util.applyDefaults(attributes,attrs[i]);
			}
		}
		return attributes;
	},
	
	/**
	 * 将几何信息的json表示转换成
	 * @param {Object} geometry
	 */
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new OpenLayers.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new OpenLayers.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new OpenLayers.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
		
    /**
     * Property: extract
     * Object with properties corresponding to the GeoJSON types.
     *     Property values are functions that do the actual value extraction.
     */
    extract: {
        /**
         * Method: extract.feature
         * Return a partial GeoJSON object representing a single feature.
         *
         * Parameters:
         * feature - {<OpenLayers.Feature.Vector>}
         *
         * Returns:
         * {Object} An object representing the point.
         */
        'feature': function(feature) {
            var geom = this.extract.geometry.apply(this, [feature.geometry]);
            var json = {
                "type": "Feature",
                "properties": feature.attributes,
                "geometry": geom
            };
            if (feature.fid != null) {
                json.id = feature.fid;
            }
            return json;
        },
        
        /**
         * Method: extract.geometry
         * Return a GeoJSON object representing a single geometry.
         *
         * Parameters:
         * geometry - {<OpenLayers.Geometry>}
         *
         * Returns:
         * {Object} An object representing the geometry.
         */
        'geometry': function(geometry) {
            if (geometry == null) {
                return null;
            }
            if (this.internalProjection && this.externalProjection) {
                geometry = geometry.clone();
                geometry.transform(this.internalProjection, 
                                   this.externalProjection);
            }                       
            var geometryType = geometry.CLASS_NAME.split('.')[2];
            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);
            var json;
            if(geometryType == "Collection") {
                json = {
                    "type": "GeometryCollection",
                    "geometries": data
                };
            } else {
                json = {
                    "type": geometryType,
                    "coordinates": data
                };
            }
            
            return json;
        },

        /**
         * Method: extract.point
         * Return an array of coordinates from a point.
         *
         * Parameters:
         * point - {<OpenLayers.Geometry.Point>}
         *
         * Returns: 
         * {Array} An array of coordinates representing the point.
         */
        'point': function(point) {
            return [point.x, point.y];
        },

        /**
         * Method: extract.multipoint
         * Return an array of point coordinates from a multipoint.
         *
         * Parameters:
         * multipoint - {<OpenLayers.Geometry.MultiPoint>}
         *
         * Returns:
         * {Array} An array of point coordinate arrays representing
         *     the multipoint.
         */
        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
            }
            return array;
        },
        
        /**
         * Method: extract.linestring
         * Return an array of coordinate arrays from a linestring.
         *
         * Parameters:
         * linestring - {<OpenLayers.Geometry.LineString>}
         *
         * Returns:
         * {Array} An array of coordinate arrays representing
         *     the linestring.
         */
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array;
        },

        /**
         * Method: extract.multilinestring
         * Return an array of linestring arrays from a linestring.
         * 
         * Parameters:
         * linestring - {<OpenLayers.Geometry.MultiLineString>}
         * 
         * Returns:
         * {Array} An array of linestring arrays representing
         *     the multilinestring.
         */
        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
            }
            return array;
        },
        
        /**
         * Method: extract.polygon
         * Return an array of linear ring arrays from a polygon.
         *
         * Parameters:
         * polygon - {<OpenLayers.Geometry.Polygon>}
         * 
         * Returns:
         * {Array} An array of linear ring arrays representing the polygon.
         */
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
            }
            return array;
        },

        /**
         * Method: extract.multipolygon
         * Return an array of polygon arrays from a multipolygon.
         * 
         * Parameters:
         * multipolygon - {<OpenLayers.Geometry.MultiPolygon>}
         * 
         * Returns:
         * {Array} An array of polygon arrays representing
         *     the multipolygon
         */
        'multipolygon': function(multipolygon) {
            var array = [];
            for(var i=0, len=multipolygon.components.length; i<len; ++i) {
                array.push(this.extract.polygon.apply(this, [multipolygon.components[i]]));
            }
            return array;
        },
        
        /**
         * Method: extract.collection
         * Return an array of geometries from a geometry collection.
         * 
         * Parameters:
         * collection - {<OpenLayers.Geometry.Collection>}
         * 
         * Returns:
         * {Array} An array of geometry objects representing the geometry
         *     collection.
         */
        'collection': function(collection) {
            var len = collection.components.length;
            var array = new Array(len);
            for(var i=0; i<len; ++i) {
                array[i] = this.extract.geometry.apply(
                    this, [collection.components[i]]
                );
            }
            return array;
        }
    },

    CLASS_NAME: "Geo.Util.Format.MapServiceQuery" 
});     ﻿﻿﻿﻿﻿/**
 * Class: Geo.Util.Format.GeoTextFeatures
 * 文字服务结果解析器。
 * 
 * Inherits from:
 *  - <Geo.Format.JSON>
 */
Geo.Util.Format.GeoTextFeatures = Geo.Class(Geo.Format.JSON, {
	
	/**
	 * Property: json
	 * {Object} 结果对象。
	 */
	json: null,
	
	/**
	 * Property: layersStyle
	 * {Object} 图层样式。
	 */
	layersStyle: null,
	
	/**
	 * Property: commonFeatures
	 * 用于保存所有的线或面
	 * gid与几何对象的键值对
	 */
	commonFeatures:{},
	
	/**
	 * Constructor: Geo.Util.Format.GeoTextFeatures 
	 * Geo.Util.Format.GeoTextFeatures 构造函数。
	 */
	initialize: function(options) {
       OpenLayers.Util.extend(this, options);
    },
	
	/**
	 * Method: cleanCommonFeatures
	 * 清除要素。
	 */
	cleanCommonFeatures: function() {
		for(var feature in this.commonFeatures) {
			delete this.commonFeatures[feature];
		}
	},
	
	/**
	 * APIMethod: read
	 * 读取服务返回的JSON串。
	 * 
	 * Parameters:
	 * json {String} 服务返回的字符串
	 * return {Object} JSON对象
	 */
	read: function(json, filter) {
		var text = {};
		
		if (typeof json == "string") {
            this.json = OpenLayers.Format.JSON.prototype.read.apply(this,[json, filter]);
			if(this.json.error) {
				text = this.json;
				return text;
			}
			text["tile"] = this.features["tile"].apply(this, [this.json["tile"]]);
		}
		return text;
	},
	
	/**
	 * Method:_getGeometry
	 * 将OGC JSON 几何信息标示方法转换成openlayers几何表示法得到openlayers几何对象。
	 * 
	 * Parameters:
	 * geometry - {Object} OGC REST 方式表示几何信息。
	 * gid - {String} 要素ID。
	 * 
	 * Returns: 
     * {Geo.Geometry} 几何对象。
	 */
	_getGeometry: function(geometry,gid) {
		for(var pro in geometry) {
			//TODO：服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new OpenLayers.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				 var geometry = new OpenLayers.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
			}else {
				var geometry = this._geometryType[pro](geometry[pro]);
			}
			geometry.gid = gid
			return geometry;
		}
	},
	
	/**
	 * Property:_geometryType
	 * 将几何信息的json表示转换成
	 */
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new OpenLayers.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				if(geometry.length === 1) {
					var ps = [];
					for(var p = 0,points = geometry[0].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[0][p][0],geometry[0][p][1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					return line;
				}else if(geometry.length > 1) {
					for(var i = 0, j = geometry.length; i < j; i++) {
						var ps = [];
						for(var p = 0,points = geometry[i].length; p < points;p++) {
							ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
						}
						var line = new OpenLayers.Geometry.LineString(ps);
						lines.push(line);
					}
					var paths = new OpenLayers.Geometry.MultiLineString(lines);
				}
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new OpenLayers.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
	
	convertLabelToMultiRow: function(label,featureStyle) {
		var defaultLabel = label;
		label = OpenLayers.String.trim(label);
		//换行算法开始----
		var labelLength = Math.ceil(label.length);
		var eachRowNumer = null;
		//每行显示多少条
		if(this.isCustomStyle && featureStyle && typeof featureStyle.maxCharactersPerLine === "number") {
			eachRowNumer = featureStyle.maxCharactersPerLine;
		}else {
			eachRowNumer = this.eachRowNumer;
		}
		//得到文字显示的行数
		var rowNumber = Math.ceil(label.length/eachRowNumer);
		if(rowNumber > 1) {
			//得到除了最后一行以外的其他行的子的个数
			var charNumerNoLast = Math.ceil(label.length/rowNumber);
			//最后一行
			var lastRowNumber = label.length - charNumerNoLast * (rowNumber - 1);
			var nowStr = "";
			for(var i = 0; i <= rowNumber - 1; i++) {
				if(i === rowNumber - 1) {
					nowStr+=(label.slice(label.length - (lastRowNumber),label.length));
					break;
				}
				nowStr+=(label.slice(i * charNumerNoLast,i * charNumerNoLast + charNumerNoLast)+"\n");
			}
			return nowStr;
		}
		//换行算法结束----
		return defaultLabel;
	},
	
	/**
	 * Property:featureTypes
	 * 根据几何信息生成要素。
	 */
	featureTypes : {
		"Point": function(geometry, featureJson,style) {
			if(!this.isCustomStyle) {
				var featureStyle = null;
				var url = null;
				var location = this.url.indexOf("/",this.url.length - 1);
				if(location != -1) {
					//TODO：图片格式可能是png，也可能是其他格式
					url = this.url + "Icon/"+ featureJson.grid+"?version=1.0.0&service=TEXT";
				}else {
					url = this.url + "/Icon/" + featureJson.grid+"?version=1.0.0&service=TEXT";
				}
				//	TODO:url需要想办法传入，此问题没解决
				if(typeof featureJson.grid === "number" && featureJson.text) {
					featureStyle = {
		                //设置点的图标. TODO:请求格式后面会有变化
		                externalGraphic: url,
						//标注名称
		                label: featureJson.text,
						graphicHeight:10,
						graphicWidth:10,
		                fontSize: "14px"
		            };
				}else if(!featureJson.grid && featureJson.text) {
				//	featureStyle = Geo.Util.extend({},OpenLayers.Feature.Vector.style['default']);
					featureStyle.label = featureJson.text;
				}else if(featureJson.grid && !featureJson.text){
					//有图标没有文字
					featureStyle = {
		                //设置点的图标. TODO:请求格式后面会有变化
		                externalGraphic: url,
						//标注名称
		                label: featureJson.text,
						graphicHeight:10,
						graphicWidth:10,
		                fontSize: "14px"
		            };
				}else {//没有图标且没有文字标注的点
			//		featureStyle = Geo.Util.extend({},OpenLayers.Feature.Vector.style['default']);
					featureStyle = {
		                //设置点的图标. TODO:请求格式后面会有变化
		                externalGraphic: url,
						//标注名称
		                label: " ",
						graphicHeight:10,
						graphicWidth:10,
		                fontSize: "14px"
		            };
					return null;
				}
				style = Geo.Util.extend(featureStyle,style);
			}
			if(!featureJson.text) {
				return null;
			}
			var featurStyle = Geo.Util.extend(featureStyle,style);
			featurStyle.label = this.convertLabelToMultiRow(featureJson.text,featureStyle);
			
            var labelFeature = new Geo.Feature.Vector(geometry, null, featurStyle);
			return labelFeature;
		},
		"LineString": function(geometry, featureJson,style) {

			var linestyle = null;
			//如果存在文字标注
			if(style && typeof featureJson.text === "string" && featureJson.text.length > 0) {
				linestyle = {
			        strokeColor: "#ee9900",
			        strokeOpacity: 1,
			        strokeWidth: 6
			    };
				linestyle.alongLineLabel = featureJson.text;
			}else {
				linestyle = Geo.Util.extend({
					strokeColor: "#ee9900",
			        strokeOpacity: 1,
			        strokeWidth: 6
				},linestyle);
				linestyle.alongLineLabel = featureJson.text;
			}
			linestyle = Geo.Util.extend(linestyle,style);
	        var lineStringFeature = new Geo.Feature.Vector(geometry,null,linestyle);
			return lineStringFeature;
		},
		"MultiLineString": function(geometry, featureJson,style) {
			var linestyle = null;
			if(style && typeof featureJson.text === "string") {
				style = Geo.Util.extend({alongLineLabel:featureJson.text},style);
				linestyle = {
			        strokeColor: "#ee9900",
			        strokeOpacity: 1,
			        strokeWidth: 6
			    };
				linestyle.alongLineLabel = featureJson.text;
			}else {
				linestyle = Geo.Util.extend({
					strokeColor: "#ee9900",
			        strokeOpacity: 1,
			        strokeWidth: 6
				},linestyle);
				linestyle.alongLineLabel = featureJson.text;
			}
			linestyle = Geo.Util.extend(linestyle,style);
	        var lineStringFeature = new Geo.Feature.Vector(geometry,null,linestyle);
			
			return lineStringFeature;
		},
		"Polygon": function(geometry, featureJson,style) {
			//面要素
			var polygonFeature = null;
			//如果有文字标注并且没有点图标的时候，文字就设置为样式的label。
			if(typeof featureJson.text === "string" && featureJson.text.length > 0 && featureJson.grid === undefined) {
				if(style) {
					style.label = featureJson.text;
				}
			}else if(typeof featureJson.text === "string" && featureJson.text.length > 0 && featureJson.grid !== undefined){
				if(style) {
					style.label = featureJson.text;
				}
			}
			var point = geometry.getCentroid();
			featureStyle = {
                //设置点的图标. TODO:可以开放一个参数，请求本地的图标
                externalGraphic: "",
				//标注名称
                label: featureJson.text,
				type:"polygon",
				graphicHeight:10,
				graphicWidth:10,
                fontSize: "14px"
            };
			pstyle = Geo.Util.extend(featureStyle,style);
			polygonFeature = new Geo.Feature.Vector(point,null,pstyle);
			return polygonFeature;
		},
		//fixed:面带图标的情况不予考虑
		"Polygon_markerTextPoint": function (geometry,grid,text,url) {
			//得到质心:TODO：后面可能会变成接口公开
			var centro = geometry.getCentroid();
			//	TODO:url需要想办法传入，此问题没解决
			var featureStyle = {
                //设置点的图标
                externalGraphic: (url+"/"+ grid +"?version=1.0.0&service=TEXT"),
                //设置图标的宽高
                graphicHeight:32,
                graphicWidth: 32,
				//标注名称
                label: text,
                fontSize: "12px"
            };
			//TODO:点的位置由数据的质心或中心点定
            var labelFeature = new Geo.Feature.Vector(centro, null, featureStyle);
			return labelFeature;
		}
	},
	
	/**
	 * Property:features
	 * 解析features接口
	 */	
	features: {
		"labelGeometry": function(labelGeometry) {//解析labelGeometry节点
			var geometryArray = [];
			for(var i = 0, len = labelGeometry.length; i < len; i++) {
				var geometry = this._getGeometry.apply(this, [labelGeometry[i]["geometry"],labelGeometry[i].gid]);
				if(geometry === undefined) {
					continue;
				}
				geometryArray.push(geometry)
			}
			return geometryArray;
		},
		"tile": function(tile) {//解析tiles节点
			var featurestileGroup = [];
			var FeaturesTileArr = [];
			for(var i = 0, len = tile.length; i < len; i++) {
				
				var features = this.features["layer"].apply(this, [tile[i].layer]);
				var featuresTile = new Geo.Util.Format.GeoTextFeatures.FeaturesTile({
					row: parseInt(tile[i].x),
					col: parseInt(tile[i].y),
					level: parseInt(tile[i].l),
					features: features
				});
				featurestileGroup.push(featuresTile);
			}
			
			return featurestileGroup;
		},
		"l": function() {},
		"x": function(){},
		"y": function(){},
		"layer": function(layers) {
			var layersArr = [];
			var features = [];
			for(var i = 0; i < layers.length; i++) {
				var style = null;
				if(this.layersStyle) {
					style = this.layersStyle[layers[i].layerName];
				}
				var layerFeatures = this.features["feature"].apply(this, [layers[i].feature,style]);
				features = features.concat(layerFeatures);
			}
			return features;
		},
		"layerName": function() {
			
		},
		"feature": function(features, style) {
			var labelGeometry = this.features["labelGeometry"].apply(this, [this.json.labelGeometry]);
			var featuresArr = [];
			for(var i = 0,len1 = features.length ; i < len1; i++) {
				//要素json对象
				var featureJson = features[i];
				for(var j = 0, len = labelGeometry.length; j < len; j++) {
					//如果gid与geometry 的id一致，那么就创建features
					if(labelGeometry[j].gid === featureJson.gid) {
						if(featureJson.gid in this.commonFeatures) {
							continue;
						}
						var feature = null;
						if(labelGeometry[j] instanceof Geo.Geometry.Polygon) {
							feature = this.featureTypes["Polygon"].apply(this, [labelGeometry[j],featureJson,style]);
							this.commonFeatures[featureJson.gid] = feature;
						}else if(labelGeometry[j] instanceof Geo.Geometry.LineString) {
							feature = this.featureTypes["LineString"].apply(this, [labelGeometry[j],featureJson,style]);
							this.commonFeatures[featureJson.gid] = feature;
						}else if(labelGeometry[j] instanceof Geo.Geometry.MultiLineString) {
							feature = this.featureTypes["MultiLineString"].apply(this, [labelGeometry[j],featureJson,style]);
						}else if(labelGeometry[j] instanceof Geo.Geometry.Point) {
							feature = this.featureTypes["Point"].apply(this, [labelGeometry[j],featureJson,style]);
							this.commonFeatures[featureJson.gid] = feature;
							if(feature == null) {
								continue;
							}
						}
						featuresArr.push(feature);
					}
				}
			}
			return featuresArr;
		}
	},
	
    CLASS_NAME: "Geo.Util.Format.GeoTextFeatures"
});

﻿﻿﻿﻿/**
 * Class: Geo.Util.Format.GeoTextFeatures
 * 文字服务瓦片类。说明：本类处理的是文字服务的点数据
 */
Geo.Util.Format.GeoTextFeatures.FeaturesTile = Geo.Class({
	
	id: null,
	
	/**
	 * Property: row
	 * {Integer} 行号。
	 */
	row: 0,
	
	/**
	 * Property: col
	 * {Integer} 列号。
	 */
	col: 0,
	
	/**
	 * Property: level
	 * {Integer} 层级。
	 */
	level: 0,
	
	/**
	 * Property: features
	 * {Array(Geo.Feature.Vector)} 点要素。
	 */
	features: null,
	
	/**
	 * Property: tileBounds
	 * {Geo.Bounds} 瓦片范围。
	 */
	tileBounds: null,
	
	/**
	 * Constructor: initialize
	 * 瓦片类构造器。
	 */
	initialize: function(options) {
       OpenLayers.Util.extend(this, options);
    },
	
	/**
	 * Method: destroy
	 * 销毁瓦片类。
	 */
	destroy: function(){
		this.features = [];
		this.features = null;
		this.tileBounds = null;
		this.id = null;
		this.row = null;
		this.col = null;
		this.level = null;
	}
});

/**
 * 沿线标签类
 */
Geo.Util.Format.GeoTextFeatures.LineLabelGroup = Geo.Class({
	
	/**
	 * Property: features
	 * {Array(Geo.Feature.Vector)} 沿线标注要素。
	 */
	features:[],
	
	/**
	 * Property: labelCharSpace
	 * {Array(Geo.Feature.Vector)} 沿线标注字间距。
	 */
	labelCharSpace: 5,
	
	/**
	 * Property: isVisibleLabel
	 * {Boolean} 标注是否可见。
	 */
	isVisibleLabel: true,
	
	/**
	 * Property: label
	 * {String} 标注名称。
	 */
	label: null,
	
	/**
	 * Constructor: initialize
	 * 沿线标签类。
	 */
	initialize: function(options) {
		this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
		OpenLayers.Util.extend(this, options);
		//防止一组文字标注单个字之间文字相交
		this.isIntersectLabelChar();
    },
	
	/**
	 * Method: getLabelCharBounds
	 * 得到单个文字的范围。
	 */
	getLabelCharBounds: function(feature, map) {
		var position = new Geo.LonLat(feature.geometry.x, feature.geometry.y);
        var charCount = feature.style.label.length;
        var res = map.getResolution();
        var size = new Geo.Size((parseInt(feature.style.fontSize))*charCount*res,parseInt(feature.style.fontSize)*res);
        var charBounds = new Geo.Bounds(position.lon-size.w/2, position.lat-size.h/2,
                                          position.lon+size.w/2, position.lat+size.h/2);
										  
						  
		return charBounds;
	},
	
	/**
	 * Method: isIntersectLabelChar
	 * 单个字之间是否相交。
	 */
	isIntersectLabelChar: function() {
		var features = this.features;
		for(var i = 0; i < features.length - 1; i++) {
			var precharBounds = this.getLabelCharBounds(features[i], map);
			var nextcharBounds = this.getLabelCharBounds(features[i + 1], map);
			var isIntersect = precharBounds.intersectsBounds(nextcharBounds, false);
			if(isIntersect) {
				this.isVisibleLabel = false;
				break;
			}
		}
	},
	
	/**
	 * Method: getLabelBounds
	 * 得到线上字所站的范围。
	 */
	getLabelBounds: function(map) {
		var labelBounds = null;
		var features = this.features;
		for(var i = 0; i < features.length; i++) {
			var charBounds = this.getLabelCharBounds(features[i], map);
			if(labelBounds == null) {
				labelBounds = charBounds;
			}else {
				labelBounds.extend(charBounds);
			}	
		}
		return labelBounds;
	},
	
	/**
	 * Method: destroy
	 * 销毁沿线标注对象。
	 */
	destroy: function() {
		this.features = [];
		this.features = null;
		this.labelCharSpace = null;
		this.isShowLabel = null;
		this.label = null;
	},
	
	CLASS_NAME:"LineLabelGroup"
	
});/**
 * Class: Geo.Util.Format.WMTS
 * 根据wmts的服务url，获取GetCapabilities信息，解析后得到图层配置参数，构建WMTS图层。
 */
Geo.Util.Format.WMTS = Geo.Class({

    /**
     * APIProperty: pyramid
     * {<Geo.Pyramid>} 金字塔对象
     */
    pyramid: null,
    
    /**
     * Constructor: Geo.Util.Format.WMTS
     * Geo.Util.Format.WMTS构造函数。
     */
    initialize: function(options){
		OpenLayers.Util.extend(this, options);
		
		//如果为null，则构造一个默认金字塔对象
        if (this.pyramid == null) {
			this.pyramid = new Geo.Pyramid();
        }
    },
    
    /**
     * APIMethod: createLayer
     * 根据url创建WMTS图层对象。
     * 请求url，响应返回capabilities的XML文档信息，解析该XML文档，获得图层配置参数，最后生成WMTS图层对象。
     * 如果wmts服务中含有多个图层配置信息，可设置config中属性layer为对应图层identifier的值，即取该图层的配置参数，生成WMTS图层对象。
     * 如不设置config中属性layer，则默认取第一个图层的配置参数生成WMTS图层对象。
     * 
     * Parameters:
     * url - {String} WMTS服务地址。
     * config - {Object} 可选。图层的配置参数。
     * 
     * Returns:
     * {<Geo.View2D.Layer.WMTS>} 一个WMTS图层对象。
     */
    createLayer: function(url, config){
        var wmtsLayer = null;
        this.getCapabilities(url, 
		OpenLayers.Function.bind(function(result){
			//响应返回capabilities的XML文档信息
            var data = result.responseXML;
            if (!data || !data.documentElement) {
                data = result.responseText;
            }
            var format = new OpenLayers.Format.WMTSCapabilities.v1_0_0();
            var capabilities = format.read(data);
            wmtsLayer = this._createLayer(url, capabilities, config, "2D");
        }, this),
		function(){
            alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
			//wmtsLayer = new OpenLayers.Layer.WMTS({url:url});
        });
        return wmtsLayer;
    },
    
    /**
     * APIMethod: createLayer3D
     * 根据url创建三维WMTS图层对象。
     * 请求url，响应返回capabilities的XML文档信息，解析该XML文档，获得图层配置参数，最后生成WMTS图层对象。
     * 如果wmts服务中含有多个图层配置信息，可设置config中属性layer为对应图层identifier的值，即取该图层的配置参数，生成WMTS图层对象。
     * 如不设置config中属性layer，则默认取第一个图层的配置参数生成WMTS图层对象。
     * 
     * Parameters:
     * url - {String} WMTS服务地址。
     * config - {Object} 可选。图层的配置参数。
     *
     * Returns:
     * {<Geo.View3D.Layer.WMTS>} 一个WMTS图层对象。
     */
    createLayer3D: function(url, config){
        var wmtsLayer = null;
        this.getCapabilities(url, 
		OpenLayers.Function.bind(function(result){
			//响应返回capabilities的XML文档信息
            var data = result.responseXML;
            if (!data || !data.documentElement) {
                data = result.responseText;
            }
            var format = new OpenLayers.Format.WMTSCapabilities.v1_0_0();
            var capabilities = format.read(data);
            wmtsLayer = this._createLayer(url, capabilities, config, "3D");
        }, this),
		function(){
            alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
			//wmtsLayer = new OpenLayers.Layer.WMTS({url:url});
        });
        return wmtsLayer;
    },
    
    /**
     * APIMethod: getLayerIdentifiers
     * 根据url获取WMTS服务capabilities中的图层标识名(identifier)数组。
     *
     * Parameters:
     * url - {String} WMTS服务地址。
     *
     * Returns:
     * {Array(String)} 返回WMTS服务capabilities中的图层标识名(identifier)数组。
     */
    getLayerIdentifiers: function(url){
        var layerIdentifiers = [];
        this.getCapabilities(url, 
		OpenLayers.Function.bind(function(result){
			//响应返回capabilities的XML文档信息
            var data = result.responseXML;
            if (!data || !data.documentElement) {
                data = result.responseText;
            }
            var format = new OpenLayers.Format.WMTSCapabilities.v1_0_0();
            var capabilities = format.read(data);
			var contents = capabilities.contents;
			//把图层名加入数组
	        for (var i = 0, ii = contents.layers.length; i < ii; ++i) {
				layerIdentifiers.push(contents.layers[i].identifier);
			}
        }, this),
		function(){
            alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
			//wmtsLayer = new OpenLayers.Layer.WMTS({url:url});
        });
        return layerIdentifiers;
    },
    
    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(url, successFn, failFn){
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WMTS"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
            };
        }
        OpenLayers.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },
	
    /**
     * Method: _createLayer
     * 根据capabilities信息创建WMTS图层对象。
     *
     * Parameters:
     * url - {String} WMTS服务地址。
     * capabilities - {Object} capabilities信息。可用OpenLayers.Format.WMTSCapabilities.v1_0_0解析器调用<read>方法返回capabilities信息。
     * config - {Object} 可选。图层的配置参数。
     *
     * Returns:
     * {<Geo.View2D.Layer.WMTS>} 一个WMTS图层对象。
     */
    _createLayer: function(url, capabilities, config, mapType){
		//config不存在，则赋值为空的对象
		if(!config){
			config = {};
		}
		
		var contents = capabilities.contents;
		
		// find the layer definition with the given identifier
        var layers = contents.layers;
        var layerDef;
		//默认取第一个图层
		layerDef = contents.layers[0];
		//如果有设置图层名，则取图层名对应的图层数据
        for (var i = 0, ii = contents.layers.length; i < ii; ++i) {
			if (contents.layers[i].identifier === config.layer) {
				layerDef = contents.layers[i];
				break;
			}
		}
        if (!layerDef) {
            throw new Error("Layer not found");
        }
        
		// format 例如tiles
        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length) {
            format = layerDef.formats[0];
        }
		
		// find the matrixSet definition
        var matrixSet;
        if (config.matrixSet) {
            matrixSet = contents.tileMatrixSets[config.matrixSet];
        }else if (layerDef.tileMatrixSetLinks.length >= 1) {
			//默认取第一个矩阵集
            matrixSet = contents.tileMatrixSets[layerDef.tileMatrixSetLinks[0].tileMatrixSet];
        }
        if (!matrixSet) {
            throw new Error("matrixSet not found");
        }
		
		// get the default style for the layer
        var style;
        for (var i = 0, ii = layerDef.styles.length; i < ii; ++i) {
            style = layerDef.styles[i];
            if (style.isDefault) {
                break;
            }
        }
		
		//requestEncoding 请求代码，"KVP"或"REST"
        var requestEncoding = config.requestEncoding;
        if (!requestEncoding) {
            requestEncoding = "KVP";
			/*
            if (capabilities.operationsMetadata.GetTile.dcp.http) {
                var http = capabilities.operationsMetadata.GetTile.dcp.http;
                // Get first get method
                if (http.get[0].constraints) {
                    var constraints = http.get[0].constraints;
                    var allowedValues = constraints.GetEncoding.allowedValues;

                    // The OGC documentation is not clear if we should use
                    // REST or RESTful, ArcGis use RESTful,
                    // and OpenLayers use REST.
                    if (!allowedValues.KVP &&
                            (allowedValues.REST || allowedValues.RESTful)) {
                        requestEncoding = "REST";
                    }
                }
            }
			*/
        }
        
        //var dimensions = [];
        //var params = config.params || {};
        // to don't overwrite the changes in the applyDefaults
        //delete config.params;
		//for (var id = 0, ld = layerDef.dimensions.length ; id < ld ; id++) {
		//    var dimension = layerDef.dimensions[id];
		//    dimensions.push(dimension.identifier);
		//    if (!params.hasOwnProperty(dimension.identifier)) {
		//        params[dimension.identifier] = dimension['default'];
		//    }
		//}
		
		//var projection = config.projection || matrixSet.supportedCRS.replace(
        //        /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3");
        //var units = config.units ||
        //        (projection === "EPSG:4326" ? "degrees" : "m");
		
		//分辨率
        var resolutions = [];
        for (var i = 0, len = matrixSet.matrixIds.length; i < len; i++) {
            resolutions.push(this.pyramid.getResolutionForScale(parseFloat(matrixSet.matrixIds[i].scaleDenominator)));
        }
		/*
		//url
		var url;
        if (requestEncoding === "REST" && layerDef.resourceUrls) {
            url = [];
            var resourceUrls = layerDef.resourceUrls,
                resourceUrl;
            for (var t = 0, tt = layerDef.resourceUrls.length; t < tt; ++t) {
                resourceUrl = layerDef.resourceUrls[t];
                if (resourceUrl.format === format && resourceUrl.resourceType === "tile") {
                    url.push(resourceUrl.template);
                }
            }
        }
        else {
            var httpGet = capabilities.operationsMetadata.GetTile.dcp.http.get;
            url = [];
            var constraint;
            for (var i = 0, ii = httpGet.length; i < ii; i++) {
                constraint = httpGet[i].constraints;
                if (!constraint || (constraint && constraint.
                        GetEncoding.allowedValues[requestEncoding])) {
                    url.push(httpGet[i].url);
                }
            }
        }
		*/
		//zoomOffset 地图级别偏移量
		var zoomOffset = Number(matrixSet.matrixIds[0].identifier);
		//瓦片原点 OpenLayers.LonLat
		var tileOrigin = matrixSet.matrixIds[0].topLeftCorner;
		
		//构造三维WMTS图层所需的属性。
		var topLevel = Number(matrixSet.matrixIds[0].identifier);
		var bottomLevel = Number(matrixSet.matrixIds[matrixSet.matrixIds.length - 1].identifier);
		
		switch(mapType){
			case "2D":
		        //config存在的参数，不会被替换
		        var wmtsConfig = OpenLayers.Util.applyDefaults(config, {
		            url: url,
		            requestEncoding: requestEncoding,//请求代码，"KVP"或"REST"
		            name: layerDef.title,//名称
		            style: style.identifier,//样式标识
		            layer: layerDef.identifier,//图层标识
		            format: format,//数据格式
		            matrixSet: matrixSet.identifier,//矩阵集名称
		            zoomOffset: zoomOffset,//地图级别偏移量
		            resolutions: resolutions,//分辨率config.isBaseLayer === false ? undefined :resolutions,
		            maxResolution: resolutions[0],//最大分辨率
		            minResolution: resolutions[resolutions.length - 1],//最小分辨率
		            tileFullExtent: layerDef.bounds//图层范围
		            //tileOrigin: tileOrigin//瓦片原点，计算行列号的起始位置，其值可以通过wmts服务的getCapabilities返回结果获得。默认值：lon:-180 lat:90
		            //matrixIds: matrixSet.matrixIds,
		            //projection: projection,
		            //units: units,
		            //serverResolutions: resolutions,
		            //dimensions: dimensions,
		            //params: params
		        });
		        return new OpenLayers.Layer.WMTS(wmtsConfig);
				break;
			case "3D":
				//config存在的参数，不会被替换
		        var wmtsConfig = OpenLayers.Util.applyDefaults(config, {
		            url: url,
		            name: layerDef.title,//名称
		            projection: "EPSG:4326",//当前图层使用的投影
					//opacity: 1,//图层透明度
		            style: style.identifier,//样式标识
		            layer: layerDef.identifier,//图层标识
		            format: format,//数据格式
		            matrixSet: matrixSet.identifier,//矩阵集名称
		            topLevel: topLevel,//图层顶层级别
					bottomLevel: bottomLevel,//图层底层级别
		            tileFullExtent: layerDef.bounds//图层范围
		        });
		        return new Geo.View3D.Layer.WMTS(wmtsConfig);
				break;
		}
		
    },
    
    CLASS_NAME: "Geo.Util.Format.WMTS"
});
/**
 * Class: Geo.Util.Format.WMS
 * 根据wms的服务url，获取GetCapabilities信息，解析后得到图层配置参数，构建WMS图层。
 */
Geo.Util.Format.WMS = Geo.Class({

    /**
     * Property: pyramid
     * {<Geo.Pyramid>} 金字塔对象
     */
    pyramid: null,
    
    /**
     * Constructor: Geo.Util.Format.WMS
     * Geo.Util.Format.WMS构造函数。
     */
    initialize: function(options){
		OpenLayers.Util.extend(this, options);
		
		//如果为null，则构造一个默认金字塔对象
        if (this.pyramid == null) {
			this.pyramid = new Geo.Pyramid();
        }
    },
    
    /**
     * APIMethod: createLayer
     * 根据url创建WMS图层对象。
     * 请求url，响应返回capabilities的XML文档信息，解析该XML文档，获得图层配置参数，最后生成WMS图层对象。
     * 如果wms服务中含有多个图层配置信息，可设置config中属性layer为对应图层name的值，即取该图层的配置参数，生成WMS图层对象。
     * 如不设置config中属性layer，则默认取第一个图层的配置参数生成WMS图层对象。
     * 
     * Parameters:
     * url - {String} WMS服务地址。
     * config - {Object} 可选。图层的配置参数。
     * 
     * Returns:
     * {<Geo.View2D.Layer.WMS>} 一个WMS图层对象。
     */
    createLayer: function(url, config){
        var flag = true;
		var wmsLayer = null;
        this.getCapabilities(url, config,
		OpenLayers.Function.bind(function(result){
			//响应返回capabilities的XML文档信息
            var data = result.responseXML;
            if (!data || !data.documentElement) {
                data = result.responseText;
            }
			if(data == null || data == ""){
            	this.failFn(url);
            	flag = false;
            	return;
            }
            var format = new OpenLayers.Format.WMSCapabilities();
            var capabilities = format.read(data);
            wmsLayer = this._createLayer(url,capabilities, config, "2D");
        }, this),
		function(){
            alert("WMS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
        });
        if(flag){
        	return wmsLayer;
        }
    },
    
    /**
     * APIMethod: createLayer3D
     * 根据url创建三维WMS图层对象。
     * 请求url，响应返回capabilities的XML文档信息，解析该XML文档，获得图层配置参数，最后生成WMS图层对象。
     * 如果wms服务中含有多个图层配置信息，可设置config中属性layer为对应图层name的值，即取该图层的配置参数，生成WMS图层对象。
     * 如不设置config中属性layer，则默认取第一个图层的配置参数生成WMS图层对象。
     * 
     * Parameters:
     * url - {String} WMS服务地址。
     * config - {Object} 可选。图层的配置参数。
     *
     * Returns:
     * {<Geo.View3D.Layer.WMS>} 一个WMS图层对象。
     */
    createLayer3D: function(url, config){
		var flag = true;
        var wmsLayer = null;
        this.getCapabilities(url,config, 
		OpenLayers.Function.bind(function(result){
			//响应返回capabilities的XML文档信息
            var data = result.responseXML;
            if (!data || !data.documentElement) {
                data = result.responseText;
            }
			if(data == null || data == ""){
            	this.failFn(url);
            	flag = false;
            	return;
            }
            var format = new OpenLayers.Format.WMSCapabilities();
            var capabilities = format.read(data);
            wmsLayer = this._createLayer(url,capabilities, config, "3D");
        }, this),
		function(){
            alert("WMS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
        });
         if(flag){
        	return wmsLayer;
        }
    },
    
	failFn: function(url){
        alert("WMS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
    },
	
    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(url, config, successFn, failFn){
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WMS",
            VERSION: (config ? config.version : null) ? config.version : "1.1.1"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("WMS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n版本号：" + params[VERSION] + "\n操作类型：GetCapabilities");
            };
        }
        OpenLayers.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },
	
    /**
     * Method: _createLayer
     * 根据capabilities信息创建WMS图层对象。
     *
     * Parameters:
     * capabilities - {Object} capabilities信息。可用OpenLayers.Format.WMSCapabilities.v1_0_0解析器调用<read>方法返回capabilities信息。
     * config - {Object} 可选。图层的配置参数。
     *
     * Returns:
     * {<Geo.View2D.Layer.WMS>} 一个WMS图层对象。
     */
    _createLayer: function(url,capabilities, config, mapType){
		//config不存在，则赋值为空的对象
		if(!config){
			config = {};
		}
		
		var capability = capabilities.capability;
		
		// find the layer definition with the given identifier
        var layers = capability.layers;
        var layerDef;
		//默认取第一个图层
		layerDef = capability.layers[0];
		//如果有设置图层名，则取图层名对应的图层数据
        for (var i = 0, ii = capability.layers.length; i < ii; ++i) {
			if (capability.layers[i].name === config.layer) {
				layerDef = capability.layers[i];
				break;
			}
		}
        if (!layerDef) {
            throw new Error("Layer not found");
        }
        
        // format 例如tiles
        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length>0) {
            format = layerDef.formats[0];
        }

        // transparent
        var transparent = config.transparent;
        if(!transparent || transparent==""){
        	transparent = true;
        }
        
		// name
        var name;;
        if (layerDef.name) {
            name = layerDef.name;
        }
        
        // version
        var version = config.version;
        if (!version && capabilities.version) {
        	version = capabilities.version;
        }
        
        // projection
        var projection = config.srs;
        if (!projection && layerDef.srs) {
        	for(var k in layerDef.srs){
        		projection = k;
        	}
        }
        
        // maxExtent
        var maxExtent = config.llbbox;
        if (!maxExtent && layerDef.llbbox && layerDef.llbbox.length>0) {
            maxExtent = layerDef.llbbox[0]+","+layerDef.llbbox[1]+","+layerDef.llbbox[2]+","+layerDef.llbbox[3];
        }
        
		switch(mapType){
			case "2D":
				var wmsLayer = new Geo.View2D.Layer.WMS(
		             "WMS",//服务名称   
		             url,//服务地址
		             {   
		             	//服务版本
			            version: version,
			            //图层标识，从服务的getCapabilities描述信息获取
			            layers: name,  
			            //数据格式
			            format: format, 
			            //图层背景是否透明，true表示透明   
			            transparent: transparent  
		             },   
		             {   
		                //图层最大范围   
		                maxExtent: Geo.Bounds.fromString(maxExtent),
		                //投影
		                projection: projection,  
		                //坐标轴顺序,false表示经度、纬度的顺序，true表示纬度、经度的顺序   
		                isReverse: true
		             }   
		         );   
		        return wmsLayer;
				break;
			case "3D":
				var serviceObj = new Geo.Service.WMS("wms", url);
				var wms3dlayer;
            	var wms3dlayer = new Geo.View3D.Layer.WMS(
				"wms", //服务名称 
				url,//服务地址
          		{
            		//服务版本
	           		version: version,
            		//图层标识，从服务的getCapabilities描述信息获取
	            	layers: name, 
				    //数据格式
	            	format: format,
	            	//请求的瓦片背景区域是否透明,默认：TRUE	
				    transparent: transparent            		
            	},
            	{
            		//图层透明度设置，可以设置：0-1，默认：1
            		opacity : 1,
            		//当前图层使用的投影
            		projection: projection,
            		//瓦片宽度，瓦片高度，默认：256，256
            		//tileSize: new Geo.Size(256,256),
					//图层最大范围   
                	maxExtent: Geo.Bounds.fromString(maxExtent)	
				});
				return wms3dlayer;
				break;
		}
		
    },
    
    CLASS_NAME: "Geo.Util.Format.WMS"
});
/**
 * Class: Geo.Util.Format.GeoWMTS
 * 根据wmts的服务url，获取GetCapabilities信息，解析后得到图层配置参数，构建WMTS图层。
 */
Geo.Util.Format.GeoWMTS = Geo.Class({

    /**
     * APIProperty: pyramid
     * {<Geo.Pyramid>} 金字塔对象
     */
    pyramid: null,
    
    /**
     * Constructor: Geo.Util.Format.WMTS
     * Geo.Util.Format.WMTS构造函数。
     */
    initialize: function(options){
		OpenLayers.Util.extend(this, options);
		
		//如果为null，则构造一个默认金字塔对象
        if (this.pyramid == null) {
			this.pyramid = new Geo.Pyramid();
        }
    },
    
    /**
     * APIMethod: createLayer
     * 根据url创建WMTS图层对象。
     * 请求url，响应返回capabilities的XML文档信息，解析该XML文档，获得图层配置参数，最后生成WMTS图层对象。
     * 如果wmts服务中含有多个图层配置信息，可设置config中属性layer为对应图层identifier的值，即取该图层的配置参数，生成WMTS图层对象。
     * 如不设置config中属性layer，则默认取第一个图层的配置参数生成WMTS图层对象。
     * 
     * Parameters:
     * url - {String} WMTS服务地址。
     * config - {Object} 可选。图层的配置参数。
     * 
     * Returns:
     * {<Geo.View2D.Layer.WMTS>} 一个WMTS图层对象。
     */
    createLayer: function(url, config){
    	var flag = true;
        var wmtsLayer = null;
        this.getCapabilities(url, 
		OpenLayers.Function.bind(function(result){
			//响应返回capabilities的XML文档信息
            var data = result.responseXML;
            if (!data || !data.documentElement) {
                data = result.responseText;
            }
            if(data == null || data == ""){
            	this.failFn(url);
            	flag = false;
            	return;
            }
            var format = new OpenLayers.Format.WMTSCapabilities.v1_0_0();
            var capabilities = format.read(data);
            wmtsLayer = this._createLayer(url, capabilities, config);
        }, this),
		function(){
            alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
            return;
        });
        if(flag){
        	return wmtsLayer;
        }
    },
    
    failFn: function(url){
        alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
        "请求地址：" + url + "\n操作类型：GetCapabilities");
    },
    
    /**
     * APIMethod: getLayerIdentifiers
     * 根据url获取WMTS服务capabilities中的图层标识名(identifier)数组。
     *
     * Parameters:
     * url - {String} WMTS服务地址。
     *
     * Returns:
     * {Array(String)} 返回WMTS服务capabilities中的图层标识名(identifier)数组。
     */
    getLayerIdentifiers: function(url){
        var layerIdentifiers = [];
        this.getCapabilities(url, 
		OpenLayers.Function.bind(function(result){
			//响应返回capabilities的XML文档信息
            var data = result.responseXML;
            if (!data || !data.documentElement) {
                data = result.responseText;
            }
            var format = new OpenLayers.Format.WMTSCapabilities.v1_0_0();
            var capabilities = format.read(data);
			var contents = capabilities.contents;
			//把图层名加入数组
	        for (var i = 0, ii = contents.layers.length; i < ii; ++i) {
				layerIdentifiers.push(contents.layers[i].identifier);
			}
        }, this),
		function(){
            alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
			//wmtsLayer = new OpenLayers.Layer.WMTS({url:url});
        });
        return layerIdentifiers;
    },
    
    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(url, successFn, failFn){
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WMTS"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
            };
        }
        OpenLayers.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },
	
    /**
     * Method: _createLayer
     * 根据capabilities信息创建WMTS图层对象。
     *
     * Parameters:
     * url - {String} WMTS服务地址。
     * capabilities - {Object} capabilities信息。可用OpenLayers.Format.WMTSCapabilities.v1_0_0解析器调用<read>方法返回capabilities信息。
     * config - {Object} 可选。图层的配置参数。
     *
     * Returns:
     * {<Geo.View2D.Layer.WMTS>} 一个WMTS图层对象。
     */
    _createLayer: function(url, capabilities, config){
		//config不存在，则赋值为空的对象
		if(!config){
			config = {};
		}
		
		var contents = capabilities.contents;
		
		// find the layer definition with the given identifier
        var layers = contents.layers;
        var layerDef;
		//默认取第一个图层
		layerDef = contents.layers[0];
		//如果有设置图层名，则取图层名对应的图层数据
        for (var i = 0, ii = contents.layers.length; i < ii; ++i) {
			if (contents.layers[i].identifier === config.layer) {
				layerDef = contents.layers[i];
				break;
			}
		}
        if (!layerDef) {
            throw new Error("Layer not found");
        }
        
		// format 例如tiles
        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length) {
            format = layerDef.formats[0];
        }
		
		// find the matrixSet definition
        var matrixSet;
        if (config.matrixSet) {
            matrixSet = contents.tileMatrixSets[config.matrixSet];
        }else if (layerDef.tileMatrixSetLinks.length >= 1) {
			//默认取第一个矩阵集
            matrixSet = contents.tileMatrixSets[layerDef.tileMatrixSetLinks[0].tileMatrixSet];
        }
        if (!matrixSet) {
            throw new Error("matrixSet not found");
        }
		
		// get the default style for the layer
        var style;
        for (var i = 0, ii = layerDef.styles.length; i < ii; ++i) {
            style = layerDef.styles[i];
            if (style.isDefault) {
                break;
            }
        }
		
		//requestEncoding 请求代码，"KVP"或"REST"
        var requestEncoding = config.requestEncoding;
        if (!requestEncoding) {
            requestEncoding = "KVP";
            /*
            if (capabilities.operationsMetadata.GetTile.dcp.http) {
                var http = capabilities.operationsMetadata.GetTile.dcp.http;
                // Get first get method
                if (http.get[0].constraints) {
                    var constraints = http.get[0].constraints;
                    var allowedValues = constraints.GetEncoding.allowedValues;

                    // The OGC documentation is not clear if we should use
                    // REST or RESTful, ArcGis use RESTful,
                    // and OpenLayers use REST.
                    if (!allowedValues.KVP &&
                            (allowedValues.REST || allowedValues.RESTful)) {
                        requestEncoding = "REST";
                    }
                }
            }
            */
        }
		
		//分辨率
        var resolutions = [];
        for (var i = 0, len = matrixSet.matrixIds.length; i < len; i++) {
            resolutions.push(this.pyramid.getResolutionForScale(parseFloat(matrixSet.matrixIds[i].scaleDenominator)));
        }
		/*
		//url
		var url;
        if (requestEncoding === "REST" && layerDef.resourceUrls) {
            url = [];
            var resourceUrls = layerDef.resourceUrls,
                resourceUrl;
            for (var t = 0, tt = layerDef.resourceUrls.length; t < tt; ++t) {
                resourceUrl = layerDef.resourceUrls[t];
                if (resourceUrl.format === format && resourceUrl.resourceType === "tile") {
                    url.push(resourceUrl.template);
                }
            }
        }
        else {
            var httpGet = capabilities.operationsMetadata.GetTile.dcp.http.get;
            url = [];
            var constraint;
            for (var i = 0, ii = httpGet.length; i < ii; i++) {
                constraint = httpGet[i].constraints;
                if (!constraint || (constraint && constraint.
                        GetEncoding.allowedValues[requestEncoding])) {
                    url.push(httpGet[i].url);
                }
            }
        }
		*/
		//zoomOffset 地图级别偏移量
		var zoomOffset = Number(matrixSet.matrixIds[0].identifier);
		//瓦片原点 OpenLayers.LonLat
		var tileOrigin = matrixSet.matrixIds[0].topLeftCorner;
		
        //config存在的参数，不会被替换
        var wmtsConfig = OpenLayers.Util.applyDefaults(config, {
            url: url,
            requestEncoding: requestEncoding,//请求代码，"KVP"或"REST"
            name: layerDef.title,//名称
            style: style.identifier,//样式标识
            layer: layerDef.identifier,//图层标识
            format: format,//数据格式
            matrixSet: matrixSet.identifier,//矩阵集名称
            userecent:true,
            matrixIds:matrixSet.matrixIds,
            zoomOffset: zoomOffset,//地图级别偏移量
            resolutions: resolutions,//分辨率config.isBaseLayer === false ? undefined :resolutions,
            maxResolution: resolutions[0],//最大分辨率
            minResolution: resolutions[resolutions.length - 1],//最小分辨率
            tileFullExtent: layerDef.bounds,//图层范围
            tileOrigin: tileOrigin//瓦片原点，计算行列号的起始位置，其值可以通过wmts服务的getCapabilities返回结果获得
        });
       return new OpenLayers.Layer.GeoWMTS(wmtsConfig);
		
    },
    
    CLASS_NAME: "Geo.Util.Format.GeoWMTS"
});
/**
 * Class: Geo.Util.GeoAvoidObject
 * 标注对象 。
 */
Geo.Util.GeoAvoidObject = Geo.Class({
    /**
     * APIProperty: positions
     * {Array} 。
     */
	positions: [],
	
	/**
     * APIProperty: postionIndex
     * {Int} 。
     */
	postionIndex: 0,
	
	 /**
     * APIProperty: rect
     * {Array} 。
     */
	rects: [],
	
	/**
     * APIProperty: featrueObject
     * {Object} 。
     */
	featrueObject:null,

	/**
	 * Constructor: Geo.Util.Text.GeoAvoidObject
	 * Geo.Util.Text.GeoAvoidObject构造函数。
	 */
	initialize: function(){
		
	},
	
	 /**
     * APIMethod: isIntersect
     * 判断当前标注对象与传入的标注对象是否相交  。
     *
     * Parameters:
     * other - {GeoAvoidObject}  传入的标注对象。
     *
     * Returns:
     * ｛Boolean｝
     */ 
	isIntersect:function(other){
		var offsetX = this.positions[this.postionIndex].x - other.positions[other.postionIndex].x;
		var offsetY = this.positions[this.postionIndex].y - other.positions[other.postionIndex].y;
		
		var rect = this.rects[this.postionIndex];
		var otherRect = other.rects[other.postionIndex];
		
		var absOffsetX = Math.abs(offsetX);
		var absOffsetY = Math.abs(offsetY);
		//外接矩形相离，不相交
		if(offsetX < 0)
		{
			if(absOffsetX > rect.w)
			{
				return false;
			}
		}
		else
		{
			if(absOffsetX > otherRect.w)
			{
				return false;
			}
		}
		
		if(offsetY <0)
		{
			if(absOffsetY > rect.h)
			{
				return false;
			}
		}
		else
		{
			if(absOffsetY > otherRect.h)
			{
				return false;
			}
		}
		
		return true;
	},
		
	CLASS_NAME:"Geo.Util.GeoAvoidObject"
});/**
 * Class: Geo.Util.GeoPreAvoidContainer
 * 先占位原则避让算法。
 * 
 */
Geo.Util.GeoPreAvoidContainer = Geo.Class({
    /**
     * APIProperty: array
     * {Array} 避让数据。
     */
	array: [],
	
	/**
	 * Constructor: Geo.Util.Text.GeoPreAvoidContainer
	 * Geo.Util.Text.GeoPreAvoidContainer构造函数。
	 */
	initialize: function(){
		
	},
	
	/**
     * APIMethod: append
     * 往避让容器中加入标注对象，经过避让算法后，如果避让成功，则增加到避让容器中，否则不加入 。
     *
     * Parameters:
     * avoid - {Object}  标注对象。
     *
     * Returns:
     * ｛Boolean｝
     */
	append:function(avoid){
		var flag = true;
		//循环标注的8个位置
		for(var i = 0;i < avoid.positions.length;i++)
		{
			flag = true;
			//给标注设置避让位置的索引号
			avoid.postionIndex = i;
			for ( var j = 0; j <this.array.length ; j++ )
			{
				//如果和容器中任意一个标注对象相交
				if ( avoid.isIntersect(this.array[j]) )
				{
					flag=false;
					break;
				}
			}
			//如果当前标注位置的标注对象与容器中任何一个标注对象都不相交，则加入到避让容器中
			if(flag)
			{
				this.array.push(avoid);
				return true;
			}
		}
		return false;
	},
	
	/**
     * APIMethod: getGeoAvoidObjects
     * 获取容器中的对象 。
     *
     * Returns:
     * ｛Array｝
     */
	getGeoAvoidObjects:function(){
		return this.array;
	},
	
	/**
     * APIMethod: getGeoAvoidObjects
     * 获取容器中的对象 。
     *
     * Returns:
     * ｛Array｝
     */
	clean:function(){
		this.array = new Array();
	},
	
	CLASS_NAME:"Geo.Util.GeoPreAvoidContainer"
});/**
 * Class: Geo.Util.ConfigHanlder
 * 用于根据配置文件初始化内置对象。
 */
(function(){
	Geo.Util.ConfigHanlder = {
	};
	//初始化内置服务对象的方法。
	Geo.Util.ConfigHanlder.initconfigListener = function(config){
        //实例化内置服务对象
        if (config) {
        
            if (config.bus && config.bus.url) {
                //公交服务对象
                Geo.Service.BusIns = new Geo.Service.Bus("内置公交服务对象", config.bus.url, {
                    networkName: config.bus.networkName
                });
            }
            if (config.route && config.route.url) {
                //路网服务对象
                Geo.Service.GeoRouteIns = new Geo.Service.GeoRoute("内置路网服务对象", config.route.url);
            }
            if (config.geocoding && config.geocoding.url) {
                //地名地址服务对象
                Geo.Query.GeoCodingQueryIns = new Geo.Query.GeoCodingQuery(config.geocoding.url, {
                    version: config.geocoding.version
                });
            }
            if (config.wps && config.wps.url) {
                //缓冲分析服务对象
                Geo.Analysis.BufferAnalysisIns = new Geo.Analysis.BufferAnalysis(config.wps.url);
                //叠置分析服务对象
                Geo.Analysis.SuperposeAnalysisIns = new Geo.Analysis.SuperposeAnalysis(config.wps.url);
            }
            if (config.wfs && config.wfs.url) {
                //要素服务对象
                Geo.Query.WFSQueryIns = new Geo.Query.WFSQuery(config.wfs.url, config.wfs.featureType, {
                    geometryName: config.wfs.geometry,
                    format: config.wfs.version == "1.1.0" ? new Geo.Format.GML.v3({
                        xy: !config.wfs.order
                    }) : new Geo.Format.GML.v2({
                        xy: true
                    }),
                    version: config.wfs.version,
                    maxFeatures: config.wfs.maxFeatures
                });
            }
        }
    };
    Geo.Util.ConfigHanlder.events = new OpenLayers.Events;
    Geo.Util.ConfigHanlder.events.on({
        "initconfig": Geo.Util.ConfigHanlder.initconfigListener
    });
})();
/**
 * Class: Geo.View2D.Map
 * 地图对象类，继承自Geo.Map类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.Map>
 */
Geo.View2D.Map = Geo.Class(OpenLayers.Map, {

    /**
     * APIProperty: pyramid
     * {<Geo.Pyramid>} 地图的金字塔方案对象，默认值为Geo.Pyramid.DEFAULT_PYRAMID常量指定的360度金字塔方案。
     */
    pyramid: null,
    
    /**
     * APIProperty: allOverlays
     * {Boolean} 视图中所有图层是否都为覆盖图层，默认为false，也必须为false。
     */
    allOverlays: false,
    
    /**
     * APIProperty: layerGroup
     * {<Geo.LayerGroup>} 地图中加载的图层组对象的引用。
     */
    layerGroup: null,
	
	/**
     * APIProperty: EVENT_TYPES
     * {Array} 事件类型。
     */
    EVENT_TYPES: ["unloadLayerGroup", "loadlayergroup"],
    
    /**
     * APIProperty: overLayers
     * {Array} 所有的覆盖图层。
     */
    overLayers: null,
	
    /**
     * APIProperty: enableAnimateZoomer
     * {Boolean} 设置是否开启平滑缩放的效果。也能设置为一个对象。
     * 如果设置为一个对象，该对象被传递至{<Geo.AnimateZoomer>}的构造函数。
     * 默认为false
     */
    enableAnimateZoomer: false,
	
    /**
     * APIProperty: animateZoomer
     * {<Geo.AnimateZoomer>} 地图的图层平滑缩放效果对象。
     */
	animateZoomer: null,
	
    /**
     * APIProperty: layerGroupLoaded
     * {Boolean} 实例化一个地图对象时，是否默认会加载一组底图图层。
     */
	layerGroupLoaded: false,
	
    /**
     * APIProperty: layerGroupType
     * {String} 表示实例化一个地图对象时，默认加载图层组的类型，一般设置为"vec"或"img"。
     * "vec"表示矢量图层组，"img"表示影像图层组。若不设置，默认会显示矢量图层组。
     */
	layerGroupType: null,
	
    /**
     * Constructor: Geo.View2D.Map
     * Geo.View2D.Map构造函数。
     * 
     * Parameters:
     * div - {String} 地图对象将被渲染到哪个div 元素中。
     * options - {Object} 地图对象相关选项设置。
     */
    initialize: function(div, options){
		this.EVENT_TYPES =
            Geo.View2D.Map.prototype.EVENT_TYPES.concat(
            OpenLayers.Map.prototype.EVENT_TYPES
        );
        this.overLayers = [];
		options = options || {};
		if (options.controls == null) {
            this.controls = [ new Geo.View2D.Control.Navigation(),
                              new Geo.View2D.Control.PanZoomBar(),
                              new Geo.View2D.Control.ArgParser(),
							  new Geo.View2D.Control.MagnifyingGlass()
                            ];
        }else {
            this.controls = [];
        }
		
        OpenLayers.Map.prototype.initialize.apply(this, arguments);
		
		//视图中所有图层必须为为覆盖图层。
		this.allOverlays = false;
        this.pyramid = this.pyramid ? this.pyramid : new Geo.Pyramid();
        this.setPyramid(this.pyramid);
		
		if (this.layerGroupLoaded == true) {
			//获取天地图基础图层组
			var layerGroup = Geo.View2D.BaseLayerGroup.getTDTGroup(this.layerGroupType);
			if(layerGroup){
				this.loadLayerGroup(layerGroup);
			}
		}
		
		//是否开启平滑缩放效果。 
		var config = {layerLoaded: true};
        if(typeof this.enableAnimateZoomer === "object") {
            config = OpenLayers.Util.extend(config, this.enableAnimateZoomer);
        }
        this.animateZoomer = this.enableAnimateZoomer ? new Geo.AnimateZoomer(this, config) : null;
    },
    
     /**
	 * APIMethod: addLayer
	 * 添加图层。一般情况下推荐使用addOverLayer方法，即将单个图层作为覆盖层添加。
	 *
	 * Parameters: 
	 * layer - {<Geo.View2D.Layer>} 二维视图图层对象。
	 */	
    
    //此方法将强行将添加图层isBaseLayer属性改为false
    //_notResetLayers为不公开参数，用于图层组加载时不更新基础层相关参数与重排列置顶层，解决图层组切换效率与跳级问题。
    //默认值为false，即让用户添加覆盖图层时会更新基础层相关参数与重排列置顶层。
    addLayer: function(layer,_notResetLayers){
	
	    var isUpdateBaseLayer = false;
	    
	    if (layer.maxResolution && layer.minResolution) {
	        isUpdateBaseLayer = true;
	    }
	    //强行将基础图层属性改为false
	    layer.isBaseLayer = false;
	    
	    //如果是置顶图层，则添加插入至图层顶层。否则添加插入至置顶图层的最底层的位置。
	    if (layer.isOnTop) {
	        this.insertLayerFirst(layer);
	    }
	    else {
	        var idx = this._getLastTopLayerPosition();
	        this.insertLayerIndex(layer, idx);
	    }
	    if (!_notResetLayers) {
	        if (isUpdateBaseLayer) {
	            this.updateBaseLayer();
	        }
	    }
    },

    /**
	 * APIMethod: addOverLayer
	 * 将指定图层作为覆盖层添加。与addLayer方法不同的是，该图层的引用除了保存到地图对象的layers数组中，还将保存到overLayers数组。
	 * 覆盖层在基础图层组切换时，叠加顺序不受基础图层加载、卸载的影响，始终保持在所有基础图层的上方。
	 *
	 * Parameters: 
	 * layer - {<Geo.View2D.Layer>} 二维视图图层对象。
	 */		
    addOverLayer: function(layer){
        this.addLayer(layer);
        this.overLayers.push(layer);
    },
    
    removeLayer: function(layer){
        
        //移除在覆盖图层数组中的引用
        OpenLayers.Util.removeItem(this.overLayers, layer);
        OpenLayers.Map.prototype.removeLayer.apply(this, arguments);
    },
        
	/** 
     * APIMethod: raiseLayer
     * 调整图层顺序。
     *
     * Paremeters:
     * layer - {<Geo.View2D.Layer>} 图层对象的引用。
     * delta - {int} 图层调整的偏移量,当指定增量值为正时图层上移，当指定增量值为负时图层下移。
     */
	raiseLayer : function(layer, delta) {
		//要移动图层的当前位置
		var currentIndex = this.getLayerIndex(layer);
		//delta表示移动几位
	    var tempDelta = Math.abs(delta);
		if(delta > 0) {
			for (var i = currentIndex, len=this.layers.length; i<len; i++) {
				//若起大于0
				if(tempDelta == 0 || len <= i+1) {
					break;
				}
				if(!this.layers[i+1].displayInLayerSwitcher) {
					delta ++;
				}else {
					tempDelta--;
				}
        		
        	}
		}else if(delta < 0) {
			for (var i = currentIndex, len=this.layers.length;i >= 0; i--) {
        		if(tempDelta == 0 || i - 1 < 0) {
					break;
				}
				if(!this.layers[i-1].displayInLayerSwitcher) {
					delta = delta - 1;
				}else {
					tempDelta--;
				}
        	}
		}
		OpenLayers.Map.prototype.raiseLayer.apply(this, arguments);
	},

	
    /**
	 * APIMethod: resetTopLayer
	 * 将置顶图层重新排列。
	 */	
    resetTopLayer: function(){
        var layersNum = this.layers.length;
		var topIndex = layersNum - 1;
        for (var i = layersNum - 1; i >= 0; i--) {
            var layer = this.layers[i];
            if (layer.isOnTop && !layer.isBaseLayer) {
                this.setLayerIndex(layer, topIndex--);
            }
        }
    },
	
	/**
	 * APIMethod: resetOverLayer
	 * 将覆盖图层重新排列。
	 */	
	resetOverLayer:function(){
		var layersNum = this.layers.length;
		var topIndex = layersNum - 1;
        for (var i = layersNum - 1; i >= 0; i--) {
            var layer = this.layers[i];
            
            //如果不是覆盖图层则视为底图图层将之移到最底层
            if (OpenLayers.Util.indexOf(this.overLayers,layer) != -1) {
                this.setLayerIndex(layer, topIndex--);
            }
        }
	},
    
    /**
	 * APIMethod: setPyramid
	 * 设置金字塔,如果无参数默认为360度金字塔。
	 *
	 * Parameters: 
	 * pyramid - {<Geo.Pyramid>} 金字塔定义。
	 */	
    setPyramid: function(pyramid){
        if (!pyramid) {
            pyramid = new Geo.Pyramid();
        }
        this.pyramid = pyramid;
		this.numZoomLevels = this.pyramid.getNumZoomLevels();
        this.maxExtent = this.pyramid.maxExtent.clone();
		if(this.pyramid.resolutions && typeof this.pyramid.resolutions == 'object' && this.pyramid.resolutions.constructor == Array) {
			var resolutions = this.pyramid.resolutions;
			this.updateBaseLayer({
	            resolutions: resolutions,
	            maxExtent: this.maxExtent
	        });
		}else {
			this.maxResolution = this.pyramid.getMaxResolution();
        	this.minResolution = this.pyramid.getMinResolution();
			this.updateBaseLayer({
	            maxResolution: this.maxResolution,
	            minResolution: this.minResolution,
	            maxExtent: this.maxExtent
	        });
		}
    },
	
   /** 
    * APIMethod: removePopup
    * 移除浮云框
    * Parameters:
    * popup - {<Geo.View2D.Popup>}
    */
    removePopup: function(popup) {
        Geo.Util.removeItem(this.popups, popup);
        if (popup.div) {
            try { this.layerContainerDiv.removeChild(popup.div); }
            catch (e) { } // Popups sometimes apparently get disconnected
                      // from the layerContainerDiv, and cause complaints.
        }
		if(popup.calculateShadowLocation) {
			this.events.unregister("zoomend", popup,popup.calculateShadowLocation);
		}
		if(popup.shadowDiv) {
			 try {this.layerContainerDiv.removeChild(popup.shadowDiv); }
            catch (e) { }
		}
        popup.map = null;
    },
    
    /**
	 * APIMethod: updateBaseLayer
	 * 更新基础图层相关选项,如果无指定选项设置，则根据地图中所有图层相关设置更新基础图层选项。
	 *
	 * Parameters: 
	 * options - - {Object} 相关选项设置。
	 */	
    updateBaseLayer: function(options){
	    var defOptions = {
	        displayInLayerSwitcher: false,
	        isBaseLayer: true
	    }
	    var blOptions = {};
	    if (!options) {
	        blOptions = {
	        	resolutions:this.resolutions,
	            maxResolution: this.getLayersMaxResolution(),
	            minResolution: this.getLayersMinResolution(),
	            maxExtent: this.getLayersMaxExtent()
	        };
	    }
	    else {
	        OpenLayers.Util.extend(blOptions, options);
	    }
	    OpenLayers.Util.extend(blOptions, defOptions);
	    var bl = new OpenLayers.Layer("GeoGlobeBaseLayer", blOptions);
	    
	    if (this.baseLayer) {
	        this.removeLayer(this.baseLayer);
	    }
	    OpenLayers.Map.prototype.addLayer.apply(this, [bl]);
	    this.setLayerIndex(bl, 0);
    },
	
	getResolutions: function() {
		var resolutions = this.resolutions || this.pyramid.resolutions;
		return resolutions;
	},
    
    /**
	 * APIMethod: getLayersMaxResolution
	 * 获取地图中所有图层的最大分辨率，如果所有图层均无分辨率设置，则以地图金字塔最大分辨率为准。
	 * 
	 * Returns:
     * {Float} 分辨率。
	 */	
    getLayersMaxResolution: function(){
        var layers = this.layers, res = null;
        for (var i = 0; i < layers.length; i++) {
			var layerOptions  = layers[i].getOptions();
			var layerMaxRes = layerOptions.maxResolution;
            if (layers[i].isBaseLayer || !layerMaxRes) {
				continue;
			}                
            res = res ? Math.max(res, layerMaxRes) : layerMaxRes;
        }
        var pyramidMaxRes = this.pyramid.getMaxResolution();
        res = (res <= 0 || res > pyramidMaxRes) ? pyramidMaxRes : res;
        return res;
    },
    
    /**
	 * APIMethod: getLayersMinResolution
	 * 获取地图中所有图层的最小分辨率，如果所有图层均无分辨率设置，则以地图金字塔最小分辨率为准。
	 * 
	 * Returns:
     * {Float} 分辨率。
	 */	
    getLayersMinResolution: function(){
        var layers = this.layers, res = null;
        for (var i = 0; i < layers.length; i++) {
			var layerOptions  = layers[i].getOptions();
			var layerMinRes = layerOptions.minResolution;
            if(layers[i].isBaseLayer || !layerMinRes){
				continue;
			}
            res = res ? Math.min(res, layerMinRes) : layerMinRes;
        }
        var pyramidMinRes = this.pyramid.getMinResolution();
        res = (res <= 0 || res < pyramidMinRes) ? pyramidMinRes : res;
        return res;
    },
    
     /**
	 * APIMethod: getLayersMaxExtent
	 * 取所有图层的最大范围，如果所有图层均无最大范围，则以金字塔的最大范围为准。
	 * 
	 *  Returns:
     *  {<Geo.Bounds>}图层范围。
	 */	
    getLayersMaxExtent: function(){
        var extent = null;
        var layers = this.layers;
        for (var i = 0; i < layers.length; i++) {
            if (layers[i].isBaseLayer || !layers[i].maxExtent) 
                continue;
            if (extent) {
                extent.extend(layers[i].maxExtent);
            }
            else {
                extent = layers[i].maxExtent.clone();
            }
        }
        var pyramidMaxExtent = this.pyramid.maxExtent.clone();
        extent = extent ? extent : pyramidMaxExtent;
        return extent;
    },
	
    /**
     * APIMethod: loadLayerGroup
     * 加载指定方案到地图对象。
     *
     * Parameters: 
	 * layerGroup - {<Geo.LayerGroup>} 图层组，在该图层组中，序号值最大的图层在顶层，序号值最小的图层在底层。
     * 
     * Returns:
     * {Boolean} 装载方案是否成功。
     */
    loadLayerGroup: function(layerGroup){
	    if (this.layerGroup == layerGroup) {
	        var msg = "不能重复加载图层组到地图中！";
	        OpenLayers.Console.warn(msg);
	        return false;
	    }
	    this.unloadLayerGroup();
	    layerGroup.setMap(this);
	    this.layerGroup = layerGroup;
	    
	    this.updateBaseLayer();
	    this.events.triggerEvent("loadlayergroup", {
	        layerGroup: layerGroup,
	        map: this
	    });
    },
    
    /**
     * APIMethod: unloadLayerGroup
     * 卸载图层组。
     */
    unloadLayerGroup: function(){
		var layerGroup = this.layerGroup;
        if (!layerGroup) {
			return false;
		}
		layerGroup.removeMap();
        this.layerGroup = null;

    },
	
    /**
     * Method: _getLastTopLayerPosition
     * 取最后一个置顶图层位置。
     */
    _getLastTopLayerPosition: function(){
        var layersNum = this.layers.length;
        var topIndex = layersNum - 1;
        for (var i = topIndex; i >= 0; i--) {
            var layer = this.layers[i];
            //if (layer.isOnTop && !layer.isBaseLayer) {
            //this.setLayerIndex(layer, topIndex--);
            //}
            if (!layer.isOnTop) {
                return i + 1;
            }
        }
    },
	
	/**
     * Method: insertLayerFirst
     * 插入所有图层的最顶层。
     */
    insertLayerFirst: function(layer){
        var idx = this.layers.length;
        this.insertLayerIndex(layer,idx);
    },
	
	/**
     * Method: insertLayerLast
     * 插入所有图层的最底层。
     */
    insertLayerLast: function(layer){
        var idx = 1;
        this.insertLayerIndex(layer,idx);
    },
	
	/**
     * Method: insertLayerIndex
     * 插入所有图层的索引位置。
     */
    insertLayerIndex: function(layer,idx){
        //强行将基础图层属性改为false
        layer.isBaseLayer = false;
        for (var i = 0, len = this.layers.length; i < len; i++) {
            if (this.layers[i] == layer) {
                var msg = OpenLayers.i18n('layerAlreadyAdded', {
                    'layerName': layer.name
                });
                OpenLayers.Console.warn(msg);
                return false;
            }
        }

        if (this.events.triggerEvent("preaddlayer", {layer: layer}) === false) {
            return;
        }

        layer.div.className = "olLayerDiv";
        layer.div.style.overflow = "";

        if (idx < 0) {
            idx = 1;//排除空基础图层
        } else if (idx > this.layers.length) {
            idx = this.layers.length;
        }

        //this.setLayerZIndex(layer, idx);
		
        if (layer.isFixed) {
            this.viewPortDiv.appendChild(layer.div);
        } else {
            this.layerContainerDiv.appendChild(layer.div);
        }
        
		//this.layers.push(layer);
        this.layers.splice(idx, 0, layer);
		//重新设置图层的ZIndex样式。
		this.resetLayersZIndex();

        layer.setMap(this);
        layer.redraw();

        this.events.triggerEvent("addlayer", {layer: layer});
		layer.events.triggerEvent("added", {map: this, layer: layer});
        layer.afterAdd();
    },
	
    /**
     * APIMethod: setRealCenter
     * 设置中心点。
     */
	setRealCenter: function(lonlat, zoom, dragging, forceZoomChange){
    	if (this.resolutions) {
	        var _resolution = this.pyramid.getResolutionForLevel(zoom);
	        var isbig = false;
	        for (var i = 0; i < this.resolutions.length; i++) {
	            if (_resolution * 1e5 == this.resolutions[i] * 1e5) {
	                zoom = i;
	                isbig = true;
	                break;
	            }
	            else 
	                if (_resolution * 1e5 < this.resolutions[i] * 1e5) {
	                    isbig = false;
	                }
	                else 
	                    if (_resolution * 1e5 > this.resolutions[i] * 1e5) {
	                        if (isbig == false) {
	                            if (i == 0) {
	                                zoom = i;
	                            }
	                            else {
	                                var prezoom = this.pyramid.getLevelForResolution(this.resolutions[i - 1]);
	                                var nextzoom = this.pyramid.getLevelForResolution(this.resolutions[i]);
	                                if ((nextzoom - zoom) < (zoom - prezoom)) {
	                                    zoom = i;
	                                }
	                                else {
	                                    zoom = i - 1;
	                                }
	                            }
	                            isbig = true;
	                            
	                            break;
	                        }
	                        
	                    }
	        }
	        if (isbig == false) {
	            zoom = i - 1
	        }
	        
	    }
	    else {
	        zoom = zoom - this.pyramid.getLevelForResolution(this.getLayersMaxResolution());
	    }
	    this.panTween && this.panTween.stop();
	    this.moveTo(lonlat, zoom, {
	        'dragging': dragging,
	        'forceZoomChange': forceZoomChange
	    });
	},
	
    /**
     * APIMethod: getRealZoom
     * 获取级别。
     */
	getRealZoom: function(){
	    if (this.resolutions) {
	        return this.pyramid.getLevelForResolution(this.resolutions[this.zoom]);
	    }
	    else {
	        return this.zoom + this.pyramid.getLevelForResolution(this.getLayersMaxResolution());
	    }
	},
	
    CLASS_NAME: "Geo.View2D.Map"
});/**
 * Class: Geo.View2D.Tile.TileFeature
 * Geo.View2D.Tile.TileFeature的实例是存放在图层中的矢量块。
 *
 * Inherits from:
 *  - <Geo.View2D.Tile>
 */
Geo.View2D.Tile.TileFeature = Geo.Class(Geo.View2D.Tile, {
	
    /** 
     * Constructor: Geo.View2D.Tile.TileFeature
     * 创建Geo.View2D.Tile.TileFeature对象实例。
     * 
     * Parameters:
     * layer - {<Geo.View2D.Layer.HotareaWMTS>} 热区WMTS图层。
     * position - {<Geo.Pixel>} 位置。
     * bounds - {<Geo.Bounds>} 范围。
     * url - {<String>} 请求路径，一般为null。
     * size - {<Geo.Size>} 尺寸大小。
     * options - {Object} 参数选项。
     */   
    initialize: function(layer, position, bounds, url, size, options){
        Geo.View2D.Tile.prototype.initialize.apply(this, arguments);
    },
    
    /**
     * Method: draw
     * Check that a tile should be drawn, and draw it.
     *
     * Returns:
     * {Boolean} Always returns true.
     */
    draw: function(){
        if (this.layer != this.layer.map.baseLayer && this.layer.reproject) {
            this.bounds = this.getBoundsFromBaseLayer(this.position);
        }
        var drawTile = Geo.View2D.Tile.prototype.draw.apply(this, arguments);
        
        return this.renderTile();
    },
    
    /** 
     * Method: renderTile
     * Show the tile.  To be implemented by subclasses.
     */
    renderTile: function(){
		
        this.url = this.layer.getURL(this.bounds);
        if (this.url == "") {
            return;
        }
        //alert(this.url);
        var isExist = false;
        for (var i = 0; i < this.layer.urls.length; i++) {
            if (this.layer.urls[i] == this.url) {
                isExist = true;
				
            }
        }
        
        if (!isExist) {
            this.layer.urls.push(this.url);
            
            var url = this.url;
            var params = {};
            var xhr = OpenLayers.Request.GET({
                url: url,
                params: params,
                scope: this,
                async: true, // true表示异步，false表示同步。
                success: function(result){
                    var geojsonStr = result.responseText;
                    if (geojsonStr == "" || geojsonStr == null) {
                        return;
                    }
                    //this.layer.vectorLayer.destroyFeatures();
                    if (this.layer && this.layer.vectorLayer) {
                        var geojsonFormat = new OpenLayers.Format.GeoJSON();
                        var features = geojsonFormat.read(geojsonStr);
                        var style = {
                            fillColor: "#ee9900",
                            fillOpacity: 0,
                            strokeColor: "#ee9900",//"#d9534f",//"#66FF66",
                            strokeOpacity: 0,
                            cursor: "pointer"
                        }
						var pointFeatures = [];
                        for (var i = 0; i < features.length; i++) {
                            features[i].style = style;
							
							features[i].attributes.type = features[i].data.type = "polygon";
							var displayname = features[i].attributes.displayname;
							var descriptionname = features[i].attributes.descriptionname;
							
							//创建点要素
							var lon = features[i].attributes.x;
							var lat = features[i].attributes.y;
		                    var p = new Geo.Geometry.Point(lon, lat);
							var picsymid = features[i].attributes.picsymid;
                            var f = new Geo.Feature.Vector(p, {
                                type: "point",
								relatedid: features[i].id,
                                picsymid: picsymid,
								displayname: displayname,
								descriptionname: descriptionname,
                                overPicUrl: this.layer.getPicURL(picsymid, true),
                                outPicUrl: this.layer.getPicURL(picsymid, false)
                            });
							
							//http://192.168.42.159:9010/MAP501/wmts?SERVICE=WMTS&VERSION=1.0.0&REQUEST=GetIcon&LAYER=kloo_hotarea&PICID=0&ISANTI=true
							//var imgPath = "http://" +  Cfg.host  +  "/" + Cfg.projectName + "/JsCodeDemo/js/images/common/" + i + ".png";
							features[i].attributes.relatedid = features[i].data.relatedid = f.id;
							
							
							var picUrl = this.layer.getPicURL(picsymid, false);
							var img = new Image();
							img.src = picUrl;
							var gw = img.width;
							var gh = img.height;
		                    f.style = {
		                        externalGraphic: picUrl,
				                graphicWidth: gw,
				                graphicHeight: gh,
				                graphicXOffset: parseInt(-gw/2),
				                graphicYOffset: parseInt(-gh/2),
								cursor: "pointer"
		                    };
		                    pointFeatures.push(f);
                        }
                        
                        this.layer.vectorLayer.addFeatures(features);
                        this.layer.vectorLayer.addFeatures(pointFeatures);
                    }
                },
                failure: function(result){
					//OpenLayers.Util.removeItem(this.layer.urls, this.url);
                    //alert("failure");
                }
            });
        }
        
    },
    
    moveTo: function(bounds, position, redraw){
        if (redraw == null) {
            redraw = true;
        }
        
        this.bounds = bounds.clone();
        this.position = position.clone();
        if (redraw) {
            this.draw();
        }
    },
	
    CLASS_NAME: "Geo.View2D.Tile.TileFeature"
});

/**
 * Class: Geo.View2D.Layer.GlobeTile
 * GeoGlobe瓦片图层类，继承自Geo.View2D.Layer.Grid类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Layer.Grid>
 */
Geo.View2D.Layer.GlobeTile = Geo.Class(Geo.View2D.Layer.Grid,{

	/**
	 * APIProperty: alwaysInRange
	 * {Boolean} 强制在任意分辨率下显示图层，默认false。
	 */
	alwaysInRange: false,
	
	/**
     * APIProperty: isBaseLayer
     * {Boolean} 是否基础层，默认为false。
     */
	isBaseLayer:false,
	
	/**
     * APIProperty: topLevel
     * {Integer} 图层顶层级别。
     */
	topLevel: null,
	
	/**
     * APIProperty: bottomLevel
     * {Integer} 图层底层级别。
     */
	bottomLevel: null,
	
	/**
     * APIProperty: pyramid
     * {<Geo.Pyramid>} 地图金字塔。
     */
	pyramid : null,
	
	/**
     * APIProperty: accessUrl
     * {String} 服务访问地址。
     */
	accessUrl : null,
	
	/**
     * APIProperty: mirrorUrl
     * {Array} 服务镜像地址。可以为一个服务设置多个地址，解决浏览器图片链接数限制问题。
     */
	mirrorUrl : null,
	
	/**
     * APIProperty: serviceName
     * {String} 服务访问名称。
     */
	serviceName : null,
	
	/**
     * APIProperty: verstionTime
     * {String} 时间版本。
     */
	verstionTime: "9999-01-01 00:00:00",
	
	/**
     * APIProperty: cacheExpireTime
     * {String} 缓存过期时间。
     */
	cacheExpireTime : "now",

	/**
     * APIProperty: buffer
     * {String} 瓦片缓存大小。
     */
	buffer:0,
	
	/**
     * APIProperty: transitionEffect
     * {String} 平滑缩放效果。
     */
	transitionEffect: null,
	
	/**
     * Constructor: Geo.View2D.Layer.GlobeTile
     * 创建GeoGlobe瓦片图层对象实例。
     *
     * Parameters:
     * name - {String} GeoGlobe瓦片图层名称。
     * url - {String} 瓦片服务地址。
     * options - {Object} 对象构造参数。
     * 
     * 示例:
     * (code)
     * new Geo.View2D.Layer.GlobeTile("天地图矢量注记", "http://tile0.tianditu.com/services/AB0512_Anno", {
     *      topLevel: 2,
     *      bottomLevel: 12,
     *      maxExtent: new Geo.Bounds(-180, -90, 180, 90)
     * })
     * (end)
     */
	initialize : function(name, url, options){
		
		this.name = name;
		this.url = url;
		this.convertUrl(this.url);
		
		//初始化图层的金字塔和顶层底层级别，如果无金字塔指定，则默认为360度金字塔
		if(!options){
			options = {};
		};
		options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		options.topLevel = options.topLevel ? options.topLevel : options.pyramid.topLevelIndex;
		options.bottomLevel = options.bottomLevel ? options.bottomLevel : options.pyramid.bottomLevelIndex;		
		
		//初始化图层的最大最小分辨率
		var maxRes = options.pyramid.getMaxResolution();
		options.maxResolution = options.pyramid.getResolutionForLevel(options.topLevel);
		options.minResolution = options.pyramid.getResolutionForLevel(options.bottomLevel);
		
		options.tileSize = options.pyramid.tileSize;
		
		var para = null;		
		var newArguments = [name, url, para, options];
		Geo.View2D.Layer.Grid.prototype.initialize.apply(this, newArguments);
		
	},
	
	/**
     * APIMethod: convertUrl
     * 将服务地址转换成实际瓦片图片访问地址。
	 * 
	 * Paramters:
	 * url - {String} 服务地址。
     */
	convertUrl: function(url){
		var tmpUrl = url.split("/services/");
		if (tmpUrl[0] && tmpUrl[1]) {
			this.accessUrl = tmpUrl[0] + "/DataServer";
			this.serviceName = tmpUrl[1];
		} else {
			OpenLayers.Console.error("解析GeoGlobe 2.0.0服务地址错误:" + url);
			return;
		}
	},
	
	/**
     * APIMethod: addTile
     * 添加瓦片。
     * 
     * Paramters:
	 * bounds - {<Geo.Bounds>}
	 * position - {<Geo.Pixel>}
	 * 
	 * Returns:
     * {<Geo.View2D.Tile.Image>} 瓦片图片。
     */
	addTile: function(bounds, position) {
		return new Geo.View2D.Tile.Image(this, position, bounds,
                                             null, this.tileSize);
    },
 
	/**
     * APIMethod: setVerstionTime
     * 设置历史版本,设置版本后会重新绘制本图层。
     * 
     * Paramters:
	 * verstion - {String} 历史版本号,格式为"2010-06-23 18:48:23"。
     */
    setVerstionTime: function(verstion){
    	if(verstion){
    		this.verstionTime = verstion;
    		this.redraw();
    	}
    },
	
	/**
     * APIMethod: getURL
     * 获取瓦片图片地址。
     * 
     * Paramters:
	 * bounds - {<Geo.Bounds>}
	 * 
	 * Returns:
     * {String} 瓦片图片地址。
     */
	getURL: function(bounds) {
	
		var blankUrl = OpenLayers.Util.getImagesLocation() + "blank.gif";		
		bounds = this.adjustBounds(bounds);	
		var pyramidMaxResolution = this.pyramid.getMaxResolution();
		
		var deg,level,x,y;
		level = this.pyramid.getLevelForResolution(this.map.getResolution());
        deg = this.pyramid.getTopTileSize().w / Math.pow(2,level);
        
		
		//判断原点
		//宽度为正，说明X轴向从左到右
		if(this.pyramid.topTileFromX < this.pyramid.topTileToX){
			x = Math.round((bounds.left - this.pyramid.topTileFromX)/deg);
		} else {
			x = Math.round((this.pyramid.topTileFromX - bounds.right)/deg);
		}
		//高度为正，说明Y轴向从下到上
		if (this.pyramid.topTileFromY < this.pyramid.topTileToY){
			y = Math.round((bounds.bottom - this.pyramid.topTileFromY)/deg);
		} else{
			y = Math.round((this.pyramid.topTileFromY - bounds.top)/deg);
		}	
		if (x < 0 || y < 0){
			  return OpenLayers.Util.getImagesLocation() + "blank.gif";
		}
		
		// 加入服务镜像地址处理，如果图层mirrorUrl不为空，则调用HTTPRequest父类的selectUrl方法
		// 从镜像地址数组取一条url
		var accessUrl = "";
		var urlPara = {};
		if(this.mirrorUrl == null){
			accessUrl = this.accessUrl;
			urlPara = {
				"T": this.serviceName,
				"X": x,
				"Y": y,
				"L": level,
				"INDATE": this.verstionTime
			}			
		} else {			
			accessUrl = this.selectUrl(x, this.mirrorUrl); 
			var tmpUrl = accessUrl.split("/services/");
			if (tmpUrl[0] && tmpUrl[1]) {
				accessUrl = tmpUrl[0] + "/DataServer";				
				urlPara = {
					"T": tmpUrl[1],
					"X": x,
					"Y": y,
					"L": level,
					"INDATE": this.verstionTime
				}
			} 
		}
		accessUrl = this.getFullRequestString(urlPara, accessUrl);
		//document.getElementById("output").innerHTML += accessUrl + " , " + bounds.toBBOX() + " " + this.calculateInRange() +" <br>";
		return accessUrl;
		
	},
	
	/**
     * APIMethod: selectUrl
     * 镜像地址分布方法,行号(x)与镜像地址数量取余数。
     * 
     * Parameters:
     * factor - {Integer}
     * urls - {Array(String)}
     * 
     * Returns:
     * {String} 选择地址。
     */
	selectUrl:function(factor, urls){
		var len = urls.length;
		var remainder = factor % len;
		return urls[remainder];
		
	},
	
	/**
     * APIMethod: getDataExtent
     * 获取获取图层范围。
     * 
     * Returns:
     * {<Geo.Bounds>}图层范围。
     */
	getDataExtent: function () {
        if (this.maxExtent){
			return this.maxExtent.clone();
		}
    },
	
	/**
     * APIMethod: clone
     * 复制图层对象。
     * 
     * Returns:
     * {<Geo.View2D.Layer.GlobeTile>} 被克隆的图层对象。
     */
    clone : function(obj){
		if (obj == null) {
			obj = new Geo.View2D.Layer.GlobeTile(this.name,
                                       this.url,
                                       this.options);
		}
	 	obj = Geo.View2D.Layer.Grid.prototype.clone.apply(this, [obj]);
	 	return obj;
	},	
	
	CLASS_NAME: "Geo.View2D.Layer.GlobeTile"
});

/**
 * Class: Geo.View2D.Layer.CWMS
 * CWMS图层类，继承自Geo.View2D.Layer.Grid类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Layer.Grid>
 */
Geo.View2D.Layer.CWMS = Geo.Class(Geo.View2D.Layer.Grid,{
	
	/**
	 * APIProperty: layerId
	 * {String} 图层的唯一编号。
	 */
	layerId : null,
	
	/**
	 * APIProperty: mapStyleId
	 * {String}当前请求图层样式的唯一编号。
	 */
	mapStyleId : null,
	
	/**
	 * APIProperty: srid
	 * {String}图层的参考坐标系id。
	 * 
	 */
	srid : null,
	
	/**
	 * APIProperty: sourceDate
	 * {Date}数据的最后更新日期。
	 */
	sourceDate : null,
	
	/**
	 * APIProperty: formatSuffix
	 * {String}输出图片格式。
	 */
	formatSuffix : null,
	
	/**
     * APIProperty: buffer
     * {String} 瓦片缓存大小。
     */
	buffer : 0,
	
	/**
     * Constructor: Geo.Service.CWMS
     * Geo.Service.CWMS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *    layerId - {String}图层Id 必填。
     *    mapstyleId - {String}当前请求图层样式的唯一编号 必填。
     *    srid -{String} 图层的参考坐标系 必填。
     *    sourceDate - {Date}据的最后更新日期 必填。
     *    formatSuffix - {String}输出图片格式 可选（默认值是png）。
     *    scales | resolutions - {Array} 比例尺或级别 必填。
     *    maxExtent - {<Geo.Bounds>} 图层的最大范围 必填。
     *  
     *  例子:
     *  (code)
     *  var cwmsLayer1 = new Geo.View2D.Layer.CWMS("cwms1","http://10.4.6.52:7001/CWMS1",{
	 *				layerId:"GeoGlobeMap_1",
	 *				mapStyleId:"GISP:1",
	 *				srid:"EPSG:4326",
	 *				sourceDate:myDate,
	 *				formatSuffix:"png",
	 *				scales:[4622333.678977588,2311166.839488794,1155583.419744397,577791.7098721985,288895.85493609926
	 *				,144447.92746804963,72223.96373402482,36111.98186701241],
	 *				maxExtent :Geo.Bounds.fromString("70.3125,5.625,146.25,56.25")
	 *			
	 *		});
     *  (end)
     */
	initialize: function(name, url, options){
		this.mapStyleId = options.mapStyleId;
		this.srid = options.srid;
		this.sourceDate = options.sourceDate;
		this.formatSuffix = options.formatSuffix || "png" ;
		var para = null;		
		var newArguments = [name, url, para, options];
		Geo.View2D.Layer.Grid.prototype.initialize.apply(this, newArguments);
	},
	
	/**
     * Method: addTile
     * addTile creates a tile, initializes it, and adds it to the layer div. 
     * 
     * Parameters:
     * bounds - {<Geo.Bounds>}
     * position - {<Geo.Pixel>}
     * 
     * Returns:
     * {<Geo.View2D.Tile.Image>} The added Geo.View2D.Tile.Image
     */
    addTile: function(bounds,position) {
        return new Geo.View2D.Tile.Image(this, position, bounds, 
                                         null, this.tileSize);
    },
	
	/**
     * APIMethod: getURL
     * 获取瓦片图片地址。
     * 
     * Paramters:
	 * bounds - {<Geo.Bounds>} 瓦片的范围。
	 * 
	 * Returns:
     * {String} 瓦片图片地址。
     */
	getURL: function(bounds) {
		bounds = this.adjustBounds(bounds);
        var res = this.map.getResolution();
		var fx = (bounds.left - this.map.maxExtent.left) / (res * this.tileSize.w);
		var fy = (this.map.maxExtent.top - bounds.top) / (res * this.tileSize.h);

        var col = Math.floor(fx);
        var row = Math.floor(fy);
		var cwms = new Geo.Service.CWMS(
			this.name,
			this.url
		);
		var currentRes = this.map.getResolution();
		var level = this.map.pyramid.getLevelForResolution(currentRes);
		
		var url = cwms.getMap({
			layerId : this.layerId,
			mapStyleId : this.mapStyleId,
			srid : this.srid,
			sourceDate : this.sourceDate,
			level : level,
			col : col,
			row : row,
			formatSuffix : this.formatSuffix
		});
		
		return url;
	},	
	
	CLASS_NAME: "Geo.View2D.Layer.CWMS"
});/**
 * Class: Geo.View2D.Layer.GeoWMTS
 * 吉奥多时相wmts类，继承自Geo.View2D.Layer.WMTS类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Layer.WMTS>
 */
Geo.View2D.Layer.GeoWMTS = Geo.Class(Geo.View2D.Layer.WMTS, {
	
	/**
     * APIProperty: pyramid
     * {<Geo.Pyramid>} 地图金字塔。
     */
	pyramid : null,
	
	/**
     * APIProperty: time
     * {String} 时间版本。
     *  声明：time的值只能通过setVerstionTime方法才能改变。
     */
	time: "9999-01-01 00:00:00",
	
	/**
	 * APIProperty: userecent
	 * 为FALSE时只有存在指定时相的瓦片数据时，才返回瓦片数据，
	 * 否则返回提示。为TRUE时，只要存在不晚于指定时相的瓦片数据时，
	 * 返回其中最新的瓦片数据。默认为true。
	 */
	userecent: true,
	
	/**
     * Constructor: Geo.View2D.Layer.GeoWMTS
     * 创建GeoWMTS图层对象实例。
     *
     * Parameters:
     * name - {String} GeoGlobe瓦片图层名称。
     * url - {String} 瓦片服务地址。
     * options - {Object} 对象构造参数。
     * 
     * 示例:
     * (code)
     * 
     * (end)
     */
	initialize : function(options) {
		var params = {};
		if(options.params) {//支持老结构
			if(options.params.time) {
				this.time = options.params.time;
			}
			if(typeof options.params.userecent === "boolean") {
				this.userecent = options.params.userecent;
			}
		}else {//支持新结构
			if(options.time) {
				params.time = options.time;
				this.time = options.time;
			}
			if(typeof options.userecent === "boolean") {
				params.userecent = options.userecent;
				this.userecent = options.userecent;
			}
			options.params = params;
		}
		options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		Geo.View2D.Layer.WMTS.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: setVerstionTime
     * 设置历史版本,设置版本后会重新绘制本图层。
     * 
     * Paramters:
	 * verstion - {<String>} 历史版本号,格式为"2010-06-23 18:48:23"。
     */
    setVerstionTime: function(verstion){
    	if(verstion){
    		this.params.TIME = verstion;
			this.time = verstion;
    		this.redraw();
    	}
    },
	
	/**
     * APIMethod: setParams
     *  设置多时相相关参数。
     * 
     * Paramters:
	 *  params:
	 *   time - {String}时间版本。
	 *   userecent - {Boolean} 
	 *   为FALSE时只有存在指定时相的瓦片数据时，才返回瓦片数据，
	 *   否则返回提示。为TRUE时，只要存在不晚于指定时相的瓦片数据时，
	 *   返回其中最新的瓦片数据。默认为true。
     */
	setParams: function(params) {
		if(params.time) {
			this.params.TIME = params.time;
			this.time = params.time;
			var userecent = typeof params.userecent == "boolean" ? params.userecent : true;
			this.params.USERECENT = userecent;
			this.userecent = userecent;
			this.redraw();
		}
	},
	
    /** 
     * Method: getTileInfo
     * Get tile information for a given location at the current map resolution.
     *
     * Parameters:
     * loc - {<OpenLayers.LonLat} A location in map coordinates.
     *
     * Returns:
     * {Object} An object with "col", "row", "i", and "j" properties.  The col
     *     and row values are zero based tile indexes from the top left.  The
     *     i and j values are the number of pixels to the left and top 
     *     (respectively) of the given location within the target tile.
     */
    getTileInfo: function(lonlat) {
		var level = this.pyramid.getLevelForResolution(this.map.getResolution());
		var lon = lonlat.lon;
		var lat = lonlat.lat;
		var size = this.pyramid.getTopTileSize()
		var degree = size.w / Math.pow(2,level);
		
		//金字塔宽高
		var width = this.pyramid.maxExtent.getWidth();
		var height = this.pyramid.maxExtent.getHeight();
		
		//总行列数
		var totalCol = Math.round(width / degree);
		var totalRow = Math.round(height / degree);
		
		//计算列索引号
		var isStartLeft = (this.pyramid.topTileFromX < this.pyramid.topTileToX) ? true : false;
		var colIndex = Math.ceil(Math.abs(lon - this.pyramid.topTileFromX)/degree) - 1;
		if(!isStartLeft){
			colIndex = totalCol - colIndex;
		}
		
		var isStartTop = (this.pyramid.topTileFromY > this.pyramid.topTileToY) ? true : false;
		var rowIndex = Math.ceil(Math.abs(lat - this.pyramid.topTileFromY)/degree) - 1;
		if (!isStartTop){
			rowIndex = totalRow - rowIndex;
		}
		
		return {
			col: colIndex,
			row: rowIndex
		}
    },
	
	/**
     * APIMethod: clone
     * 复制图层对象。
     * 
     * Returns:
     * {<Geo.View2D.Layer.GlobeTile>} 被克隆的图层对象。
     */
    clone : function(obj){
		if (obj == null) {
			obj = new Geo.View2D.Layer.GeoWMTS(this.options);
		}
	 	obj = Geo.View2D.Layer.WMTS.prototype.clone.apply(this, [obj]);
	 	return obj;
	},	
	
	CLASS_NAME: "Geo.View2D.Layer.GeoWMTS"
});/**
 * Class: Geo.View2D.Layer.ArcGISTileLayer
 *	 ArcGIS瓦片图层是用于加载ArcGIS地图瓦片服务的图层。
 *	 本图层支持等比分辨率的地图瓦片服务或非等比分辨率的地图瓦片服务的加载。
 */ 
Geo.View2D.Layer.ArcGISTileLayer = Geo.Class(Geo.View2D.Layer.XYZ, {  

    /**
     * APIProperty: url
     * {String} ArcGIS地图瓦片服务地址
     */
    url: null,
	
	/**
     * Property: useArcGISServer
     * {String | Array} 
     */
	useArcGISServer:true,
    
   /**
    * Constructor: Geo.View2D.Layer.ArcGISTileLayer
    * 
    * Parameters: 
    * name - {String} 图层名称
    * url - {String} arcgis地图瓦片服务地址
    * 
    * 示例:
    * (code)
    * 	var arcgisTileLayer = new Geo.View2D.Layer.ArcGISTileLayer("arc", "http://192.168.32.64/ArcGIS/rest/services/2dmap/MapServer");
    * (end)
    */ 
    initialize: function(name, url, options) {
        OpenLayers.Layer.XYZ.prototype.initialize.apply(this, arguments);

        if (this.resolutions) {        
            this.serverResolutions = this.resolutions;
            this.maxExtent = this.getMaxExtentForResolution(this.resolutions[0]);
        }
		this.jsonp = new OpenLayers.Protocol.Script();
		this.jsonp.createRequest(url, {
            f: 'json',
            pretty: 'true'
        }, OpenLayers.Function.bind(this._loadTiles,this));
    }, 
	
	/** 
    * Method: _loadTiles
    * 访问服务能力描述信息的回调函数
    */
	_loadTiles: function(layerInfo) {
	        if (layerInfo) {
          
            var info = layerInfo;
            
            // build our extents
            var startingTileExtent = new OpenLayers.Bounds(
                info.fullExtent.xmin, 
                info.fullExtent.ymin, 
                info.fullExtent.xmax, 
                info.fullExtent.ymax  
            );

           
            this.projection = 'EPSG:' + info.spatialReference.wkid;
            this.sphericalMercator = (info.spatialReference.wkid == 102100);
            
            // convert esri units into openlayers units (basic feet or meters only)
            this.units = (info.units == "esriFeet") ? 'dd' : 'm';

            // optional extended section based on whether or not the server returned
            // specific tile information
            if (!!info.tileInfo) {            
                // either set the tiles based on rows/columns, or specific width/height
                this.tileSize = new OpenLayers.Size(
                    info.tileInfo.width || info.tileInfo.cols, 
                    info.tileInfo.height || info.tileInfo.rows
                );
                
                // this must be set when manually configuring this layer
                this.tileOrigin = new OpenLayers.LonLat(
                    info.tileInfo.origin.x, 
                    info.tileInfo.origin.y
                );

                var upperLeft = new OpenLayers.Geometry.Point(
                    startingTileExtent.left, 
                    startingTileExtent.top
                );
                
                var bottomRight = new OpenLayers.Geometry.Point(
                    startingTileExtent.right, 
                    startingTileExtent.bottom
                );            
                
                if (this.useScales) {
                    this.scales = [];
                } else {
                    this.resolutions = [];
                }
                
                this.lods = [];
                for(var key in info.tileInfo.lods) {
                    if (info.tileInfo.lods.hasOwnProperty(key)) {
                        var lod = info.tileInfo.lods[key];
                        if (this.useScales) {
                            this.scales.push(lod.scale);
                        } else {
                            this.resolutions.push(lod.resolution);
                        }
                    
                        var start = this.getContainingTileCoords(upperLeft, lod.resolution);
                        lod.startTileCol = start.x;
                        lod.startTileRow = start.y;
                    
                        var end = this.getContainingTileCoords(bottomRight, lod.resolution);
                        lod.endTileCol = end.x;
                        lod.endTileRow = end.y;    
                        this.lods.push(lod);
                    }
                }
				
                this.maxExtent = this.calculateMaxExtentWithLOD(this.lods[0]);

                this.serverResolutions = this.resolutions;
				
                if (this.overrideDPI && info.tileInfo.dpi) {
                    // see comment above for 'overrideDPI'
                    OpenLayers.DOTS_PER_INCH = info.tileInfo.dpi;
                }
            } 
       }
		
	},

	/** 
    * APIMethod: setMap
    * 添加图层到地图。
    */
	setMap: function() {
		OpenLayers.Layer.XYZ.prototype.setMap.apply(this, arguments);
		var that = this;
//		this.map.events.register("zoomend", this, function() {
//			
//			that.maxExtent = this.calculateMaxExtentWithLOD(that.lods[that.map.getZoom()]);
//		});
	},

   /** 
    * Method: getContainingTileCoords
    * Calculates the x/y pixel corresponding to the position of the tile
    *     that contains the given point and for the for the given resolution.
    * 
    * Parameters:
    * point - {<OpenLayers.Geometry.Point>} 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<OpenLayers.Pixel>} The x/y pixel corresponding to the position 
    * of the upper left tile for the given resolution.
    */
    getContainingTileCoords: function(point, res) {
        return new OpenLayers.Pixel(
           Math.max(Math.floor((point.x - this.tileOrigin.lon) / (this.tileSize.w * res)),0),
           Math.max(Math.floor((this.tileOrigin.lat - point.y) / (this.tileSize.h * res)),0)
        );
    },
    
   /** 
    * Method: calculateMaxExtentWithLOD
    * Given a Level of Detail object from the server, this function
    *     calculates the actual max extent
    * 
    * Parameters: 
    * lod - {Object} a Level of Detail Object from the server capabilities object 
            representing a particular zoom level
    * 
    * Returns: 
    * {<OpenLayers.Bounds>} The actual extent of the tiles for the given zoom level
    */
   calculateMaxExtentWithLOD: function(lod) {

        var numTileCols = (lod.endTileCol - lod.startTileCol) + 1;
        var numTileRows = (lod.endTileRow - lod.startTileRow) + 1;        

        var minX = this.tileOrigin.lon + (lod.startTileCol * this.tileSize.w * lod.resolution);
        var maxX = minX + (numTileCols * this.tileSize.w * lod.resolution);

        var maxY = this.tileOrigin.lat - (lod.startTileRow * this.tileSize.h * lod.resolution);
        var minY = maxY - (numTileRows * this.tileSize.h * lod.resolution);
        return new OpenLayers.Bounds(minX, minY, maxX, maxY);
   },
    
   /** 
    * Method: calculateMaxExtentWithExtent
    * 
    * Parameters: 
    * extent - {<OpenLayers.Bounds>} The 'suggested' extent for the layer
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<OpenLayers.Bounds>} The actual extent of the tiles for the given zoom level
    */
   calculateMaxExtentWithExtent: function(extent, res) {
        var upperLeft = new OpenLayers.Geometry.Point(extent.left, extent.top);
        var bottomRight = new OpenLayers.Geometry.Point(extent.right, extent.bottom);
        var start = this.getContainingTileCoords(upperLeft, res);
        var end = this.getContainingTileCoords(bottomRight, res);
        var lod = {
            resolution: res,
            startTileCol: start.x,
            startTileRow: start.y,
            endTileCol: end.x,
            endTileRow: end.y
        };
        return this.calculateMaxExtentWithLOD(lod);
   },
    
    /** 
    * Method: getUpperLeftTileCoord
    * 
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<OpenLayers.Pixel>} The x/y pixel corresponding to the position 
    * of the upper left tile for the given resolution.
    */
    getUpperLeftTileCoord: function(res) {
        var upperLeft = new OpenLayers.Geometry.Point(
            this.maxExtent.left,
            this.maxExtent.top);
        return this.getContainingTileCoords(upperLeft, res);
    },

    /** 
    * Method: getLowerRightTileCoord
    *  
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<OpenLayers.Pixel>} The x/y pixel corresponding to the position
    * of the lower right tile for the given resolution.
    */
    getLowerRightTileCoord: function(res) {
        var bottomRight = new OpenLayers.Geometry.Point(
            this.maxExtent.right,
            this.maxExtent.bottom);
        return this.getContainingTileCoords(bottomRight, res);
    },
    
   /** 
    * Method: getMaxExtentForResolution
    * Since the max extent of a set of tiles can change from zoom level
    *     to zoom level, we need to be able to calculate that max extent 
    *     for a given resolution.
    *
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<OpenLayers.Bounds>} The extent for this resolution
    */ 
    getMaxExtentForResolution: function(res) {
        var start = this.getUpperLeftTileCoord(res);
        var end = this.getLowerRightTileCoord(res);

        var numTileCols = (end.x - start.x) + 1;
        var numTileRows = (end.y - start.y) + 1;

        var minX = this.tileOrigin.lon + (start.x * this.tileSize.w * res);
        var maxX = minX + (numTileCols * this.tileSize.w * res);
        
        var maxY = this.tileOrigin.lat - (start.y * this.tileSize.h * res);
        var minY = maxY - (numTileRows * this.tileSize.h * res);
        return new OpenLayers.Bounds(minX, minY, maxX, maxY);
    },
    
   /** 
    * APIMethod: clone 
    * 克隆本图层
    * 
    * Parameters: 
    * [obj] - {Object} 本图层对象的一个实例
    *  
    * Returns: 
    * {<Geo.View2D.Layer.ArcGISTileLayer>} 克隆对象
    */ 
    clone: function (obj) { 
        if (obj == null) { 
            obj = new Geo.View2D.Layer.ArcGISTileLayer(this.name, this.url, this.options);
        }
        return OpenLayers.Layer.XYZ.prototype.clone.apply(this, [obj]);
    },

    /**
     * Method: getMaxExtent
     * Get this layer's maximum extent.
     *
     * Returns:
     * {OpenLayers.Bounds}
     */
    getMaxExtent: function() {
        var resolution = this.map.getResolution();
        return this.maxExtent;// = this.getMaxExtentForResolution(resolution);
    },

    /**
     * Method: getTileOrigin
     * Determine the origin for aligning the grid of tiles.  
     *     The origin will be derived from the layer's <maxExtent> property. 
     *
     * Returns:
     * {<OpenLayers.LonLat>} The tile origin.
     */
    getTileOrigin: function() {
        var extent = this.getMaxExtent();
        return new OpenLayers.LonLat(extent.left, extent.bottom);
    },

   /**
    * Method: getURL
    * Determine the URL for a tile given the tile bounds.  This is should support
    *     urls that access tiles through an ArcGIS Server MapServer or directly through
    *     the hex folder structure using HTTP.  Just be sure to set the useArcGISServer
    *     property appropriately!  This is basically the same as 
    *     'OpenLayers.Layer.TMS.getURL',  but with the addition of hex addressing,
    *     and tile rounding.
    *
    * Parameters:
    * bounds - {<OpenLayers.Bounds>}
    *
    * Returns:
    * {String} The URL for a tile based on given bounds.
    */
    getURL: function (bounds) {
        var res = this.getResolution(); 

        // tile center
        var originTileX = (this.tileOrigin.lon + (res * this.tileSize.w/2)); 
        var originTileY = (this.tileOrigin.lat - (res * this.tileSize.h/2));

        var center = bounds.getCenterLonLat();
        var point = { x: center.lon, y: center.lat };
        var x = (Math.round(Math.abs((center.lon - originTileX) / (res * this.tileSize.w)))); 
        var y = (Math.round(Math.abs((originTileY - center.lat) / (res * this.tileSize.h)))); 
        var z = this.map.getZoom();

        // this prevents us from getting pink tiles (non-existant tiles)
        if (this.lods) {        
            var lod = this.lods[this.map.getZoom()];
            if ((x < lod.startTileCol || x > lod.endTileCol) 
                || (y < lod.startTileRow || y > lod.endTileRow)) {
                    return null;
            }
        }
        else {
            var start = this.getUpperLeftTileCoord(res);
            var end = this.getLowerRightTileCoord(res);
            if ((x < start.x || x >= end.x)
                || (y < start.y || y >= end.y)) {
                    return null;
            }        
        }

        // Construct the url string
        var url = this.url;
        var s = '' + x + y + z;

        if (OpenLayers.Util.isArray(url)) {
            url = this.selectUrl(s, url);
        }
		
        // Accessing tiles through ArcGIS Server uses a different path
        // structure than direct access via the folder structure.
        if (this.useArcGISServer) {
            // AGS MapServers have pretty url access to tiles
            url = url + '/tile/${z}/${y}/${x}';
        } else {
            // The tile images are stored using hex values on disk.
            x = 'C' + this.zeroPad(x, 8, 16);
            y = 'R' + this.zeroPad(y, 8, 16);
            z = 'L' + this.zeroPad(z, 2, 16);
            url = url + '/${z}/${y}/${x}.' + this.type;
        }

        // Write the values into our formatted url
        url = OpenLayers.String.format(url, {'x': x, 'y': y, 'z': z});

        return url;
    },

    /**
     * Method: zeroPad
     * Create a zero padded string optionally with a radix for casting numbers.
     *
     * Parameters:
     * num - {Number} The number to be zero padded.
     * len - {Number} The length of the string to be returned.
     * radix - {Number} An integer between 2 and 36 specifying the base to use
     *     for representing numeric values.
     */
    zeroPad: function(num, len, radix) {
		
        var str = num.toString(radix || 10);
        while (str.length < len) {
            str = "0" + str;
        }
        return str;
    },

    CLASS_NAME: 'Geo.View2D.Layer.ArcGISTileLayer' 
}); /**
 * Copyright (C) 2013 OSM Buildings, Jan Marsch
 * A leightweight JavaScript library for visualizing 3D building geometry on interactive maps.
 * @osmbuildings, http://osmbuildings.org
 */

var OSMBuildings = (function() {

    'use strict';



// object access shortcuts  ;  Int32Array:8位有符号整数
var Int32Array = Int32Array || Array,
	//Uint8Array:8位无符号整数
    Uint8Array = Uint8Array || Array,
    m = Math,
    exp = m.exp,
    log = m.log,
    sin = m.sin,
    cos = m.cos,
    tan = m.tan,
    atan = m.atan,
    min = m.min,
    max = m.max,
    ceil = m.ceil,
    floor = m.floor,
    doc = document;





var Color = (function() {

    function hsla2rgb(hsla) { // h belongs to [0, 360]; s,l,a belong to [0, 1]
        var r, g, b;

        if (hsla.s === 0) {
            r = g = b = hsla.l; // achromatic
        } else {
            var q = hsla.l < 0.5 ? hsla.l * (1+hsla.s) : hsla.l + hsla.s - hsla.l * hsla.s,
                p = 2 * hsla.l-q;
            hsla.h /= 360;
            r = hue2rgb(p, q, hsla.h + 1/3);
            g = hue2rgb(p, q, hsla.h);
            b = hue2rgb(p, q, hsla.h - 1/3);
        }
        return new Color(
            r * 255 <<0,
            g * 255 <<0,
            b * 255 <<0,
            hsla.a
        );
    }

    function hue2rgb(p, q, t) {
        if (t < 0) {
            t += 1;
        }
        if (t > 1) {
            t -= 1;
        }
        if (t < 1 / 6) {
            return p + (q-p) * 6 * t;
        }
        if (t < 1 / 2) {
            return q;
        }
        if (t < 2 / 3) {
            return p + (q-p) * (2/3 - t) * 6;
        }
        return p;
    }

    function Color(r, g, b, a) { // r,g,b belong to [0, 255]; a belongs to [0,1]
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = arguments.length < 4 ? 1 : a;
    }

    var proto = Color.prototype;

    proto.toString = function() {
//        if (this.a === 1) {
//            return '#' + ((1 << 24) + (this.r << 16) + (this.g << 8) + this.b).toString(16).slice(1, 7);
//        }
        return 'rgba(' + [this.r <<0, this.g <<0, this.b <<0, this.a.toFixed(2)].join(',') + ')';
    };

    proto.setLightness = function(l) {
        var hsla = Color.toHSLA(this);
        hsla.l *= l;
        hsla.l = Math.min(1, Math.max(0, hsla.l));
        return hsla2rgb(hsla);
    };

    proto.setAlpha = function(a) {
        return new Color(this.r, this.g, this.b, this.a * a);
    };

    /*
     * str can be in any of the following forms:
     * "#[00-ff][00-ff][00-ff]", "#[00-ff][00-ff][00-ff][00-ff]",
     * "rgb([0-255],[0-255],[0-255])", "rgba([0-255],[0-255],[0-255],[0-1])",
     * "hsl([0-360],[0-1],[0-1])", "hsla([0-360],[0-1],[0-1],[0-1])"
     */
    Color.parse = function(str) {
        var m;
        str += '';
        if (~str.indexOf('#') && (m = str.match(/^#?(\w{2})(\w{2})(\w{2})(\w{2})?$/))) {
            return new Color(
                parseInt(m[1], 16),
                parseInt(m[2], 16),
                parseInt(m[3], 16),
                m[4] ? parseInt(m[4], 16) / 255 : 1
            );
        }

        if ((m = str.match(/rgba?\((\d+)\D+(\d+)\D+(\d+)(\D+([\d.]+))?\)/))) {
            return new Color(
                parseInt(m[1], 10),
                parseInt(m[2], 10),
                parseInt(m[3], 10),
                m[4] ? parseFloat(m[5]) : 1
            );
        }

        if ((m = str.match(/hsla?\(([\d.]+)\D+([\d.]+)\D+([\d.]+)(\D+([\d.]+))?\)/))) {
            return hsla2rgb({
                h: parseInt(m[1], 10),
                s: parseFloat(m[2]),
                l: parseFloat(m[3]),
                a: m[4] ? parseFloat(m[5]) : 1
            });
        }
    };

    Color.toHSLA = function(rgba) { // r,g,b belong to [0, 255]; a belongs to [0,1]
        var r = rgba.r/255,
            g = rgba.g/255,
            b = rgba.b/255,
            max = Math.max(r, g, b), min = Math.min(r, g, b),
            h, s, l = (max+min) / 2,
            d;

        if (max === min) {
            h = s = 0; // achromatic
        } else {
            d = max-min;
            s = l > 0.5 ? d / (2-max-min) : d / (max+min);
            switch (max) {
                case r: h = (g-b) / d + (g < b ? 6 : 0); break;
                case g: h = (b-r) / d + 2; break;
                case b: h = (r-g) / d + 4; break;
            }
            h /= 6;
        }

        return { h:h*360, s:s, l:l, a:rgba.a };
    };

    return Color;

}());



// calculations are based on http://aa.quae.nl/en/reken/zonpositie.html
// code credits to Vladimir Agafonkin (@mourner)

var getSunPosition = (function() {

    var m = Math,
      PI = m.PI,
      sin = m.sin,
      cos = m.cos,
      tan = m.tan,
      asin = m.asin,
      atan = m.atan2;

    var rad = PI/180,
      dayMs = 1000*60*60*24,
      J1970 = 2440588,
      J2000 = 2451545,
      e = rad*23.4397; // obliquity of the Earth

    function toJulian(date) {
      return date.valueOf()/dayMs - 0.5+J1970;
    }
    function toDays(date) {
      return toJulian(date)-J2000;
    }
    function getRightAscension(l, b) {
      return atan(sin(l)*cos(e) - tan(b)*sin(e), cos(l));
    }
    function getDeclination(l, b) {
      return asin(sin(b)*cos(e) + cos(b)*sin(e)*sin(l));
    }
    function getAzimuth(H, phi, dec) {
      return atan(sin(H), cos(H)*sin(phi) - tan(dec)*cos(phi));
    }
    function getAltitude(H, phi, dec) {
      return asin(sin(phi)*sin(dec) + cos(phi)*cos(dec)*cos(H));
    }
    function getSiderealTime(d, lw) {
      return rad * (280.16 + 360.9856235*d) - lw;
    }
    function getSolarMeanAnomaly(d) {
      return rad * (357.5291 + 0.98560028*d);
    }
    function getEquationOfCenter(M) {
      return rad * (1.9148*sin(M) + 0.0200 * sin(2*M) + 0.0003 * sin(3*M));
    }
    function getEclipticLongitude(M, C) {
      var P = rad*102.9372; // perihelion of the Earth
      return M+C+P+PI;
    }

    return function getSunPosition(date, lat, lon) {
      var lw = rad*-lon,
        phi = rad*lat,
        d = toDays(date),
        M = getSolarMeanAnomaly(d),
        C = getEquationOfCenter(M),
        L = getEclipticLongitude(M, C),
        D = getDeclination(L, 0),
        A = getRightAscension(L, 0),
        t = getSiderealTime(d, lw),
        H = t-A;

      return {
        altitude: getAltitude(H, phi, D),//垂直高度
        azimuth: getAzimuth(H, phi, D) - PI/2 // origin: north   //方向角
      };
    };

}());



var readGeoJSON = function(collection) {
    var i, il, j, jl, k, kl,
        res = [],
        feature,
        geometry, properties, coordinates,
        wallColor, roofColor,
        last,
        height,
        polygon, footprint, heightSum, holes,
        lat = 1, lon = 0, alt = 2,
        item;

    for (i = 0, il = collection.length; i < il; i++) {
        feature = collection[i];
        if (feature.type !== 'Feature') {
            continue;
        }

        geometry = feature.geometry;
        properties = feature.properties;

        if (geometry.type === 'LineString') {
            last = coordinates.length-1;
            if (coordinates[0][0] === coordinates[last][0] && coordinates[0][1] === coordinates[last][1]) {
                coordinates = geometry.coordinates;
            }
        }

        if (geometry.type === 'Polygon') {
            coordinates = geometry.coordinates;
        }

        // just use the outer ring
        if (geometry.type === 'MultiPolygon') {
            coordinates = geometry.coordinates[0];
        }

        if (!coordinates) {
            continue;
        }

        if (properties.color || properties.wallColor) {
            wallColor = properties.color || properties.wallColor;
        }

        if (properties.roofColor) {
            roofColor = properties.roofColor;
        }

        polygon   = coordinates[0];
        footprint = [];
        height    = properties.height;
        heightSum = 0;
        for (j = 0, jl = polygon.length; j < jl; j++) {
            footprint.push(polygon[j][lat], polygon[j][lon]);
            heightSum += height || polygon[j][alt] || 0;
        }

        holes = [];
        for (j = 1, jl = coordinates.length; j < jl; j++) {
            polygon = coordinates[i];
            holes[j-1] = [];
			//fixed:为了防止polygon.length报错
			if(!polygon) {
				continue;
			}
            for (k = 0, kl = polygon.length; k < kl; k++) {
                holes[j-1].push(polygon[k][lat], polygon[k][lon]);
            }
        }

        // one item per coordinates ring (usually just one ring)
        item = {
            id:properties.id || (footprint[0] + ',' + footprint[1]),
            footprint:makeWinding(footprint, 'CW')
        };
		//fixed:为了防止polygon为空，加了对几何信息的判断
		if(polygon) {
			 if (heightSum)            item.height    = heightSum/polygon.length <<0;
		}
       
        if (properties.minHeight) item.minHeight = properties.minHeight;
        if (wallColor)            item.wallColor = wallColor;
        if (roofColor)            item.roofColor = roofColor;
        if (holes.length)     item.holes = holes;
        res.push(item);
    }

    return res;
};



var readOSMXAPI = (function() {

    var YARD_TO_METER = 0.9144,
        FOOT_TO_METER = 0.3048,
        INCH_TO_METER = 0.0254,
        METERS_PER_LEVEL = 3;

    function parseDimension(str) {
        var value = parseFloat(str);

        if (~str.indexOf('m')) {
            return value <<0;
        }
        if (~str.indexOf('yd')) {
            return value*YARD_TO_METER <<0;
        }
        if (~str.indexOf('ft')) {
            return value*FOOT_TO_METER <<0;
        }
        if (~str.indexOf('\'')) {
            var parts = str.split('\'');
            var res = parts[0]*FOOT_TO_METER + parts[1]*INCH_TO_METER;
            return res <<0;
        }
        return value <<0;
    }

    var baseMaterials = {
        asphalt:'tar_paper',
        bitumen:'tar_paper',
        block:'stone',
        bricks:'brick',
        glas:'glass',
        glassfront:'glass',
        grass:'plants',
        masonry:'stone',
        granite:'stone',
        panels:'panel',
        paving_stones:'stone',
        plastered:'plaster',
        rooftiles:'roof_tiles',
        roofingfelt:'tar_paper',
        sandstone:'stone',
        sheet:'canvas',
        sheets:'canvas',
        shingle:'tar_paper',
        shingles:'tar_paper',
        slates:'slate',
        steel:'metal',
        tar:'tar_paper',
        tent:'canvas',
        thatch:'plants',
        tile:'roof_tiles',
        tiles:'roof_tiles'
    };

    // cardboard
    // eternit
    // limestone
    // straw

    var materialColors = {
        brick:'#cc7755',
        bronze:'#ffeecc',
        canvas:'#fff8f0',
        concrete:'#999999',
        copper:'#a0e0d0',
        glass:'#e8f8f8',
        gold:'#ffcc00',
        plants:'#009933',
        metal:'#aaaaaa',
        panel:'#fff8f0',
        plaster:'#999999',
        roof_tiles:'#f08060',
        silver:'#cccccc',
        slate:'#666666',
        stone:'#996666',
        tar_paper:'#333333',
        wood:'#deb887'
    };

    function parseMaterial(str) {
        str = str.toLowerCase();
        if (str[0] === '#') {
            return str;
        }
        return materialColors[baseMaterials[str] || str] || null;
    }

    function isBuilding(data) {
        var tags = data.tags;
        return (tags &&
            !tags.landuse &&
            (tags.building || tags['building:part']) &&
            (!tags.layer || tags.layer >= 0));
    }

//  living:'bricks',
//  nonliving:'tar_paper',
//  worship:'copper'

    function getBuildingType(tags) {
        if (tags.amenity === 'place_of_worship') {
            return 'worship';
        }

        var type = tags.building;
        if (type === 'yes' || type === 'roof') {
            type = tags['building:use'];
        }
        if (!type) {
            type = tags.amenity;
        }

        switch (type) {
            case 'apartments':
            case 'house':
            case 'residential':
            case 'hut':
                return 'living';
            case 'church':
                return 'worship';
        }

        return 'nonliving';
    }

    function getRelationWays(members) {
        var m, outer, inner = [];
        for (var i = 0, il = members.length; i < il; i++) {
            m = members[i];
            if (m.type !== 'way' || !ways[m.ref]) {
                continue;
            }
            if (!m.role || m.role === 'outer') {
                outer = ways[m.ref];
                continue;
            }
            if (m.role === 'inner' || m.role === 'enclave') {
                inner.push(ways[m.ref]);
                continue;
            }
        }
        if (!outer || !outer.tags) {
            return;
        }
        return { outer:outer, inner:inner };
    }

    function getFootprint(points) {
        if (!points) {
            return;
        }

        var footprint = [], p;
        for (var i = 0, il = points.length; i < il; i++) {
            p = nodes[ points[i] ];
            footprint.push(p[0], p[1]);
        }

        // do not close polygon yet
        if (footprint[footprint.length-2] !== footprint[0] && footprint[footprint.length-1] !== footprint[1]) {
            footprint.push(footprint[0], footprint[1]);
        }

        // can't span a polygon with just 2 points (+ start & end)
        if (footprint.length < 8) {
            return;
        }

        return footprint;
    }

    function mergeTags(dst, src) {
        for (var p in src) {
            if (!dst[p]) {
                dst[p] = src[p];
            }
        }
        return dst;
    }

    function filterTags(tags) {
        var height = 0, minHeight = 0;

        if (tags.height) {
            height = parseDimension(tags.height);
        }
        if (!height && tags['building:height']) {
            height = parseDimension(tags['building:height']);
        }

        if (!height && tags.levels) {
            height = tags.levels*METERS_PER_LEVEL <<0;
        }
        if (!height && tags['building:levels']) {
            height = tags['building:levels']*METERS_PER_LEVEL <<0;
        }

        // min_height
        if (tags.min_height) {
            minHeight = parseDimension(tags.min_height);
        }
        if (!minHeight && tags['building:min_height']) {
            minHeight = parseDimension(tags['building:min_height']);
        }

        if (!minHeight && tags.min_level) {
            minHeight = tags.min_level*METERS_PER_LEVEL <<0;
        }
        if (!minHeight && tags['building:min_level']) {
            minHeight = tags['building:min_level']*METERS_PER_LEVEL <<0;
        }

        var wallColor, roofColor;

        // wall material
        if (tags['building:material']) {
            wallColor = parseMaterial(tags['building:material']);
        }
        if (tags['building:facade:material']) {
            wallColor = parseMaterial(tags['building:facade:material']);
        }
        if (tags['building:cladding']) {
            wallColor = parseMaterial(tags['building:cladding']);
        }
        // wall color
        if (tags['building:color']) {
            wallColor = tags['building:color'];
        }
        if (tags['building:colour']) {
            wallColor = tags['building:colour'];
        }

        // roof material
        if (tags['roof:material']) {
            roofColor = parseMaterial(tags['roof:material']);
        }
        if (tags['building:roof:material']) {
            roofColor = parseMaterial(tags['building:roof:material']);
        }
        // roof color
        if (tags['roof:color']) {
            roofColor = tags['roof:color'];
        }
        if (tags['roof:colour']) {
            roofColor = tags['roof:colour'];
        }
        if (tags['building:roof:color']) {
            roofColor = tags['building:roof:color'];
        }
        if (tags['building:roof:colour']) {
            roofColor = tags['building:roof:colour'];
        }

        return {
            height:    height,
            minHeight: minHeight,
            wallColor: wallColor,
            roofColor: roofColor
        };
    }

    function processNode(node) {
        nodes[node.id] = [node.lat, node.lon];
    }

    function processWay(way) {
        var tags, footprint;
        if (isBuilding(way)) {
            tags = filterTags(way.tags);
            if ((footprint = getFootprint(way.nodes))) {
                addResult(way.id, tags, footprint);
            }
        } else {
            tags = way.tags;
            if (!tags || (!tags.highway && !tags.railway && !tags.landuse)) { // TODO: add more filters
                ways[way.id] = way;
            }
        }
    }

    function processRelation(relation) {
        var relationWays, outerWay, holes = [],
            tags, outerFootprint, innerFootprint;
        if (isBuilding(relation) && (relation.tags.type === 'multipolygon' || relation.tags.type === 'building')) {
            if ((relationWays = getRelationWays(relation.members))) {
                var relTags = filterTags(relation.tags);
                if ((outerWay = relationWays.outer)) {
                    tags = filterTags(outerWay.tags);
                    if ((outerFootprint = getFootprint(outerWay.nodes))) {
                        tags = mergeTags(tags, relTags);
                        for (var i = 0, il = relationWays.inner.length; i < il; i++) {
                            if ((innerFootprint = getFootprint(relationWays.inner[i].nodes))) {
                                holes.push(makeWinding(innerFootprint, 'CCW'));
                            }
                        }
                        addResult(outerWay.id, tags, outerFootprint, holes.length ? holes : null);
                    }
                }
            }
        }
    }

    function addResult(id, tags, footprint, holes) {
        var item = { id:id, footprint:makeWinding(footprint, 'CW'), holes:holes };
        if (tags.height)    item.height    = tags.height;
        if (tags.minHeight) item.minHeight = tags.minHeight;
        if (tags.wallColor) item.wallColor = tags.wallColor;
        if (tags.roofColor) item.roofColor = tags.roofColor;
        if (holes)      item.holes = holes;
        res.push(item);
    }

    var nodes, ways, res;

    return function(data) {
        nodes = {};
        ways = {};
        res = [];

        var item;
        for (var i = 0, il = data.length; i < il; i++) {
            item = data[i];
            switch(item.type ) {
                case 'node':     processNode(item);     break;
                case 'way':      processWay(item);      break;
                case 'relation': processRelation(item); break;
            }
        }

        return res;
    };
})();



// constants, shared to all instances
var VERSION      = '0.1.8a',
    ATTRIBUTION  = '&copy; <a href="http://osmbuildings.org">OSM Buildings</a>',
    OSM_XAPI_URL = 'http://overpass-api.de/api/interpreter?data=[out:json];(way[%22building%22]({s},{w},{n},{e});node(w);way[%22building:part%22=%22yes%22]({s},{w},{n},{e});node(w);relation[%22building%22]({s},{w},{n},{e});way(r);node(w););out;',
//  OSM_XAPI_URL = 'http://overpass.osm.rambler.ru/cgi/interpreter?data=[out:json];(way[%22building%22]({s},{w},{n},{e});node(w);way[%22building:part%22=%22yes%22]({s},{w},{n},{e});node(w);relation[%22building%22]({s},{w},{n},{e});way(r);node(w););out;',

    PI         = Math.PI,
    HALF_PI    = PI/2,
    QUARTER_PI = PI/4,
    RAD        = 180/PI,

    MAP_TILE_SIZE  = 256,    // map tile size in pixels
    DATA_TILE_SIZE = 0.0075, // data tile size in geo coordinates, smaller: less data to load but more requests

    MIN_ZOOM = 15,

    LAT = 'latitude', LON = 'longitude',

    DEFAULT_HEIGHT = 15,
    HEIGHT_SCALE = 3;



function getDistance(p1, p2) {
    var dx = p1[0]-p2[0],
        dy = p1[1]-p2[1];
    return dx*dx + dy*dy;
}
//不理解
function crop(num) {
    return (num*10000 << 0) / 10000;
}

function getCenter(points) {
    var len, x = 0, y = 0;
    for (var i = 0, il = points.length-3; i < il; i += 2) {
        x += points[i];
        y += points[i+1];
    }
    len = (points.length-2) / 2;
    return [x/len <<0, y/len <<0];
}

function getSquareSegmentDistance(px, py, p1x, p1y, p2x, p2y) {
    var dx = p2x-p1x,
        dy = p2y-p1y,
        t;
    if (dx !== 0 || dy !== 0) {
        t = ((px-p1x) * dx + (py-p1y) * dy) / (dx*dx + dy*dy);
        if (t > 1) {
            p1x = p2x;
            p1y = p2y;
        } else if (t > 0) {
            p1x += dx*t;
            p1y += dy*t;
        }
    }
    dx = px-p1x;
    dy = py-p1y;
    return dx*dx + dy*dy;
}

function simplify(points) {
    var sqTolerance = 2,
        len = points.length/2,
        markers = new Uint8Array(len),

        first = 0,
        last  = len - 1,

        i,
        maxSqDist,
        sqDist,
        index,

        firstStack = [],
        lastStack  = [],

        newPoints  = [];

    markers[first] = markers[last] = 1;

    while (last) {
        maxSqDist = 0;

        for (i = first + 1; i < last; i++) {
            sqDist = getSquareSegmentDistance(
                points[i    *2], points[i    *2 + 1],
                points[first*2], points[first*2 + 1],
                points[last *2], points[last *2 + 1]
            );
            if (sqDist > maxSqDist) {
                index = i;
                maxSqDist = sqDist;
            }
        }

        if (maxSqDist > sqTolerance) {
            markers[index] = 1;

            firstStack.push(first);
            lastStack.push(index);

            firstStack.push(index);
            lastStack.push(last);
        }

        first = firstStack.pop();
        last = lastStack.pop();
    }

    for (i = 0; i < len; i++) {
        if (markers[i]) {
            newPoints.push(points[i*2], points[i*2 + 1]);
        }
    }

    return newPoints;
}

// detect polygon winding direction: clockwise or counter clockwise
function getWinding(points) {
    var x1, y1, x2, y2,
        a = 0,
        i, il;
    for (i = 0, il = points.length-3; i < il; i += 2) {
        x1 = points[i];
        y1 = points[i+1];
        x2 = points[i+2];
        y2 = points[i+3];
        a += x1*y2 - x2*y1;
    }
    return (a/2) > 0 ? 'CW' : 'CCW';
}

// make polygon winding clockwise. This is needed for proper backface culling on client side.
function makeWinding(points, direction) {
    var winding = getWinding(points);
    if (winding === direction) {
        return points;
    }
    var revPoints = [];
    for (var i = points.length-2; i >= 0; i -= 2) {
        revPoints.push(points[i], points[i+1]);
    }
    return revPoints;
}



    var osmb = function(url) {



// private variables, specific to an instance
var width = 0, height = 0,
    halfWidth = 0, halfHeight = 0,
    originX = 0, originY = 0,
    zoom, size,

    activeRequest,

    context,
	//设置墙的默认颜色
    defaultWallColor = new Color(200, 190, 180),
	//建筑左右两边墙的亮度
    defaultAltColor  = defaultWallColor.setLightness(0.8),
	//建筑屋顶的亮度
    defaultRoofColor = defaultWallColor.setLightness(1.2),

    wallColorAlpha = defaultWallColor + '',
    altColorAlpha  = defaultAltColor + '',
    roofColorAlpha = defaultRoofColor + '',
	//淡出因数：
    fadeFactor = 1,
    animTimer,
    zoomAlpha = 1,

    minZoom = MIN_ZOOM,
    maxZoom = 20,
    maxHeight,

    camX, camY, camZ,

    isZooming;



function pixelToGeo(x, y) {
    var res = {};
    x /= size;
    y /= size;
    res[LAT] = y <= 0  ? 90 : y >= 1 ? -90 : RAD * (2 * atan(exp(PI * (1 - 2 * y))) - HALF_PI),
    res[LON] = (x === 1 ?  1 : (x % 1 + 1) % 1) * 360 - 180;
    return res;
}

function geoToPixel(lat, lon) {
    var latitude  = min(1, max(0, 0.5 - (log(tan(QUARTER_PI + HALF_PI * lat / 180)) / PI) / 2)),
        longitude = lon / 360 + 0.5;
    return {
        x: longitude*size <<0,
        y: latitude *size <<0
    };
}

function fromRange(sVal, sMin, sMax, dMin, dMax) {
    sVal = min(max(sVal, sMin), sMax);
    var rel = (sVal-sMin) / (sMax-sMin),
        range = dMax-dMin;
    return min(max(dMin + rel*range, dMin), dMax);
}

function xhr(_url, param, callback) {
    var url = _url.replace(/\{ *([\w_]+) *\}/g, function(tag, key) {
        return param[key] || tag;
    });

    var req = 'XDomainRequest' in window ? new XDomainRequest() : new XMLHttpRequest();

    function changeState(state) {
        if ('XDomainRequest' in window && state !== req.readyState) {
            req.readyState = state;
            if (req.onreadystatechange) {
                req.onreadystatechange();
            }
        }
    }

    req.onerror = function() {
        req.status = 500;
        req.statusText = 'Error';
        changeState(4);
    };

    req.ontimeout = function() {
        req.status = 408;
        req.statusText = 'Timeout';
        changeState(4);
    };

    req.onprogress = function() {
        changeState(3);
    };

    req.onload = function() {
        req.status = 200;
        req.statusText = 'Ok';
        changeState(4);
    };

    req.onreadystatechange = function() {
        if (req.readyState !== 4) {
            return;
        }
        if (!req.status || req.status < 200 || req.status > 299) {
            return;
        }
        if (callback && req.responseText) {
            callback(JSON.parse(req.responseText));
        }
    };

    changeState(0);
    req.open('GET', url);
    changeState(1);
    req.send(null);
    changeState(2);

    return req;
}



var Cache = (function() {

    var _time = new Date();
    var _data = {};

    var me = {};

    me.add = function(key, data) {
        _data[key] = { data:data, time:Date.now() };
    };

    me.get = function(key) {
        return _data[key] && _data[key].data;
    };
	//清除缓存数据
    me.purge = function() {
        _time.setMinutes(_time.getMinutes()-5);
        for (var key in _data) {
            if (_data[key].time < _time) {
                delete _data[key];
            }
        }
    };

    return me;

}());



var Data = (function() {

    var _url;
    var _index = {}; // maintain a list of cached items in order to fade in new ones

    function _closureParse(cacheKey) {
        return function(res) {
            _parse(res, cacheKey);
        };
    }

    function _parse(data, cacheKey) {
        if (!data) {
            return;
        }

        var items;
        if (data.type === 'FeatureCollection') { // GeoJSON
            items = readGeoJSON(data.features);
        } else if (data.osm3s) { // XAPI,本（readOSMXAPI）方法不是GeoJSON的返回方法，暂不考虑
            items = readOSMXAPI(data.elements);
        }

        if (cacheKey) {//添加数据到缓存
            Cache.add(cacheKey, items);
        }

        _add(items, true);
    }

    function _getFootprint(polygon) {
        var footprint = new Int32Array(polygon.length),
            px;
        for (var i = 0, il = polygon.length-1; i < il; i+=2) {
            px = geoToPixel(polygon[i], polygon[i+1]);
            footprint[i]   = px.x;
            footprint[i+1] = px.y;
        }
		//稀疏数据
        footprint = simplify(footprint);
        if (footprint.length < 8) { // 3 points + end==start (*2)
            return;
        }
        return footprint;
    }
	//不清楚isNew的含义
    function _add(data, isNew) {
        var items = _scale(data, zoom, isNew);

        var item;
        for (var i = 0, il = items.length; i < il; i++) {
            item = items[i];
            if (!_index[item.id]) {
                item.scale = isNew ? 0 : 1;
                me.renderItems.push(items[i]);
                _index[item.id] = 1;
            }
        }
        fadeIn();
    }

    function _scale(items, zoom) {
        var i, il, j, jl,
            res = [],
            item,
			//footprint屋底
            height, minHeight, footprint,
			//roof屋顶，wall:墙
            color, wallColor, altColor, roofColor,
            holes, innerFootprint,
            zoomDelta = maxZoom-zoom;

        for (i = 0, il = items.length; i < il; i++) {

            item = items[i];
			//?:HEIGHT_SCALE是一个什么概念
            height = (item.height || DEFAULT_HEIGHT)*HEIGHT_SCALE >> zoomDelta;
            if (!height) {
                continue;
            }

            minHeight = item.minHeight*HEIGHT_SCALE >> zoomDelta;
            if (minHeight > maxHeight) {
                continue;
            }

            if (!(footprint = _getFootprint(item.footprint))) {
                continue;
            }

            holes = [];
            if (item.holes) {
                for (j = 0, jl = item.holes.length; j < jl; j++) {
                    if ((innerFootprint = _getFootprint(item.holes[j]))) {
                        holes.push(innerFootprint);
                    }
                }
            }

            wallColor = null;
            altColor  = null;
            if (item.wallColor) {
                if ((color = Color.parse(item.wallColor))) {
					//带透明度的颜色，zoomAlpha是透明度
                    wallColor = color.setAlpha(zoomAlpha);
                    altColor  = '' + wallColor.setLightness(0.8);
                    wallColor = '' + wallColor;
                }
            }

            roofColor = null;
            if (item.roofColor) {
                if ((color = Color.parse(item.roofColor))) {
                    roofColor = '' + color.setAlpha(zoomAlpha);
                }
            }

            res.push({
                id:        item.id,
                footprint: footprint,
                height:    min(height, maxHeight),
                minHeight: minHeight,
                wallColor: wallColor,
                altColor:  altColor,
                roofColor: roofColor,
                center:    getCenter(footprint),
                holes:     holes.length ? holes : null
            });
        }

        return res;
    }

    var me = {};

    me.renderItems = []; // TODO: move to renderer

    me.load = function(url) {
        _url = url || OSM_XAPI_URL;
        me.update();
    };

    me.update = function() {
        if (!_url || zoom < MIN_ZOOM) {
            return;
        }

        var nw = pixelToGeo(originX,       originY),
            se = pixelToGeo(originX+width, originY+height),
            sizeLat = DATA_TILE_SIZE,
            sizeLon = DATA_TILE_SIZE*2;

        var bounds = {
            n: ceil( nw.latitude /sizeLat) * sizeLat,
            e: ceil( se.longitude/sizeLon) * sizeLon,
            s: floor(se.latitude /sizeLat) * sizeLat,
            w: floor(nw.longitude/sizeLon) * sizeLon
        };

        Cache.purge();
        me.renderItems = [];
        _index = {};

        var lat, lon,
            cached, key;

        for (lat = bounds.s; lat <= bounds.n; lat += sizeLat) {
            for (lon = bounds.w; lon <= bounds.e; lon += sizeLon) {
                key = lat + ',' + lon;
                if ((cached = Cache.get(key))) {
                    _add(cached);
                } else {
                    xhr(_url, {
                        n: crop(lat+sizeLat),
                        e: crop(lon+sizeLon),
                        s: crop(lat),
                        w: crop(lon)
                    }, _closureParse(key));
                }
            }
        }
    };

    me.set = function(data) {
        me.renderItems = [];
        _index = {};
        _parse(data);
    };

    return me;

}());




function fadeIn() {
    if (animTimer) {
        return;
    }

    animTimer = setInterval(function() {
        var item, needed = false;
        for (var i = 0, il = Data.renderItems.length; i < il; i++) {
            item = Data.renderItems[i];
            if (item.scale < 1) {
                item.scale += 0.5*0.2; // amount*easing
                if (item.scale > 1) {
                    item.scale = 1;
                }
                needed = true;
            }
        }

        renderAll();

        if (!needed) {
            clearInterval(animTimer);
            animTimer = null;
        }
    }, 33);
}

function renderAll() {
    Shadows.render();
    FlatBuildings.render();
    render();
}

function render() {
	////clearRect相当于相橡皮擦，把矩形的内容把擦掉
    context.clearRect(0, 0, width, height);

    // show on high zoom levels only and avoid rendering during zoom
    if (zoom < minZoom || isZooming) {
        return;
    }

    var i, il, j, jl,
        item,
        h, _h, mh, _mh,
        flatMaxHeight = FlatBuildings.MAX_HEIGHT,
        sortCam = [camX+originX, camY+originY],
        vp = {
            minX: originX,
            maxX: originX+width,
            minY: originY,
            maxY: originY+height
        },
        footprint, roof, holes,
        isVisible,
        wallColor, altColor;

    // TODO: FlatBuildings are drawn separately, data has to be split
    Data.renderItems.sort(function(a, b) {
        return getDistance(b.center, sortCam)/b.height - getDistance(a.center, sortCam)/a.height;
    });

    for (i = 0, il = Data.renderItems.length; i < il; i++) {
        item = Data.renderItems[i];

        if (item.height <= flatMaxHeight) {
            continue;
        }

        isVisible = false;
        footprint = item.footprint;
        for (j = 0, jl = footprint.length - 1; j < jl; j += 2) {
            // checking footprint is sufficient for visibility
            // TODO: pre-filter by data tile position
            if (!isVisible) {
                isVisible = (footprint[j] > vp.minX && footprint[j] < vp.maxX && footprint[j+1] > vp.minY && footprint[j+1] < vp.maxY);
            }
        }

        if (!isVisible) {
            continue;
        }

        // when fading in, use a dynamic height
        h = item.scale < 1 ? item.height*item.scale : item.height;
        // precalculating projection height factor
        _h = camZ / (camZ-h);

        _mh = 0;
        if (item.minHeight) {
            mh = item.scale < 1 ? item.minHeight*item.scale : item.minHeight;
            _mh = camZ / (camZ-mh);
        }

        wallColor = item.wallColor || wallColorAlpha;
        altColor  = item.altColor  || altColorAlpha;
        roof = renderPolygon(footprint, _h, _mh, wallColor, altColor);

        holes = [];
        if (item.holes) {
            for (j = 0, jl = item.holes.length; j < jl; j++) {
                holes[j] = renderPolygon(item.holes[j], _h, _mh, wallColor, altColor);
            }
        }

        // fill roof and optionally stroke it
        context.fillStyle   = item.roofColor || roofColorAlpha;
        context.strokeStyle = altColor;
        drawShape(roof, true, holes);
    }
}

function renderPolygon(polygon, h, mh, wallColor, altColor) {
    var a = { x:0, y:0 }, b = { x:0, y:0 },
        _a, _b,
        roof = [];
    for (var i = 0, il = polygon.length-3; i < il; i += 2) {
        a.x = polygon[i]  -originX;
        a.y = polygon[i+1]-originY;
        b.x = polygon[i+2]-originX;
        b.y = polygon[i+3]-originY;

        // project 3d to 2d on extruded footprint
        _a = project(a.x, a.y, h);
        _b = project(b.x, b.y, h);

        if (mh) {
            a = project(a.x, a.y, mh);
            b = project(b.x, b.y, mh);
        }

        // backface culling check
        if ((b.x-a.x) * (_a.y-a.y) > (_a.x-a.x) * (b.y-a.y)) {
            // depending on direction, set wall shading
            if ((a.x < b.x && a.y < b.y) || (a.x > b.x && a.y > b.y)) {
				//填充颜色
                context.fillStyle = altColor;
            } else {
                context.fillStyle = wallColor;
            }
            drawShape([
                b.x, b.y,
                a.x, a.y,
                _a.x, _a.y,
                _b.x, _b.y
            ]);
        }
        roof[i]   = _a.x;
        roof[i+1] = _a.y;
    }

    return roof;
}

function drawShape(points, stroke, holes) {
    if (!points.length) {
        return;
    }

    var i, il, j, jl;
    context.beginPath();

    context.moveTo(points[0], points[1]);
    for (i = 2, il = points.length; i < il; i += 2) {
        context.lineTo(points[i], points[i+1]);
    }

    if (holes) {
        for (i = 0, il = holes.length; i < il; i++) {
            points = holes[i];
            context.moveTo(points[0], points[1]);
            for (j = 2, jl = points.length; j < jl; j += 2) {
                context.lineTo(points[j], points[j+1]);
            }
        }
    }

    context.closePath();
    if (stroke) {
        context.stroke();
    }
    context.fill();
}

function project(x, y, m) {
    return {
        x: (x-camX) * m + camX <<0,
        y: (y-camY) * m + camY <<0
    };
}

/*
function debugMarker(x, y, color, size) {
    context.fillStyle = color || '#ffcc00';
    context.beginPath();
    context.arc(x, y, size || 3, 0, PI*2, true);
    context.closePath();
    context.fill();
}

function debugLine(ax, ay, bx, by, color) {
    context.strokeStyle = color || '#ff0000';
    context.beginPath();
    context.moveTo(ax, ay);
    context.lineTo(bx, by);
    context.closePath();
    context.stroke();
}
*/



var Shadows = (function() {

    var _context;
    var _enabled = true;
    var _color = new Color(0, 0, 0);
    var _date = null;
    var _direction = { x:0, y:0 };

    function _project(x, y, h) {
        return {
            x: x + _direction.x*h,
            y: y + _direction.y*h
        };
    }

    var me = {};

    me.setContext = function(context) {
        _context = context;
        // TODO: fix bad Date() syntax
        me.setDate(new Date().setHours(10)); // => render()
    };

    me.enable = function(flag) {
        _enabled = !!flag;
        // should call me.render() but it is usually set by setStyle() and there a renderAll() is called
    };

    me.render = function() {
        var center, sun, length, alpha, colorStr;

        _context.clearRect(0, 0, width, height);

        // show on high zoom levels only and avoid rendering during zoom
        if (!_enabled || zoom < minZoom || isZooming) {
            return;
        }

        // TODO: at some point, calculate me just on demand
        center = pixelToGeo(originX+halfWidth, originY+halfHeight);
        sun = getSunPosition(_date, center.latitude, center.longitude);

        if (sun.altitude <= 0) {
            return;
        }

        length = 1 / tan(sun.altitude);
        alpha = 0.4 / length;
        _direction.x = cos(sun.azimuth) * length;
        _direction.y = sin(sun.azimuth) * length;

        // TODO: maybe introduce Color.setAlpha()
        _color.a = alpha;
        colorStr = _color + '';

        var i, il, j, jl,
            item,
            f, h, g,
            x, y,
            footprint,
            mode,
            isVisible,
            ax, ay, bx, by,
            a, b, _a, _b,
            points,
            allFootprints = [];

        _context.beginPath();

        for (i = 0, il = Data.renderItems.length; i < il; i++) {
            item = Data.renderItems[i];

// TODO: no shadows when buildings are too flat => don't add them to renderItems then
//        if (item.height <= FlatBuildings.MAX_HEIGHT) {
//            continue;
//        }

            isVisible = false;
            f = item.footprint;
            footprint = [];
            for (j = 0, jl = f.length - 1; j < jl; j += 2) {
                footprint[j]   = x = f[j]  -originX;
                footprint[j+1] = y = f[j+1]-originY;

                // TODO: checking footprint is sufficient for visibility - NOT VALID FOR SHADOWS!
                if (!isVisible) {
                    isVisible = (x > 0 && x < width && y > 0 && y < height);
                }
            }

            if (!isVisible) {
                continue;
            }

            // when fading in, use a dynamic height
            h = item.scale < 1 ? item.height*item.scale : item.height;

            // prepare same calculations for min_height if applicable
            if (item.minHeight) {
                g = item.scale < 1 ? item.minHeight*item.scale : item.minHeight;
            }

            mode = null;

            for (j = 0, jl = footprint.length-3; j < jl; j += 2) {
                ax = footprint[j];
                ay = footprint[j+1];
                bx = footprint[j+2];
                by = footprint[j+3];

                _a = _project(ax, ay, h);
                _b = _project(bx, by, h);

                if (item.minHeight) {
                    a = _project(ax, ay, g);
                    b = _project(bx, by, g);
                    ax = a.x;
                    ay = a.y;
                    bx = b.x;
                    by = b.y;
                }

                if ((bx-ax) * (_a.y-ay) > (_a.x-ax) * (by-ay)) {
                    if (mode === 1) {
                        _context.lineTo(ax, ay);
                    }
                    mode = 0;
                    if (!j) {
                        _context.moveTo(ax, ay);
                    }
                    _context.lineTo(bx, by);
                } else {
                    if (mode === 0) {
                        _context.lineTo(_a.x, _a.y);
                    }
                    mode = 1;
                    if (!j) {
                        _context.moveTo(_a.x, _a.y);
                    }
                    _context.lineTo(_b.x, _b.y);
                }
            }

            _context.closePath();

            allFootprints.push(footprint);
        }

        _context.fillStyle = colorStr;
        _context.fill();

        // now draw all the footprints as negative clipping mask
        _context.globalCompositeOperation = 'destination-out';
        _context.beginPath();
        for (i = 0, il = allFootprints.length; i < il; i++) {
            points = allFootprints[i];
            _context.moveTo(points[0], points[1]);
            for (j = 2, jl = points.length; j < jl; j += 2) {
                _context.lineTo(points[j], points[j+1]);
            }
            _context.lineTo(points[0], points[1]);
            _context.closePath();
        }
        _context.fillStyle = '#00ff00';
        _context.fill();
        _context.globalCompositeOperation = 'source-over';
    };

    me.setDate = function(date) {
        _date = date;
        me.render();
    };

    return me;

}());



var FlatBuildings = (function() {

    var _context;

    var me = {};

    me.MAX_HEIGHT = 8;

    me.setContext = function(context) {
        _context = context;
    };

    me.render = function() {
        _context.clearRect(0, 0, width, height);

        // show on high zoom levels only and avoid rendering during zoom
        if (zoom < minZoom || isZooming) {
            return;
        }

        var i, il, j, jl,
            item,
            f,
            x, y,
            footprint,
            isVisible,
            ax, ay;

        _context.beginPath();

        for (i = 0, il = Data.renderItems.length; i < il; i++) {
            item = Data.renderItems[i];

            if (item.height > me.MAX_HEIGHT) {
                continue;
            }

            isVisible = false;
            f = item.footprint;
            footprint = [];
            for (j = 0, jl = f.length-1; j < jl; j += 2) {
                footprint[j]   = x = f[j]  -originX;
                footprint[j+1] = y = f[j+1]-originY;

                // checking footprint is sufficient for visibility
                if (!isVisible) {
                    isVisible = (x > 0 && x < width && y > 0 && y < height);
                }
            }

            if (!isVisible) {
                continue;
            }

            for (j = 0, jl = footprint.length-3; j < jl; j += 2) {
                ax = footprint[j];
                ay = footprint[j + 1];
                if (!j) {
                    _context.moveTo(ax, ay);
                } else {
                    _context.lineTo(ax, ay);
                }
            }

            _context.closePath();
        }

        _context.fillStyle   = roofColorAlpha;
        _context.strokeStyle = altColorAlpha;

        _context.stroke();
        _context.fill();
    };

    return me;

}());



var Layers = (function() {

    var _container = doc.createElement('DIV');
    _container.style.pointerEvents = 'none';
    _container.style.position = 'absolute';
    _container.style.left = 0;
    _container.style.top  = 0;

    var _items = [];

    // TODO: improve this to _createItem(Layer) => layer.setContext(context)
    Shadows.setContext(      _createItem());
    FlatBuildings.setContext(_createItem());
    context = _createItem(); // default (global) render context

    function _createItem() {
        var canvas = doc.createElement('CANVAS');
        canvas.style.webkitTransform = 'translate3d(0,0,0)'; // turn on hw acceleration
        canvas.style.imageRendering = 'optimizeSpeed';
        canvas.style.position = 'absolute';
        canvas.style.left = 0;
        canvas.style.top  = 0;

        var context = canvas.getContext('2d');
        context.lineCap   = 'round';
        context.lineJoin  = 'round';
        context.lineWidth = 1;

        context.mozImageSmoothingEnabled    = false;
        context.webkitImageSmoothingEnabled = false;

        _items.push(canvas);
        _container.appendChild(canvas);

        return context;
    }

    var me = {};

    me.appendTo = function(parentNode) {
        parentNode.appendChild(_container);
        return _container;
    };

    me.setSize = function(w, h) {
        for (var i = 0, il = _items.length; i < il; i++) {
            _items[i].width  = w;
            _items[i].height = h;
        }
    };

    return me;

}());



function setSize(w, h) {
    width  = w;
    height = h;
    halfWidth  = width /2 <<0;
    halfHeight = height/2 <<0;
    camX = halfWidth;
    camY = height;
	//window.devicePixelRatio是设备上物理像素和设备独立像素(device-independent pixels (dips))的比例。
	//公式表示就是：window.devicePixelRatio = 物理像素 / dips
    camZ = width / (1.5 / (window.devicePixelRatio || 1)) / tan(90/2) <<0; // adapting cam pos to field of view (90°), 1.5 is an empirical correction factor
    Layers.setSize(width, height);
    // TODO: change of maxHeight needs to adjust building heights!
    maxHeight = camZ-50;
}

function setOrigin(x, y) {
    originX = x;
    originY = y;
}

function setZoom(z) {
    zoom = z;
    size = MAP_TILE_SIZE <<zoom;

    zoomAlpha = 1 - fromRange(zoom, minZoom, maxZoom, 0, 0.3);

    wallColorAlpha = defaultWallColor.setAlpha(zoomAlpha) + '';
    altColorAlpha  = defaultAltColor.setAlpha( zoomAlpha) + '';
    roofColorAlpha = defaultRoofColor.setAlpha(zoomAlpha) + '';
}

function setCam(x, y) {
    camX = x;
    camY = y;
}

function setStyle(style) {
    style = style || {};
    if (style.color || style.wallColor) {
        defaultWallColor = Color.parse(style.color || style.wallColor);
        wallColorAlpha = defaultWallColor.setAlpha(zoomAlpha) + '';
		//设置墙的左右面透明度
        defaultAltColor = defaultWallColor.setLightness(0.8);
        altColorAlpha = defaultAltColor.setAlpha(zoomAlpha) + '';
		//设置墙的左右面透明度
        defaultRoofColor = defaultWallColor.setLightness(1.2);
        roofColorAlpha = defaultRoofColor.setAlpha(zoomAlpha) + '';
    }

    if (style.roofColor) {
        defaultRoofColor = Color.parse(style.roofColor);
        roofColorAlpha = defaultRoofColor.setAlpha(zoomAlpha) + '';
    }

    if (style.shadows !== undefined) {
        Shadows.enable(style.shadows);
    }

    renderAll();
}



this.onResize = function(e) {
    setSize(e.width, e.height);
    renderAll();
    Data.update();
}

function onMoveEnd(e) {
    renderAll();
    Data.update(); // => fadeIn() => renderAll()
}

function onZoomStart(e) {
    isZooming = true;
    // effectively clears because of isZooming flag
    renderAll();
}

function onZoomEnd(e) {
    isZooming = false;
    setZoom(e.zoom);
    Data.update(); // => fadeIn()
    renderAll();
}



this.setStyle = function(style) {
    setStyle(style);
};

this.setCamOffset = function(x, y) {
    camX = halfWidth + x;
    camY = height    + y;
};

this.setMaxZoom = function(z) {
    maxZoom = z;
};

this.setDate = function(date) {
    Shadows.setDate(date);
};

this.appendTo = function(parentNode) {
    return Layers.appendTo(parentNode);
};

this.loadData = function(url) {
    Data.load(url);
};

this.setData = function(data) {
    Data.set(data);
};

this.onMoveEnd   = onMoveEnd;
this.onZoomEnd   = onZoomEnd;
this.onZoomStart = onZoomStart;
this.setOrigin   = setOrigin;
this.setSize     = setSize;
this.setZoom     = setZoom;
this.render      = render;
this.renderAll   = renderAll;



    };

    osmb.VERSION     = VERSION;
    osmb.ATTRIBUTION = ATTRIBUTION;

    return osmb;

}());



/**
 *  Class: Geo.View2D.Layer.Buildings
 *  3D楼块图层是通过OGC的地图服务查询接口或Arcgis的地图服务查询接口获取矢量数据，并在地图
 *  上生成立体矢量数据的图层。
 *  
 *	Inherits from:
 *  	- <Geo.View2D.Layer>
 */
Geo.View2D.Layer.Buildings = Geo.Class(Geo.View2D.Layer, {

	/** 
     * APIProperty: name
     * {String} 服务名称
     */
    name: 'GEO Buildings',
	
	/**
	 * APIProperty: url
	 * {String} 地图服务服务地址
	 */
	url: null,
	
	/**
	 * APIProperty: minLevel
	 * {Integer}设置查询的最小级别，超出了最小级别则不做查询。默认值：15，取值范围[15-20]，其中minLevel必须要小于或等于maxLevel。
	 */
	minLevel: 15,
	
	/**
	 * APIProperty: maxLevel
	 * {Integer}设置查询的最大级别，超出了设定的最大级别则不做查询。默认值：20，取值范围[15-20]，其中maxLevel必须要大于或等于minLevel。
	 */
	maxLevel: 20,
	
	/**
	 *	Property: featureExt
	 *	本属性用于减少服务器负荷
	 */
	featureExt: null,
	
	/**
	 *	APIProperty: heightScaleRatio
	 *	{Integer} 房屋高度的夸张系数
	 */
	heightScaleRatio: 1,
	
	/**
	 *	APIProperty: heightAttribute
	 *	{Integer} 高度属性名称
	 */
	heightAttribute: "HRG",
	
	/**
	 * APIProperty: query
	 * {Geo.Query.MapServiceQueryParameters} 3D楼块查询条件对象查询条件。
	 * >如果用户不创建Geo.Query.MapServiceQueryParameters对象，那么图层将会创建一个默认的Geo.Query.MapServiceQueryParameters对象。
	 * >说明：
	 * >query对象的geometry属性：如果用户不设置geometry属性，那么geometry属性会根据地图当前可视范围以及extentScaleRatio计算得到。
	 * >如果用户设置了本属性，则以用户设置的为准。
	 */
	query: null,
	
	/**
	 *	APIProperty: extentScaleRatio
	 *	{float} 请求范围比率，默认值为2.1。目的是减少服务器负担，扩大请求范围。
	 */
	extentScaleRatio: 2.1,
	
	/**
	 *	APIProperty: zoomOffset
	 *	{Integer} 地图的级别偏移量
	 */
	zoomOffset: 0,
	
	/**
	 *	Property: dxSum
	 *	图层移动后的偏移
	 */
    dxSum: 0,
    
	/**
	 *	Property: dySum
	 *	图层移动后的偏移
	 */
    dySum: 0,
		
	/**
     * Constructor: Geo.View2D.Layer.Buildings
     *
     * Example:
     * (code)
     * 	var geoBuildings = new Geo.View2D.Layer.Buildings();
	 *	map.addLayer(geoBuildings);
     * (end)
     *
     * Parameters:
     * 	name - {String} 图层名称
     * 	url - {String} 地图服务
     * 	options - {Object} 参数对象，可选参数值如下：
     * 	>	query - {Geo.Query.MapServiceQueryParameters}(可选) 3D楼块查询条件对象
     * 	>	extentScaleRatio - {float} (可选) 请求范围比率，默认值为2.1 
     * 	>	heightAttribute - {Integer} (可选) 楼块高度的属性名
     * 	>	heightScaleRatio - {Integer} (可选) 房屋高度的夸张系数，默认值为1
     *  >	zoomOffset - {Integer} (可选) 地图级别偏移量
     * 	>	minLevel - {Integer} (可选) 最小级别
     * 	>	maxLevel - {Integer} (可选) 最大级别
     */
    initialize: function(name, url, options) {
		
		//判断浏览器是否支持canvas画布
		if (!(!!document.createElement('canvas').getContext)) {
			alert('您的浏览器不支持当前的canvas矢量渲染方式，请使用支持HTML5的浏览器运行。');
		}
        options = options || {};
		
//	   	options.projection = 'EPSG:900913';
		
		this.format = new Geo.Format.JSON();
		if(options.query instanceof Geo.Query.MapServiceQueryParameters) {
			
			this.query = options.query;
			
		}else {
			this.query = new Geo.Query.MapServiceQueryParameters();
			
		}
		this.query.returnGeometry = true;
		
		if(typeof url == "string") {
			this.url = url;
			//构造图层类,Geo.View2D.Layer.Buildings类依赖Geo.Query.MapServiceQueryParameters类以及Geo.Query.MapServiceQuery类
			this.mapServiceQuery = new Geo.Query.MapServiceQuery(url);
			var format = this.format;
			this.mapServiceQuery.queryTemp = function(queryParameter ,successFn, failFn) {
				var params = this._getParamsFromQueryParameter(queryParameter);	
				var DEFAULT_PARAMS = {
					f:"json",
					pretty:true
				}
				Geo.Util.applyDefaults(
			        params, DEFAULT_PARAMS
			    );
				OpenLayers.loadURL(this.url,params,this,function(result) {
					var res = format.read(result.responseText);
					successFn(res);
				},failFn);
			}
		}
		
		Geo.View2D.Layer.prototype.initialize.apply(this, [name, options]);
    },
	
	/**
	 * Method: _loadData
	 */
	_loadData: function() {
		if (this.timerId != null) {
            window.clearTimeout(this.timerId);
        }
		//根据当前地图视口范围，按照比例，得到一个更大的范围,根据这个更大的范围进行查询
		 this.timerId = window.setTimeout(
			OpenLayers.Function.bind(function() {
			if(this.mapServiceQuery instanceof Geo.Query.MapServiceQuery) {
				if(this.featureExt && this.featureExt.featureExt) {
					var isContain = this.featureExt.featureExt.containsBounds(this.map.getExtent());
					if(isContain && this.featureExt.zoom === this.map.zoom) {
						return;
					}
					this.featureExt = {
						featureExt: this.map.getExtent().scale(this.extentScaleRatio),
						zoom: this.map.zoom
					};
					this.query.geometry = this.featureExt.featureExt;
				}else {
					this.featureExt = {
						featureExt : this.map.getExtent().scale(this.extentScaleRatio),
						zoom: this.map.zoom
					};
					this.query.geometry = this.featureExt.featureExt;
				}
				this.mapServiceQuery.queryTemp(this.query, Geo.Function.bind( this._onQueryComplete, this));
			}
		}, this) ,500);
    },
	
	_getPolygon: function() {
		//当前范围
		var currentExtent = this.map.getExtent().scale(this.extentScaleRatio);
		var featureExt = this.featureExt;
		var polygon = null;
		//之前的范围
		if(featureExt instanceof Geo.Bounds) {
			if(currentExtent.left > featureExt.left && currentExtent.bottom > featureExt.bottom) {
				var pointLB = new Geo.Geometry.Point(currentExtent.left,currentExtent.bottom);
				var pointMT = new Geo.Geometry.Point(featureExt.right,featureExt.top);
				var pointMB = new Geo.Geometry.Point(featureExt.right,currentExtent.bottom);
				var pointRB = new Geo.Geometry.Point(currentExtent.right,currentExtent.bottom);
				var pointRT = new Geo.Geometry.Point(currentExtent.right,currentExtent.top);
				var pointLT = new Geo.Geometry.Point(currentExtent.left,currentExtent.top);
				polygon = new Geo.Geometry.Polygon(new Geo.Geometry.LinearRing([pointLB,pointMT,pointMB,pointRB,pointRT,pointLT,pointLB]));
			}else if(currentExtent.left > featureExt.left && currentExtent.bottom < featureExt.bottom) {
				var pointLB = new Geo.Geometry.Point(currentExtent.left,currentExtent.bottom);
				var pointLM = new Geo.Geometry.Point(currentExtent.left,featureExt.bottom);
				var pointMM = new Geo.Geometry.Point(featureExt.right,featureExt.bottom);
				var pointMT = new Geo.Geometry.Point(featureExt.right,currentExtent.top);
				var pointRT = new Geo.Geometry.Point(currentExtent.right,currentExtent.top);
				var pointLT = new Geo.Geometry.Point(currentExtent.left,currentExtent.bottom);
				polygon = new Geo.Geometry.Polygon(new Geo.Geometry.LinearRing([pointLB,pointLM,pointMM,pointMT,pointRT,pointLT,pointLB]));
			}else if(currentExtent.bottom > featureExt.bottom && currentExtent.right < featureExt.right) {
				var pointLT = new Geo.Geometry.Point(currentExtent.left,currentExtent.top);
				var pointLB = new Geo.Geometry.Point(currentExtent.left,currentExtent.bottom);
				var pointRB = new Geo.Geometry.Point(featureExt.left,currentExtent.bottom);
				var pointRM = new Geo.Geometry.Point(featureExt.left,featureExt.top);
				var pointMR = new Geo.Geometry.Point(currentExtent.right,featureExt.top);
				var pointRT = new Geo.Geometry.Point(currentExtent.right,currentExtent.top);
				polygon = new Geo.Geometry.Polygon(new Geo.Geometry.LinearRing([pointLT,pointLB,pointRB,pointRM,pointMR,pointRT,pointLT]));
			}else if(currentExtent.bottom < featureExt.bottom && currentExtent.right < featureExt.right) {
				var pointLB = new Geo.Geometry.Point(currentExtent.left,currentExtent.bottom);
				var pointRB = new Geo.Geometry.Point(currentExtent.right,currentExtent.bottom);
				var pointRM = new Geo.Geometry.Point(currentExtent.right,featureExt.bottom);
				var pointMT = new Geo.Geometry.Point(featureExt.left,featureExt.bottom);
				var pointRT = new Geo.Geometry.Point(featureExt.left,currentExtent.top);
				var pointLT = new Geo.Geometry.Point(currentExtent.left,currentExtent.top);
				polygon = new Geo.Geometry.Polygon(new Geo.Geometry.LinearRing([pointLB,pointRB,pointRM,pointMT,pointRT,pointLT,pointLB]));
			}
		}
		return polygon;
	},
	
	/**
	 * Method: _onQueryComplete
	 */
	_onQueryComplete: function(result) {
		if(Geo.Util.isArray(result.features)) {
			if(result.features.length <= 0 ) {   
			   alert("没有数据!");   
			    return;   
			}
			this.geoJSON(result.features);
		}
	},
	
//	/**
//	 * Method: _onResize
//	 * TODO:改变地图窗口大小的时候，执行本方法，目前暂未注册事件
//	 */
//	_onResize: function(extent, width, height) {
//      if (this.osmb) {
//        this.osmb.setSize(width,height );
//        this.osmb.render();
//      };
//    },
	
	/**
	 * APIMethod: loadData
	 * json {String} 加载本地json数据
	 */
	loadData: function(json) {
		if(!(typeof this.url === "string")) {
			var json = this.format.read(json);
		
			this.features = json.features;
			var zoom = this.zoomOffset +  this.map.getZoom();
			if(this.features && this.features.length > 0 && this.maxLevel >= zoom && this.minLevel <= zoom) {
				this.geoJSON(json.features);
			}
		}
	},
	
	/**
	 * Method: geoJSON
	 * features {Array(Geo.Feature.Vector)} 要素集合
	 */
	geoJSON: function(features) {
		var oids = {};
		var jfs = [];
		this._oids = {};
		for (var i = 0; i < features.length; i++) {
			var f = features[i];
			var gj = {
				"type": "Feature",
				"geometry": {
					"type": "Polygon",
					"coordinates": f.geometry.rings
				},
				"properties": {
					"height": f.attributes[this.heightAttribute] * this.heightScaleRatio+40,//parseInt(f.attributes["OID"]/100+2000),//f.attributes["hgt"],//
					"isNew":1
				}
			}
			jfs[i] = gj;
		}
		this.osmb.setData({
			"type": "FeatureCollection",
			"features": jfs
		});
    },
	
	/**
	 * Method: setOrigin
	 */
    setOrigin: function() {
        var origin = this.map.getLonLatFromPixel(new Geo.Pixel(0, 0)),
            res = this.map.resolution,
            ext = this.maxExtent,
            x = Math.round((origin.lon - ext.left) / res),
            y = Math.round((ext.top - origin.lat) / res);
        this.osmb.setOrigin(x, y);
    },
	
	/**
	 * APIMethod: setMap
	 * map {Geo.View2D.Map} 
	 */
    setMap: function(map) {
		
        if (!this.map) {
            Geo.View2D.Layer.prototype.setMap.call(this, map);
        }

        if (!this.osmb) {
            this.osmb = new OSMBuildings();
            this.container = this.osmb.appendTo(this.div);
        }
	//	this._loadData();
		
        this.osmb.setSize(this.map.size.w, this.map.size.h);
		
        this.osmb.setZoom(this.map.zoom);
		
        this.setOrigin();
		
		this.map.events.register("zoomend", this, this._zoomend);
		//注册地图移动等事件
		this.map.events.register("moveend", this, this._moveend);
    },
	
	_zoomend: function() {
		if(typeof this.url === "string") {
			var extent = this.map.getExtent();
			//在指定级别范围内查询
			if(this.maxLevel >= this.map.getZoom() && this.minLevel <= this.map.getZoom()) {
			//	this._loadData();
			}
		}else if(this.url === undefined || this.url === null) {
			var zoom = this.zoomOffset +  this.map.getZoom();
			if(this.features && this.features.length > 0 && this.maxLevel >= zoom && this.minLevel <= zoom) {
				this.geoJSON(this.features);
			}
		} 
	},
	
	/**
	 * Method: _moveend
	 */
	_moveend: function(zoomChanged) {
	},
	
	/**
	 * Method: removeMap
	 * 
	 */
    removeMap: function(map) {
		this.map.events.unregister("zoomend", this, this._zoomend);
		//注册地图移动等事件
		this.map.events.unregister("moveend", this, this._moveend);
        this.container.parentNode.removeChild(this.container);
		this.osmb = null;
		this.query = null;
		this.mapServiceQuery = null;
		this.format = null;
        Geo.View2D.Layer.prototype.removeMap.call(this, map);
    },
	
	/**
	 * APIMethod: onMapResize
	 * 地图容器大小改变。当地图容器大小发生改变时，调用此方法调整3D楼块数据的位置。
	 */
    onMapResize: function() {
        Geo.View2D.Layer.prototype.onMapResize.call(this);
        this.osmb.onResize({ width: this.map.size.w, height: this.map.size.h });
    },

	/**
	 * Method: moveTo
	 */
    moveTo: function(bounds, zoomChanged, dragging) {
        var result = Geo.View2D.Layer.prototype.moveTo.call(this, bounds, zoomChanged, dragging);
        if (!dragging) {
            var
                offsetLeft = parseInt(this.map.layerContainerDiv.style.left, 10),
                offsetTop  = parseInt(this.map.layerContainerDiv.style.top, 10)
            ;
            this.div.style.left = -offsetLeft + 'px';
            this.div.style.top  = -offsetTop  + 'px';
        }

        this.setOrigin();
        this.dxSum = 0;
        this.dySum = 0;
        this.osmb.setCamOffset(this.dxSum, this.dySum);
		var zoom = this.zoomOffset +  this.map.getZoom();
		if (zoomChanged) {
	        this.osmb.onZoomEnd({ zoom: zoom });
			if(this.maxLevel >= zoom && this.minLevel <= zoom) {
				//当this.FeatureExt不包含当前范围且级别未发生改变时，请求数据
				this._loadData();
			}
			
	    } else {
			var extent = this.map.getExtent();
			if(this.maxLevel >= zoom && this.minLevel <= zoom && this.featureExt && !this.featureExt.featureExt.containsBounds(extent)) {
				this._loadData();
			}
	        this.osmb.onMoveEnd();
	    }
        return result;
    },
	

	/**
	 * Method: moveByPx
	 */
    moveByPx: function(dx, dy) {
        this.dxSum += dx;
        this.dySum += dy;
        var result = Geo.View2D.Layer.prototype.moveByPx.call(this, dx, dy);
        this.osmb.setCamOffset(this.dxSum, this.dySum);
        this.osmb.render();
        return result;
    },

    // TODO: refactor these ugly bindings
	/**
	 * APIMethod: setStyle
	 * 设置房屋样式。
	 * 
	 * style - {Object}
	 * 	roofColor - {String} 屋顶颜色
	 * 	wallColor - {String} 围墙颜色（左右方向颜色）
	 * 示例：
	 * (code)
	 * osmb.setStyle({
	 * 		roofColor: "#ecf4ff", //屋顶颜色
	 * 		wallColor: "#ffec7e"  //围墙颜色
	 * });
	 * (end)
	 */
    setStyle: function(style) {
        this.osmb.setStyle(style);
        return this;
    },
	
	/**
	 * APIMethod: setDate
	 * 根据时间点设置房屋阴影。
	 * 
	 * Parameters:
	 * date - {Date} 某一天的时间点
	 * 示例：
	 * (code)
	 * 	osmb.setDate(new Date("2013-6-10 22:00:00"));
	 * (end)
	 */
    setDate: function(date) {
        this.osmb.setDate(date);
        return this;
    },
	
  	CLASS_NAME: 'Geo.View2D.Layer.Buildings'
	
});/**
 * Class: Geo.View2D.Layer.GeoThematicLayer
 * 专题图图层类。该类的实例用于渲染专题图数据。
 *
 * Inherits from:
 *  - <Geo.View2D.Layer.Vector>
 */
Geo.View2D.Layer.GeoThematicLayer = Geo.Class(Geo.View2D.Layer.Vector, {
    
    /**
      * Property: loaded
      * {Boolean} Flag for whether the GML data has been loaded yet.
      */
    loaded: false,

    /**
      * Property: format
      * {<OpenLayers.Format>} The format you want the data to be parsed with.
      */
    format: null,

    /**
     * Property: formatOptions
     * {Object} Hash of options which should be passed to the format when it is
     * created. Must be passed in the constructor.
     */
    formatOptions: null,

    /**
     * APIProperty: gmlUrl
     * {String} 专题图数据文件路径。
     */
    gmlUrl: null,

    /**
     * APIProperty: styleUrl
     * {String} 专题图数据样式文件路径。
     */
    styleUrl: null,

    /**
     * Constructor: Geo.View2D.Layer.GeoThematicLayer
     * 创建一个专题图图层。
     *
     * Parameters:
     * name - {String} 图层名称。
     * options - {Object} 参数选项。
     *   gmlUrl {String} (必选) 专题图数据文件路径。
     *   styleUrl {String} (必选) 专题图数据样式文件路径。
     *   该文件包含专题图数据的样式，例如在PolygonRendition属性下，包含以下样式：
     * (code)
     *   { "Type": "polygon",//类型
     *     "FillColor": "#657800",//填充颜色
     *     "FillOpacity": "1",//填充色透明度
     *     "StrokeColor": "#000000",//边框颜色
     *     "StrokeOpacity": "1",//边框颜色透明度
     *     "StrokeWidth": "1"//边框宽度
     *   }
     * (end)
     */
     initialize: function(name, options) {
        var newArguments = [];
        newArguments.push(name, options);
        Geo.View2D.Layer.Vector.prototype.initialize.apply(this, newArguments);
    },

    /**
     * APIMethod: setVisibility
     * 设置是否显示该图层。
     *  
     * Parameters:
     * visible - {Boolean} 是否显示。
     */
    setVisibility: function(visibility) {
        Geo.View2D.Layer.Vector.prototype.setVisibility.apply(this, arguments);
        if(this.visibility && !this.loaded){
            // Load the GML
            this.loadGML();
        }
    },

    /**
     * Method: moveTo
     * If layer is visible and GML has not been loaded, load GML, then load GML
     * and call Geo.View2D.Layer.Vector.moveTo() to redraw at the new location.
     * 
     * Parameters:
     * bounds - {Object} 
     * zoomChanged - {Object} 
     * minor - {Object} 
     */
    moveTo:function(bounds, zoomChanged, minor) {
        Geo.View2D.Layer.Vector.prototype.moveTo.apply(this, arguments);
        // Wait until initialisation is complete before loading GML
        // otherwise we can get a race condition where the root HTML DOM is
        // loaded after the GML is paited.
        // See http://trac.openlayers.org/ticket/404
        if(this.visibility && !this.loaded){
            this.loadGML();
        }
    },

    /**
     * Method: loadGML
     */
    loadGML: function() {
        if (!this.loaded) {
            this.events.triggerEvent("loadstart");
            OpenLayers.Request.GET({
				//async: false,
                url: this.gmlUrl,
                success: this.requestSuccess,
                failure: this.requestFailure,
                scope: this
            });
            this.loaded = true;
        }    
    },    
    
    /**
     * Method: setUrl
     * 改变GML文件路径，重新加载。
     *
     * Parameters:
     * url - {String} 文件路径。
     */
    setUrl:function(url) {
        this.gmlUrl = url;
        this.destroyFeatures();
        this.loaded = false;
        this.loadGML();
    },
    
    /**
     * Method: requestSuccess
     * 请求GML文件成功回调函数。
     *
     * Parameters:
     * request - {String} 
     */
    requestSuccess:function(request) {
        var doc = request.responseXML;
        
        if (!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        
        var options = {};
        
        OpenLayers.Util.extend(options, this.formatOptions);
        if (this.map && !this.projection.equals(this.map.getProjectionObject())) {
            options.externalProjection = this.projection;
            options.internalProjection = this.map.getProjectionObject();
        }    
        
        var gml = this.format ? new this.format(options) : new OpenLayers.Format.GML(options);
		var features = gml.read(doc);
		
		if(this.styleUrl){
			//获取样式
	        OpenLayers.Request.GET({
	            async: false,
	            url: this.styleUrl,
	            success: function(result){
	                var jsonParser = new OpenLayers.Format.JSON();
	                this.thematicStyle = jsonParser.read(result.responseText);
	            },
	            failure: function(request){
	                alert("加载专题图样式文件 " + this.styleUrl + " 出现错误。");
				},
	            scope: this
	        });
		}
		//设置样式
		this.setThematicFeaturesStyle(features, this.thematicStyle);
		
        this.addFeatures(features);
		this.addThematicLegend();
        this.events.triggerEvent("loadend");
    },
    
    /**
     * Method: requestFailure
     * 请求GML文件失败回调函数。
     *
     * Parameters:
     * request - {String} 
     */
    requestFailure: function(request) {
        OpenLayers.Console.userError(OpenLayers.i18n("errorLoadingGML", {'url':this.gmlUrl}));
        this.events.triggerEvent("loadend");
    },
	
    /**
     * Method: setThematicFeaturesStyle
     * 设置专题图要素的样式。
     *
     * Parameters:
     * features - {<Geo.Feature.Vector>} 专题图要素。
     * thematicStyle - {Object} 样式对象。
     */
	setThematicFeaturesStyle: function(features, thematicStyle) {
		if(!thematicStyle){
			return;
		}
		var propertyName = thematicStyle.Renditions.PropertyRendition.PropertyName;
		var rangeValueRules = thematicStyle.Renditions.PropertyRendition.RangeValueRule;
		
        for (var i = 0; i < features.length; i++) {
			var style = {};
			var propertyRange = features[i].attributes[propertyName];
			for (var j = 0; j < rangeValueRules.length; j++) {
				var bottomValue = Number(rangeValueRules[j].BottomValue);
				var topValue = Number(rangeValueRules[j].TopValue);
				//判断属性值的取值区间，并获取样式。
                if (((rangeValueRules[j].IncludeBottom && bottomValue == propertyRange) || bottomValue < propertyRange) && 
				((rangeValueRules[j].IncludeTop && topValue == propertyRange) || propertyRange < topValue)) {
					style = {
						fillColor: rangeValueRules[j].PolygonRendition.FillColor,
						fillOpacity: Number(rangeValueRules[j].PolygonRendition.FillOpacity),
						strokeColor: rangeValueRules[j].PolygonRendition.StrokeColor,
						strokeOpacity: Number(rangeValueRules[j].PolygonRendition.StrokeOpacity),
						strokeWidth: Number(rangeValueRules[j].PolygonRendition.StrokeWidth)
					}
					break;
                }
			}
        	features[i].style = style;
        }
    },
	
    /**
     * Method: addThematicLegend
     * 添加专题图图例。
     */
	addThematicLegend: function() {
        if (!this.thematicStyle || !this.map) {
            return;
        }
		var div = document.createElement("DIV");
		this.thematicLegendDIV = div;
		div.id = "pieLegendContainer";
		div.style.position = "absolute";
		div.style.zIndex = "1000";
		div.style.right = "5px";
		div.style.bottom = "5px";
		div.style.border = "#15589a 1px solid";
		div.innerHTML = '<div id="legendTitle"><span>图例</span></div><div id="legendContent"></div>';
		this.map.viewPortDiv.appendChild(div);
		document.getElementById("legendContent").innerHTML = '';
		var rangeValueRules = this.thematicStyle.Renditions.PropertyRendition.RangeValueRule;
		for (var i = 0; i < rangeValueRules.length; i++) {
	        document.getElementById("legendContent").innerHTML += '<div class="legend-item">' +
	        '<span class="legend-color" style="background-color: ' + rangeValueRules[i].PolygonRendition.FillColor + ';"></span>' +
            '<span class="legend-itemName">' + rangeValueRules[i].BottomValue + ' - ' + rangeValueRules[i].TopValue + '</span></div>';
		}
	},
	
    /**
     * Method: removeThematicLegend
     * 删除专题图图例。
     */
	removeThematicLegend: function() {
		if (!this.map) {
            return;
        }
		if(this.map.viewPortDiv){
			this.map.viewPortDiv.removeChild(this.thematicLegendDIV);
		}
		this.thematicLegendDIV.innerHTML = "";
		this.thematicLegendDIV = null;
	},
	
    CLASS_NAME: "Geo.View2D.Layer.GeoThematicLayer"
});
﻿/**
 * Class: Geo.View2D.Layer.HeatMapLayer
 * 热图图层类，继承自Geo.View2D.Layer类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 *
 * Inherits from:
 *  - <Geo.View2D.Layer>
 */
Geo.View2D.Layer.HeatMapLayer = Geo.Class(Geo.View2D.Layer, {
	
	/**
	 * Property: heatmap
	 * {Object} 热图对象。
	 */
    heatmap: null,
	
	/**
	 * Property: tmpData
	 * {Object} 保存的数据。
	 */
    tmpData: null,
	
	/**
	 * APIProperty: heatmapOptions
	 * {Object} 热图参数对象。
     * 	 visible {Boolean} 最大数量。
     *   radius {Number} 半径数值。
     *   legend {Object} 图例选项。需要图例则设置，不需要图例不用设置。
     *   gradient {Object} 渐变的颜色。
     *   
	 */
	heatmapOptions: null,
	
	/**
     * Constructor: Geo.View2D.Layer.HeatMapLayer
     * 创建热图图层对象实例。
     *
     * Parameters:
     * name - {String} 图层名称。
     * options - {Object} 对象构造参数。
     */
    initialize: function(name, options){
        Geo.View2D.Layer.prototype.initialize.apply(this, [name, options]);
	},
	
    /** 
     * Method: setMap
     * 设置地图对象。
     * 
     * Parameters:
     * map - {<Geo.View2D.Map>} 
     */
    setMap: function(map){
        Geo.View2D.Layer.prototype.setMap.apply(this, arguments);
		
        var heatdiv = document.createElement("div");
		heatdiv.style.cssText = "position:absolute;width:" + this.map.size.w + "px;height:" + this.map.size.h + "px;";
        // this will be the heatmaps element
        this.div.appendChild(heatdiv);
        // add to our heatmap.js config
        this.heatmapOptions.element = heatdiv;
        this.heatmapOptions.map = map;
        // create the heatmap with passed heatmap-options
        this.heatmap = h337.create(this.heatmapOptions);
		
        // on zoomend and moveend we have to move the canvas element and redraw the datapoints with new positions
        this.map.events.on({
            "zoomend": this.updateLayer,
            "moveend": this.updateLayer,
            scope: this
        });
		//this.map.events.register("zoomend", this, this.updateLayer);
    },

    /** 
     * Method: updateLayer
     */
    updateLayer: function(){
		if (this.tmpData && this.tmpData.max) {
			var pixelOffset = this.getPixelOffset();
			var el = this.heatmap.get('element');
			// if the pixeloffset e.g. for x was positive move the canvas element to the left by setting left:-offset.y px 
			// otherwise move it the right by setting it a positive value. same for top
			el.style.top = ((pixelOffset.y > 0) ? ('-' + pixelOffset.y) : (Math.abs(pixelOffset.y))) + 'px';
			el.style.left = ((pixelOffset.x > 0) ? ('-' + pixelOffset.x) : (Math.abs(pixelOffset.x))) + 'px';
			
			this.setDataSet(this.tmpData);
		}
    },
	
    /** 
     * Method: getPixelOffset
     */
    getPixelOffset: function(){
        var o = this.map.layerContainerOrigin, o_lonlat = new OpenLayers.LonLat(o.lon, o.lat), o_pixel = this.getViewPortPxFromLonLat(o_lonlat), c = this.map.center, c_lonlat = new OpenLayers.LonLat(c.lon, c.lat), c_pixel = this.getViewPortPxFromLonLat(c_lonlat);
        
        return {
            x: o_pixel.x - c_pixel.x,
            y: o_pixel.y - c_pixel.y
        };
        
    },
	
    /** 
     * APIMethod: setDataSet
     * 设置数据集。
     * 
     * Parameters:
     * obj - {Object} 
     * 	 max {Number} (必选) 最大数量。
     *   data {Object} (必选) 数据。例如：[{lat: 33.5363, lon:-117.044, count: 1},{lat: 33.5608, lon:-117.24, count: 1}]
     */
    setDataSet: function(obj){
        var set = {}, dataset = obj.data, dlen = dataset.length, entry, lonlat, pixel;
        
        set.max = obj.max;
        set.data = [];
        // get the pixels for all the lonlat entries
        while (dlen--) {
            entry = dataset[dlen];
			lonlat = entry.lonlat.clone().transform(this.projection, this.map.getProjectionObject());
			pixel = this.roundPixels(this.getViewPortPxFromLonLat(lonlat));
            
            if (pixel) {
                set.data.push({
                    x: pixel.x,
                    y: pixel.y,
                    count: entry.count
                });
            }
        }
        this.tmpData = obj;
        this.heatmap.store.setDataSet(set);
    },
	
    /**
     * Method: roundPixels
     */
    roundPixels: function(p){
        if (p.x < 0 || p.y < 0) {
            return false;
        }
        
        p.x = (p.x >> 0);
        p.y = (p.y >> 0);
        
        return p;
    },
	
    /**
     * Method: addDataPoint
     */
    addDataPoint: function(lonlat){
        var pixel = this.roundPixels(this.getViewPortPxFromLonLat(lonlat));
        var entry = {
            lonlat: lonlat
        };
		var args;
        
        if (arguments.length == 2) {
            entry.count = arguments[1];
        }
        
        this.tmpData.data.push(entry);
        
        if (pixel) {
            args = [pixel.x, pixel.y];
            
            if (arguments.length == 2) {
                args.push(arguments[1]);
            }
            this.heatmap.store.addDataPoint.apply(this.heatmap.store, args);
        }
        
    },
	
    /**
     * APIMethod: toggle
     * 显示或隐藏热图。
     */
    toggle: function(){
        this.heatmap.toggleDisplay();
    },
	
    /**
     * APIMethod: toggleLegend
     * 显示或隐藏热图图例。
     */
    toggleLegend: function(){
        if (this.heatmap.get("legend")) {
            var display = this.heatmap.get("legend").getElement().style.display;
            if (display == "" || display == "block") {
                this.heatmap.get("legend").getElement().style.display = "none";
            }
            else {
                this.heatmap.get("legend").getElement().style.display = "block";
            }
        }
    },
	
    /**
     * APIMethod: destroy
     * 销毁该对象。
     */
    destroy: function(){
		//清除热图数据。
		this.heatmap.cleanup();
		if(this.map && this.heatmap.get("legend")){
			this.map.viewPortDiv.removeChild(this.heatmap.get("legend").getElement());
		}
		
		//取消事件监听。
		this.map.events.un({
            "zoomend": this.updateLayer,
            "moveend": this.updateLayer,
            scope: this
        });
        Geo.View2D.Layer.prototype.destroy.apply(this, arguments);
    },
	
    CLASS_NAME: "Geo.View2D.Layer.HeatMapLayer"
});
/**
 * Class: Geo.View2D.Layer.ThematicTile
 * 基于专题图服务的专题图图层。
 * 
 * Inherits from:
 *  - <Geo.View2D.Layer.Grid>
 */
Geo.View2D.Layer.ThematicTile = OpenLayers.Class(OpenLayers.Layer.Grid, {
	
	/**
     * Constant: DEFAULT_PARAMS
     * {Object} 默认键值对的Hashtable 
     */
    DEFAULT_PARAMS: {
		version: "1.0.0",
		format: "jpeg"
	},
	
	/**
     * APIProperty: version
     * {String} 服务版本。
     */
	version:"1.0.0",

	/**
     * APIProperty: layerID
     * {String} 图层ID。
     */
	layerID: null,
	
	/**
     * APIProperty: chartID
     * {String} 专题符号标识。
     */
	chartID: null,
	
	/**
     * APIProperty: maxExtent
     * {Geo.Bounds} 图层的最大范围。
     */
	maxExtent: null,
	
	/**
     * APIProperty: format
     * {String} 图片样式。
     */
	format: "png",
	
	/**
     * APIProperty: colorSchemeID
     * {String} 色卡标识。
     */
	colorSchemeID: null,
	
	/**
	 * APIProperty: hasLegend
	 * {Boolean} 是否显示图例，默认值为true。
	 */
	hasLegend: true,
	
	/**
	 * APIProperty: legendSize
	 * {Geo.Size} 图例的宽高。
	 */
	legendSize: new Geo.Size(250,250),
	
	/**
	 * APIProperty: legendPosition     
	 * {String} 图例显示方位，默认为右下角。左上角：tl、左下角：bl、右上角：tr、右下角：br。
	 */
	legendPosition:"br",
	
	/**
	 * APIProperty: hasEdge
	 * {Boolean} 是否绘制专题图符号的边线，默认值为true。
	 */
	hasEdge: true,
	
	/**
	 * APIProperty: hasLabel
	 * {Boolean} 是否绘制专题图符号的标注，默认值为true。
	 */
	hasLabel: true,
	
	/**
	 * Property: vectorLayer
	 * {String} 示例图层。
	 */
	vectorLayer: null,
	
	/**
	 * APIProperty: thematicTipsListeners
	 * {Object}鼠标移入移出专题图数据时的事件监听。可自定义featureout、featureover事件监听的函数实现。实现专题图数据的自定义鼠标交互功能。
	 */
	thematicTipsListeners: null,
	
	/**
	 * APIProperty: featureoverCallback
	 * 鼠标经过要素时的回调,如果用户需要自定义专题图提示功能，则需要覆盖本方法
	 */
	featureoverCallback: null,
	
	/**
	 * APIProperty: featureoutCallback
	 * 鼠标移除要素时的回调,如果用户需要自定义专题图提示功能，则需要覆盖本方法
	 */
	featureoutCallback: null,
	
	//TODO:控制瓦片的请求级别，通过图层的最大范围来控制显示级别。
	/**
	 * Constructor: Geo.View2D.Layer.ThematicTile
     * 创建一个专题图图层。
     *
     * Parameters:
     * name - {String} 图层名称。
     * url - {String} 专题图服务地址。
     * params - {Object} 本项目前暂不使用。
     * options - {Object} 对象构造参数（可选）。
     * > layerID -  {String} 图层ID。
	 * > hasLegend - {Boolean} 是否显示图例。
	 * > hasEdge - {Boolean} 是否绘制专题图符号的边线。
	 * > hasLabel - {Boolean} 是否绘制专题图符号的标注。
	 * > chartID - {String} 专题符号标识。 
	 * > thematicTipsListeners - {Object} 实现专题图提示的相关事件
	 * 
	 * Examples:
	 * (code)
	 * 	//添加专题图图层
	 *		var thmatic = new Geo.View2D.Layer.ThematicTile("t",Cfg.map2DThematicUrl_JS,{},{
 	 *			layerID: Cfg.map2DThematicLayerID_JS,
	 *			hasLegend: Cfg.map2DThematicHasLegend_JS,
	 *			chartID:Cfg.map2DThematicchartID_JS,
	 *			//鼠标移入移出专题图数据时的事件监听
	 *			thematicTipsListeners:{
	 *				//鼠标移出事件
	 *				featureout:function(e) {
	 *					e.feature.style.fillOpacity = 0;
	 *					e.feature.style.strokeOpacity = 0;
	 *					thmatic.vectorLayer.drawFeature(e.feature);
	 *					var popups = map.popups;
	 *					for(var i = 0;i < popups.length;i++) {
	 *						map.removePopup(popups[i]);
	 *					}
	 *				},
	 *				//鼠标移入事件
	 *				featureover:function(e) {
	 *	               	var popups = map.popups;
	 *					for(var i = 0;i < popups.length;i++) {
	 *						map.removePopup(popups[i]);
	 *					}
	 *					var text = e.feature.attributes.text;
	 *					var center = e.feature.geometry.getCentroid();	
	 *					e.feature.style.fillOpacity = 0.7;
	 *					e.feature.style.strokeOpacity = 0.7;
	 *					thmatic.vectorLayer.drawFeature(e.feature);
	 *					var popup = new OpenLayers.Popup.FramedCloud("", 
     *		 	                new Geo.LonLat(center.x,center.y),null,text,null, false);
	 *					map.addPopup(popup);
	 *	            }
	 *			},
	 *			maxExtent: Geo.Bounds.fromString(Cfg.map2DThematic_maxExtent_JS)
	 *		});
	 * (end)
	 */
	initialize: function(name, url, params, options) {
		if(params == null){
			params = {};
		}
		this.getCapabilities(url,OpenLayers.Function.bind(function(result){
			//响应返回capabilities的XML文档信息
            var data = result.responseXML;
            if (!data || !data.documentElement) {
                data = result.responseText;
            }
            var data = eval('(' + data + ')');
            var layers = data.layers[0];
            if(options!=null){
            	if(options.layerID==null){//专题图图层标识
            		options.layerID = layers.id;
            	}
            	if(options.hasLegend==null){//是否显示专题图图例
            		options.hasLegend = true;
            	}
            	if(options.hasLabel==null){
            		options.hasLabel = false;
            	}
            	if(options.chartID==null){//专题图符号标识
            		if(layers.chartID==null){
						options.chartID = layers.charts[0].id;
					}else{
						options.chartID = layers.chartID[0].id;
					}
            	}
            	if(options.maxExtent==null){//专题图图层范围
            		options.maxExtent = Geo.Bounds.fromString(layers.fullExtent.minx+","+layers.fullExtent.miny+","+layers.fullExtent.maxx+","+layers.fullExtent.maxy);
            	}
            }else{
            	options = {};
            	options.layerID = layers.id;//专题图图层标识
            	options.hasLegend = true;//是否显示专题图图例
            	options.hasLabel = false;
            	if(layers.chartID==null){//专题图符号标识
					options.chartID = layers.charts[0].id;
				}else{
					options.chartID = layers.chartID[0].id;
				}
				//专题图图层范围
				options.maxExtent = Geo.Bounds.fromString(layers.fullExtent.minx+","+layers.fullExtent.miny+","+layers.fullExtent.maxx+","+layers.fullExtent.maxy);
            }
        }, this),
		function(){
            alert("专题图服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
        });
	
	
        var newArguments = [];
        //uppercase params
        params = OpenLayers.Util.upperCaseObject(params);
        if (parseFloat(params.VERSION) >= 1.3 && !params.EXCEPTIONS) {
            params.EXCEPTIONS = "INIMAGE";
        } 
        newArguments.push(name, url, params, options);
		this.singleTile = true;
        OpenLayers.Layer.Grid.prototype.initialize.apply(this, newArguments);
        OpenLayers.Util.applyDefaults(
                       this.params, 
                       OpenLayers.Util.upperCaseObject(this.DEFAULT_PARAMS)
                       );

        //layer is transparent        
        if (!this.noMagic && this.params.TRANSPARENT && 
            this.params.TRANSPARENT.toString().toLowerCase() == "true") {
            
            // unless explicitly set in options, make layer an overlay
            if ( (options == null) || (!options.isBaseLayer) ) {
                this.isBaseLayer = false;
            } 
            
            // jpegs can never be transparent, so intelligently switch the 
            //  format, depending on the browser's capabilities
            if (this.params.FORMAT == "image/jpeg") {
                this.params.FORMAT = OpenLayers.Util.alphaHack() ? "gif"
                                                                 : "png";
            }
        }
		var featureoverCallback = this.featureoverCallback || 
		OpenLayers.Function.bind(function(e) {
					
															 
					var center = e.feature.geometry.getCentroid();										 
		//			var px2 = this.map.getLayerPxFromLonLat({
		//            lon: bounds.right,
		//            lat: bounds.bottom
		//        });
					
					if(this.timerId1 !== null) {
	            window.clearTimeout(this.timerId1);
	            this.timerId1 = null;
	        }
			
				//延迟4秒关闭
				this.timerId1 = window.setTimeout(
		            OpenLayers.Function.bind(function() {
		               	var popups = map.popups;
						for(var i = 0;i < popups.length;i++) {
							map.removePopup(popups[i]);
						}
						var text = e.feature.attributes.text;
						var center = e.feature.geometry.getCentroid();	
						e.feature.style.fillOpacity = 0.7;
						e.feature.style.strokeOpacity = 0.7;
						this.vectorLayer.drawFeature(e.feature);
						var popup = new OpenLayers.Popup.FramedCloud("", 
			                new Geo.LonLat(center.x,center.y),
			                null,
			                text,
			            null, false);
						map.addPopup(popup);
						this.couter++;
		            }, this),
		            200
		        )
				}, 
                this);
		
	var featureoutCallback = this.featureoutCallback ||
		OpenLayers.Function.bind(function(e) {
			e.feature.style.fillOpacity = 0;
			e.feature.style.strokeOpacity = 0;
			this.vectorLayer.drawFeature(e.feature);
			var popups = map.popups;
					for(var i = 0;i < popups.length;i++) {
						map.removePopup(popups[i]);
					}
			}, this);
			var eventListeners = this.thematicTipsListeners || {
				featureover: featureoverCallback,
				featureout: featureoutCallback
			};
			this.vectorLayer = new Geo.View2D.Layer.Vector("hotArea", {
				maxExtent : this.maxExtent,
				eventListeners: eventListeners
			});
			this.jsonp = new OpenLayers.Protocol.Script();
			//图层开始加载的时候清除数据
			this.events.on({
		        "moveend": OpenLayers.Function.bind(this.updateHotArea, 
	                this)
		    });
    },
    
    
    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(url,successFn, failFn){
        var params = {
           REQUEST: "GetCapabilities",
           SERVICE: "TMS",
           f: "json"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("专题图服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
            };
        }
        OpenLayers.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },
    
	
	/**
	 * Method: setOpacity
	 * 设置图例专题图例透明度
	 * 
	 * opacity {Number} 透明度
	 */
	setOpacity: function(opacity){
		OpenLayers.Layer.Grid.prototype.setOpacity.apply(this, [opacity]);
		//TODO：图例的透明度,没有经过测试
		if ( this.imageLegend && this.imageLegend.parentNode) {
			OpenLayers.Util.modifyDOMElement(this.imageLegend, null, null, null, 
                                                 null, null, null, opacity);
		}
	},
	
	/**
	 * Method: display
	 * 设置图例可见性。
	 * 
	 * display {Boolean} 是否可见。
	 */
	display: function(display){
		OpenLayers.Layer.Grid.prototype.display.apply(this, [display]);
		//TODO:增加对图例可见性的设置,没有经过测试
		if (this.imageLegend && this.imageLegend.parentNode) {
			 if (display != (this.div.style.display != "none")) {
				this.imageLegend.style.display = display;
	        }
		}
	},
	
	/**
	 * Method: getLegend
	 * 得到图例。
	 * 
	 * options {Object} 可选项。
	 */
	getLegend: function(options) {
		//http://192.168.42.76:7021/ThematicMapService/tms/legend/0/020101.png?ColorSchemaID=3
		var location = this.url.indexOf("/",this.url.length - 1);
		if(location != -1) {
			this.url = this.url.substr(0,this.url.length - 1);
		}
		var path =  "${url}/legend/${layerID}/${chartID}.${format}";//?colorSchemaID = ${colorSchemaID}
		path = Geo.String.format(path, {
			'url': this.url, 
			'layerID': options.layerID, 
			'chartID': options.chartID,
			'format': options.format || "png"
		});
		if(typeof options.colorSchemeID === "string") {
			path += ("?colorSchemeID=" + options.colorSchemeID);
		}
		return path;
	},
	
	/**
	 * Method: showLegend
	 * 显示图例。
	 * 
	 * TODO:属性中需要增加图例的显示方位，显示大小。
	 */
	showLegend: function() {
		var path = this.getLegend({
			layerID:this.layerID,
			chartID:this.chartID,
			ColorSchemeID: this.ColorSchemeID
		});
		//(id, px, sz, imgURL, position, border,opacity, delayDisplay)
		if(!this.imageLegend) {
			this.imageLegend = Geo.Util.createImage(this.id,new Geo.Pixel(0,0),this.legendSize,path);
			this.imageLegend.style.zIndex = this.map.Z_INDEX_BASE['Popup'];
			this.setLegendLocation(this.imageLegend);
			this.map.viewPortDiv.appendChild(this.imageLegend);
		}else{
			this.setLegendLocation(this.imageLegend);
		}
	},
	
	/**
	 * Method: setLegendLocation
	 * 设置图例位置
	 * TODO:属性中需要增加图例的显示方位，显示大小。
	 * imageLegend  {DOM}
	 */
	setLegendLocation: function(imageLegend) {
		var size = this.map.getSize();
		switch(this.legendPosition) {
			case "br": 
				var x = size.w - this.legendSize.w;
				var y = size.h - this.legendSize.h;
				imageLegend.style.left = x+"px";
				imageLegend.style.top = y+"px";
			break;
			case "bl":
				var y = size.h - this.legendSize.h;
				imageLegend.style.left = 0+"px";
				imageLegend.style.top = y+"px";
			break;
			case "tl":
				imageLegend.style.left = 0+"px";
				imageLegend.style.top = 0+"px";
			break;	
			case "tr":
				var x = size.w - this.legendSize.w;
				imageLegend.style.left = x+"px";
				imageLegend.style.top = 0+"px";
			break;
		}
	},
	
	/**
	 * Method: updateHotArea
	 * 更新热区。
	 * obj  {Geo.Events}
	 */
	updateHotArea: function(obj) {
		if(obj.zoomChanged) {
			this.vectorLayer.removeAllFeatures();
		}else {
			this.vectorLayer.redraw();
		}
		
		
	},

    /**
     * Method: clone
     * Create a clone of this layer
     *
     * Returns:
     * {<OpenLayers.Layer.WMS>} An exact clone of this layer
     */
    clone: function (obj) {
        
        if (obj == null) {
            obj = new Geo.View2D.Layer.ThematicTile(this.name,
                                           this.url,
                                           this.params,
                                           this.getOptions());
        }

        //get all additions from superclasses
        obj = OpenLayers.Layer.Grid.prototype.clone.apply(this, [obj]);

        // copy/set any non-init, non-simple values here

        return obj;
    },    
	
    
    /**
     * Method: getURL
     * Return a GetMap query string for this layer
     *
     * Parameters:
     * bounds - {<OpenLayers.Bounds>} A bounds representing the bbox for the
     *                                request.
     *
     * Returns:
     * {String} A string with the layer's url and parameters and also the
     *          passed-in bounds and appropriate tile size specified as 
     *          parameters.
     */
    getURL: function (bounds) {
        bounds = this.adjustBounds(bounds);
        var imageSize = this.getImageSize();
//		this.getTileFeature(bounds,imageSize);
        var newParams = {};
		//http://192.168.42.76:7021/ThematicMapService/tms/map/0/020101/
		//87.6061172485352/20.0317935943604/126.643341064453/45.7414932250977/1024/1024.png?
		//ColorSchemaID=3&hasLegend=true&hasEdge=true&hasLabel=true
      	//var requestString = this.getFullRequestString(newParams);
		var url = "${url}/map/${layerID}/${chartID}/${left}/${bottom}/${right}/${top}/${width}/${height}.${format}?"+
		"hasLegend=${hasLegend}&hasEdge=${hasEdge}&hasLabel=${hasLabel}";
		url = OpenLayers.String.format(url, {
			'url': this.url,
			'layerID': this.layerID,
			'chartID': this.chartID,
			'left': bounds.left,
			'bottom': bounds.bottom,
			'right':bounds.right,
			'top': bounds.top,
			'width': imageSize.w,
			'height': imageSize.h,
			'format': this.format,
			'hasLegend':this.hasLegend,
			'hasEdge': this.hasEdge,
			'hasLabel': this.hasLabel,
			'colorSchemeID': this.colorSchemeID
		});
		if(typeof this.colorSchemeID === "string") {
			url += ("&colorSchemeID=" + this.colorSchemeID);
		}
		//&ColorSchemaID=${ColorSchemaID}
        return url;
    },
	
	/**
	 * Method: initSingleTile
	 * 请求单个瓦片。
	 * bounds -  {Geo.Bounds} 获取范围。
	 */
	initSingleTile: function(bounds){
		OpenLayers.Layer.Grid.prototype.initSingleTile.apply(this, 
                                                             arguments);
		var center = bounds.getCenterLonLat();
        var tileWidth = bounds.getWidth() * this.ratio;
        var tileHeight = bounds.getHeight() * this.ratio;
                                       
        var tileBounds = 
            new OpenLayers.Bounds(center.lon - (tileWidth/2),
                                  center.lat - (tileHeight/2),
                                  center.lon + (tileWidth/2),
                                  center.lat + (tileHeight/2));
  
        var px = this.map.getLayerPxFromLonLat({
            lon: tileBounds.left,
            lat: tileBounds.top
        });
		var px2 = this.map.getLayerPxFromLonLat({
            lon: tileBounds.right,
            lat: tileBounds.bottom
        });
		var pixelsize = new Geo.Size((px2.x - px.x),(px2.y - px.y));
		if(this.timerId !== null) {
            window.clearTimeout(this.timerId);
            this.timerId = null;
        }
		
		//延迟4秒关闭
		this.timerId = window.setTimeout(
            OpenLayers.Function.bind(function() {
               this.getTileFeature(tileBounds,pixelsize);
            }, this),
            80
        )													 
		
	},
	
	/**
	 * Method: getTileFeature
	 * 得到与瓦片相对应的要素。
	 * bounds -  {Geo.Bounds} 获取范围。
	 * mapSize -  {Geo.Size} 地图范围。
	 */
	getTileFeature: function(bounds,mapSize) {
		var url = "${url}/hotarea/${layerID}/${chartID}/${left}/${bottom}/${right}/${top}/${width}/${height}?f=json";
		url = OpenLayers.String.format(url, {
			'url': this.url,
			'layerID': this.layerID,
			'chartID': this.chartID,
			'left': bounds.left,
			'bottom': bounds.bottom,
			'right':bounds.right,
			'top': bounds.top,
			'width': mapSize.w,
			'height': mapSize.h
		});
		this.jsonp.createRequest(url,null, OpenLayers.Function.bind(function(result) {
			var failFn = failFn || this.failFn;
			if(result.error) {
				failFn(result.error);
				return;
			}
			var hotAreas = result.HotAreas;
			var features = [];
			if(hotAreas) {
				var polygonstyle = Geo.Util.extend({},OpenLayers.Feature.Vector.style['default']);
				polygonstyle.fillOpacity = 0;
				polygonstyle.strokeOpacity = 0;
				for(var i = 0,len = hotAreas.length; i < len; i++) {
					polygonstyle.text = hotAreas[i].text;
					var f = new Geo.Feature.Vector(this._getGeometry(hotAreas[i].geometry,bounds,hotAreas[i].text),polygonstyle,polygonstyle);
					features.push(f);
				}
			}
			if(features.length > 0) {
				
				this.vectorLayer.removeAllFeatures();
				this.vectorLayer.addFeatures(features);
			}
			if(this.hasLegend) {
				this.showLegend();
			}
			//successFn();
		},this));
	},
	
	/**
	 * Method: _getGeometry
	 * 得到openlayers几何对象
	 * 
	 * Parameters:
	 * geometry - {Geo.Geometry} 几何对象。
	 * bounds - {Geo.Bounds} 地图范围。
	 * text - {String} 文字信息。
	 */
	_getGeometry: function(geometry,bounds,text) {
		for(var pro in geometry) {
			//TODO：服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new OpenLayers.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				var geometry = new OpenLayers.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
				//TODO:需要增加多点类型
			}else {
				var geometry = this._geometryType[pro].apply(this, [geometry[pro],bounds,text]);
			}
			return geometry;
		}
	},
	
	/**
	 * Method: convertPixelsToLonLats
	 * 像素转经纬度
	 * 
	 * Parameters:
	 * pixels - {Geo.Pixels} 像素。
	 * bounds - {Geo.Bounds} 地图范围。
	 */
	convertPixelsToLonLats: function(pixels,bounds) {
		var px = this.map.getLayerPxFromLonLat({
            lon: bounds.left,
            lat: bounds.top
        });
//		var res = this.map.getResolution();
//		var width = (px.x + pixels[0]) * res;
//		var height = (px.y + pixels[1]) * res;
		var px2 = this.map.getLayerPxFromLonLat({
            lon: bounds.right,
            lat: bounds.bottom
        });
		var pixelsize = new Geo.Pixel((px2.x - px.x),(px2.y - px.y));
		
	//	var size = this.map.getSize();
		var widLon = (pixels[0]/pixelsize.x)*(bounds.right -bounds.left);
		var widLat = (pixels[1]/pixelsize.y)*(bounds.bottom -bounds.top);
		
	//	var res = this.map.getResolution();
//		var lon = pixels[0]*res;
//		var lat = pixels[1]*res;
		return [bounds.left + widLon,bounds.top + widLat];
	},
	
	/**
	 * Method: 将几何信息的json表示转换成openlayers几何对象。
	 */		
	_geometryType: {
		"points": function(geometry,bounds,text) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var lonlat = this.convertPixelsToLonLats(geometry[i],bounds);
					var point = new OpenLayers.Geometry.Point(lonlat[0], lonlat[1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry,bounds,text) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						var lonlat = this.convertPixelsToLonLats(geometry[i][p],bounds);
						ps.push(new OpenLayers.Geometry.Point(lonlat[0],lonlat[1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new OpenLayers.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry,bounds,text) {
			var lines = [];

			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						var lonlat = this.convertPixelsToLonLats(geometry[i][p],bounds);
						ps.push(new OpenLayers.Geometry.Point(lonlat[0],lonlat[1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var polygonstyle = Geo.Util.extend({},OpenLayers.Feature.Vector.style['default']);
				var Polygon = new OpenLayers.Geometry.Polygon(lines, null, polygonstyle);
			}
			
			
			return Polygon;
		}
	},
	
    /**
     * Method: mergeNewParams
     * Catch changeParams and uppercase the new params to be merged in
     *     before calling changeParams on the super class.
     * 
     *     Once params have been changed, the tiles will be reloaded with
     *     the new parameters.
     * 
     * Parameters:
     * newParams - {Object} Hashtable of new params to use
     */
    mergeNewParams:function(newParams) {
        var upperParams = OpenLayers.Util.upperCaseObject(newParams);
        var newArguments = [upperParams];
        return OpenLayers.Layer.Grid.prototype.mergeNewParams.apply(this, 
                                                             newArguments);
    },
	
	/**
     * Method: setMap
     *
     * Parameters:
     * map - {<OpenLayers.Map>} The map.
     */
    setMap: function(map) {
		OpenLayers.Layer.Grid.prototype.setMap.call(this, map);
		map.events.register('mousemove', this, OpenLayers.Function.bind(function(evt) {
			this._mouselonLatPosition = map.getLonLatFromPixel(evt.xy);
//			var _mouselonLatPosition = this._mouselonLatPosition;
//			var features = this.vectorLayer.features;
//			var count = 0;
//			for(var i = 0,len = features.length; i < len; i++ ) {
//				var isIntersect = features[i].geometry.intersects(new Geo.Geometry.Point(_mouselonLatPosition.Lon,_mouselonLatPosition.Lat));
//				if(!isIntersect) {
//					count++;
//				}
//				
//			}
//			if(count === features.length) {
//				if(this.timerId1 !== null) {
//            window.clearTimeout(this.timerId1);
//            this.timerId1 = null;
//			return;
//        }
//		
//		//延迟4秒关闭
//		this.timerId1 = window.setTimeout(
//		            OpenLayers.Function.bind(function() {
//		               	var popups = map.popups;
//						for(var i = 0;i < popups.length;i++) {
//							map.removePopup(popups[i]);
//						}
//		            }, this),
//		            2000
//		        )
//			}
		}, this));
		map.addLayer(this.vectorLayer);
    },
	
	/**
     * Method: removeMap
     * Called when the layer is removed from the map.
     *
     * Parameters:
     * map - {<OpenLayers.Map>} The map.
     */
    removeMap: function(map) {
		//清除要素（热区）
		this.vectorLayer.destroyFeatures(this.vectorLayer.features);
		//移除本图层
        OpenLayers.Layer.Grid.prototype.removeMap.call(this, map);
		for(var m = 0,len = map.layers.length; m < len;m++) {
			if(map.layers[m].id === this.vectorLayer.id) {
				//清除矢量图层
				map.removeLayer(this.vectorLayer);
				break;
			}
		}
		if (this.imageLegend && this.imageLegend.parentNode) {
			//移除图例
            this.imageLegend.parentNode.removeChild(this.imageLegend);
			this.imageLegend = null;
        }
		this.map.events.un({
	        "zoomend": this.updateHotArea
	    });
		this.jsonp.destroy();
    },

    /** 
     * Method: getFullRequestString
     * Combine the layer's url with its params and these newParams. 
     *   
     *     Add the SRS parameter from projection -- this is probably
     *     more eloquently done via a setProjection() method, but this 
     *     works for now and always.
     *
     * Parameters:
     * newParams - {Object}
     * altUrl - {String} Use this as the url instead of the layer's url
     * 
     * Returns:
     * {String} 
     */
    getFullRequestString:function(newParams, altUrl) {
        var mapProjection = this.map.getProjectionObject();
        var projectionCode = this.projection && this.projection.equals(mapProjection) ?
            this.projection.getCode() :
            mapProjection.getCode();
        var value = (projectionCode == "none") ? null : projectionCode;
        if (parseFloat(this.params.VERSION) >= 1.3) {
            this.params.CRS = value;
        } else {
            this.params.SRS = value;
        }
        
        if (typeof this.params.TRANSPARENT == "boolean") {
            newParams.TRANSPARENT = this.params.TRANSPARENT ? "TRUE" : "FALSE";
        }

        return OpenLayers.Layer.Grid.prototype.getFullRequestString.apply(
                                                    this, arguments);
    },

    CLASS_NAME: "Geo.View2D.Layer.ThematicTile"
});﻿﻿﻿﻿﻿﻿﻿﻿﻿/**
 * Class: Geo.View2D.Layer.GeoText
 * 文字图层，继承自Geo.View2D.Layer.Vector类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Layer.Vector>
 */
Geo.View2D.Layer.GeoText = Geo.Class(Geo.View2D.Layer.Vector,	{
	
	/**
     * Property: renderers
     * {Array(String)} 目前只支持canvas绘制
     */
    renderers: ['Canvas'],
	
	/**
	 * APIProperty: url
	 * {String} 文字服务地址。
	 */
	url: null,
	
	/**
	 * APIProperty: eachRowNumer
	 * {Number} 点要素的文字标注每行显示的文字个数。
	 */
	eachRowNumer: 4,
	
	/**
	 * APIProperty: isCustomStyle
	 * {Boolean} 是否使用自定义样式。默认为false,即使用服务提供的样式。
	 */
	isCustomStyle: false,
	
	/**
	 * APIProperty: layersStyle
	 * {Object} 值的类型为json对象，格式为：{key:value}，其中key的取值为文字服务Root接口中的dateTableName节点的值，
	 * value的取值为Geo.Feature.Vector类的Geo.Feature.Vector.style属性的键值。
	 * > 取值举例：
	 *  > {
	 *		> 		"中学4490":{
	 *		> 			pointRadius:6,
	 *		> 			fillOpacity:0.5,
	 *		> 			fillColor:"blue",
	 *		> 			strokeColor:"red",
	 *	    >             fontSize: "12px"
	 *		> 		}
	 *		> 	}
	 * 图层样式说明：
	 *   文字标注的样式支持情况：
	 *   >  文字名称：支持。此名称用户不可设置，由服务提供。
	 *   >  文字颜色：支持。请参考js SDK类参考中Geo.Feature.Vector类的Geo.Feature.Vector.style属性的键值:fontColor。
	 *   >  文字标注背景颜色：GeoGlobe 5.1不支持。
	 *   >  字体样式：支持。请参考js SDK类参考中Geo.Feature.Vector类的Geo.Feature.Vector.style属性的键值:fontStyle。
	 *   >  注意：字体样式目前只支持"正常"和"右斜"两种样式。目前不支持："左斜","左耸","右耸"。
	 *   >  字体样式倾斜角度：GeoGlobe 5.1不支持。
	 *   >  文字偏移：GeoGlobe 5.1不支持。
	 *   >  字体样式倾斜角度：GeoGlobe 5.1不支持。
	 *   >  文字是否有下划线：GeoGlobe 5.1不支持。
	 *   >  文字是否有删除下：GeoGlobe 5.1不支持。
	 *   >  文字是否为粗体：支持。请参考js SDK类参考中Geo.Feature.Vector类的Geo.Feature.Vector.style属性的键值:fontWeight。
	 *   >  背景是否透明：GeoGlobe 5.1不支持。
	 *   >  文字是否有光晕：GeoGlobe 5.1不支持。
	 * 	 >  文字是否有阴影：GeoGlobe 5.1不支持。
	 * 	 >  文字阴影颜色：GeoGlobe 5.1不支持。
	 *   >  文字阴影偏移方向：GeoGlobe 5.1不支持。
	 *   >  文字阴影偏移方向：GeoGlobe 5.1不支持。
	 *   >  字体宽高：支持。请参考js SDK类参考中Geo.Feature.Vector类的Geo.Feature.Vector.style属性的键值:fontSize。
	 *   >  文字垂直对齐方式：GeoGlobe 5.1不支持。
	 * 	 >  文字水平对齐方式：GeoGlobe 5.1不支持。
	 */
	layersStyle: null,
	
	/**
	 * APIProperty: isHideGlandFeatures
	 * {Boolean} 是否消隐(是否隐藏被压住的要素)
	 */
	isHideGlandFeatures: false,
	
	/**
	 * Property: isShowLine
	 * {Boolean} 是否消隐(是否隐藏被压住的要素)
	 */
	isShowLine: false,
	
	/**
	 * Property: lineLabelDefaultStyle
	 * {Boolean} 沿线文字的默认样式。当服务没有提供沿线文字的样式时，本属性才会生效。
	 */
	lineLabelDefaultStyle: {
		fontColor: "#000000",
		fontFamily: "宋体",
		fontOpacity: 1,
		fontSize: "16px"
	},
	
	/**
	 * Property: textFeatures
	 * {Array(Geo.Feature.Vector)} 沿线标注
	 */
	textFeatures: [],
	
	/**
     * Property: pyramid
     * {<Geo.Pyramid>} 地图金字塔。
     */
	pyramid : null,
	
	/**
     * Property: isRotation
     * {Boolean} 是否旋转。
     */
	isRotation: false,
	
	/**
     * Property: pyramid
     * {<Geo.Pyramid>} 地图金字塔。
     */
	positionIndex: 1,
	
	//保存已经绘制的要素，防止重复绘制
	/**
     * Property: pyramid
     * {<Geo.Pyramid>} 地图金字塔。
     */
	drawFeatures: {},
	
	/**
	 * Property: isAvoidOuterMaxExtent
	 * {Boolean} 超出了图层最大范围的要素是否消隐，默认为true。
	 */
	isAvoidOuterMaxExtent: true,
	
	/**
	 * Property: currentFeatures
	 * {Array(Geo.Feature.Vector)} （消隐后）需要绘制的要素
	 */
	currentFeatures: null,
	
	/**
	 * Property: textCounter
	 * {Integer} 
	 */
	textCounter: 0,
	
	/**
	 * APIProperty: service
	 * {String} 服务类型。取值为TEXT。
	 */
	service:"TEXT",
	
	/**
	 *  Property: alongLineoffset
	 *  {Integer} 沿线文字的偏移
	 */
	alongLineoffset: null,
	
	/**
	 * APIProperty: labelCharSpace
	 * {Integer}单个字之间的距离（单位为像素）
	 */
	labelCharSpace: 9,
	
	/**
	 * Property: labelSpaceRadio
	 * {Integer}标签间的间隔系数（间隔距离与标签宽度的比）
	 */
	labelSpaceRadio:1,
	
	/**
	 * APIProperty: version
	 * {String} 文字服务版本。
	 */
	version:"1.0.0",
	
	/**
	 * APIProperty: layersID
	 * {Array(String)}图层id,取值方式：all/show/hide:1,2。
	 *	all表示请求文字服务所有的图层。
	 *	show取值举例：show:1,2，表示请求id为1,2的图层。
	 *	hide取值举例：hide:1,2，表示服务会请求图层id为1,2以外的图层。
	 */
	layersID: null,
	
	/**
	 * Property:directions
	 * {Array(String)} 标签方位
	 */
	directions:["rt","ct","cb","lt","rb","lb","rm","lm"],
	
	/**
	 * Property: avoidArea
	 * {Array(Geo.Bounds)}避让列表
	 */
	avoidArea: null,
	
    /**
     * Constructor: Geo.View2D.Layer.GeoText
     * 文字图层构造方法。
     *
     * Parameters:
     * name - {String} 图层名称。
     * options - {Object} 对象构造参数。类的公有属性可作为构造方法里options对象的选项。
     * 
     * Example:
     * (code)
     * 	var textLayer = new Geo.View2D.Layer.GeoText("text", {
	 *			url: "http://192.168.42.54:9010/test/Text",
	 *          //使用自定义样式时需设置本属性为true
	 *			isCustomStyle:true,
	 *			layersID: ("show:" + Cfg.geoTextService_layers),
	 *			service:"TEXT",
	 *			version: "1.0.0",
	 *          //在layersStyle属性中设置自定义样式
	 *			layersStyle: {
	                //"中学4490"为文字服务root接口中dataTableName节点的值。
	 *				"中学4490":{
	 *					pointRadius:6,
	 *					fillColor:"blue",
	 *					strokeColor:"red",
	 *	                fontSize: "12px"
	 *				}
	 *			},
	 *			//创建文字服务策略类
	 *			strategies: [new Geo.Strategy.GeoTextXYZ()]
	 *		});
     * (end)
     */	
	initialize: function(name,options) {
		options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		Geo.View2D.Layer.Vector.prototype.initialize.apply(this, arguments);
		
		if(!this.layersID && !this.url) {
			throw new Error("图层id或文字服务地址不能为空！");
		}
		//构造文字服务类
		var GeoText = new Geo.Service.GeoText("GeoText",this.url);
		//读取文字服务能力描述信息
		GeoText.getCapabilities(
		OpenLayers.Function.bind(function(result) {
			if(typeof this.layersID === "string" && this.layersID.length > 0) {
				var layer = this.layersID.split(":");
				if(layer.length > 1) {
					var layersArr = layer[1].split(",");
				}else if(layer.length === 1){
					var layersArr = layer[0].split(",");
				}
				
				var layersId = [];
				for(var i = 0; i < layersArr.length; i++) {
					layersId.push(parseInt(layersArr[i]));
				}
			}
			//根据图层id获取文字样式
			var layersStyle = GeoText.getTextStylesByLayerIds(result,layersId);
			var ops = {};
			ops.url = this.url;
			ops.isCustomStyle = this.isCustomStyle;
			//如果用户自定义了样式，并且设置自定义样式isCustomStyle=true,那么
			if(typeof options.layersStyle === "object" && options.isCustomStyle) {
				ops.layersStyle = options.layersStyle;
			}else {
				ops.layersStyle = layersStyle;
			}
			//设置自定义换行
			if(options.isCustomStyle) {
				ops.eachRowNumer = options.eachRowNumer || this.eachRowNumer;
			}
			
			//结果解析器
			this.formatFeatures = new Geo.Util.Format.GeoTextFeatures(ops);
		}, this));

//		var ops = {};
//		ops.url = this.url;
//		ops.isCustomStyle = this.isCustomStyle;
//		if(options && options.layersStyle) {
//			ops.layersStyle = options.layersStyle;
//		}
//		//结果解析器
//		this.formatFeatures = new Geo.Util.Format.GeoTextFeatures(ops);
		
		this.geoPreAvoidContainer = new Geo.Util.GeoPreAvoidContainer();
		this.events.on({
	        "moveend": OpenLayers.Function.bind(function() {
				if(this.timer !== null) {
		            window.clearInterval(this.timer);
		            this.timer = null;
		        }
			}, this)
	    });
	},
	
	/**
	 * Method: read
	 * 读取文字服务，Features接口。
	 * 
	 * Parameters:
     * options - {Object} 
     * 	lxyArray - {String} 必选 层级与行列号。取值举例:4,9-11,0-2
     *  
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
	 */
	read: function(options,sucessFn,failFn) {
        options = OpenLayers.Util.extend({}, options);
		 var response = new OpenLayers.Protocol.Response({requestType: "read"});
		 var failFn = failFn || function(){};
        OpenLayers.Util.applyDefaults(options, this.options || {});
		//TODO:接受请求参数。
		var url =this.url + "/"+ "Features" + "/" + this.layersID +"/" +  options.lxyArray + 
		"?f=json&" + "version=" + this.version + "&service=" + this.service;
    	//做get	请求操作
		response.priv = OpenLayers.Request.GET({
            url: url,
            scope: this,
			callback: this.createCallback(this.handleRead, response, options),
            failure: failFn
        });
		return response;
    },
	
	/**
     * Method: createCallback
     * Returns a function that applies the given public method with resp and
     *     options arguments.
     *
     * Parameters:
     * method - {Function} The method to be applied by the callback.
     * response - {<OpenLayers.Protocol.Response>} The protocol response object.
     * options - {Object} Options sent to the protocol method
     */
    createCallback: function(method, response, options) {
        return OpenLayers.Function.bind(function() {
            method.apply(this, [response, options]);
        }, this);
    },
	
    /**
     * Method: handleRead
     * 读取成功回调返回的内容。
     *
     * Parameters:
     * response - {<OpenLayers.Protocol.Response>} 返回结果对象。
     * options - {Object} 可选项。
     */
    handleRead: function(response, options) {
        options = OpenLayers.Util.extend({}, options);
        OpenLayers.Util.applyDefaults(options, this.options);

        if(options.callback) {
            var request = response.priv;
            if(request.status >= 200 && request.status < 300) {
                // success
                var result = this.parseResponse(request, options.readOptions);
                if (result && !result.error) {
                	response.features = result;
                    response.code = OpenLayers.Protocol.Response.SUCCESS;
                } else {
                    // failure (service exception)
                    response.code = OpenLayers.Protocol.Response.FAILURE;
                    response.error = result;
                }
            } else {
                // failure
                response.code = OpenLayers.Protocol.Response.FAILURE;
            }
            options.callback.call(options.scope, response);
        }
    },
	
    /**
     * Method: parseResponse
     * 解析服务返回结果。
     *
     * Parameters:
     * request - {XMLHttpRequest} XMLHttpRequest对象
     * options - {Object} 可选项
     *
     * Returns:
     * {Array({<OpenLayers.Feature.Vector>})}返回要素数组
     * 
     */
    parseResponse: function(request, options) {
		var result = this.formatFeatures.read(request.responseText);
		if(result.error) {
			return result;
		}
		var featurestileGroups = result["tile"];
        return featurestileGroups;
    },
	
	/**
	 * Method: getValidLabelPlaceCode
	 * 根据要素获取标签的有效范围。
	 * 
	 * Parameters:
     * feature - {Geo.Feature.Vector} 要素对象。
     * 
     * Returns:
     * {String} 文字标签的方位。
	 */
	getValidLabelPlaceCode: function(feature,tileBounds) {
		var placeList = this.directions;
		var placeCode;
		for (var i = placeList.length - 1; i > -1; i--) {
			var labelBounds = this.getLabelInfo(feature,null,placeList[i]).bounds;
			//拿标签所在的所有方位的范围与避让区做比较，看有没有可用的区域
			if(this.isValidLabelBounds(labelBounds,tileBounds)){
			    placeCode = placeList[i];
			    break;
			}
		}
		//如果不存在有效范围，那么不显示
		if(!placeCode){
			placeCode = "none";
			feature.style.display="none";
		}
		return placeCode;
	},
	
	/**
	 * Method: isValidLabelBounds
	 * 判断文字标签的范围是否是有效范围。
	 * 
	 * Parameters:
     * bounds - {Geo.Bounds} 文字标签的范围。
     * 
     * Returns:
     * {Boolean} true表示范围有效，false表示范围无效。
	 * 
	 */
    isValidLabelBounds: function(bounds,tileBounds) {
        var isValid = true;
        var isContain = true;
		var avoidArea = this.avoidArea;
		var maxBounds = tileBounds;//new Geo.Bounds(-180,-90,180,90);
		if(bounds instanceof OpenLayers.Bounds) {
            isContain = maxBounds.containsBounds(bounds);
            if(!isContain && this.isAvoidOuterMaxExtent){
                isValid = false;
                return isValid;
            }
        }
        for (var i=avoidArea.length-1; i > -1; i--) {
            var isIntersect = this.isIntersects(avoidArea[i],bounds);
            if(isIntersect){
                isValid = false;
                break;
            }
        }
        return isValid;
    },
	
	/**
	 * Method: isIntersects
	 * 判断两个对象是否相交，不论是bounds还是geometry
	 * 
	 * Parameters:
     * obj1 - {Geo.Bounds} 要素的范围。
     * obj2 - {Geo.Bounds} 要素的范围。
     * 
     * Returns:
     * {Boolean} true表示两个范围有相交部分，false则不相交。 
	 */
	isIntersects: function(obj1,obj2) {
		var isIntersects;
		
		if((obj1.CLASS_NAME == obj2.CLASS_NAME)
		    && (obj1.CLASS_NAME === "OpenLayers.Bounds")) {
			//第二个参数必须得是false	
		    isIntersects =  obj1.intersectsBounds( obj2, false);
		}
		
		if(obj1.CLASS_NAME !== obj2.CLASS_NAME){
		    var shape1 = (obj1.CLASS_NAME == "OpenLayers.Bounds") ? obj1.toGeometry() : obj1;
		    var shape2 = (obj2.CLASS_NAME == "OpenLayers.Bounds") ? obj2.toGeometry() : obj2;
		    isIntersects =  shape1.intersects( shape2);
		}
        return isIntersects;
    },
	
	/**
	 * Method: convertPixelToLonlatSize
	 * 像素大小转度大小。
	 * 
	 * Parameters:
     * pixelSize - {Geo.Pixel} 像素大小。
     * 
     * Returns:
     * {Geo.Size} 经纬度大小。
	 */
    convertPixelToLonlatSize: function(pixelSize){
        var res = this.map.getResolution();
        return new Geo.Size(pixelSize.w*res, pixelSize.h*res);
    },
	
	/**
	 * Method: getLabelPixelSize
	 * 根据样式得到标签的像素大小。
	 * 
	 * Parameters:
     * style - {Object} 文字标注的样式。
     * 
     * Returns:
     * {Geo.Size} 文字标注的大小。 
	 */
    getLabelPixelSize: function(style){
        var text = style.label;
        if(!text){
            return null;
        }
		//新增方法开始-----
		var labelgroup = text.split("\n");
		var rows = labelgroup.length;
		//新增方法结束-----
		
		

        var context = this.renderer.canvas;
        context.save();

        var fontStyle = [style.fontStyle ? style.fontStyle : "normal",
                 "normal", // "font-variant" not supported
                 style.fontWeight ? style.fontWeight : "normal",
                 style.fontSize ? style.fontSize : "1em",
                 style.fontFamily ? style.fontFamily : "sans-serif"].join(" ");
        context.font = fontStyle;
        //measureText无法直接得到height值
        var lineHeight =// context.measureText('Mg').height ||
                          context.measureText('MM').width;//获取宽度不要用小写，要用大写
        //row是新增的,text换成labelgroup[0]
        var textSize = new Geo.Size(context.measureText(labelgroup[0]).width,
                                      lineHeight * rows);
        context.restore();
        return textSize;
    },
	
	/**
	 * Method: getLabelInfo
	 * 根据要素地理坐标与标签方位，获取标签的地理位置与范围。
	 * 
	 * Parameters:
     * feature - {Geo.Feature.Vecotor} 要素对象。
     * style - {Object} 要素的样式。
     * placeCode  - {String} 标签的方位。
     * 
     * Returns:
     * {Object} 文字标注的范围与位置。 
	 */
    getLabelInfo: function(feature,style,placeCode) {
        style = style || feature.style;
		//TODO
        var labelPixelSize = this.getLabelPixelSize(style);
		//TODO
        var labelLonlatSize = this.convertPixelToLonlatSize(labelPixelSize);
        var featuerLocation = new Geo.LonLat(feature.geometry.x,feature.geometry.y);
		var featurePixelSize = null;
        if(style.graphicWidth) {
			featurePixelSize = new Geo.Size(style.graphicWidth, style.graphicHeight);
		}else {
			featurePixelSize = new Geo.Size(style.pointRadius*2,style.pointRadius*2);
		}
        var featureLonlatSize = this.convertPixelToLonlatSize(featurePixelSize);

        var labelLonlat,labelBounds;

        switch(placeCode){
            case "lt":
                labelLonlat = new Geo.LonLat(featuerLocation.lon - featureLonlatSize.w/2 - labelLonlatSize.w,
                                              featuerLocation.lat + featureLonlatSize.h/2 + labelLonlatSize.h);
                break;
            case "ct":
                labelLonlat = new Geo.LonLat(featuerLocation.lon - labelLonlatSize.w/2,
                                              featuerLocation.lat + featureLonlatSize.h/2 + labelLonlatSize.h);
                break;
            case "rt":
                labelLonlat = new Geo.LonLat(featuerLocation.lon + featureLonlatSize.w/2,
                                              featuerLocation.lat + featureLonlatSize.h/2 + labelLonlatSize.h);
                break;
            case "lm":
                labelLonlat = new Geo.LonLat(featuerLocation.lon - featureLonlatSize.w/2 - labelLonlatSize.w,//+,
                                          featuerLocation.lat + labelLonlatSize.h/2);
                break;
            case "rm":
                labelLonlat = new Geo.LonLat(featuerLocation.lon + featureLonlatSize.w/2,
                                              featuerLocation.lat + labelLonlatSize.h/2);
                break;
            case "lb":
                labelLonlat = new Geo.LonLat(featuerLocation.lon - featureLonlatSize.w/2 - labelLonlatSize.w,//+,
                                      featuerLocation.lat - featureLonlatSize.h/2);
                break;
            case "cb":
                labelLonlat = new Geo.LonLat(featuerLocation.lon - labelLonlatSize.w/2,
                                              featuerLocation.lat - featureLonlatSize.h/2);
                break;
            case "rb":
                labelLonlat = new Geo.LonLat(featuerLocation.lon + featureLonlatSize.w/2,
                                              featuerLocation.lat - featureLonlatSize.h/2);
                break;
        }

        labelBounds = new Geo.Bounds(labelLonlat.lon, labelLonlat.lat-labelLonlatSize.h,
                                labelLonlat.lon+labelLonlatSize.w, labelLonlat.lat);
        return {
            location:labelLonlat,
            bounds: labelBounds
        };
    },
	
	/**
	 * Method: getFeatureArea
	 * 得到要素的地理范围，不包含标签。
	 * 
	 * Parameters:
     * feature - {Geo.Feature.Vecotor} 要素对象。
     * 
     * Returns:
     * {Geo.Bounds || Geo.Geometry} 要素对象或要素的范围。 
	 */
	getFeatureArea: function(feature) {
		var geometry = feature.geometry;
        switch(geometry.CLASS_NAME) {
            case "OpenLayers.Geometry.Point":
                var res = this.map.getResolution(),
                    style = feature.style,
                    lonlatSize;
				var iconSize = null;
				if(style.graphicWidth) {
					iconSize = new Geo.Size(style.graphicWidth,
		                                      style.graphicHeight);
				}else {
					iconSize = new Geo.Size(style.pointRadius*2,style.pointRadius*2);
				}	
                if(style.externalGraphic){//计算带图标的要素的范围
                    lonlatSize = new Geo.Size(res * iconSize.w, res*iconSize.h);
                    return new Geo.Bounds(geometry.x - lonlatSize.w/2,geometry.y - lonlatSize.h/2,
                                                  geometry.x + lonlatSize.w/2,geometry.y + lonlatSize.h/2);
                } else {//不带点要素的图标的大小。
                    lonlatSize = new Geo.Size(res * iconSize.w, res*iconSize.h);
                    return new Geo.Bounds(geometry.x - lonlatSize.w/2,geometry.y - lonlatSize.h/2,
                                                  geometry.x + lonlatSize.w/2,geometry.y + lonlatSize.h/2);
                }
                break;
            case "OpenLayers.Geometry.LineString":
			case "OpenLayers.Geometry.LinearRing":
			case "OpenLayers.Geometry.MultiLineString":
            case "OpenLayers.Geometry.Polygon":
                return geometry;
                break;
        }
	},
	
	/**
	 * Method: setMap
	 * 将图层与地图关联。
	 * 
	 * Parameters:
	 * map - {Geo.View2D.Map} 地图对象。
	 */
	setMap: function(map) {  
        Geo.View2D.Layer.Vector.prototype.setMap.apply(this, arguments);

    },
	
	/**
	 * Method: update
	 * 更新图层。
	 * 
	 * Parameters:
	 * featurestileGroup - {Array(Geo.Util.Format.GeoTextFeatures.FeaturesTile)} 要素数组。
	 */
	update: function(featurestileGroup) {
		this.textCounter--;
		if(!featurestileGroup ||featurestileGroup.length == 0) {
			return;
		}
		//要素标签避让
		this.avoidLabelArea(featurestileGroup);
	},
	
	/**
	 * Method: removeFeatures
	 * 移除要素。
	 */
	removeFeatures: function() {
		this.avoidArea = [];
		this.avoidArea.length = 0;
		for(var line in this.drawFeatures) {
			delete this.drawFeatures[line];
		}
		this.removeAllFeatures();
		if (this.delayedClearText !== null) {
		    window.clearTimeout(this.delayedClearText);
		    this.delayedClearText = null;
		}
	},
	/**
	 * Method: getTextWidthAndHeight
	 * 获取文本的宽度和高度。
	 */
	getTextWidthAndHeight:function(style)
	{
		var text = style.label;
        if(!text){
            return null;
        }
        var context = this.renderer.canvas;
        context.save();
        var fontStyle = [style.fontStyle ? style.fontStyle : "normal",
                 "normal", // "font-variant" not supported
                 style.fontWeight ? style.fontWeight : "normal",
                 style.fontSize ? style.fontSize : "1em",
                 style.fontFamily ? style.fontFamily : "sans-serif"].join(" ");
        context.font = fontStyle;
        //measureText无法直接得到height值
        var lineHeight = context.measureText('MM').width;//获取宽度不要用小写，要用大写
        var textSize = new Geo.Size(context.measureText(text).width,lineHeight);
        context.restore();
        return textSize;
	},
	
	/**
	 * Method: avoidLabelArea
	 * 要素标签避让。
	 */
	avoidLabelArea: function(featurestileGroup) {
		var drawFeatures = [];
		var labelFeatures = [];
		
		for(var i = featurestileGroup.length - 1; i >= 0;i--) {
			var tileBounds = this.pyramid.getTileBoundsForGridIndex(featurestileGroup[i].row, featurestileGroup[i].col, featurestileGroup[i].level);
			featurestileGroup[i].tileBounds = tileBounds;
			this.avoidArea = [];
			this.avoidArea.length = 0;
			//将要素加入避让区
			var features = this.avoidFeatureArea(featurestileGroup[i]);
	        //如果有沿线标注，则画上去
			if (featurestileGroup[i].labelFeatures && featurestileGroup[i].labelFeatures.length > 0) {
					var labelFeauresTemp = this.addLabelFeatures(featurestileGroup[i]);
					labelFeatures = labelFeatures.concat(labelFeauresTemp);
			
			};

			//执行避让操作
			var drawFeature = this.avoidFeatures(features, featurestileGroup[i].tileBounds);
			drawFeatures = drawFeatures.concat(drawFeature);
		}
		if(labelFeatures.length > 0) {
			for(var m = 0,n = labelFeatures.length;m < n;m++) {
				for(var x = 0,y=drawFeatures.length; x < y;x++) {
					var ins = labelFeatures[m].geometry.intersects(drawFeatures[x]);
					if(ins) {
						drawFeatures[x].style.display="none";
						continue;
					}
				}
			}
		}
		
		//沿线标注
		OpenLayers.Layer.Vector.prototype.addFeatures.apply(this, [labelFeatures]);
		OpenLayers.Layer.Vector.prototype.addFeatures.apply(this, [drawFeatures]);
	},
	
	/**
	 * Method: destroyLineLabelGroup
	 * 沿线标注画到地图上后，就销毁请求的数据，这个不影响已经添加到地图上的数据。
	 */
	destroyLineLabelGroup: function(featurestile) {
		for(var i = 0, j = featurestile.labelFeatures.length; i < j; i++) {
			featurestile.labelFeatures[i].destroy();
		}
	},
	
	/**
	 * Method: destroyLineLabelGroup
	 * 按瓦片范围请求的数据添加到地图后，就清楚瓦片范围用于运算的数据。
	 */
	clearfeaturestile: function(featurestileGroup) {
		for(var i = featurestileGroup.length - 1; i >= 0;i--) {
			featurestileGroup[i].destroy();
		}
		
	},
	
	/**
	 * Method: addLabelFeatures
	 * 添加沿线标注要素。
	 */
	addLabelFeatures: function(featurestile) {
		for(var i = 0, j = featurestile.labelFeatures.length; i < j; i++) {
			var ilabelBounds = featurestile.labelFeatures[i].getLabelBounds(map);
			for(var m = 0, n = featurestile.labelFeatures.length; m < n; m++) {
				if(i === m) {
					continue;
				}
				var mlabelBounds = featurestile.labelFeatures[m].getLabelBounds(map);
				var isInterset = ilabelBounds.intersectsBounds(mlabelBounds);
				if(isInterset) {
					featurestile.labelFeatures[m].isVisibleLabel = false;
				}
			}
		}
		var labelFeatures = [];
		for(var m = 0, n = featurestile.labelFeatures.length; m < n; m++) {
			if(featurestile.labelFeatures[m].isVisibleLabel) {
		//		var labelBounds = featurestile.labelFeatures[m].getLabelBounds(map);
				
			//	var geometry = labelBounds.toGeometry();
		//		this.avoidArea.push(geometry);
//				var ll = new Geo.Feature.Vector(geometry);
//				OpenLayers.Layer.Vector.prototype.addFeatures.apply(this, [ll]);
				var features = featurestile.labelFeatures[m].features;
				labelFeatures = labelFeatures.concat(features);
			}
		}
		featurestile.labelFeatures = [];
		return labelFeatures;
	},
	
	/**
	 * Method: avoidFeatures
	 * 避让掉不该绘制的要素。
	 * 
	 * Parameters:
	 * features - {Array(Geo.Feature.Vector)} 要素。
	 * tileBounds - {Geo.Bounds} 瓦片范围。
	 * 
	 * Returns:
     * {Array} 返回能绘制的要素。 
	 */
	avoidFeatures: function(features,tileBounds) {
		var drawFeature = [];
		for(var i = features.length - 1; i > -1;i--) {
			if (features[i].geometry.CLASS_NAME === "OpenLayers.Geometry.Point") {
				if(features[i].style.display === "none" || features[i].style.label && OpenLayers.String.trim(features[i].style.label) === ""
				|| features[i].style.alongLineLabel && OpenLayers.String.trim(features[i].style.alongLineLabel) === "") {
					continue;
				}
				//面标注
				if(features[i].style.type !== "polygon") {
					//点标注
					this.avoidPointLabel(features[i],tileBounds);
					drawFeature.push(features[i]);
				}else{
					drawFeature.push(features[i]);
				}
				
			}else if (features[i].geometry.CLASS_NAME === "OpenLayers.Geometry.LineString" || features[i].geometry.CLASS_NAME === "OpenLayers.Geometry.MultiLineString") {
			//	this.setLineVisibility(features[i]);
	        }else {
				drawFeature.push(features[i]);
			}
		}
		//清除本次循环的对象
		return drawFeature;
	},
	
	/**
	 * Method: avoidPointLabel
	 * 点标签加入避让区。
	 * 
	 * Parameters:
	 * point - {Geo.Feature.Vector} 点要素。
	 */
	avoidPointLabel: function(point,tileBounds) {
		var feature = point;
        var placeCode = this.getValidLabelPlaceCode(feature,tileBounds);
		if(placeCode === "none") {
			feature.style.label="";
			feature.style.display="none";
			feature.style.fontSize = "";
		}else {
			this.convertToLabelPlaceStyle(feature.style,placeCode);
	        var labelBounds = this.getLabelInfo(feature,null,placeCode).bounds;
//			var geometry1 = labelBounds.toGeometry();
//		var geo = new Geo.Feature.Vector(geometry1);		
//		OpenLayers.Layer.Vector.prototype.addFeatures.apply(this, [geo]);
			//将点的标签范围加入避让区
			this.avoidArea.push(labelBounds);
		}
	},
	
	/**
	 * Method: convertToLabelPlaceStyle
	 * 
	 * Parameters:
	 * style - {Object} 要素样式。
	 * placeCode - {String} 要素方位。
	 */
	convertToLabelPlaceStyle: function(style, placeCode) {


        /* 位置代码：
            left,center,right
            top,middle,bottom
            ----------------------
            lt ct rt
            lm    rm
            lb cb rb
         */

        //placeCode = "lm";

        if(style.graphicWidth) {
			 var iconSize = new Geo.Size(style.graphicWidth,
                                      style.graphicHeight);
		}else {
			 var iconSize = new Geo.Size(style.pointRadius*2,style.pointRadius*2);
		}
        var spacing = 0;//2;

        switch(placeCode){
            case "lt":
                style.labelAlign = "rb";
                style.labelXOffset = -(spacing + iconSize.w/2);
                style.labelYOffset = spacing + iconSize.h/2;
                break;
            case "ct":
                style.labelAlign = "cb";
                style.labelXOffset = 0;
                style.labelYOffset = spacing + iconSize.h/2;
                break;
            case "rt":
                style.labelAlign = "lb";
                style.labelXOffset = spacing + iconSize.w/2;
                style.labelYOffset = spacing + iconSize.h/2;
                break;
            case "lm":
                style.labelAlign = "rm";
                style.labelXOffset = spacing - iconSize.w/2;
                style.labelYOffset = 0;
                break;
            case "rm":
                style.labelAlign = "lm"
                style.labelXOffset = spacing + iconSize.w/2;
                style.labelYOffset = 0;
                break;
            case "lb":
                style.labelAlign = "rt"
                style.labelXOffset = -(spacing + iconSize.w/2);
                style.labelYOffset = -(spacing + iconSize.w/2);
                break;
            case "cb":
                style.labelAlign = "ct";
                style.labelXOffset = 0;
                style.labelYOffset = -(spacing + iconSize.h/2);
                break;
            case "rb":
                style.labelAlign = "lt"
                style.labelXOffset = (spacing + iconSize.w/2);
                style.labelYOffset = -(spacing + iconSize.w/2);
                break;
        }
        return style;
    },
	
	/**
	 * Method: addLabelCharBoundsToInvalidBounds
	 * 将文字标注要素所占的范围加入避让区。
	 * 
	 * Parameters:
	 * labelCharFeatures - {Array(Geo.Feature.Vector)} 文字标注要素。
	 */
	addLabelCharBoundsToInvalidBounds: function(labelCharFeatures,featureLocation) {
        for (var i = 0; i < labelCharFeatures.length; i++) {
            var labelCharFeature = labelCharFeatures[i];
            var charBounds = this.getLaeblBounds(labelCharFeature);
			//线的字符范围加入避让区
            this.avoidArea.push(charBounds);
        }
    },
	
	/**
	 * Method: boundsToFeature
	 * 将Bounds范围转换为几何对象。
	 * 
	 * Parameters:
	 * bounds - {Geo.Bounds} 范围。
	 * 
	 * Returns:
     * {Geo.Feature.Vector} 要素对象。 
	 */
	boundsToFeature: function(bounds){
        var polygon = bounds.toGeometry();
        return new Geo.Feature.Vector(polygon);
    },
	
	/**
	 * Method: getLaeblBounds
	 * 文字标注要素。
	 * 
	 * Parameters:
	 * labelFeature - {Geo.Feature.Vector} 文字标注要素。
	 * 
	 * Returns:
     * {Geo.Bounds} 单个文字标注的范围。 
	 */
	getLabelBounds: function(labelFeature){
        var position = new Geo.LonLat(labelFeature.geometry.x, labelFeature.geometry.y);
        var charCount = labelFeature.style.label.length;
        var res = map.getResolution();
        var size = new Geo.Size((labelFeature.style.fontSize + this.labelCharSpace/2.0)*charCount*res,labelFeature.style.fontSize*res);
        var charBounds = new Geo.Bounds(position.lon-size.w/2, position.lat-size.h/2,
                                          position.lon+size.w/2, position.lat+size.h/2);
        return charBounds;
    },
	
	/**
	 * Method: getLabelLonLatSize
	 * 根据样式和标注名称得到标注的行高。
	 * 
	 * Parameters:
	 * label - {String} 文字标注串。
	 * style - {Object} 要素样式。
	 * 
	 * Returns:
     * {Geo.Size} 文字标注的宽高。 
	 */
	getLabelLonLatSize:function (label,style){
        //todo:未考虑多行标签、行高与英文情况
        var fontSize = parseInt(style.fontSize);
        var res = this.map.getResolution();
        var width = (fontSize + this.labelCharSpace/2.0) * label.length * res;
		//像素乘以分辨率为经纬度值
        var height = fontSize * res
        return new Geo.Size(width, height);
    },
	
	/**
	 * Method: getLabelFeaturesForLineString
	 * 根据文字标注串得到文字标注要素。
	 * 
	 * Parameters:
	 * label - {String} 文字标注串。
	 * style - {Object} 要素样式。
	 * geometry- {Geo.Geometry} 几何对象。
	 * 
	 * Returns:
     * {Array} 得到文字标注要素。
	 */
	getLabelFeaturesForLineString: function(label,style,geometry,featurestile) {
        //标签偏移位置
        geometry.move(-map.getResolution()*12,0);
        var labelLonLatWidth = this.getLabelLonLatSize(label,style).w;
		//TODO：标签间距,此参数需要对外
        var labelSpace = labelLonLatWidth * 6;//间隔系数为0.8
		//线的总长度
        var totalLength = geometry.getLength();
		//计算出去标签长度与标签间距长度后剩下的宽度
        var remainLength = totalLength % (labelLonLatWidth + labelSpace);
		//根据标签文本宽度、字间距、标签间隔计算标签在折线上的重复次数；   labelLonLatWidth文本标签的宽度；labelSpace标签间的间隔长度
        var labelCount = Math.floor(totalLength / (labelLonLatWidth + labelSpace))
		+ Math.floor(remainLength/labelLonLatWidth);
		//计算一条线段中，绘制第一个文本标签的第一个字的位置。
        var initStartPosition = (totalLength - (labelCount - 1) * labelSpace - labelLonLatWidth * labelCount) / 2;
		while(initStartPosition < 0) {
			labelCount = labelCount - 1;
			initStartPosition = (totalLength - (labelCount - 1) * labelSpace - labelLonLatWidth * labelCount) / 2;
		}
		//总宽度除以总字数，等于每个字的宽度todo:未考虑沿线标签字间距
        var labelCharWidth = labelLonLatWidth / label.length;
        var labelCharPositionsOnLine = [];
        var labelCharText = [];
		//先只管文字的位置，不管角度
        for (var i = 0; i < labelCount; i++) {
			//一个一个字循环
            for (var j = 0; j < label.length; j++) {
				//计算标签的起点距离。
                var labelStartPosition = initStartPosition + i *(labelLonLatWidth + labelSpace);
				//保存线上的每个字的位置
                labelCharPositionsOnLine.push(labelStartPosition + j * labelCharWidth);
				//保存线上的每个字
                labelCharText.push(label[j]);
            }
        }

        //计算每段路径长度
        var points = geometry.getVertices();
        var pathsInfo = [];
        var totalLengthCounter = 0;
		//循环线上的每个点，保存每两个点的夹角等信息。
        for (var i = 0; i < points.length - 1; i++) {
            var startPoint = points[i];
            var endPoint = points[i+1];
            var angle = this.getTwoPointsAngle(startPoint,endPoint);
            var length = startPoint.distanceTo(endPoint);
            totalLengthCounter = totalLengthCounter + length;
            pathsInfo.push({
                start: startPoint,
                end: endPoint,
                angle: angle,
                length: length,
                totalLength: totalLengthCounter
            });
        }

        var labelCharFeatures = [];
        var currentPathIndex = 0;
		
        for (var i = 0; i < labelCharPositionsOnLine.length; i++) {
			var charPosition = labelCharPositionsOnLine[i];
			var currentLength = 0;

			//TODO：还有情况没有判断
            var parthInfo = pathsInfo[currentPathIndex];
            while(parthInfo.totalLength < charPosition){
                currentPathIndex++;
                parthInfo = pathsInfo[currentPathIndex];
            }
            var lastTotalLength;
            if(currentPathIndex > 0){
                lastTotalLength = pathsInfo[currentPathIndex-1].totalLength;
            } else {
                lastTotalLength = 0;
            }

	           var currentLength = charPosition - lastTotalLength;
            var labelCharPoint = this.getPointOnLine(parthInfo.start,parthInfo.end,currentLength);
			
            var charStyle = Geo.Util.extend({}, this.lineLabelDefaultStyle);
            charStyle.label = labelCharText[i];
			//TODO:是否旋转
			if(this.isRotation) {
				charStyle.labelRotation = -parthInfo.angle;
			}
			charStyle = Geo.Util.extend(charStyle, style);
            labelCharFeatures.push(new Geo.Feature.Vector(labelCharPoint,null,charStyle));
			
        }
		var labelGroup = this.getSortLabelCharFeatures(labelCharFeatures,label,featurestile);
        return labelGroup;
    },
	
	/**
	 * Method: getSortLabelCharFeatures
	 * 沿线标注排序
	 */
	getSortLabelCharFeatures: function(labelCharFeatures,label,featurestile) {
		var lineLabelGroup = [];
		function isInteger( str ) {
			var regu = /^[-]{0,1}[0-9]{1,}$/;
			return regu.test(str);
		}
		var linePointGroup = [];
		for(var i = 0; i < labelCharFeatures.length; i++) {
			
			if(isInteger(""+(i + 1)/label.length)) {
				linePointGroup.push(labelCharFeatures[i]);
				var pointgroup = new Geo.Util.Format.GeoTextFeatures.LineLabelGroup({
					features: linePointGroup,
					labelCharSpace: this.labelCharSpace,
					label: label
				});
				var map = this.map;
				var labelBounds = pointgroup.getLabelBounds(map);
				//瓦片是否包含给定的标签
				var isContain = featurestile.tileBounds.containsBounds(labelBounds, true);
				if(isContain) {
					if(!Geo.Util.isArray(featurestile.labelFeatures)) {
						featurestile.labelFeatures = [];
					}
					featurestile.labelFeatures.push(pointgroup);
				}
				linePointGroup = [];
				var addX = 0;
				var addY = 0;
				for(var y = 0; y < label.length - 1; y++) {
					addX += Math.abs(labelCharFeatures[i - y].geometry.x - labelCharFeatures[i - y - 1].geometry.x);
					addY += Math.abs(labelCharFeatures[i - y].geometry.y - labelCharFeatures[i - y - 1].geometry.y);
				}
//				var angle = this.getTwoPointsAngle(labelCharFeatures[i - (labelCharFeatures.length - 1)].geometry,labelCharFeatures[i].geometry);
				//从上到下，反着来
				if(addX <= addY  && labelCharFeatures[i - (label.length - 1)].geometry.x >= labelCharFeatures[i].geometry.x &&
				labelCharFeatures[i - (label.length - 1)].geometry.y <= labelCharFeatures[i].geometry.y) {
					var fanArray = [];
					for(var y = 0; y < label.length; y++) {
						//判断是偶数
						if(label.length % 2 === 0 && (y + 1) <= label.length / 2) {
							var houGeometry = labelCharFeatures[i - y].geometry.clone();
							var qianGeometry = labelCharFeatures[i - (label.length - 1) + y].geometry.clone();
							
							labelCharFeatures[i - y].geometry = qianGeometry;
							labelCharFeatures[i - (label.length - 1) + y].geometry = houGeometry;
						}else if(label.length % 2 !== 0 && (y + 1) < Math.ceil(label.length / 2.0)) {
							var houGeometry = labelCharFeatures[i - y].geometry.clone();
							var qianGeometry = labelCharFeatures[i - (label.length - 1) + y].geometry.clone();
							
							labelCharFeatures[i - y].geometry = qianGeometry;
							labelCharFeatures[i - (label.length - 1) + y].geometry = houGeometry;
						}
					}
				}else if(addX <= addY && labelCharFeatures[i - (label.length - 1)].geometry.x <= labelCharFeatures[i].geometry.x &&
				labelCharFeatures[i - (label.length - 1)].geometry.y <= labelCharFeatures[i].geometry.y) {
					for(var y = 0; y < label.length; y++) {
						//判断是偶数
						if(label.length % 2 === 0 && (y + 1) <= label.length / 2) {
							var houGeometry = labelCharFeatures[i - y].geometry.clone();
							var qianGeometry = labelCharFeatures[i - (label.length - 1) + y].geometry.clone();
							
							labelCharFeatures[i - y].geometry = qianGeometry;
							labelCharFeatures[i - (label.length - 1) + y].geometry = houGeometry;
						}else if(label.length % 2 !== 0 && (y + 1) < Math.ceil(label.length / 2.0)) {
							var houGeometry = labelCharFeatures[i - y].geometry.clone();
							var qianGeometry = labelCharFeatures[i - (label.length - 1) + y].geometry.clone();
							
							labelCharFeatures[i - y].geometry = qianGeometry;
							labelCharFeatures[i - (label.length - 1) + y].geometry = houGeometry;
						}
					}
				}else if(addX > addY && labelCharFeatures[i - (label.length - 1)].geometry.x > labelCharFeatures[i].geometry.x) {
					for(var y = 0; y < label.length; y++) {
						//判断是偶数
						if(label.length % 2 === 0 && (y + 1) <= label.length / 2) {
							var houGeometry = labelCharFeatures[i - y].geometry.clone();
							var qianGeometry = labelCharFeatures[i - (label.length - 1) + y].geometry.clone();
							
							labelCharFeatures[i - y].geometry = qianGeometry;
							labelCharFeatures[i - (label.length - 1) + y].geometry = houGeometry;
						}else if(label.length % 2 !== 0 && (y + 1) < Math.ceil(label.length / 2.0)) {
							var houGeometry = labelCharFeatures[i - y].geometry.clone();
							var qianGeometry = labelCharFeatures[i - (label.length - 1) + y].geometry.clone();
							
							labelCharFeatures[i - y].geometry = qianGeometry;
							labelCharFeatures[i - (label.length - 1) + y].geometry = houGeometry;
						}
					}
				}
			}else {
				linePointGroup.push(labelCharFeatures[i]);
			}
		}
		return lineLabelGroup;
	},
	
	/**
	 * Method: getPointOnLine
	 * 计算两点间直线的指定长度所处的点位。
	 * 
	 * Parameters:
	 * start - {Number} 起点。
	 * end - {Object} 终点。
	 * length- {Number} 两点间的距离。
	 * 
	 * Returns:
     * {Array} 得到文字标注要素。 
	 */
    getPointOnLine: function(start,end,length){
		var point;
        if(length <= 0) {
            point = start;
        } else {
			var totalLength = start.distanceTo(end);
			var addY = (end.y - start.y) * length / totalLength;
			var addX = (end.x - start.x) * length / totalLength;
            point = new Geo.Geometry.Point(start.x + addX,
                                             start.y + addY);
        }

        return point;
    },
	
	/**
	 * Method: getTwoPointsAngle
	 * 根据起点和终点得到线与地图水平线之间的夹角。
	 * 
	 * Parameters:
	 * start - {Number} 起点。
	 * end - {Object} 终点。
	 * 
	 * Returns:
     * {Array} 角度。 
	 */
	getTwoPointsAngle: function(start,end){
        var k = (end.y - start.y) / (end.x - start.x);
        return Math.atan(k) / 0.017453293;
    },
	
	/**
	 * Method: avoidFeatureArea
	 * 要素范围避让。
	 * 
	 * Parameters:
	 * features - {Array(Geo.Feature.Vector)} 将要素加入避让区。
	 */
	avoidFeatureArea: function(featurestile) {
		var features = featurestile.features;
		for(var i=features.length-1; i > -1; i--) {
			//如果类型为字符串，则表示是线或面，TODO：这里还没有判断面
			var area = this.getFeatureArea(features[i]);
			var linegeometry = features[i].geometry.clone();
			var label = features[i].style.alongLineLabel;
			if(features[i].geometry instanceof OpenLayers.Geometry.LineString) {
				var linePointGroup = this.getLabelFeaturesForLineString(label, features[i].style,linegeometry,featurestile);
			}else if(features[i].geometry instanceof OpenLayers.Geometry.MultiLineString) {
				//增加对多点的解析
				for(var a = 0,len = linegeometry.components.length;a < len; a++) {
					var linePointGroup = this.getLabelFeaturesForLineString(label, {
			            fontSize: 16
			        },linegeometry.components[a].clone(),featurestile);
				} 
			}
        	this.avoidArea.push(area);
		}
		return features;
	},
	
	/**
	 * Method: removeMap
	 * 将图层移除地图。
	 * 
	 * Parameters:
	 * map - {Geo.View2D.Map} 地图。
	 */
	removeMap: function(map) {
        Geo.View2D.Layer.Vector.prototype.removeMap.apply(this, arguments);
		map.events.un({
	        "zoomend": this.update
	    });
    },
	
	CLASS_NAME: "Geo.View2D.Layer.GeoText"
});
Geo.View2D.Layer.GeoText.TOP = "ct";
Geo.View2D.Layer.GeoText.BOTTOM = "cb";
Geo.View2D.Layer.GeoText.LEFT="lm";
Geo.View2D.Layer.GeoText.RIGHT="rm";
Geo.View2D.Layer.GeoText.TOP_LEFT="lt";
Geo.View2D.Layer.GeoText.BOTTOM_LEFT="lb";
Geo.View2D.Layer.GeoText.TOP_RIGHT="rt";
Geo.View2D.Layer.GeoText.BOTTOM_RIGHT="rb";/**
 * Class: Geo.View2D.Layer.HotareaWMTS
 * 热区wmts类，继承自Geo.View2D.Layer.WMTS类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 *
 * Inherits from:
 *  - <Geo.View2D.Layer.WMTS>
 */
Geo.View2D.Layer.HotareaWMTS = Geo.Class(Geo.View2D.Layer.WMTS, {
	
    /**
     * APIProperty: vectorLayer
     * {<Geo.View2D.Layer.Vector>} 热区图层包含的矢量图层。
     */
	vectorLayer: null,
	
    /**
     * APIProperty: selectCtrl
     * {<Geo.View2D.Control.SelectFeature>} 选择要素控件。
     */
	selectCtrl: null,
	
    /**
     * Constructor: Geo.View2D.Layer.HotareaWMTS
     * 创建HotareaWMTS图层对象实例。
     *
     * Parameters:
     * options - {Object} 参数选项。
     */
    initialize: function(options){
		Geo.View2D.Layer.WMTS.prototype.initialize.apply(this, arguments);
		this.urls = [];
    },
	
	/**
     * Method: setMap
     */
    setMap: function() {
        Geo.View2D.Layer.WMTS.prototype.setMap.apply(this, arguments);
		
		this.map.events.register("zoomend", this, this.removeFeatures);
		this.map.addLayers([this.vectorLayer]);
		
		//要素高亮控件
        this.highlightCtrl = new Geo.View2D.Control.SelectFeature(this.vectorLayer, {
            hover: true,
			highlightOnly: true,
            eventListeners: {
                beforefeaturehighlighted: function(evt){
				},
				featurehighlighted: function(evt){
					var feature = evt.feature;
					this.hotareaWMTS.highlight(feature);
					var pointFeature = this.hotareaWMTS.getCombinationFeature(feature).point;
					//无点击才触发，mouseover事件
					if (!pointFeature.isclicked) {
						this.hotareaWMTS.onMouseOverFeature(pointFeature);
					}
				},
				featureunhighlighted: function(evt){
					var feature = evt.feature;
					var pointFeature = this.hotareaWMTS.getCombinationFeature(feature).point;
					//无点击才触发，mouseout事件
					if(!pointFeature.isclicked){
						this.hotareaWMTS.unhighlight(feature);
						this.hotareaWMTS.onMouseOutFeature(pointFeature);
					}else{
						this.hotareaWMTS.highlight(feature);
					}
				}
            }
        });
		
		//选择要素控件
        this.selectCtrl = new Geo.View2D.Control.SelectFeature(this.vectorLayer, {
            hover: false,
			clickout: true,
			eventListeners: {
                beforefeaturehighlighted: function(evt){
				},
				featurehighlighted: function(evt){
					var feature = evt.feature;
					this.hotareaWMTS.highlight(feature);
				},
				featureunhighlighted: function(evt){
					//var feature = evt.feature; 
					//this.hotareaWMTS.unhighlight(feature);
				}
            },
			onSelect: function(feature){
				this.hotareaWMTS.highlight(feature);
				
				var pointFeature = this.hotareaWMTS.getCombinationFeature(feature).point;
				pointFeature.isclicked = true;
				this.hotareaWMTS.onSelectFeature(pointFeature);
			},
			onUnselect: function(feature){
				this.hotareaWMTS.unhighlight(feature);
				
				var pointFeature = this.hotareaWMTS.getCombinationFeature(feature).point;
				pointFeature.isclicked = false;
				this.hotareaWMTS.onUnselectFeature(pointFeature);
			}
        });
		this.map.addControl(this.highlightCtrl);
		this.map.addControl(this.selectCtrl);
		this.highlightCtrl.activate();
		this.selectCtrl.activate();
		
		this.highlightCtrl.hotareaWMTS = this;
		this.selectCtrl.hotareaWMTS = this;
    },
    
    /**
     * Method: highlight
     * 高亮要素。
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 被高亮的要素对象。
     */
	highlight: function(feature){
		var combinationFeature = this.getCombinationFeature(feature);
		var pointFeature = combinationFeature.point;
		var polygonFeature = combinationFeature.polygon;
		var hoverPicUrl = pointFeature.attributes.overPicUrl;
		var displayname = polygonFeature.attributes.displayname;
		
		var img = new Image();
		img.src = hoverPicUrl;
		var gw = img.width;
		var gh = img.height;
		
        var typeStyle = {
            point: {
                externalGraphic: hoverPicUrl,
                graphicWidth: gw,
                graphicHeight: gh,
                graphicXOffset: parseInt(-gw/2),
                graphicYOffset: parseInt(-gh/2),
				cursor: "pointer"
            },
            polygon: {
				fillOpacity: 0,//透明
				strokeOpacity: 0,//透明
				cursor: "pointer"
//                fillColor: "#f0f7fe",
//                //fillOpacity: 0,//透明
//                strokeColor: "#76a1cb",//"#d9534f",//"#66FF66",
//                //strokeOpacity: 0,//透明
//                strokeWidth: 1,
//                labelXOffset: 0,
//                labelYOffset: 0,//OpenLayers.BROWSER_NAME == "safari" ? 0 : -4,//兼容IE和chrome，处理字体的错位问题
//                cursor: "inherit",
//                fontColor: "#19446e",
//                label: displayname
            }
        };
        
        this.vectorLayer.drawFeature(pointFeature, typeStyle["point"]);
        this.vectorLayer.drawFeature(polygonFeature, typeStyle["polygon"]);
	},
    
    /**
     * Method: highlight
     * 取消高亮要素。
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 被取消高亮的要素对象。
     */
	unhighlight: function(feature){
		var combinationFeature = this.getCombinationFeature(feature);
		var pointFeature = combinationFeature.point;
		var polygonFeature = combinationFeature.polygon;
		var outPicUrl = pointFeature.attributes.outPicUrl;
        var displayname = polygonFeature.attributes.displayname;
		
		var img = new Image();
		img.src = outPicUrl;
		var gw = img.width;
		var gh = img.height;
        var typeStyle = {
            point: {
                externalGraphic: outPicUrl,
                graphicWidth: gw,
                graphicHeight: gh,
                graphicXOffset: parseInt(-gw/2),
                graphicYOffset: parseInt(-gh/2),
				cursor: "pointer"
            },
            polygon: {
                fillColor: "#f0f7fe",
                fillOpacity: 0,//透明
                strokeColor: "#76a1cb",//"#d9534f",//"#66FF66",
                strokeOpacity: 0,//透明
                strokeWidth: 1,
                cursor: "pointer"
                //labelXOffset: 0,
                //labelYOffset: OpenLayers.BROWSER_NAME == "safari" ? 0 : -4,//
                //fontColor: "#19446e",
                //label: displayname
            }
        };
        
        this.vectorLayer.drawFeature(pointFeature, typeStyle["point"]);
        this.vectorLayer.drawFeature(polygonFeature, typeStyle["polygon"]);
	},
	
    /**
     * APIMethod: onSelectFeature
     * 点击选取要素后触发的方法。
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 点击后，被触发的要素。
     */
	onSelectFeature: function(feature) {
    },
	
    /**
     * APIMethod: onUnselectFeature
     * 取消选取要素后触发的方法。
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 取消选择后，被触发的要素。
     */
	onUnselectFeature: function(feature) {
    },
	
    /**
     * APIMethod: onMouseOverFeature
     * 鼠标移上要素后触发的方法。
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 鼠标移上要素后，被触发的要素。
     */
	onMouseOverFeature: function(feature) {
    },
	
    /**
     * APIMethod: onMouseOutFeature
     * 鼠标移出要素后触发的方法。
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 鼠标移出要素后，被触发的要素。
     */
	onMouseOutFeature: function(feature) {
    },
	
    /**
     * APIMethod: removeFeatures
     * 清除热区图层上所有要素。
     */
	removeFeatures: function() {
		this.selectCtrl.unselectAll();
		this.vectorLayer.destroyFeatures();
		this.urls = [];
    },
	
	/**
     * Method: moveTo
     * This function is called whenever the map is moved. All the moving
     * of actual 'tiles' is done by the map, but moveTo's role is to accept
     * a bounds and make sure the data that that bounds requires is pre-loaded.
     *
     * Parameters:
     * bounds - {<Geo.Bounds>}
     * zoomChanged - {Boolean}
     * dragging - {Boolean}
     */
    moveTo:function(bounds, zoomChanged, dragging) {
		if (zoomChanged || !this.matrix) {
            this.updateMatrixProperties();
        }
		
        OpenLayers.Layer.HTTPRequest.prototype.moveTo.apply(this, arguments);
        
        bounds = bounds || this.map.getExtent();

        if (bounds != null) {
             
            // if grid is empty or zoom has changed, we *must* re-tile
            var forceReTile = !this.grid.length || zoomChanged;

            // total bounds of the tiles
            var tilesBounds = this.getTilesBounds();            
      
            if (this.singleTile) {
                
                // We want to redraw whenever even the slightest part of the 
                //  current bounds is not contained by our tile.
                //  (thus, we do not specify partial -- its default is false)
                if ( forceReTile || 
                     (!dragging && !tilesBounds.containsBounds(bounds))) {
                    this.initSingleTile(bounds);
                }
            } else {
             
                // if the bounds have changed such that they are not even 
                //  *partially* contained by our tiles (IE user has 
                //  programmatically panned to the other side of the earth) 
                //  then we want to reTile (thus, partial true).  
                //
                if (forceReTile || !tilesBounds.containsBounds(bounds, true)) {
                    this.initGriddedTiles(bounds);
                } else {
                    this.moveGriddedTiles();
                }
            }
        }
    },
	
    /**
     * Method: getCombinationFeature
     * 获取组合要素。包含点和面的一组要素。
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 要素。
     *
     * Returns:
     * {Object} 返回包含点和面的一组要素。
     */
    getCombinationFeature: function(feature) {
        var pointFeature = null;
        var polygonFeature = null;
        var type = feature.attributes.type;
        var relatedid = feature.attributes.relatedid;
        if (type == "point") {
            pointFeature = feature;
			polygonFeature = this.vectorLayer.getFeatureById(relatedid);
        }
        else {
            pointFeature = this.vectorLayer.getFeatureById(relatedid);
			polygonFeature  = feature;
        }
        
        return {
            point: pointFeature,
            polygon: polygonFeature
        };
    },
	
    /**
     * Method: removeMap
     * Called when the layer is removed from the map.
     *
     * Parameters:
     * map - {<OpenLayers.Map>} The map.
     */
    removeMap: function(map) {
		this.map.removeControl(this.highlightCtrl);
		this.map.removeControl(this.selectCtrl);
		this.highlightCtrl = null;
		this.selectCtrl = null;
		this.map.events.unregister("zoomend", this, this.removeFeatures);
		this.map.removeLayer(this.vectorLayer);
		this.vectorLayer = null;
		OpenLayers.Layer.Grid.prototype.removeMap.apply(this, arguments);
    },
	
	/**
     * Method: addTile
     * Create a tile, initialize it, and add it to the layer div. 
     *
     * Parameters
     * bounds - {<Geo.Bounds>}
     * position - {<Geo.Pixel>}
     *
     * Returns:
     * {<Geo.Tile>} The added Geo.Tile
     */
    addTile: function(bounds, position) {
		if(this.format == "text/json"){
			return new Geo.View2D.Tile.TileFeature(this, position, bounds, null, 
                                         this.tileSize, this.tileOptions);
		}
    },
	
	/**
     * Method: destroy
     * Deconstruct the layer and clear the grid.
     */
    destroy: function() {
        OpenLayers.Layer.Grid.prototype.destroy.apply(this, arguments);
    },
	
	/**
     * Method: getPicURL
     * 
     * Parameters:
     * picid - {<Number>}
     * isanti - {<Blooean>}
     * 
     * Returns:
     * {String} A URL for the pic.
     */
    getPicURL: function(picid, isanti){
		
        // assemble all required parameters
        var params = {
            SERVICE: "WMTS",
            REQUEST: "GetIcon",
            VERSION: this.version,
            LAYER: this.layer,
            STYLE: this.style,
            TILEMATRIXSET: this.matrixSet,
            TILEMATRIX: this.matrix.identifier,
            PICID: picid, //0
            ISANTI: isanti // false
        };
        var url = OpenLayers.Layer.Grid.prototype.getFullRequestString.apply(this, [params]);
        
        return url;
    },
	
    CLASS_NAME: "Geo.View2D.Layer.HotareaWMTS"
});/**
 * 根据官方zrender 1.0.2版本改写，支持amd、cmd、和标签式引入三种方式
 * 其中标签式引用在Geo对象或者window对象下扩展出两个对象zrender和color
 */
(function(root, factory) {
	// Browser globals (root is window)
	var value = factory();
	if(Geo) {
	    root.Geo.zrender = value.zrender;
	    root.Geo.zrColor = value.color;
	}else{
	    root.zrender = value.zrender;
	    root.zrColor = value.color;
	}
}(this, function() {
    var require, define;
    (function() {
        var mods = {};
        define = function(id, deps, factory) {
            mods[id] = { id: id, deps: deps, factory: factory, defined: 0, exports: {}, require: createRequire(id) };
        };
        require = createRequire("");

        function normalize(id, baseId) {
            if (!baseId) {
                return id;
            }
            if (id.indexOf(".") === 0) {
                var basePath = baseId.split("/");
                var namePath = id.split("/");
                var baseLen = basePath.length - 1;
                var nameLen = namePath.length;
                var cutBaseTerms = 0;
                var cutNameTerms = 0;
                pathLoop:
                    for (var i = 0; i < nameLen; i++) {
                        switch (namePath[i]) {
                            case "..":
                                if (cutBaseTerms < baseLen) {
                                    cutBaseTerms++;
                                    cutNameTerms++;
                                } else {
                                    break pathLoop;
                                }
                                break;
                            case ".":
                                cutNameTerms++;
                                break;
                            default:
                                break pathLoop;
                        }
                    }
                basePath.length = baseLen - cutBaseTerms;
                namePath = namePath.slice(cutNameTerms);
                return basePath.concat(namePath).join("/");
            }
            return id;
        }

        function createRequire(baseId) {
            var cacheMods = {};

            function localRequire(id, callback) {
                if (typeof id === "string") {
                    var exports = cacheMods[id];
                    if (!exports) {
                        exports = getModExports(normalize(id, baseId));
                        cacheMods[id] = exports;
                    }
                    return exports;
                } else {
                    if (id instanceof Array) {
                        callback = callback || function() {};
                        callback.apply(this, getModsExports(id, callback, baseId));
                    }
                }
            }
            return localRequire;
        }

        function getModsExports(ids, factory, baseId) {
            var es = [];
            var mod = mods[baseId];
            for (var i = 0, l = Math.min(ids.length, factory.length); i < l; i++) {
                var id = normalize(ids[i], baseId);
                var arg;
                switch (id) {
                    case "require":
                        arg = (mod && mod.require) || require;
                        break;
                    case "exports":
                        arg = mod.exports;
                        break;
                    case "module":
                        arg = mod;
                        break;
                    default:
                        arg = getModExports(id);
                }
                es.push(arg);
            }
            return es;
        }

        function getModExports(id) {
            var mod = mods[id];
            if (!mod) {
                throw new Error("No " + id);
            }
            if (!mod.defined) {
                var factory = mod.factory;
                var factoryReturn = factory.apply(this, getModsExports(mod.deps || [], factory, id));
                if (typeof factoryReturn !== "undefined") {
                    mod.exports = factoryReturn;
                }
                mod.defined = 1;
            }
            return mod.exports;
        }
    }());

    define('zrender/lib/excanvas', ['require'], function(require) {
        // Only add this code if we do not already have a canvas implementation
        if (!document.createElement('canvas').getContext) {
            (function() {

                // alias some functions to make (compiled) code shorter
                var m = Math;
                var mr = m.round;
                var ms = m.sin;
                var mc = m.cos;
                var abs = m.abs;
                var sqrt = m.sqrt;

                // this is used for sub pixel precision
                var Z = 10;
                var Z2 = Z / 2;

                var IE_VERSION = +navigator.userAgent.match(/MSIE ([\d.]+)?/)[1];

                /**
                 * This funtion is assigned to the <canvas> elements as element.getContext().
                 * @this {HTMLElement}
                 * @return {CanvasRenderingContext2D_}
                 */
                function getContext() {
                    return this.context_ ||
                        (this.context_ = new CanvasRenderingContext2D_(this));
                }

                var slice = Array.prototype.slice;
               
                function bind(f, obj, var_args) {
                    var a = slice.call(arguments, 2);
                    return function() {
                        return f.apply(obj, a.concat(slice.call(arguments)));
                    };
                }

                function encodeHtmlAttribute(s) {
                    return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
                }

                function addNamespace(doc, prefix, urn) {
                    if (!doc.namespaces[prefix]) {
                        doc.namespaces.add(prefix, urn, '#default#VML');
                    }
                }

                function addNamespacesAndStylesheet(doc) {
                    addNamespace(doc, 'g_vml_', 'urn:schemas-microsoft-com:vml');
                    addNamespace(doc, 'g_o_', 'urn:schemas-microsoft-com:office:office');

                    // Setup default CSS.  Only add one style sheet per document
                    if (!doc.styleSheets['ex_canvas_']) {
                        var ss = doc.createStyleSheet();
                        ss.owningElement.id = 'ex_canvas_';
                        ss.cssText = 'canvas{display:inline-block;overflow:hidden;' +
                            // default size is 300x150 in Gecko and Opera
                            'text-align:left;width:300px;height:150px}';
                    }
                }

                // Add namespaces and stylesheet at startup.
                addNamespacesAndStylesheet(document);

                var G_vmlCanvasManager_ = {
                    init: function(opt_doc) {
                        var doc = opt_doc || document;
                        // Create a dummy element so that IE will allow canvas elements to be
                        // recognized.
                        doc.createElement('canvas');
                        doc.attachEvent('onreadystatechange', bind(this.init_, this, doc));
                    },

                    init_: function(doc) {
                        // find all canvas elements
                        var els = doc.getElementsByTagName('canvas');
                        for (var i = 0; i < els.length; i++) {
                            this.initElement(els[i]);
                        }
                    },

                    /**
                     * Public initializes a canvas element so that it can be used as canvas
                     * element from now on. This is called automatically before the page is
                     * loaded but if you are creating elements using createElement you need to
                     * make sure this is called on the element.
                     * @param {HTMLElement} el The canvas element to initialize.
                     * @return {HTMLElement} the element that was created.
                     */
                    initElement: function(el) {
                        if (!el.getContext) {
                            el.getContext = getContext;

                            // Add namespaces and stylesheet to document of the element.
                            addNamespacesAndStylesheet(el.ownerDocument);

                            // Remove fallback content. There is no way to hide text nodes so we
                            // just remove all childNodes. We could hide all elements and remove
                            // text nodes but who really cares about the fallback content.
                            el.innerHTML = '';

                            // do not use inline function because that will leak memory
                            el.attachEvent('onpropertychange', onPropertyChange);
                            el.attachEvent('onresize', onResize);

                            var attrs = el.attributes;
                            if (attrs.width && attrs.width.specified) {
                                // TODO: use runtimeStyle and coordsize
                                // el.getContext().setWidth_(attrs.width.nodeValue);
                                el.style.width = attrs.width.nodeValue + 'px';
                            } else {
                                el.width = el.clientWidth;
                            }
                            if (attrs.height && attrs.height.specified) {
                                // TODO: use runtimeStyle and coordsize
                                // el.getContext().setHeight_(attrs.height.nodeValue);
                                el.style.height = attrs.height.nodeValue + 'px';
                            } else {
                                el.height = el.clientHeight;
                            }
                            //el.getContext().setCoordsize_()
                        }
                        return el;
                    }
                };

                function onPropertyChange(e) {
                    var el = e.srcElement;

                    switch (e.propertyName) {
                        case 'width':
                            el.getContext().clearRect();
                            el.style.width = el.attributes.width.nodeValue + 'px';
                            // In IE8 this does not trigger onresize.
                            el.firstChild.style.width = el.clientWidth + 'px';
                            break;
                        case 'height':
                            el.getContext().clearRect();
                            el.style.height = el.attributes.height.nodeValue + 'px';
                            el.firstChild.style.height = el.clientHeight + 'px';
                            break;
                    }
                }

                function onResize(e) {
                    var el = e.srcElement;
                    if (el.firstChild) {
                        el.firstChild.style.width = el.clientWidth + 'px';
                        el.firstChild.style.height = el.clientHeight + 'px';
                    }
                }

                G_vmlCanvasManager_.init();

                // precompute "00" to "FF"
                var decToHex = [];
                for (var i = 0; i < 16; i++) {
                    for (var j = 0; j < 16; j++) {
                        decToHex[i * 16 + j] = i.toString(16) + j.toString(16);
                    }
                }

                function createMatrixIdentity() {
                    return [
                        [1, 0, 0],
                        [0, 1, 0],
                        [0, 0, 1]
                    ];
                }

                function matrixMultiply(m1, m2) {
                    var result = createMatrixIdentity();

                    for (var x = 0; x < 3; x++) {
                        for (var y = 0; y < 3; y++) {
                            var sum = 0;

                            for (var z = 0; z < 3; z++) {
                                sum += m1[x][z] * m2[z][y];
                            }

                            result[x][y] = sum;
                        }
                    }
                    return result;
                }

                function copyState(o1, o2) {
                    o2.fillStyle = o1.fillStyle;
                    o2.lineCap = o1.lineCap;
                    o2.lineJoin = o1.lineJoin;
                    o2.lineWidth = o1.lineWidth;
                    o2.miterLimit = o1.miterLimit;
                    o2.shadowBlur = o1.shadowBlur;
                    o2.shadowColor = o1.shadowColor;
                    o2.shadowOffsetX = o1.shadowOffsetX;
                    o2.shadowOffsetY = o1.shadowOffsetY;
                    o2.strokeStyle = o1.strokeStyle;
                    o2.globalAlpha = o1.globalAlpha;
                    o2.font = o1.font;
                    o2.textAlign = o1.textAlign;
                    o2.textBaseline = o1.textBaseline;
                    o2.arcScaleX_ = o1.arcScaleX_;
                    o2.arcScaleY_ = o1.arcScaleY_;
                    o2.lineScale_ = o1.lineScale_;
                }

                var colorData = {
                    aliceblue: '#F0F8FF',
                    antiquewhite: '#FAEBD7',
                    aquamarine: '#7FFFD4',
                    azure: '#F0FFFF',
                    beige: '#F5F5DC',
                    bisque: '#FFE4C4',
                    black: '#000000',
                    blanchedalmond: '#FFEBCD',
                    blueviolet: '#8A2BE2',
                    brown: '#A52A2A',
                    burlywood: '#DEB887',
                    cadetblue: '#5F9EA0',
                    chartreuse: '#7FFF00',
                    chocolate: '#D2691E',
                    coral: '#FF7F50',
                    cornflowerblue: '#6495ED',
                    cornsilk: '#FFF8DC',
                    crimson: '#DC143C',
                    cyan: '#00FFFF',
                    darkblue: '#00008B',
                    darkcyan: '#008B8B',
                    darkgoldenrod: '#B8860B',
                    darkgray: '#A9A9A9',
                    darkgreen: '#006400',
                    darkgrey: '#A9A9A9',
                    darkkhaki: '#BDB76B',
                    darkmagenta: '#8B008B',
                    darkolivegreen: '#556B2F',
                    darkorange: '#FF8C00',
                    darkorchid: '#9932CC',
                    darkred: '#8B0000',
                    darksalmon: '#E9967A',
                    darkseagreen: '#8FBC8F',
                    darkslateblue: '#483D8B',
                    darkslategray: '#2F4F4F',
                    darkslategrey: '#2F4F4F',
                    darkturquoise: '#00CED1',
                    darkviolet: '#9400D3',
                    deeppink: '#FF1493',
                    deepskyblue: '#00BFFF',
                    dimgray: '#696969',
                    dimgrey: '#696969',
                    dodgerblue: '#1E90FF',
                    firebrick: '#B22222',
                    floralwhite: '#FFFAF0',
                    forestgreen: '#228B22',
                    gainsboro: '#DCDCDC',
                    ghostwhite: '#F8F8FF',
                    gold: '#FFD700',
                    goldenrod: '#DAA520',
                    grey: '#808080',
                    greenyellow: '#ADFF2F',
                    honeydew: '#F0FFF0',
                    hotpink: '#FF69B4',
                    indianred: '#CD5C5C',
                    indigo: '#4B0082',
                    ivory: '#FFFFF0',
                    khaki: '#F0E68C',
                    lavender: '#E6E6FA',
                    lavenderblush: '#FFF0F5',
                    lawngreen: '#7CFC00',
                    lemonchiffon: '#FFFACD',
                    lightblue: '#ADD8E6',
                    lightcoral: '#F08080',
                    lightcyan: '#E0FFFF',
                    lightgoldenrodyellow: '#FAFAD2',
                    lightgreen: '#90EE90',
                    lightgrey: '#D3D3D3',
                    lightpink: '#FFB6C1',
                    lightsalmon: '#FFA07A',
                    lightseagreen: '#20B2AA',
                    lightskyblue: '#87CEFA',
                    lightslategray: '#778899',
                    lightslategrey: '#778899',
                    lightsteelblue: '#B0C4DE',
                    lightyellow: '#FFFFE0',
                    limegreen: '#32CD32',
                    linen: '#FAF0E6',
                    magenta: '#FF00FF',
                    mediumaquamarine: '#66CDAA',
                    mediumblue: '#0000CD',
                    mediumorchid: '#BA55D3',
                    mediumpurple: '#9370DB',
                    mediumseagreen: '#3CB371',
                    mediumslateblue: '#7B68EE',
                    mediumspringgreen: '#00FA9A',
                    mediumturquoise: '#48D1CC',
                    mediumvioletred: '#C71585',
                    midnightblue: '#191970',
                    mintcream: '#F5FFFA',
                    mistyrose: '#FFE4E1',
                    moccasin: '#FFE4B5',
                    navajowhite: '#FFDEAD',
                    oldlace: '#FDF5E6',
                    olivedrab: '#6B8E23',
                    orange: '#FFA500',
                    orangered: '#FF4500',
                    orchid: '#DA70D6',
                    palegoldenrod: '#EEE8AA',
                    palegreen: '#98FB98',
                    paleturquoise: '#AFEEEE',
                    palevioletred: '#DB7093',
                    papayawhip: '#FFEFD5',
                    peachpuff: '#FFDAB9',
                    peru: '#CD853F',
                    pink: '#FFC0CB',
                    plum: '#DDA0DD',
                    powderblue: '#B0E0E6',
                    rosybrown: '#BC8F8F',
                    royalblue: '#4169E1',
                    saddlebrown: '#8B4513',
                    salmon: '#FA8072',
                    sandybrown: '#F4A460',
                    seagreen: '#2E8B57',
                    seashell: '#FFF5EE',
                    sienna: '#A0522D',
                    skyblue: '#87CEEB',
                    slateblue: '#6A5ACD',
                    slategray: '#708090',
                    slategrey: '#708090',
                    snow: '#FFFAFA',
                    springgreen: '#00FF7F',
                    steelblue: '#4682B4',
                    tan: '#D2B48C',
                    thistle: '#D8BFD8',
                    tomato: '#FF6347',
                    turquoise: '#40E0D0',
                    violet: '#EE82EE',
                    wheat: '#F5DEB3',
                    whitesmoke: '#F5F5F5',
                    yellowgreen: '#9ACD32'
                };


                function getRgbHslContent(styleString) {
                    var start = styleString.indexOf('(', 3);
                    var end = styleString.indexOf(')', start + 1);
                    var parts = styleString.substring(start + 1, end).split(',');
                    // add alpha if needed
                    if (parts.length != 4 || styleString.charAt(3) != 'a') {
                        parts[3] = 1;
                    }
                    return parts;
                }

                function percent(s) {
                    return parseFloat(s) / 100;
                }

                function clamp(v, min, max) {
                    return Math.min(max, Math.max(min, v));
                }

                function hslToRgb(parts) {
                    var r, g, b, h, s, l;
                    h = parseFloat(parts[0]) / 360 % 360;
                    if (h < 0)
                        h++;
                    s = clamp(percent(parts[1]), 0, 1);
                    l = clamp(percent(parts[2]), 0, 1);
                    if (s == 0) {
                        r = g = b = l; // achromatic
                    } else {
                        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                        var p = 2 * l - q;
                        r = hueToRgb(p, q, h + 1 / 3);
                        g = hueToRgb(p, q, h);
                        b = hueToRgb(p, q, h - 1 / 3);
                    }

                    return '#' + decToHex[Math.floor(r * 255)] +
                        decToHex[Math.floor(g * 255)] +
                        decToHex[Math.floor(b * 255)];
                }

                function hueToRgb(m1, m2, h) {
                    if (h < 0)
                        h++;
                    if (h > 1)
                        h--;

                    if (6 * h < 1)
                        return m1 + (m2 - m1) * 6 * h;
                    else if (2 * h < 1)
                        return m2;
                    else if (3 * h < 2)
                        return m1 + (m2 - m1) * (2 / 3 - h) * 6;
                    else
                        return m1;
                }

                var processStyleCache = {};

                function processStyle(styleString) {
                    if (styleString in processStyleCache) {
                        return processStyleCache[styleString];
                    }

                    var str, alpha = 1;

                    styleString = String(styleString);
                    if (styleString.charAt(0) == '#') {
                        str = styleString;
                    } else if (/^rgb/.test(styleString)) {
                        var parts = getRgbHslContent(styleString);
                        var str = '#',
                            n;
                        for (var i = 0; i < 3; i++) {
                            if (parts[i].indexOf('%') != -1) {
                                n = Math.floor(percent(parts[i]) * 255);
                            } else {
                                n = +parts[i];
                            }
                            str += decToHex[clamp(n, 0, 255)];
                        }
                        alpha = +parts[3];
                    } else if (/^hsl/.test(styleString)) {
                        var parts = getRgbHslContent(styleString);
                        str = hslToRgb(parts);
                        alpha = parts[3];
                    } else {
                        str = colorData[styleString] || styleString;
                    }
                    return processStyleCache[styleString] = { color: str, alpha: alpha };
                }

                var DEFAULT_STYLE = {
                    style: 'normal',
                    variant: 'normal',
                    weight: 'normal',
                    size: 10,
                    family: 'sans-serif'
                };

                // Internal text style cache
                var fontStyleCache = {};

                function processFontStyle(styleString) {
                    if (fontStyleCache[styleString]) {
                        return fontStyleCache[styleString];
                    }

                    var el = document.createElement('div');
                    var style = el.style;
                    try {
                        style.font = styleString;
                    } catch (ex) {
                        // Ignore failures to set to invalid font.
                    }

                    return fontStyleCache[styleString] = {
                        style: style.fontStyle || DEFAULT_STYLE.style,
                        variant: style.fontVariant || DEFAULT_STYLE.variant,
                        weight: style.fontWeight || DEFAULT_STYLE.weight,
                        size: style.fontSize || DEFAULT_STYLE.size,
                        family: style.fontFamily || DEFAULT_STYLE.family
                    };
                }

                function getComputedStyle(style, element) {
                    var computedStyle = {};

                    for (var p in style) {
                        computedStyle[p] = style[p];
                    }

                    // Compute the size
                    var canvasFontSize = parseFloat(element.currentStyle.fontSize),
                        fontSize = parseFloat(style.size);

                    if (typeof style.size == 'number') {
                        computedStyle.size = style.size;
                    } else if (style.size.indexOf('px') != -1) {
                        computedStyle.size = fontSize;
                    } else if (style.size.indexOf('em') != -1) {
                        computedStyle.size = canvasFontSize * fontSize;
                    } else if (style.size.indexOf('%') != -1) {
                        computedStyle.size = (canvasFontSize / 100) * fontSize;
                    } else if (style.size.indexOf('pt') != -1) {
                        computedStyle.size = fontSize / .75;
                    } else {
                        computedStyle.size = canvasFontSize;
                    }

                    // Different scaling between normal text and VML text. This was found using
                    // trial and error to get the same size as non VML text.
                    computedStyle.size *= 0.981;

                    return computedStyle;
                }

                function buildStyle(style) {
                    return style.style + ' ' + style.variant + ' ' + style.weight + ' ' +
                        style.size + 'px ' + style.family;
                }

                var lineCapMap = {
                    'butt': 'flat',
                    'round': 'round'
                };

                function processLineCap(lineCap) {
                    return lineCapMap[lineCap] || 'square';
                }

                /**
                 * This class implements CanvasRenderingContext2D interface as described by
                 * the WHATWG.
                 * @param {HTMLElement} canvasElement The element that the 2D context should
                 * be associated with
                 */
                function CanvasRenderingContext2D_(canvasElement) {
                    this.m_ = createMatrixIdentity();

                    this.mStack_ = [];
                    this.aStack_ = [];
                    this.currentPath_ = [];

                    // Canvas context properties
                    this.strokeStyle = '#000';
                    this.fillStyle = '#000';

                    this.lineWidth = 1;
                    this.lineJoin = 'miter';
                    this.lineCap = 'butt';
                    this.miterLimit = Z * 1;
                    this.globalAlpha = 1;
                    this.font = '10px sans-serif';
                    this.textAlign = 'left';
                    this.textBaseline = 'alphabetic';
                    this.canvas = canvasElement;

                    var cssText = 'width:' + canvasElement.clientWidth + 'px;height:' +
                        canvasElement.clientHeight + 'px;overflow:hidden;position:absolute';
                    var el = canvasElement.ownerDocument.createElement('div');
                    el.style.cssText = cssText;
                    canvasElement.appendChild(el);

                    var overlayEl = el.cloneNode(false);
                    // Use a non transparent background.
                    overlayEl.style.backgroundColor = 'red';
                    overlayEl.style.filter = 'alpha(opacity=0)';
                    canvasElement.appendChild(overlayEl);

                    this.element_ = el;
                    this.arcScaleX_ = 1;
                    this.arcScaleY_ = 1;
                    this.lineScale_ = 1;
                }

                var contextPrototype = CanvasRenderingContext2D_.prototype;
                contextPrototype.clearRect = function() {
                    if (this.textMeasureEl_) {
                        this.textMeasureEl_.removeNode(true);
                        this.textMeasureEl_ = null;
                    }
                    this.element_.innerHTML = '';
                };

                contextPrototype.beginPath = function() {
                    // TODO: Branch current matrix so that save/restore has no effect
                    //       as per safari docs.
                    this.currentPath_ = [];
                };

                contextPrototype.moveTo = function(aX, aY) {
                    var p = getCoords(this, aX, aY);
                    this.currentPath_.push({ type: 'moveTo', x: p.x, y: p.y });
                    this.currentX_ = p.x;
                    this.currentY_ = p.y;
                };

                contextPrototype.lineTo = function(aX, aY) {
                    var p = getCoords(this, aX, aY);
                    this.currentPath_.push({ type: 'lineTo', x: p.x, y: p.y });

                    this.currentX_ = p.x;
                    this.currentY_ = p.y;
                };

                contextPrototype.bezierCurveTo = function(aCP1x, aCP1y,
                    aCP2x, aCP2y,
                    aX, aY) {
                    var p = getCoords(this, aX, aY);
                    var cp1 = getCoords(this, aCP1x, aCP1y);
                    var cp2 = getCoords(this, aCP2x, aCP2y);
                    bezierCurveTo(this, cp1, cp2, p);
                };

                // Helper function that takes the already fixed cordinates.
                function bezierCurveTo(self, cp1, cp2, p) {
                    self.currentPath_.push({
                        type: 'bezierCurveTo',
                        cp1x: cp1.x,
                        cp1y: cp1.y,
                        cp2x: cp2.x,
                        cp2y: cp2.y,
                        x: p.x,
                        y: p.y
                    });
                    self.currentX_ = p.x;
                    self.currentY_ = p.y;
                }

                contextPrototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
                    // the following is lifted almost directly from
                    // http://developer.mozilla.org/en/docs/Canvas_tutorial:Drawing_shapes

                    var cp = getCoords(this, aCPx, aCPy);
                    var p = getCoords(this, aX, aY);

                    var cp1 = {
                        x: this.currentX_ + 2.0 / 3.0 * (cp.x - this.currentX_),
                        y: this.currentY_ + 2.0 / 3.0 * (cp.y - this.currentY_)
                    };
                    var cp2 = {
                        x: cp1.x + (p.x - this.currentX_) / 3.0,
                        y: cp1.y + (p.y - this.currentY_) / 3.0
                    };

                    bezierCurveTo(this, cp1, cp2, p);
                };

                contextPrototype.arc = function(aX, aY, aRadius,
                    aStartAngle, aEndAngle, aClockwise) {
                    aRadius *= Z;
                    var arcType = aClockwise ? 'at' : 'wa';

                    var xStart = aX + mc(aStartAngle) * aRadius - Z2;
                    var yStart = aY + ms(aStartAngle) * aRadius - Z2;

                    var xEnd = aX + mc(aEndAngle) * aRadius - Z2;
                    var yEnd = aY + ms(aEndAngle) * aRadius - Z2;

                    // IE won't render arches drawn counter clockwise if xStart == xEnd.
                    if (xStart == xEnd && !aClockwise) {
                        xStart += 0.125; // Offset xStart by 1/80 of a pixel. Use something
                        // that can be represented in binary
                    }

                    var p = getCoords(this, aX, aY);
                    var pStart = getCoords(this, xStart, yStart);
                    var pEnd = getCoords(this, xEnd, yEnd);

                    this.currentPath_.push({
                        type: arcType,
                        x: p.x,
                        y: p.y,
                        radius: aRadius,
                        xStart: pStart.x,
                        yStart: pStart.y,
                        xEnd: pEnd.x,
                        yEnd: pEnd.y
                    });

                };

                contextPrototype.rect = function(aX, aY, aWidth, aHeight) {
                    this.moveTo(aX, aY);
                    this.lineTo(aX + aWidth, aY);
                    this.lineTo(aX + aWidth, aY + aHeight);
                    this.lineTo(aX, aY + aHeight);
                    this.closePath();
                };

                contextPrototype.strokeRect = function(aX, aY, aWidth, aHeight) {
                    var oldPath = this.currentPath_;
                    this.beginPath();

                    this.moveTo(aX, aY);
                    this.lineTo(aX + aWidth, aY);
                    this.lineTo(aX + aWidth, aY + aHeight);
                    this.lineTo(aX, aY + aHeight);
                    this.closePath();
                    this.stroke();

                    this.currentPath_ = oldPath;
                };

                contextPrototype.fillRect = function(aX, aY, aWidth, aHeight) {
                    var oldPath = this.currentPath_;
                    this.beginPath();

                    this.moveTo(aX, aY);
                    this.lineTo(aX + aWidth, aY);
                    this.lineTo(aX + aWidth, aY + aHeight);
                    this.lineTo(aX, aY + aHeight);
                    this.closePath();
                    this.fill();

                    this.currentPath_ = oldPath;
                };

                contextPrototype.createLinearGradient = function(aX0, aY0, aX1, aY1) {
                    var gradient = new CanvasGradient_('gradient');
                    gradient.x0_ = aX0;
                    gradient.y0_ = aY0;
                    gradient.x1_ = aX1;
                    gradient.y1_ = aY1;
                    return gradient;
                };

                contextPrototype.createRadialGradient = function(aX0, aY0, aR0,
                    aX1, aY1, aR1) {
                    var gradient = new CanvasGradient_('gradientradial');
                    gradient.x0_ = aX0;
                    gradient.y0_ = aY0;
                    gradient.r0_ = aR0;
                    gradient.x1_ = aX1;
                    gradient.y1_ = aY1;
                    gradient.r1_ = aR1;
                    return gradient;
                };

                contextPrototype.drawImage = function(image, var_args) {
                    var dx, dy, dw, dh, sx, sy, sw, sh;

                    // to find the original width we overide the width and height
                    var oldRuntimeWidth = image.runtimeStyle.width;
                    var oldRuntimeHeight = image.runtimeStyle.height;
                    image.runtimeStyle.width = 'auto';
                    image.runtimeStyle.height = 'auto';

                    // get the original size
                    var w = image.width;
                    var h = image.height;

                    // and remove overides
                    image.runtimeStyle.width = oldRuntimeWidth;
                    image.runtimeStyle.height = oldRuntimeHeight;

                    if (arguments.length == 3) {
                        dx = arguments[1];
                        dy = arguments[2];
                        sx = sy = 0;
                        sw = dw = w;
                        sh = dh = h;
                    } else if (arguments.length == 5) {
                        dx = arguments[1];
                        dy = arguments[2];
                        dw = arguments[3];
                        dh = arguments[4];
                        sx = sy = 0;
                        sw = w;
                        sh = h;
                    } else if (arguments.length == 9) {
                        sx = arguments[1];
                        sy = arguments[2];
                        sw = arguments[3];
                        sh = arguments[4];
                        dx = arguments[5];
                        dy = arguments[6];
                        dw = arguments[7];
                        dh = arguments[8];
                    } else {
                        throw Error('Invalid number of arguments');
                    }

                    var d = getCoords(this, dx, dy);

                    var w2 = sw / 2;
                    var h2 = sh / 2;

                    var vmlStr = [];

                    var W = 10;
                    var H = 10;

                    // For some reason that I've now forgotten, using divs didn't work
                    vmlStr.push(' <g_vml_:group',
                        ' coordsize="', Z * W, ',', Z * H, '"',
                        ' coordorigin="0,0"',
                        ' style="width:', W, 'px;height:', H, 'px;position:absolute;');

                    // If filters are necessary (rotation exists), create them
                    // filters are bog-slow, so only create them if abbsolutely necessary
                    // The following check doesn't account for skews (which don't exist
                    // in the canvas spec (yet) anyway.

                    if (this.m_[0][0] != 1 || this.m_[0][1] ||
                        this.m_[1][1] != 1 || this.m_[1][0]) {
                        var filter = [];

                        // Note the 12/21 reversal
                        filter.push('M11=', this.m_[0][0], ',',
                            'M12=', this.m_[1][0], ',',
                            'M21=', this.m_[0][1], ',',
                            'M22=', this.m_[1][1], ',',
                            'Dx=', mr(d.x / Z), ',',
                            'Dy=', mr(d.y / Z), '');

                        // Bounding box calculation (need to minimize displayed area so that
                        // filters don't waste time on unused pixels.
                        var max = d;
                        var c2 = getCoords(this, dx + dw, dy);
                        var c3 = getCoords(this, dx, dy + dh);
                        var c4 = getCoords(this, dx + dw, dy + dh);

                        max.x = m.max(max.x, c2.x, c3.x, c4.x);
                        max.y = m.max(max.y, c2.y, c3.y, c4.y);

                        vmlStr.push('padding:0 ', mr(max.x / Z), 'px ', mr(max.y / Z),
                            'px 0;filter:progid:DXImageTransform.Microsoft.Matrix(',
                            filter.join(''), ", sizingmethod='clip');");

                    } else {
                        vmlStr.push('top:', mr(d.y / Z), 'px;left:', mr(d.x / Z), 'px;');
                    }

                    vmlStr.push(' ">',
                        '<g_vml_:image src="', image.src, '"',
                        ' style="width:', Z * dw, 'px;',
                        ' height:', Z * dh, 'px"',
                        ' cropleft="', sx / w, '"',
                        ' croptop="', sy / h, '"',
                        ' cropright="', (w - sx - sw) / w, '"',
                        ' cropbottom="', (h - sy - sh) / h, '"',
                        ' />',
                        '</g_vml_:group>');

                    this.element_.insertAdjacentHTML('BeforeEnd', vmlStr.join(''));
                };

                contextPrototype.stroke = function(aFill) {
                    var lineStr = [];
                    var lineOpen = false;

                    var W = 10;
                    var H = 10;

                    lineStr.push('<g_vml_:shape',
                        ' filled="', !!aFill, '"',
                        ' style="position:absolute;width:', W, 'px;height:', H, 'px;"',
                        ' coordorigin="0,0"',
                        ' coordsize="', Z * W, ',', Z * H, '"',
                        ' stroked="', !aFill, '"',
                        ' path="');

                    var newSeq = false;
                    var min = { x: null, y: null };
                    var max = { x: null, y: null };

                    for (var i = 0; i < this.currentPath_.length; i++) {
                        var p = this.currentPath_[i];
                        var c;

                        switch (p.type) {
                            case 'moveTo':
                                c = p;
                                lineStr.push(' m ', mr(p.x), ',', mr(p.y));
                                break;
                            case 'lineTo':
                                lineStr.push(' l ', mr(p.x), ',', mr(p.y));
                                break;
                            case 'close':
                                lineStr.push(' x ');
                                p = null;
                                break;
                            case 'bezierCurveTo':
                                lineStr.push(' c ',
                                    mr(p.cp1x), ',', mr(p.cp1y), ',',
                                    mr(p.cp2x), ',', mr(p.cp2y), ',',
                                    mr(p.x), ',', mr(p.y));
                                break;
                            case 'at':
                            case 'wa':
                                lineStr.push(' ', p.type, ' ',
                                    mr(p.x - this.arcScaleX_ * p.radius), ',',
                                    mr(p.y - this.arcScaleY_ * p.radius), ' ',
                                    mr(p.x + this.arcScaleX_ * p.radius), ',',
                                    mr(p.y + this.arcScaleY_ * p.radius), ' ',
                                    mr(p.xStart), ',', mr(p.yStart), ' ',
                                    mr(p.xEnd), ',', mr(p.yEnd));
                                break;
                        }


                        // TODO: Following is broken for curves due to
                        //       move to proper paths.

                        // Figure out dimensions so we can do gradient fills
                        // properly
                        if (p) {
                            if (min.x == null || p.x < min.x) {
                                min.x = p.x;
                            }
                            if (max.x == null || p.x > max.x) {
                                max.x = p.x;
                            }
                            if (min.y == null || p.y < min.y) {
                                min.y = p.y;
                            }
                            if (max.y == null || p.y > max.y) {
                                max.y = p.y;
                            }
                        }
                    }
                    lineStr.push(' ">');

                    if (!aFill) {
                        appendStroke(this, lineStr);
                    } else {
                        appendFill(this, lineStr, min, max);
                    }

                    lineStr.push('</g_vml_:shape>');

                    this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
                };

                function appendStroke(ctx, lineStr) {
                    var a = processStyle(ctx.strokeStyle);
                    var color = a.color;
                    var opacity = a.alpha * ctx.globalAlpha;
                    var lineWidth = ctx.lineScale_ * ctx.lineWidth;

                    // VML cannot correctly render a line if the width is less than 1px.
                    // In that case, we dilute the color to make the line look thinner.
                    if (lineWidth < 1) {
                        opacity *= lineWidth;
                    }

                    lineStr.push(
                        '<g_vml_:stroke',
                        ' opacity="', opacity, '"',
                        ' joinstyle="', ctx.lineJoin, '"',
                        ' miterlimit="', ctx.miterLimit, '"',
                        ' endcap="', processLineCap(ctx.lineCap), '"',
                        ' weight="', lineWidth, 'px"',
                        ' color="', color, '" />'
                    );
                }

                function appendFill(ctx, lineStr, min, max) {
                    var fillStyle = ctx.fillStyle;
                    var arcScaleX = ctx.arcScaleX_;
                    var arcScaleY = ctx.arcScaleY_;
                    var width = max.x - min.x;
                    var height = max.y - min.y;
                    if (fillStyle instanceof CanvasGradient_) {
                        // TODO: Gradients transformed with the transformation matrix.
                        var angle = 0;
                        var focus = { x: 0, y: 0 };

                        // additional offset
                        var shift = 0;
                        // scale factor for offset
                        var expansion = 1;

                        if (fillStyle.type_ == 'gradient') {
                            var x0 = fillStyle.x0_ / arcScaleX;
                            var y0 = fillStyle.y0_ / arcScaleY;
                            var x1 = fillStyle.x1_ / arcScaleX;
                            var y1 = fillStyle.y1_ / arcScaleY;
                            var p0 = getCoords(ctx, x0, y0);
                            var p1 = getCoords(ctx, x1, y1);
                            var dx = p1.x - p0.x;
                            var dy = p1.y - p0.y;
                            angle = Math.atan2(dx, dy) * 180 / Math.PI;

                            // The angle should be a non-negative number.
                            if (angle < 0) {
                                angle += 360;
                            }

                            // Very small angles produce an unexpected result because they are
                            // converted to a scientific notation string.
                            if (angle < 1e-6) {
                                angle = 0;
                            }
                        } else {
                            var p0 = getCoords(ctx, fillStyle.x0_, fillStyle.y0_);
                            focus = {
                                x: (p0.x - min.x) / width,
                                y: (p0.y - min.y) / height
                            };

                            width /= arcScaleX * Z;
                            height /= arcScaleY * Z;
                            var dimension = m.max(width, height);
                            shift = 2 * fillStyle.r0_ / dimension;
                            expansion = 2 * fillStyle.r1_ / dimension - shift;
                        }

                        // We need to sort the color stops in ascending order by offset,
                        // otherwise IE won't interpret it correctly.
                        var stops = fillStyle.colors_;
                        stops.sort(function(cs1, cs2) {
                            return cs1.offset - cs2.offset;
                        });

                        var length = stops.length;
                        var color1 = stops[0].color;
                        var color2 = stops[length - 1].color;
                        var opacity1 = stops[0].alpha * ctx.globalAlpha;
                        var opacity2 = stops[length - 1].alpha * ctx.globalAlpha;

                        var colors = [];
                        for (var i = 0; i < length; i++) {
                            var stop = stops[i];
                            colors.push(stop.offset * expansion + shift + ' ' + stop.color);
                        }

                        // When colors attribute is used, the meanings of opacity and o:opacity2
                        // are reversed.
                        lineStr.push('<g_vml_:fill type="', fillStyle.type_, '"',
                            ' method="none" focus="100%"',
                            ' color="', color1, '"',
                            ' color2="', color2, '"',
                            ' colors="', colors.join(','), '"',
                            ' opacity="', opacity2, '"',
                            ' g_o_:opacity2="', opacity1, '"',
                            ' angle="', angle, '"',
                            ' focusposition="', focus.x, ',', focus.y, '" />');
                    } else if (fillStyle instanceof CanvasPattern_) {
                        if (width && height) {
                            var deltaLeft = -min.x;
                            var deltaTop = -min.y;
                            lineStr.push('<g_vml_:fill',
                                ' position="',
                                deltaLeft / width * arcScaleX * arcScaleX, ',',
                                deltaTop / height * arcScaleY * arcScaleY, '"',
                                ' type="tile"',
                                // TODO: Figure out the correct size to fit the scale.
                                //' size="', w, 'px ', h, 'px"',
                                ' src="', fillStyle.src_, '" />');
                        }
                    } else {
                        var a = processStyle(ctx.fillStyle);
                        var color = a.color;
                        var opacity = a.alpha * ctx.globalAlpha;
                        lineStr.push('<g_vml_:fill color="', color, '" opacity="', opacity,
                            '" />');
                    }
                }

                contextPrototype.fill = function() {
                    this.stroke(true);
                };

                contextPrototype.closePath = function() {
                    this.currentPath_.push({ type: 'close' });
                };

                function getCoords(ctx, aX, aY) {
                    var m = ctx.m_;
                    return {
                        x: Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2,
                        y: Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2
                    };
                };

                contextPrototype.save = function() {
                    var o = {};
                    copyState(this, o);
                    this.aStack_.push(o);
                    this.mStack_.push(this.m_);
                    this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);
                };

                contextPrototype.restore = function() {
                    if (this.aStack_.length) {
                        copyState(this.aStack_.pop(), this);
                        this.m_ = this.mStack_.pop();
                    }
                };

                function matrixIsFinite(m) {
                    return isFinite(m[0][0]) && isFinite(m[0][1]) &&
                        isFinite(m[1][0]) && isFinite(m[1][1]) &&
                        isFinite(m[2][0]) && isFinite(m[2][1]);
                }

                function setM(ctx, m, updateLineScale) {
                    if (!matrixIsFinite(m)) {
                        return;
                    }
                    ctx.m_ = m;

                    if (updateLineScale) {
                        // Get the line scale.
                        // Determinant of this.m_ means how much the area is enlarged by the
                        // transformation. So its square root can be used as a scale factor
                        // for width.
                        var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
                        ctx.lineScale_ = sqrt(abs(det));
                    }
                }

                contextPrototype.translate = function(aX, aY) {
                    var m1 = [
                        [1, 0, 0],
                        [0, 1, 0],
                        [aX, aY, 1]
                    ];

                    setM(this, matrixMultiply(m1, this.m_), false);
                };

                contextPrototype.rotate = function(aRot) {
                    var c = mc(aRot);
                    var s = ms(aRot);

                    var m1 = [
                        [c, s, 0],
                        [-s, c, 0],
                        [0, 0, 1]
                    ];

                    setM(this, matrixMultiply(m1, this.m_), false);
                };

                contextPrototype.scale = function(aX, aY) {
                    this.arcScaleX_ *= aX;
                    this.arcScaleY_ *= aY;
                    var m1 = [
                        [aX, 0, 0],
                        [0, aY, 0],
                        [0, 0, 1]
                    ];

                    setM(this, matrixMultiply(m1, this.m_), true);
                };

                contextPrototype.transform = function(m11, m12, m21, m22, dx, dy) {
                    var m1 = [
                        [m11, m12, 0],
                        [m21, m22, 0],
                        [dx, dy, 1]
                    ];

                    setM(this, matrixMultiply(m1, this.m_), true);
                };

                contextPrototype.setTransform = function(m11, m12, m21, m22, dx, dy) {
                    var m = [
                        [m11, m12, 0],
                        [m21, m22, 0],
                        [dx, dy, 1]
                    ];

                    setM(this, m, true);
                };

                /**
                 * The text drawing function.
                 * The maxWidth argument isn't taken in account, since no browser supports
                 * it yet.
                 */
                contextPrototype.drawText_ = function(text, x, y, maxWidth, stroke) {
                    var m = this.m_,
                        delta = 1000,
                        left = 0,
                        right = delta,
                        offset = { x: 0, y: 0 },
                        lineStr = [];

                    var fontStyle = getComputedStyle(processFontStyle(this.font),
                        this.element_);

                    var fontStyleString = buildStyle(fontStyle);

                    var elementStyle = this.element_.currentStyle;
                    var textAlign = this.textAlign.toLowerCase();
                    switch (textAlign) {
                        case 'left':
                        case 'center':
                        case 'right':
                            break;
                        case 'end':
                            textAlign = elementStyle.direction == 'ltr' ? 'right' : 'left';
                            break;
                        case 'start':
                            textAlign = elementStyle.direction == 'rtl' ? 'right' : 'left';
                            break;
                        default:
                            textAlign = 'left';
                    }

                    // 1.75 is an arbitrary number, as there is no info about the text baseline
                    switch (this.textBaseline) {
                        case 'hanging':
                        case 'top':
                            offset.y = fontStyle.size / 1.75;
                            break;
                        case 'middle':
                            break;
                        default:
                        case null:
                        case 'alphabetic':
                        case 'ideographic':
                        case 'bottom':
                            offset.y = -fontStyle.size / 2.25;
                            break;
                    }

                    switch (textAlign) {
                        case 'right':
                            left = delta;
                            right = 0.05;
                            break;
                        case 'center':
                            left = right = delta / 2;
                            break;
                    }

                    var d = getCoords(this, x + offset.x, y + offset.y);

                    lineStr.push('<g_vml_:line from="', -left, ' 0" to="', right, ' 0.05" ',
                        ' coordsize="100 100" coordorigin="0 0"',
                        ' filled="', !stroke, '" stroked="', !!stroke,
                        '" style="position:absolute;width:1px;height:1px;">');

                    if (stroke) {
                        appendStroke(this, lineStr);
                    } else {
                        // TODO: Fix the min and max params.
                        appendFill(this, lineStr, { x: -left, y: 0 }, { x: right, y: fontStyle.size });
                    }

                    var skewM = m[0][0].toFixed(3) + ',' + m[1][0].toFixed(3) + ',' +
                        m[0][1].toFixed(3) + ',' + m[1][1].toFixed(3) + ',0,0';

                    var skewOffset = mr(d.x / Z) + ',' + mr(d.y / Z);

                    lineStr.push('<g_vml_:skew on="t" matrix="', skewM, '" ',
                        ' offset="', skewOffset, '" origin="', left, ' 0" />',
                        '<g_vml_:path textpathok="true" />',
                        '<g_vml_:textpath on="true" string="',
                        encodeHtmlAttribute(text),
                        '" style="v-text-align:', textAlign,
                        ';font:', encodeHtmlAttribute(fontStyleString),
                        '" /></g_vml_:line>');

                    this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
                };

                contextPrototype.fillText = function(text, x, y, maxWidth) {
                    this.drawText_(text, x, y, maxWidth, false);
                };

                contextPrototype.strokeText = function(text, x, y, maxWidth) {
                    this.drawText_(text, x, y, maxWidth, true);
                };

                contextPrototype.measureText = function(text) {
                    if (!this.textMeasureEl_) {
                        var s = '<span style="position:absolute;' +
                            'top:-20000px;left:0;padding:0;margin:0;border:none;' +
                            'white-space:pre;"></span>';
                        this.element_.insertAdjacentHTML('beforeEnd', s);
                        this.textMeasureEl_ = this.element_.lastChild;
                    }
                    var doc = this.element_.ownerDocument;
                    this.textMeasureEl_.innerHTML = '';
                    this.textMeasureEl_.style.font = this.font;
                    // Don't use innerHTML or innerText because they allow markup/whitespace.
                    this.textMeasureEl_.appendChild(doc.createTextNode(text));
                    return { width: this.textMeasureEl_.offsetWidth };
                };

                /******** STUBS ********/
                contextPrototype.clip = function() {
                    // TODO: Implement
                };

                contextPrototype.arcTo = function() {
                    // TODO: Implement
                };

                contextPrototype.createPattern = function(image, repetition) {
                    return new CanvasPattern_(image, repetition);
                };

                // Gradient / Pattern Stubs
                function CanvasGradient_(aType) {
                    this.type_ = aType;
                    this.x0_ = 0;
                    this.y0_ = 0;
                    this.r0_ = 0;
                    this.x1_ = 0;
                    this.y1_ = 0;
                    this.r1_ = 0;
                    this.colors_ = [];
                }

                CanvasGradient_.prototype.addColorStop = function(aOffset, aColor) {
                    aColor = processStyle(aColor);
                    this.colors_.push({
                        offset: aOffset,
                        color: aColor.color,
                        alpha: aColor.alpha
                    });
                };

                function CanvasPattern_(image, repetition) {
                    assertImageIsValid(image);
                    switch (repetition) {
                        case 'repeat':
                        case null:
                        case '':
                            this.repetition_ = 'repeat';
                            break
                        case 'repeat-x':
                        case 'repeat-y':
                        case 'no-repeat':
                            this.repetition_ = repetition;
                            break;
                        default:
                            throwException('SYNTAX_ERR');
                    }

                    this.src_ = image.src;
                    this.width_ = image.width;
                    this.height_ = image.height;
                }

                function throwException(s) {
                    throw new DOMException_(s);
                }

                function assertImageIsValid(img) {
                    if (!img || img.nodeType != 1 || img.tagName != 'IMG') {
                        throwException('TYPE_MISMATCH_ERR');
                    }
                    if (img.readyState != 'complete') {
                        throwException('INVALID_STATE_ERR');
                    }
                }

                function DOMException_(s) {
                    this.code = this[s];
                    this.message = s + ': DOM Exception ' + this.code;
                }
                var p = DOMException_.prototype = new Error;
                p.INDEX_SIZE_ERR = 1;
                p.DOMSTRING_SIZE_ERR = 2;
                p.HIERARCHY_REQUEST_ERR = 3;
                p.WRONG_DOCUMENT_ERR = 4;
                p.INVALID_CHARACTER_ERR = 5;
                p.NO_DATA_ALLOWED_ERR = 6;
                p.NO_MODIFICATION_ALLOWED_ERR = 7;
                p.NOT_FOUND_ERR = 8;
                p.NOT_SUPPORTED_ERR = 9;
                p.INUSE_ATTRIBUTE_ERR = 10;
                p.INVALID_STATE_ERR = 11;
                p.SYNTAX_ERR = 12;
                p.INVALID_MODIFICATION_ERR = 13;
                p.NAMESPACE_ERR = 14;
                p.INVALID_ACCESS_ERR = 15;
                p.VALIDATION_ERR = 16;
                p.TYPE_MISMATCH_ERR = 17;

                // set up externs
                G_vmlCanvasManager = G_vmlCanvasManager_;
                CanvasRenderingContext2D = CanvasRenderingContext2D_;
                CanvasGradient = CanvasGradient_;
                CanvasPattern = CanvasPattern_;
                DOMException = DOMException_;
            })();

        } // if
        else { // make the canvas test simple by kener.linfeng@gmail.com
            G_vmlCanvasManager = false;
        }
        return G_vmlCanvasManager;
    }); // define

    define('zrender/shape', ['require'], function(require) {
        var self = {};

        var _shapeLibrary = {}; //shape库

        /**
         * 定义图形实现
         * @param {Object} name
         * @param {Object} clazz 图形实现
         */
        self.define = function(name, clazz) {
            _shapeLibrary[name] = clazz;
            return self;
        };

        /**
         * 获取图形实现
         * @param {Object} name
         */
        self.get = function(name) {
            return _shapeLibrary[name];
        };

        return self;
    });

    define('zrender/shape/circle', ['require'],
        function(require) {
            function Circle() {
                this.type = 'circle';
            }

            Circle.prototype = {
                /**
                 * 创建圆形路径
                 * @param {Context2D} ctx Canvas 2D上下文
                 * @param {Object} style 样式
                 */
                buildPath: function(ctx, style) {
                    ctx.arc(style.x, style.y, style.r, 0, Math.PI * 2, true);
                    return;
                },

                /**
                 * 返回矩形区域，用于局部刷新和文字定位
                 * @param {Object} style
                 */
                getRect: function(style) {
                    var lineWidth;
                    if (style.brushType == 'stroke' || style.brushType == 'fill') {
                        lineWidth = style.lineWidth || 1;
                    } else {
                        lineWidth = 0;
                    }
                    return {
                        x: Math.round(style.x - style.r - lineWidth / 2),
                        y: Math.round(style.y - style.r - lineWidth / 2),
                        width: style.r * 2 + lineWidth,
                        height: style.r * 2 + lineWidth
                    };
                }
            };

            var base = require('./base');
            base.derive(Circle);

            var shape = require('../shape');
            shape.define('circle', new Circle());

            return Circle;
        }
    );

    define('zrender/shape/base', ['require'], function(require) {

        var self;
        var area = require('../tool/area');
        var matrix = require('../tool/matrix');

        /**
         * 派生实现通用功能
         * @param {Object} clazz 图形类
         */
        function derive(clazz) {
            var methods = [ // 派生实现的基类方法
                'brush',
                'setContext',
                'drawText',
                'getHighlightStyle',
                'getHighlightZoom',
                'drift',
                'isCover',
                'updateTransform'
            ];
            var len = methods.length;
            var proto = clazz.prototype;
            var i = 0;
            var method;

            for (; i < len; i++) {
                method = methods[i];
                if (!proto[method]) {
                    proto[method] = self[method];
                }
            }
        }

        /**
         * 画刷
         * @param ctx       画布句柄
         * @param e         形状实体
         * @param isHighlight   是否为高亮状态
         * @param updateCallback 需要异步加载资源的shape可以通过这个callback(e)
         *                       让painter更新视图，base.brush没用，需要的话重载brush
         */
        function brush(ctx, e, isHighlight) {
            var style = e.style || {};

            if (this.brushTypeOnly) {
                style.brushType = this.brushTypeOnly;
            }

            if (isHighlight) {
                // 根据style扩展默认高亮样式
                style = this.getHighlightStyle(
                    style,
                    e.highlightStyle || {},
                    this.brushTypeOnly
                );
            }

            if (this.brushTypeOnly == 'stroke') {
                style.strokeColor = style.strokeColor || style.color;
            }

            ctx.save();
            this.setContext(ctx, style);

            // 设置transform
            if (e.__needTransform) {
                ctx.transform.apply(ctx, this.updateTransform(e));
            }

            ctx.beginPath();
            this.buildPath(ctx, style);
            if (this.brushTypeOnly != 'stroke') {
                ctx.closePath();
            }

            switch (style.brushType) {
                case 'fill':
                    ctx.fill();
                    break;
                case 'stroke':
                    ctx.stroke();
                    break;
                case 'both':
                    ctx.stroke();
                    ctx.fill();
                    break;
                default:
                    ctx.fill();
            }

            if (style.text) {
                this.drawText(ctx, style, e.style);
            }

            ctx.restore();

            return;
        }

        /**
         * 画布通用设置
         * @param ctx       画布句柄
         * @param style     通用样式
         */
        function setContext(ctx, style) {
            // 简单判断不做严格类型检测
            if (style.color) {
                ctx.fillStyle = style.color;
            }

            if (style.strokeColor) {
                ctx.strokeStyle = style.strokeColor;
            }

            if (typeof style.opacity != 'undefined') {
                ctx.globalAlpha = style.opacity;
            }

            if (style.lineCap) {
                ctx.lineCap = style.lineCap;
            }

            if (style.lineJoin) {
                ctx.lineJoin = style.lineJoin;
            }

            if (style.miterLimit) {
                ctx.miterLimit = style.miterLimit;
            }

            if (typeof style.lineWidth != 'undefined') {
                ctx.lineWidth = style.lineWidth;
            }

            if (typeof style.shadowBlur != 'undefined') {
                ctx.shadowBlur = style.shadowBlur;
            }

            if (style.shadowColor) {
                ctx.shadowColor = style.shadowColor;
            }

            if (typeof style.shadowOffsetX != 'undefined') {
                ctx.shadowOffsetX = style.shadowOffsetX;
            }

            if (typeof style.shadowOffsetY != 'undefined') {
                ctx.shadowOffsetY = style.shadowOffsetY;
            }
        }

        /**
         * 附加文本
         * @param {Context2D} ctx Canvas 2D上下文
         * @param {Object} style 样式
         * @param {Object} normalStyle 默认样式，用于定位文字显示
         */
        function drawText(ctx, style, normalStyle) {
            // 字体颜色策略
            style.textColor = style.textColor || style.color || style.strokeColor;
            ctx.fillStyle = style.textColor;

            if (style.textPosition == 'inside') {
                ctx.shadowColor = 'rgba(0,0,0,0)'; // 内部文字不带shadowColor
            }

            // 文本与图形间空白间隙
            var dd = 10;
            var al; // 文本水平对齐
            var bl; // 文本垂直对齐
            var tx; // 文本横坐标
            var ty; // 文本纵坐标

            var textPosition = style.textPosition // 用户定义
                || this.textPosition // shape默认
                || 'top'; // 全局默认

            if ((textPosition == 'inside' || textPosition == 'top' || textPosition == 'bottom' || textPosition == 'left' || textPosition == 'right') && this.getRect // 矩形定位文字的图形必须提供getRect方法
            ) {
                var rect = (normalStyle || style).__rect || this.getRect(normalStyle || style);
                switch (textPosition) {
                    case 'inside':
                        tx = rect.x + rect.width / 2;
                        ty = rect.y + rect.height / 2;
                        al = 'center';
                        bl = 'middle';
                        if (style.brushType != 'stroke' && style.textColor == style.color) {
                            ctx.fillStyle = '#fff';
                        }
                        break;
                    case 'left':
                        tx = rect.x - dd;
                        ty = rect.y + rect.height / 2;
                        al = 'end';
                        bl = 'middle';
                        break;
                    case 'right':
                        tx = rect.x + rect.width + dd;
                        ty = rect.y + rect.height / 2;
                        al = 'start';
                        bl = 'middle';
                        break;
                    case 'top':
                        tx = rect.x + rect.width / 2;
                        ty = rect.y - dd;
                        al = 'center';
                        bl = 'bottom';
                        break;
                    case 'bottom':
                        tx = rect.x + rect.width / 2;
                        ty = rect.y + rect.height + dd;
                        al = 'center';
                        bl = 'top';
                        break;
                }
            } else if (textPosition == 'start' || textPosition == 'end') {
                var xStart;
                var xEnd;
                var yStart;
                var yEnd;
                if (typeof style.pointList != 'undefined') {
                    var pointList = style.pointList;
                    if (pointList.length < 2) {
                        // 少于2个点就不画了~
                        return;
                    }
                    var length = pointList.length;
                    switch (textPosition) {
                        case 'start':
                            xStart = pointList[0][0];
                            xEnd = pointList[1][0];
                            yStart = pointList[0][1];
                            yEnd = pointList[1][1];
                            break;
                        case 'end':
                            xStart = pointList[length - 2][0];
                            xEnd = pointList[length - 1][0];
                            yStart = pointList[length - 2][1];
                            yEnd = pointList[length - 1][1];
                            break;
                    }
                } else {
                    xStart = style.xStart || 0;
                    xEnd = style.xEnd || 0;
                    yStart = style.yStart || 0;
                    yEnd = style.yEnd || 0;
                }
                switch (textPosition) {
                    case 'start':
                        al = xStart < xEnd ? 'end' : 'start';
                        bl = yStart < yEnd ? 'bottom' : 'top';
                        tx = xStart;
                        ty = yStart;
                        break;
                    case 'end':
                        al = xStart < xEnd ? 'start' : 'end';
                        bl = yStart < yEnd ? 'top' : 'bottom';
                        tx = xEnd;
                        ty = yEnd;
                        break;
                }
                dd -= 4;
                if (xStart != xEnd) {
                    tx -= (al == 'end' ? dd : -dd);
                } else {
                    al = 'center';
                }
                if (yStart != yEnd) {
                    ty -= (bl == 'bottom' ? dd : -dd);
                } else {
                    bl = 'middle';
                }
            } else if (textPosition == 'specific') {
                tx = style.textX || 0;
                ty = style.textY || 0;
                al = 'start';
                bl = 'middle';
            }

            if (typeof tx != 'undefined' && typeof ty != 'undefined') {
                if (style.textFont) {
                    ctx.font = style.textFont;
                }
                ctx.textAlign = style.textAlign || al;
                ctx.textBaseline = style.textBaseLine || bl;

                ctx.fillText(style.text, tx, ty);
            }
        }

        /**
         * 根据默认样式扩展高亮样式
         * @param ctx Canvas 2D上下文
         * @param {Object} style 默认样式
         * @param {Object} highlightStyle 高亮样式
         */
        function getHighlightStyle(style, highlightStyle, brushTypeOnly) {
            var newStyle = {};
            for (var k in style) {
                newStyle[k] = style[k];
            }

            var color = require('../tool/color');
            var highlightColor = color.getHighlightColor();
            // 根据highlightStyle扩展
            if (style.brushType != 'stroke') {
                // 带填充则用高亮色加粗边线
                newStyle.strokeColor = highlightColor;
                newStyle.lineWidth = (style.lineWidth || 1) + this.getHighlightZoom();
                newStyle.brushType = 'both';
            } else {
                if (brushTypeOnly != 'stroke') {
                    // 描边型的则用原色加工高亮
                    newStyle.strokeColor = highlightColor;
                    newStyle.lineWidth = (style.lineWidth || 1) + this.getHighlightZoom();
                } else {
                    // 线型的则用原色加工高亮
                    newStyle.strokeColor = highlightStyle.strokeColor || color.mix(
                        style.strokeColor,
                        color.toRGB(highlightColor)
                    );
                }
            }

            // 可自定义覆盖默认值
            for (var k in highlightStyle) {
                newStyle[k] = highlightStyle[k];
            }

            return newStyle;
        }

        /**
         * 高亮放大效果参数
         * 当前统一设置为6，如有需要差异设置，通过this.type判断实例类型
         */
        function getHighlightZoom() {
            return this.type != 'text' ? 6 : 2;
        }

        /**
         * 默认漂移
         * @param e 图形实体
         * @param dx 横坐标变化
         * @param dy 纵坐标变化
         */
        function drift(e, dx, dy) {
            e.position[0] += dx;
            e.position[1] += dy;
        }

        /**
         * 默认区域包含判断
         * @param e 图形实体
         * @param x 横坐标
         * @param y 纵坐标
         */
        function isCover(e, x, y) {
            //对鼠标的坐标也做相同的变换
            if (e.__needTransform && e._transform) {
                var inverseMatrix = [];
                matrix.invert(inverseMatrix, e._transform);

                var originPos = [x, y];
                matrix.mulVector(originPos, inverseMatrix, [x, y, 1]);

                if (x == originPos[0] && y == originPos[1]) {
                    // 避免外部修改导致的__needTransform不准确
                    if (Math.abs(e.rotation[0]) > 0.0001 || Math.abs(e.position[0]) > 0.0001 || Math.abs(e.position[1]) > 0.0001 || Math.abs(e.scale[0] - 1) > 0.0001 || Math.abs(e.scale[1] - 1) > 0.0001) {
                        e.__needTransform = true;
                    } else {
                        e.__needTransform = false;
                    }
                }

                x = originPos[0];
                y = originPos[1];
            }

            // 快速预判并保留判断矩形
            var rect;
            if (e.style.__rect) {
                rect = e.style.__rect;
            } else {
                rect = this.getRect(e.style);
                e.style.__rect = rect;
            }
            if (x >= rect.x && x <= (rect.x + rect.width) && y >= rect.y && y <= (rect.y + rect.height)) {
                // 矩形内
                return area.isInside(this, e.style, x, y);
            } else {
                return false;
            }

        }

        function updateTransform(e) {
            var _transform = e._transform || matrix.create();
            matrix.identity(_transform);
            if (e.scale && (e.scale[0] !== 1 || e.scale[1] !== 1)) {
                var originX = e.scale[2] || 0;
                var originY = e.scale[3] || 0;
                if (originX || originY) {
                    matrix.translate(
                        _transform, _transform, [-originX, -originY]
                    );
                }
                matrix.scale(_transform, _transform, e.scale);
                if (originX || originY) {
                    matrix.translate(
                        _transform, _transform, [originX, originY]
                    );
                }
            }
            if (e.rotation) {
                if (e.rotation instanceof Array) {
                    if (e.rotation[0] !== 0) {
                        var originX = e.rotation[1] || 0,
                            originY = e.rotation[2] || 0;
                        if (originX || originY) {
                            matrix.translate(
                                _transform, _transform, [-originX, -originY]
                            );
                        }
                        matrix.rotate(_transform, _transform, e.rotation[0]);
                        if (originX || originY) {
                            matrix.translate(
                                _transform, _transform, [originX, originY]
                            );
                        }
                    }
                } else {
                    if (e.rotation !== 0) {
                        matrix.rotate(_transform, _transform, e.rotation);
                    }
                }
            }
            if (e.position && (e.position[0] !== 0 || e.position[1] !== 0)) {
                matrix.translate(_transform, _transform, e.position);
            }
            // 保存这个变换矩阵
            e._transform = _transform;

            return _transform;
        }

        self = {
            derive: derive,
            brush: brush,
            setContext: setContext,
            drawText: drawText,
            getHighlightStyle: getHighlightStyle,
            getHighlightZoom: getHighlightZoom,
            drift: drift,
            isCover: isCover,

            updateTransform: updateTransform
        };

        return self;
    });

    /**
     * zrender: 图形空间辅助类
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * isInside：是否在区域内部
     * isOutside：是否在区域外部
     * getTextWidth：测算单行文本宽度
     */
    define('zrender/tool/area', ['require'], function(require) {
        var util = require('../tool/util');

        var _ctx;

        /**
         * 包含判断
         * @param {string} shapeClazz : 图形类
         * @param {Object} area ： 目标区域
         * @param {number} x ： 横坐标
         * @param {number} y ： 纵坐标
         */
        function isInside(shapeClazz, area, x, y) {
            if (!area || !shapeClazz) {
                // 无参数或不支持类型
                return false;
            }
            var zoneType = shapeClazz.type;

            if (!_ctx) {
                _ctx = util.getContext();
            }
            if (!_isInsideRectangle(
                    area.__rect || shapeClazz.getRect(area), x, y
                )) {
                // 不在矩形区域内直接返回false
                return false;
            }

            // 未实现或不可用时(excanvas不支持)则数学运算，主要是line，brokenLine，ring
            var _mathReturn = _mathMethod(zoneType, area, x, y);

            if (typeof _mathReturn != 'undefined') {
                return _mathReturn;
            }

            if (zoneType != 'beziercurve' && shapeClazz.buildPath && _ctx.isPointInPath) {
                return _buildPathMethod(shapeClazz, _ctx, area, x, y);
            } else if (_ctx.getImageData) {
                return _pixelMethod(shapeClazz, area, x, y);
            }

            // 上面的方法都行不通时
            switch (zoneType) {
                //心形----------------------10
                case 'heart':
                    return true; // Todo，不精确
                    //水滴----------------------11
                case 'droplet':
                    return true; // Todo，不精确
                case 'ellipse':
                    return true; // Todo，不精确
                    // 旋轮曲线  不准确
                case 'trochoid':
                    var _r = area.location == 'out' ? area.r1 + area.r2 + area.d : area.r1 - area.r2 + area.d;
                    return _isInsideCircle(area, x, y, _r);
                    // 玫瑰线 不准确
                case 'rose':
                    return _isInsideCircle(area, x, y, area.maxr);
                    //路径，椭圆，曲线等-----------------13
                default:
                    return false; // Todo，暂不支持
            }
        }

        /**
         * 用数学方法判断，三个方法中最快，但是支持的shape少
         *
         * @param {string} zoneType ： 图形类型
         * @param {Object} area ：目标区域
         * @param {number} x ： 横坐标
         * @param {number} y ： 纵坐标
         * @return {boolean=} true表示坐标处在图形中
         */
        function _mathMethod(zoneType, area, x, y) {
            // 在矩形内则部分图形需要进一步判断
            switch (zoneType) {
                //线-----------------------1
                case 'line':
                    return _isInsideLine(area, x, y);
                    //折线----------------------2
                case 'brokenLine':
                    return _isInsideBrokenLine(area, x, y);
                    //文本----------------------3
                case 'text':
                    return true;
                    //圆环----------------------4
                case 'ring':
                    return _isInsideRing(area, x, y);
                    //矩形----------------------5
                case 'rectangle':
                    return true;
                    //圆形----------------------6
                case 'circle':
                    return _isInsideCircle(area, x, y, area.r);
                    //扇形----------------------7
                case 'sector':
                    return _isInsideSector(area, x, y);
                    //多边形---------------------8
                case 'path':
                    return _isInsidePath(area, x, y);
                case 'polygon':
                case 'star':
                case 'isogon':
                    return _isInsidePolygon(area, x, y);
                    //图片----------------------9
                case 'image':
                    return true;
            }
        }

        /**
         * 通过buildPath方法来判断，三个方法中较快，但是不支持线条类型的shape，
         * 而且excanvas不支持isPointInPath方法
         *
         * @param {Object} shapeClazz ： shape类
         * @param {Object} context : 上下文
         * @param {Object} area ：目标区域
         * @param {number} x ： 横坐标
         * @param {number} y ： 纵坐标
         * @return {boolean} true表示坐标处在图形中
         */
        function _buildPathMethod(shapeClazz, context, area, x, y) {
            // 图形类实现路径创建了则用类的path
            context.beginPath();
            shapeClazz.buildPath(context, area);
            context.closePath();
            return context.isPointInPath(x, y);
        }

        /**
         * 通过像素值来判断，三个方法中最慢，但是支持广,不足之处是excanvas不支持像素处理
         *
         * @param {Object} shapeClazz ： shape类
         * @param {Object} area ：目标区域
         * @param {number} x ： 横坐标
         * @param {number} y ： 纵坐标
         * @return {boolean} true表示坐标处在图形中
         */
        function _pixelMethod(shapeClazz, area, x, y) {
            var _rect = area.__rect || shapeClazz.getRect(area);
            var _context = util.getPixelContext();
            var _offset = util.getPixelOffset();

            util.adjustCanvasSize(x, y);
            _context.clearRect(_rect.x, _rect.y, _rect.width, _rect.height);
            _context.beginPath();
            shapeClazz.brush(_context, { style: area });
            _context.closePath();

            return _isPainted(_context, x + _offset.x, y + _offset.y);
        }

        /**
         * 坐标像素值，判断坐标是否被作色
         *
         * @param {Object} context : 上下文
         * @param {number} x : 横坐标
         * @param {number} y : 纵坐标
         * @param {number=} unit : 触发的精度，越大越容易触发，可选，缺省是为1
         * @return {boolean} 已经被画过返回true
         */
        function _isPainted(context, x, y, unit) {
            var pixelsData;

            if (typeof unit != 'undefined') {
                unit = Math.floor((unit || 1) / 2);
                pixelsData = context.getImageData(
                    x - unit,
                    y - unit,
                    unit + unit,
                    unit + unit
                ).data;
            } else {
                pixelsData = context.getImageData(x, y, 1, 1).data;
            }

            var len = pixelsData.length;
            while (len--) {
                if (pixelsData[len] !== 0) {
                    return true;
                }
            }

            return false;
        }

        /**
         * !isInside
         */
        function isOutside(shapeClazz, area, x, y) {
            return !isInside(shapeClazz, area, x, y);
        }

        /**
         * 线段包含判断
         */
        function _isInsideLine(area, x, y) {
            var _x1 = area.xStart;
            var _y1 = area.yStart;
            var _x2 = area.xEnd;
            var _y2 = area.yEnd;
            var _l = area.lineWidth;
            var _a = 0;
            var _b = _x1;

            if (_x1 !== _x2) {
                _a = (_y1 - _y2) / (_x1 - _x2);
                _b = (_x1 * _y2 - _x2 * _y1) / (_x1 - _x2);
            } else {
                return Math.abs(x - _x1) <= _l / 2;
            }

            var _s = (_a * x - y + _b) * (_a * x - y + _b) / (_a * _a + 1);
            return _s <= _l / 2 * _l / 2;
        }

        function _isInsideBrokenLine(area, x, y) {
            var pointList = area.pointList;
            var lineArea;
            var insideCatch = false;
            for (var i = 0, l = pointList.length - 1; i < l; i++) {
                lineArea = {
                    xStart: pointList[i][0],
                    yStart: pointList[i][1],
                    xEnd: pointList[i + 1][0],
                    yEnd: pointList[i + 1][1],
                    lineWidth: area.lineWidth
                };
                if (!_isInsideRectangle({
                            x: Math.min(lineArea.xStart, lineArea.xEnd) - lineArea.lineWidth,
                            y: Math.min(lineArea.yStart, lineArea.yEnd) - lineArea.lineWidth,
                            width: Math.abs(lineArea.xStart - lineArea.xEnd) + lineArea.lineWidth,
                            height: Math.abs(lineArea.yStart - lineArea.yEnd) + lineArea.lineWidth
                        },
                        x, y
                    )) {
                    // 不在矩形区内跳过
                    continue;
                }
                insideCatch = _isInsideLine(lineArea, x, y);
                if (insideCatch) {
                    break;
                }
            }
            return insideCatch;
        }

        function _isInsideRing(area, x, y) {
            if (_isInsideCircle(area, x, y, area.r) && !_isInsideCircle({
                        x: area.x,
                        y: area.y
                    },
                    x, y,
                    area.r0 || 0
                )) {
                // 大圆内，小圆外
                return true;
            }
            return false;
        }

        /**
         * 矩形包含判断
         */
        function _isInsideRectangle(area, x, y) {
            if (x >= area.x && x <= (area.x + area.width) && y >= area.y && y <= (area.y + area.height)) {
                return true;
            }
            return false;
        }

        /**
         * 圆形包含判断
         */
        function _isInsideCircle(area, x, y, r) {
            return (x - area.x) * (x - area.x) + (y - area.y) * (y - area.y) < r * r;
        }

        /**
         * 扇形包含判断
         */
        function _isInsideSector(area, x, y) {
            if (!_isInsideCircle(area, x, y, area.r) || (area.r0 > 0 && _isInsideCircle({
                        x: area.x,
                        y: area.y
                    },
                    x, y,
                    area.r0
                ))) {
                // 大圆外或者小圆内直接false
                return false;
            } else {
                // 判断夹角
                var angle = (360 - Math.atan2(y - area.y, x - area.x) / Math.PI * 180) % 360;
                var endA = (360 + area.endAngle) % 360;
                var startA = (360 + area.startAngle) % 360;
                if (endA > startA) {
                    return (angle >= startA && angle <= endA);
                } else {
                    return !(angle >= endA && angle <= startA);
                }

            }
        }

        /**
         * 多边形包含判断
         * 警告：下面这段代码会很难看，建议跳过~
         */
        function _isInsidePolygon(area, x, y) {
            /**
             * 射线判别法
             * 如果一个点在多边形内部，任意角度做射线肯定会与多边形要么有一个交点，要么有与多边形边界线重叠
             * 如果一个点在多边形外部，任意角度做射线要么与多边形有一个交点，
             * 要么有两个交点，要么没有交点，要么有与多边形边界线重叠。
             */
            var i;
            var j;
            var polygon = area.pointList;
            var N = polygon.length;
            var inside = false;
            var redo = true;
            var v;

            for (i = 0; i < N; ++i) {
                // 是否在顶点上
                if (polygon[i][0] == x && polygon[i][1] == y) {
                    redo = false;
                    inside = true;
                    break;
                }
            }

            if (redo) {
                redo = false;
                inside = false;
                for (i = 0, j = N - 1; i < N; j = i++) {
                    if ((polygon[i][1] < y && y < polygon[j][1]) || (polygon[j][1] < y && y < polygon[i][1])) {
                        if (x <= polygon[i][0] || x <= polygon[j][0]) {
                            v = (y - polygon[i][1]) * (polygon[j][0] - polygon[i][0]) / (polygon[j][1] - polygon[i][1]) + polygon[i][0];
                            if (x < v) { // 在线的左侧
                                inside = !inside;
                            } else if (x == v) { // 在线上
                                inside = true;
                                break;
                            }
                        }
                    } else if (y == polygon[i][1]) {
                        if (x < polygon[i][0]) { // 交点在顶点上
                            polygon[i][1] > polygon[j][1] ? --y : ++y;
                            //redo = true;
                            break;
                        }
                    } else if (polygon[i][1] == polygon[j][1] // 在水平的边界线上
                        && y == polygon[i][1] && ((polygon[i][0] < x && x < polygon[j][0]) || (polygon[j][0] < x && x < polygon[i][0]))
                    ) {
                        inside = true;
                        break;
                    }
                }
            }
            return inside;
        }

        /**
         * 路径包含判断，依赖多边形判断
         */
        function _isInsidePath(area, x, y) {
            var pointList = area.pointList;
            var insideCatch = false;
            for (var i = 0, l = pointList.length; i < l; i++) {
                insideCatch = _isInsidePolygon({ pointList: pointList[i] }, x, y);
                if (insideCatch) {
                    break;
                }
            }
            return insideCatch;
        }

        /**
         * 测算单行文本欢度
         * @param {Object} text
         * @param {Object} textFont
         */
        function getTextWidth(text, textFont) {
            if (!_ctx) {
                _ctx = util.getContext();
            }

            _ctx.save();
            if (textFont) {
                _ctx.font = textFont;
            }
            var width = _ctx.measureText(text).width;
            _ctx.restore();

            return width;
        }

        return {
            isInside: isInside,
            isOutside: isOutside,
            getTextWidth: getTextWidth
        };
    });


    /**
     * zrender: 向量操作类
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * author : lang(shenyi01@baidu.com)
     * code from vec2 in http://glmatrix.net/
     */
    define('zrender/tool/vector', ['require'], function() {
        var vector = {
            add: function(out, v1, v2) {
                out[0] = v1[0] + v2[0];
                out[1] = v1[1] + v2[1];
                return out;
            },
            sub: function(out, v1, v2) {
                out[0] = v1[0] - v2[0];
                out[1] = v1[1] - v2[1];
                return out;
            },
            length: function(v) {
                return Math.sqrt(this.lengthSquare(v));
            },
            lengthSquare: function(v) {
                return v[0] * v[0] + v[1] * v[1];
            },
            mul: function(out, v1, v2) {
                out[0] = v1[0] * v2[0];
                out[1] = v1[1] * v2[1];
                return out;
            },
            dot: function(v1, v2) {
                return v1[0] * v2[0] + v1[1] * v2[1];
            },
            scale: function(out, v, s) {
                out[0] = v[0] * s;
                out[1] = v[1] * s;
                return out;
            },
            normalize: function(out, v) {
                var d = vector.length(v);
                if (d === 0) {
                    out[0] = 0;
                    out[1] = 0;
                } else {
                    out[0] = v[0] / d;
                    out[1] = v[1] / d;
                }
                return out;
            },
            distance: function(v1, v2) {
                var out = [];
                return vector.length(vector.sub(out, v1, v2));
            },
            middle: function(out, v1, v2) {
                out[0] = (v1[0] + v2[0]) / 2;
                out[1] = (v1[1] + v2[1]) / 2;
                return out;
            }
        };

        return vector;
    });


    /**
     * zrender: 3x2矩阵操作类
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * author: lang(shenyi01@baidu.com)
     * code from mat2d in http://glmatrix.net/
     */

    define('zrender/tool/matrix', ['require'], function() {

        var matrix = {
            create: function() {
                return [1, 0,
                    0, 1,
                    0, 0
                ];
            },
            identity: function(out) {
                out[0] = 1;
                out[1] = 0;
                out[2] = 0;
                out[3] = 1;
                out[4] = 0;
                out[5] = 0;
            },
            mul: function(out, m1, m2) {
                out[0] = m1[0] * m2[0] + m1[2] * m2[1];
                out[1] = m1[1] * m2[0] + m1[3] * m2[1];
                out[2] = m1[0] * m2[2] + m1[2] * m2[3];
                out[3] = m1[1] * m2[2] + m1[3] * m2[3];
                out[4] = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
                out[5] = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
                return out;
            },

            translate: function(out, a, v) {
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                out[3] = a[3];
                out[4] = a[4] + v[0];
                out[5] = a[5] + v[1];
                return out;
            },
            rotate: function(out, a, rad) {
                var aa = a[0],
                    ac = a[2],
                    atx = a[4];
                var ab = a[1],
                    ad = a[3],
                    aty = a[5];
                var st = Math.sin(rad);
                var ct = Math.cos(rad);

                out[0] = aa * ct + ab * st;
                out[1] = -aa * st + ab * ct;
                out[2] = ac * ct + ad * st;
                out[3] = -ac * st + ct * ad;
                out[4] = ct * atx + st * aty;
                out[5] = ct * aty - st * atx;
                return out;
            },
            scale: function(out, a, v) {
                var vx = v[0],
                    vy = v[1];
                out[0] = a[0] * vx;
                out[1] = a[1] * vy;
                out[2] = a[2] * vx;
                out[3] = a[3] * vy;
                out[4] = a[4] * vx;
                out[5] = a[5] * vy;
                return out;
            },
            /**
             * 求逆矩阵
             */
            invert: function(out, a) {

                var aa = a[0],
                    ac = a[2],
                    atx = a[4];
                var ab = a[1],
                    ad = a[3],
                    aty = a[5];

                var det = aa * ad - ab * ac;
                if (!det) {
                    return null;
                }
                det = 1.0 / det;

                out[0] = ad * det;
                out[1] = -ab * det;
                out[2] = -ac * det;
                out[3] = aa * det;
                out[4] = (ac * aty - ad * atx) * det;
                out[5] = (ab * atx - aa * aty) * det;
                return out;
            },

            /**
             * 矩阵左乘向量
             */
            mulVector: function(out, a, v) {
                var aa = a[0],
                    ac = a[2],
                    atx = a[4];
                var ab = a[1],
                    ad = a[3],
                    aty = a[5];

                out[0] = v[0] * aa + v[1] * ac + atx;
                out[1] = v[0] * ab + v[1] * ad + aty;

                return out;
            }
        };

        return matrix;
    });

    /**
     * zrender
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * author: loutongbing@baidu.com
     *
     * shape类：椭圆
     * Todo：excanvas bug ~ 连续scale保持?? IE8下不建议使用
     * 可配图形属性：
       {
           // 基础属性
           shape  : 'ellipse',       // 必须，shape类标识，需要显式指定
           id     : {string},       // 必须，图形唯一标识，可通过zrender实例方法newShapeId生成
           zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
           invisible : {boolean},   // 默认为false，是否可见

           // 样式属性，默认状态样式样式属性
           style  : {
               x             : {number},  // 必须，椭圆心横坐标
               y             : {number},  // 必须，椭圆心纵坐标
               a             : {number},  // 必须，椭圆横轴半径
               b             : {number},  // 必须，椭圆纵轴半径
               brushType     : {string},  // 默认为fill，绘画方式
                                          // fill(填充) | stroke(描边) | both(填充+描边)
               color         : {color},   // 默认为'#000'，填充颜色，支持rgba
               strokeColor   : {color},   // 默认为'#000'，描边颜色（轮廓），支持rgba
               lineWidth     : {number},  // 默认为1，线条宽度，描边下有效

               opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
               shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
               shadowColor   : {color},   // 默认为'#000'，阴影色彩，支持rgba
               shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
               shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

               text          : {string},  // 默认为null，附加文本
               textFont      : {string},  // 默认为null，附加文本样式，eg:'bold 18px verdana'
               textPosition  : {string},  // 默认为top，附加文本位置。
                                          // inside | left | right | top | bottom
               textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                          // start | end | left | right | center
               textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                          // top | bottom | middle |
                                          // alphabetic | hanging | ideographic
               textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                          // 'inside' ? '#fff' : color
           },

           // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
           highlightStyle : {
               // 同style
           }

           // 交互属性，详见shape.Base

           // 事件属性，详见shape.Base
       }
             例子：
       {
           shape  : 'ellipse',
           id     : '123456',
           zlevel : 1,
           style  : {
               x : 200,
               y : 100,
               a : 100,
               b : 50,
               color : '#eee',
               text : 'Baidu'
           },
           myName : 'kener',  // 可自带任何有效自定义属性

           clickable : true,
           onClick : function(eventPacket) {
               alert(eventPacket.target.myName);
           }
       }
     */
    define('zrender/shape/ellipse', ['require'], function(require) {
        function Ellipse() {
            this.type = 'ellipse';
        }

        Ellipse.prototype = {
            /**
             * 创建圆形路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style) {
                var r = (style.a > style.b) ? style.a : style.b;
                var ratioX = style.a / r; //横轴缩放比率
                var ratioY = style.b / r;
                ctx.scale(ratioX, ratioY);
                ctx.arc(
                    style.x / ratioX, style.y / ratioY, r, 0, Math.PI * 2, true
                );
                ctx.scale(1 / ratioX, 1 / ratioY);
                // excanvas bug~~
                return;
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect: function(style) {
                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                } else {
                    lineWidth = 0;
                }
                return {
                    x: Math.round(style.x - style.a - lineWidth / 2),
                    y: Math.round(style.y - style.b - lineWidth / 2),
                    width: style.a * 2 + lineWidth,
                    height: style.b * 2 + lineWidth
                };
            }
        };

        var base = require('./base');
        base.derive(Ellipse);

        var shape = require('../shape');
        shape.define('ellipse', new Ellipse());

        return Ellipse;
    });


    /**
     * zrender
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：直线
     * 可配图形属性：
       {
           // 基础属性
           shape  : 'line',         // 必须，shape类标识，需要显式指定
           id     : {string},       // 必须，图形唯一标识，可通过zrender实例方法newShapeId生成
           zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
           invisible : {boolean},   // 默认为false，是否可见

           // 样式属性，默认状态样式样式属性
           style  : {
               xStart        : {number},  // 必须，起点横坐标
               yStart        : {number},  // 必须，起点纵坐标
               xEnd          : {number},  // 必须，终点横坐标
               yEnd          : {number},  // 必须，终点纵坐标
               strokeColor   : {color},   // 默认为'#000'，线条颜色（轮廓），支持rgba
               lineType      : {string},  // 默认为solid，线条类型，solid | dashed | dotted
               lineWidth     : {number},  // 默认为1，线条宽度
               lineCap       : {string},  // 默认为butt，线帽样式。butt | round | square

               opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
               shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
               shadowColor   : {color},   // 默认为'#000'，阴影色彩，支持rgba
               shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
               shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

               text          : {string},  // 默认为null，附加文本
               textFont      : {string},  // 默认为null，附加文本样式，eg:'bold 18px verdana'
               textPosition  : {string},  // 默认为end，附加文本位置。
                                          // inside | start | end
               textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                          // start | end | left | right | center
               textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                          // top | bottom | middle |
                                          // alphabetic | hanging | ideographic
               textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                          // 'inside' ? '#000' : color
           },

           // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
           highlightStyle : {
               // 同style
           }

           // 交互属性，详见shape.Base

           // 事件属性，详见shape.Base
       }
             例子：
       {
           shape  : 'line',
           id     : '123456',
           zlevel : 1,
           style  : {
               xStart : 100,
               yStart : 100,
               xEnd : 200,
               yEnd : 200,
               strokeColor : '#eee',
               lineWidth : 20,
               text : 'Baidu'
           },
           myName : 'kener',  //可自带任何有效自定义属性

           clickable : true,
           onClick : function(eventPacket) {
               alert(eventPacket.target.myName);
           }
       }
     */
    define('zrender/shape/line', ['require'], function(require) {
        function Line() {
            this.type = 'line';
            this.brushTypeOnly = 'stroke'; //线条只能描边，填充后果自负
            this.textPosition = 'end';
        }

        Line.prototype = {
            /**
             * 创建线条路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style) {
                if (!style.lineType || style.lineType == 'solid') {
                    //默认为实线
                    ctx.moveTo(style.xStart, style.yStart);
                    ctx.lineTo(style.xEnd, style.yEnd);
                } else if (style.lineType == 'dashed' || style.lineType == 'dotted') {
                    //画虚线的方法  by loutongbing@baidu.com
                    var lineWidth = style.lineWidth || 1;
                    var dashPattern = [
                        lineWidth * (style.lineType == 'dashed' ? 6 : 1),
                        lineWidth * 4
                    ];
                    var fromX = style.xStart;
                    var toX = style.xEnd;
                    var fromY = style.yStart;
                    var toY = style.yEnd;
                    var dx = toX - fromX;
                    var dy = toY - fromY;
                    var angle = Math.atan2(dy, dx);
                    var x = fromX;
                    var y = fromY;
                    var idx = 0;
                    var draw = true;
                    var dashLength;
                    var nx;
                    var ny;

                    ctx.moveTo(fromX, fromY);
                    while (!((dx < 0 ? x <= toX : x >= toX) && (dy < 0 ? y <= toY : y >= toY))) {
                        dashLength = dashPattern[idx++ % dashPattern.length];
                        nx = x + (Math.cos(angle) * dashLength);
                        x = dx < 0 ? Math.max(toX, nx) : Math.min(toX, nx);
                        ny = y + (Math.sin(angle) * dashLength);
                        y = dy < 0 ? Math.max(toY, ny) : Math.min(toY, ny);
                        if (draw) {
                            ctx.lineTo(x, y);
                        } else {
                            ctx.moveTo(x, y);
                        }
                        draw = !draw;
                    }
                }
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect: function(style) {
                var lineWidth = style.lineWidth || 1;
                return {
                    x: Math.min(style.xStart, style.xEnd) - lineWidth,
                    y: Math.min(style.yStart, style.yEnd) - lineWidth,
                    width: Math.abs(style.xStart - style.xEnd) + lineWidth,
                    height: Math.abs(style.yStart - style.yEnd) + lineWidth
                };
            }
        };

        var base = require('./base');
        base.derive(Line);

        var shape = require('../shape');
        shape.define('line', new Line());

        return Line;
    });

    /**
     * zrender
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：多边形
     * 可配图形属性：
       {
           // 基础属性
           shape  : 'polygon',      // 必须，shape类标识，需要显式指定
           id     : {string},       // 必须，图形唯一标识，可通过zrender实例方法newShapeId生成
           zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
           invisible : {boolean},   // 默认为false，是否可见

           // 样式属性，默认状态样式样式属性
           style  : {
               pointList     : {Array},   // 必须，多边形各个顶角坐标
               brushType     : {string},  // 默认为fill，绘画方式
                                          // fill(填充) | stroke(描边) | both(填充+描边)
               color         : {color},   // 默认为'#000'，填充颜色，支持rgba
               strokeColor   : {color},   // 默认为'#000'，描边颜色（轮廓），支持rgba
               lineWidth     : {number},  // 默认为1，线条宽度，描边下有效

               opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
               shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
               shadowColor   : {color},   // 默认为'#000'，阴影色彩，支持rgba
               shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
               shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

               text          : {string},  // 默认为null，附加文本
               textFont      : {string},  // 默认为null，附加文本样式，eg:'bold 18px verdana'
               textPosition  : {string},  // 默认为top，附加文本位置。
                                          // inside | left | right | top | bottom
               textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                          // start | end | left | right | center
               textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                          // top | bottom | middle |
                                          // alphabetic | hanging | ideographic
               textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                          // 'inside' ? '#fff' : color
           },

           // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
           highlightStyle : {
               // 同style
           }

           // 交互属性，详见shape.Base

           // 事件属性，详见shape.Base
       }
             例子：
       {
           shape  : 'polygon',
           id     : '123456',
           zlevel : 1,
           style  : {
               pointList : [[10, 10], [300, 20], [298, 400], [50, 450]]
               color : '#eee',
               text : 'Baidu'
           },
           myName : 'kener',  // 可自带任何有效自定义属性

           clickable : true,
           onClick : function(eventPacket) {
               alert(eventPacket.target.myName);
           }
       }
     */
    define('zrender/shape/polygon', ['require'], function(require) {
        function Polygon() {
            this.type = 'polygon';
        }

        Polygon.prototype = {
            /**
             * 创建多边形路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style) {
                var pointList = style.pointList;
                ctx.moveTo(pointList[0][0], pointList[0][1]);
                for (var i = 1, l = pointList.length; i < l; i++) {
                    ctx.lineTo(pointList[i][0], pointList[i][1]);
                }
                ctx.lineTo(pointList[0][0], pointList[0][1]);
                return;
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect: function(style) {
                var minX = Number.MAX_VALUE;
                var maxX = Number.MIN_VALUE;
                var minY = Number.MAX_VALUE;
                var maxY = Number.MIN_VALUE;

                var pointList = style.pointList;
                for (var i = 0, l = pointList.length; i < l; i++) {
                    if (pointList[i][0] < minX) {
                        minX = pointList[i][0];
                    }
                    if (pointList[i][0] > maxX) {
                        maxX = pointList[i][0];
                    }
                    if (pointList[i][1] < minY) {
                        minY = pointList[i][1];
                    }
                    if (pointList[i][1] > maxY) {
                        maxY = pointList[i][1];
                    }
                }

                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                } else {
                    lineWidth = 0;
                }
                return {
                    x: Math.round(minX - lineWidth / 2),
                    y: Math.round(minY - lineWidth / 2),
                    width: maxX - minX + lineWidth,
                    height: maxY - minY + lineWidth
                };
            }
        };

        var base = require('./base');
        base.derive(Polygon);

        var shape = require('../shape');
        shape.define('polygon', new Polygon());

        return Polygon;
    });


    /**
     * zrender
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：折线
     * 可配图形属性：
       {
           // 基础属性
           shape  : 'brokenLine',         // 必须，shape类标识，需要显式指定
           id     : {string},       // 必须，图形唯一标识，可通过zrender实例方法newShapeId生成
           zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
           invisible : {boolean},   // 默认为false，是否可见

           // 样式属性，默认状态样式样式属性
           style  : {
               pointList     : {Array},   // 必须，各个顶角坐标
               strokeColor   : {color},   // 默认为'#000'，线条颜色（轮廓），支持rgba
               lineType      : {string},  // 默认为solid，线条类型，solid | dashed | dotted
               lineWidth     : {number},  // 默认为1，线条宽度
               lineCap       : {string},  // 默认为butt，线帽样式。butt | round | square
               lineJoin      : {string},  // 默认为miter，线段连接样式。miter | round | bevel
               miterLimit    : {number},  // 默认为10，最大斜接长度，仅当lineJoin为miter时生效

               opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
               shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
               shadowColor   : {color},   // 默认为'#000'，阴影色彩，支持rgba
               shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
               shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

               text          : {string},  // 默认为null，附加文本
               textFont      : {string},  // 默认为null，附加文本样式，eg:'bold 18px verdana'
               textPosition  : {string},  // 默认为end，附加文本位置。
                                          // start | end
               textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                          // start | end | left | right | center
               textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                          // top | bottom | middle |
                                          // alphabetic | hanging | ideographic
               textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                          // 'inside' ? '#000' : color
           },

           // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
           highlightStyle : {
               // 同style
           }

           // 交互属性，详见shape.Base

           // 事件属性，详见shape.Base
       }
             例子：
       {
           shape  : 'brokenLine',
           id     : '123456',
           zlevel : 1,
           style  : {
               pointList : [[10, 10], [300, 20], [298, 400], [50, 450]],
               strokeColor : '#eee',
               lineWidth : 20,
               text : 'Baidu'
           },
           myName : 'kener',  //可自带任何有效自定义属性

           clickable : true,
           onClick : function(eventPacket) {
               alert(eventPacket.target.myName);
           }
       }
     */
    define('zrender/shape/brokenLine', ['require'], function(require) {
        function BrokenLine() {
            this.type = 'brokenLine';
            this.brushTypeOnly = 'stroke'; //线条只能描边，填充后果自负
            this.textPosition = 'end';
        }

        BrokenLine.prototype = {
            /**
             * 创建多边形路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style) {
                var pointList = style.pointList;
                if (pointList.length < 2) {
                    // 少于2个点就不画了~
                    return;
                }
                if (!style.lineType || style.lineType == 'solid') {
                    //默认为实线
                    ctx.moveTo(pointList[0][0], pointList[0][1]);
                    for (var i = 1, l = pointList.length; i < l; i++) {
                        ctx.lineTo(pointList[i][0], pointList[i][1]);
                    }
                } else if (style.lineType == 'dashed' || style.lineType == 'dotted') {
                    //画虚线的方法  by loutongbing@baidu.com
                    var lineWidth = style.lineWidth || 1;
                    var dashPattern = [
                        lineWidth * (style.lineType == 'dashed' ? 6 : 1),
                        lineWidth * 4
                    ];
                    ctx.moveTo(pointList[0][0], pointList[0][1]);
                    for (var i = 1, l = pointList.length; i < l; i++) {
                        var fromX = pointList[i - 1][0];
                        var toX = pointList[i][0];
                        var fromY = pointList[i - 1][1];
                        var toY = pointList[i][1];
                        var dx = toX - fromX;
                        var dy = toY - fromY;
                        var angle = Math.atan2(dy, dx);
                        var x = fromX;
                        var y = fromY;
                        var idx = 0;
                        var draw = true;
                        var dashLength;
                        var nx;
                        var ny;

                        while (!((dx < 0 ? x <= toX : x >= toX) && (dy < 0 ? y <= toY : y >= toY))) {
                            dashLength = dashPattern[
                                idx++ % dashPattern.length
                            ];
                            nx = x + (Math.cos(angle) * dashLength);
                            x = dx < 0 ? Math.max(toX, nx) : Math.min(toX, nx);
                            ny = y + (Math.sin(angle) * dashLength);
                            y = dy < 0 ? Math.max(toY, ny) : Math.min(toY, ny);
                            if (draw) {
                                ctx.lineTo(x, y);
                            } else {
                                ctx.moveTo(x, y);
                            }
                            draw = !draw;
                        }
                    }
                }

                return;
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect: function(style) {
                var shape = require('../shape');
                return shape.get('polygon').getRect(style);
            }
        };

        var base = require('./base');
        base.derive(BrokenLine);

        var shape = require('../shape');
        shape.define('brokenLine', new BrokenLine());

        return BrokenLine;
    });


    /**
     * zrender
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com) , 
     *         strwind (@劲风FEI, yaofeifei@baidu.com)
     *
     * shape类：矩形
     * 可配图形属性：
       {
           // 基础属性
           shape  : 'rectangle',       // 必须，shape类标识，需要显式指定
           id     : {string},       // 必须，图形唯一标识，可通过zrender实例方法newShapeId生成
           zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
           invisible : {boolean},   // 默认为false，是否可见

           // 样式属性，默认状态样式样式属性
           style  : {
               x             : {number},  // 必须，左上角横坐标
               y             : {number},  // 必须，左上角纵坐标
               width         : {number},  // 必须，宽度
               height        : {number},  // 必须，高度
               radius        : {array},   // 默认为[0]，圆角 
               brushType     : {string},  // 默认为fill，绘画方式
                                          // fill(填充) | stroke(描边) | both(填充+描边)
               color         : {color},   // 默认为'#000'，填充颜色，支持rgba
               strokeColor   : {color},   // 默认为'#000'，描边颜色（轮廓），支持rgba
               lineWidth     : {number},  // 默认为1，线条宽度，描边下有效

               opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
               shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
               shadowColor   : {color},   // 默认为'#000'，阴影色彩，支持rgba
               shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
               shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

               text          : {string},  // 默认为null，附加文本
               textFont      : {string},  // 默认为null，附加文本样式，eg:'bold 18px verdana'
               textPosition  : {string},  // 默认为top，附加文本位置。
                                          // inside | left | right | top | bottom
               textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                          // start | end | left | right | center
               textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                          // top | bottom | middle |
                                          // alphabetic | hanging | ideographic
               textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                          // 'inside' ? '#fff' : color
           },

           // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
           highlightStyle : {
               // 同style
           }

           // 交互属性，详见shape.Base

           // 事件属性，详见shape.Base
       }
             例子：
       {
           shape  : 'rectangle',
           id     : '123456',
           zlevel : 1,
           style  : {
               x : 200,
               y : 100,
               width : 150,
               height : 50,
               color : '#eee',
               text : 'Baidu'
           },
           myName : 'kener',  // 可自带任何有效自定义属性

           clickable : true,
           onClick : function(eventPacket) {
               alert(eventPacket.target.myName);
           }
       }
     */
    define('zrender/shape/rectangle', ['require'], function(require) {
        function Rectangle() {
            this.type = 'rectangle';
        }

        Rectangle.prototype = {
            /**
             * 绘制圆角矩形
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            _buildRadiusPath: function(ctx, style) {
                //左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
                //r缩写为1         相当于 [1, 1, 1, 1]
                //r缩写为[1]       相当于 [1, 1, 1, 1]
                //r缩写为[1, 2]    相当于 [1, 2, 1, 2]
                //r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
                var x = style.x;
                var y = style.y;
                var width = style.width;
                var height = style.height;
                var r = style.radius;
                var r1;
                var r2;
                var r3;
                var r4;

                if (typeof r === 'number') {
                    r1 = r2 = r3 = r4 = r;
                } else if (r instanceof Array) {
                    if (r.length === 1) {
                        r1 = r2 = r3 = r4 = r[0];
                    } else if (r.length === 2) {
                        r1 = r3 = r[0];
                        r2 = r4 = r[1];
                    } else if (r.length === 3) {
                        r1 = r[0];
                        r2 = r4 = r[1];
                        r3 = r[2];
                    } else {
                        r1 = r[0];
                        r2 = r[1];
                        r3 = r[2];
                        r4 = r[3];
                    }
                } else {
                    r1 = r2 = r3 = r4 = 0;
                }
                ctx.moveTo(x + r1, y);
                ctx.lineTo(x + width - r2, y);
                r2 !== 0 && ctx.quadraticCurveTo(
                    x + width, y, x + width, y + r2
                );
                ctx.lineTo(x + width, y + height - r3);
                r3 !== 0 && ctx.quadraticCurveTo(
                    x + width, y + height, x + width - r3, y + height
                );
                ctx.lineTo(x + r4, y + height);
                r4 !== 0 && ctx.quadraticCurveTo(
                    x, y + height, x, y + height - r4
                );
                ctx.lineTo(x, y + r1);
                r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
            },

            /**
             * 创建矩形路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style) {
                if (!style.radius) {
                    ctx.moveTo(style.x, style.y);
                    ctx.lineTo(style.x + style.width, style.y);
                    ctx.lineTo(style.x + style.width, style.y + style.height);
                    ctx.lineTo(style.x, style.y + style.height);
                    ctx.lineTo(style.x, style.y);
                    //ctx.rect(style.x, style.y, style.width, style.height);
                } else {
                    this._buildRadiusPath(ctx, style);
                }
                return;
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect: function(style) {
                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                } else {
                    lineWidth = 0;
                }
                return {
                    x: Math.round(style.x - lineWidth / 2),
                    y: Math.round(style.y - lineWidth / 2),
                    width: style.width + lineWidth,
                    height: style.height + lineWidth
                };
            }
        };

        var base = require('./base');
        base.derive(Rectangle);

        var shape = require('../shape');
        shape.define('rectangle', new Rectangle());

        return Rectangle;
    });


    /**
     * zrender
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：圆环
     * 可配图形属性：
       {
           // 基础属性
           shape  : 'ring',         // 必须，shape类标识，需要显式指定
           id     : {string},       // 必须，图形唯一标识，可通过zrender实例方法newShapeId生成
           zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
           invisible : {boolean},   // 默认为false，是否可见

           // 样式属性，默认状态样式样式属性
           style  : {
               x             : {number},  // 必须，圆心横坐标
               y             : {number},  // 必须，圆心纵坐标
               r0            : {number},  // 必须，内圆半径
               r             : {number},  // 必须，外圆半径
               brushType     : {string},  // 默认为fill，绘画方式
                                          // fill(填充) | stroke(描边) | both(填充+描边)
               color         : {color},   // 默认为'#000'，填充颜色，支持rgba
               strokeColor   : {color},   // 默认为'#000'，描边颜色（轮廓），支持rgba
               lineWidth     : {number},  // 默认为1，线条宽度，描边下有效

               opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
               shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
               shadowColor   : {color},   // 默认为'#000'，阴影色彩，支持rgba
               shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
               shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

               text          : {string},  // 默认为null，附加文本
               textFont      : {string},  // 默认为null，附加文本样式，eg:'bold 18px verdana'
               textPosition  : {string},  // 默认为outside，附加文本位置。
                                          // outside | inside
               textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                          // start | end | left | right | center
               textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                          // top | bottom | middle |
                                          // alphabetic | hanging | ideographic
               textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                          // 'inside' ? '#fff' : color
           },

           // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
           highlightStyle : {
               // 同style
           }

           // 交互属性，详见shape.Base

           // 事件属性，详见shape.Base
       }
             例子：
       {
           shape  : 'ring',
           id     : '123456',
           zlevel : 1,
           style  : {
               x : 200,
               y : 100,
               r : 50,
               color : '#eee',
               text : 'Baidu'
           },
           myName : 'kener',  // 可自带任何有效自定义属性

           clickable : true,
           onClick : function(eventPacket) {
               alert(eventPacket.target.myName);
           }
       }
     */
    define('zrender/shape/ring', ['require'], function(require) {
        function Ring() {
            this.type = 'ring';
        }

        Ring.prototype = {
            /**
             * 创建圆环路径，依赖扇形路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style) {
                //var temp = new Date();
                var shape = require('../shape');
                //t1 += new Date() - temp;
                //temp = new Date();
                shape.get('sector').buildPath(
                    ctx, {
                        x: style.x,
                        y: style.y,
                        r0: style.r0,
                        r: style.r,
                        startAngle: 0,
                        endAngle: 360
                    }
                );
                //t2 += new Date() - temp;
                return;
            },

            /**
             * 画刷
             * @param ctx       画布句柄
             * @param e         形状实体
             * @param isHighlight   是否为高亮状态
             */
            brush: function(ctx, e, isHighlight) {
                var style = e.style || {};

                if (isHighlight) {
                    // 根据style扩展默认高亮样式
                    style = this.getHighlightStyle(
                        style, e.highlightStyle || {}
                    );
                }

                ctx.save();
                this.setContext(ctx, style);

                // 设置transform
                if (e.__needTransform) {
                    ctx.transform.apply(ctx, this.updateTransform(e));
                }

                ctx.beginPath();

                this.buildPath(ctx, style);

                ctx.closePath();

                style.brushType = style.brushType || 'fill'; // default

                if (style.brushType == 'fill' || style.brushType == 'both') {
                    ctx.fill();
                }

                if (style.brushType == 'stroke' || style.brushType == 'both') {
                    ctx.beginPath();
                    ctx.moveTo(style.r0 + style.x, style.y);
                    ctx.arc(style.x, style.y, style.r0, 0, Math.PI * 2, true);

                    ctx.moveTo(style.r + style.x, style.y);
                    ctx.arc(style.x, style.y, style.r, 0, Math.PI * 2, true);
                    ctx.closePath();
                    ctx.stroke();
                }

                if (style.text) {
                    this.drawText(ctx, style, e.style);
                }


                ctx.restore();

                return;
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect: function(style) {
                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                } else {
                    lineWidth = 0;
                }
                return {
                    x: Math.round(style.x - style.r - lineWidth / 2),
                    y: Math.round(style.y - style.r - lineWidth / 2),
                    width: style.r * 2 + lineWidth,
                    height: style.r * 2 + lineWidth
                };
            }
        };

        var base = require('./base');
        base.derive(Ring);

        var shape = require('../shape');
        shape.define('ring', new Ring());

        return Ring;
    });


    /**
     * zrender
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：扇形
     * 可配图形属性：
       {
           // 基础属性
           shape  : 'sector',       // 必须，shape类标识，需要显式指定
           id     : {string},       // 必须，图形唯一标识，可通过zrender实例方法newShapeId生成
           zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
           invisible : {boolean},   // 默认为false，是否可见

           // 样式属性，默认状态样式样式属性
           style  : {
               x             : {number},  // 必须，圆心横坐标
               y             : {number},  // 必须，圆心纵坐标
               r0            : {number},  // 默认为0，内圆半径，指定后将出现内弧，同时扇边长度 = r - r0
               r             : {number},  // 必须，外圆半径
               startAngle    : {number},  // 必须，起始角度[0, 360)
               endAngle      : {number},  // 必须，结束角度(0, 360]
               brushType     : {string},  // 默认为fill，绘画方式
                                          // fill(填充) | stroke(描边) | both(填充+描边)
               color         : {color},   // 默认为'#000'，填充颜色，支持rgba
               strokeColor   : {color},   // 默认为'#000'，描边颜色（轮廓），支持rgba
               lineWidth     : {number},  // 默认为1，线条宽度，描边下有效

               opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
               shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
               shadowColor   : {color},   // 默认为'#000'，阴影色彩，支持rgba
               shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
               shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

               text          : {string},  // 默认为null，附加文本
               textFont      : {string},  // 默认为null，附加文本样式，eg:'bold 18px verdana'
               textPosition  : {string},  // 默认为outside，附加文本位置。
                                          // outside | inside
               textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                          // start | end | left | right | center
               textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                          // top | bottom | middle |
                                          // alphabetic | hanging | ideographic
               textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                          // 'inside' ? '#fff' : color
           },

           // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
           highlightStyle : {
               // 同style
           }

           // 交互属性，详见shape.Base

           // 事件属性，详见shape.Base
       }
             例子：
       {
           shape  : 'sector',
           id     : '123456',
           zlevel : 1,
           style  : {
               x : 200,
               y : 100,
               r : 50,
               color : '#eee',
               text : 'Baidu'
           },
           myName : 'kener',  // 可自带任何有效自定义属性

           clickable : true,
           onClick : function(eventPacket) {
               alert(eventPacket.target.myName);
           }
       }
     */
    define('zrender/shape/sector', ['require'], function(require) {
        var math = require('../tool/math');

        function Sector() {
            this.type = 'sector';
        }

        Sector.prototype = {
            /**
             * 创建扇形路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style) {
                var x = style.x; // 圆心x
                var y = style.y; // 圆心y
                var r0 = typeof style.r0 == 'undefined' // 形内半径[0,r)
                    ? 0 : style.r0;
                var r = style.r; // 扇形外半径(0,r]
                var startAngle = style.startAngle; // 起始角度[0,360)
                var endAngle = style.endAngle; // 结束角度(0,360]
                var PI2 = Math.PI * 2;

                startAngle = math.degreeToRadian(startAngle);
                endAngle = math.degreeToRadian(endAngle);

                //sin&cos已经在tool.math中缓存了，放心大胆的重复调用
                ctx.moveTo(
                    math.cos(startAngle) * r0 + x,
                    y - math.sin(startAngle) * r0
                );

                ctx.lineTo(
                    math.cos(startAngle) * r + x,
                    y - math.sin(startAngle) * r
                );

                ctx.arc(x, y, r, PI2 - startAngle, PI2 - endAngle, true);

                ctx.lineTo(
                    math.cos(endAngle) * r0 + x,
                    y - math.sin(endAngle) * r0
                );

                if (r0 !== 0) {
                    ctx.arc(x, y, r0, PI2 - endAngle, PI2 - startAngle, false);
                }

                return;
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect: function(style) {
                var x = style.x; // 圆心x
                var y = style.y; // 圆心y
                var r0 = typeof style.r0 == 'undefined' // 形内半径[0,r)
                    ? 0 : style.r0;
                var r = style.r; // 扇形外半径(0,r]
                var startAngle = style.startAngle; // 起始角度[0,360)
                var endAngle = style.endAngle; // 结束角度(0,360]
                var pointList = [];
                if (startAngle < 90 && endAngle > 90) {
                    pointList.push([
                        x, y - r
                    ]);
                }
                if (startAngle < 180 && endAngle > 180) {
                    pointList.push([
                        x - r, y
                    ]);
                }
                if (startAngle < 270 && endAngle > 270) {
                    pointList.push([
                        x, y + r
                    ]);
                }
                if (startAngle < 360 && endAngle > 360) {
                    pointList.push([
                        x + r, y
                    ]);
                }

                startAngle = math.degreeToRadian(startAngle);
                endAngle = math.degreeToRadian(endAngle);


                pointList.push([
                    math.cos(startAngle) * r0 + x,
                    y - math.sin(startAngle) * r0
                ]);

                pointList.push([
                    math.cos(startAngle) * r + x,
                    y - math.sin(startAngle) * r
                ]);

                pointList.push([
                    math.cos(endAngle) * r + x,
                    y - math.sin(endAngle) * r
                ]);

                pointList.push([
                    math.cos(endAngle) * r0 + x,
                    y - math.sin(endAngle) * r0
                ]);

                var shape = require('../shape');
                return shape.get('polygon').getRect({
                    brushType: style.brushType,
                    lineWidth: style.lineWidth,
                    pointList: pointList
                });
            }
        };

        var base = require('./base');
        base.derive(Sector);

        var shape = require('../shape');
        shape.define('sector', new Sector());

        return Sector;
    });

    /**
     * zrender: 数学辅助类
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * sin：正弦函数，自动缓存
     * cos：余弦函数，自动缓存
     * degreeToRadian：角度转弧度
     * radianToDegree：弧度转角度
     */
    define('zrender/tool/math', [], function() {
        var _cache = {
            sin: {}, //sin缓存
            cos: {} //cos缓存
        };
        var _radians = Math.PI / 180;

        /**
         * @param angle 弧度（角度）参数
         * @param isDegrees angle参数是否为角度计算，默认为false，angle为以弧度计量的角度
         */
        function sin(angle, isDegrees) {
            angle = (isDegrees ? angle * _radians : angle).toFixed(4);
            if (typeof _cache.sin[angle] == 'undefined') {
                _cache.sin[angle] = Math.sin(angle);
            }
            return _cache.sin[angle];
        }

        /**
         * @param radians 弧度参数
         */
        function cos(angle, isDegrees) {
            angle = (isDegrees ? angle * _radians : angle).toFixed(4);
            if (typeof _cache.cos[angle] == 'undefined') {
                _cache.cos[angle] = Math.cos(angle);
            }
            return _cache.cos[angle];
        }

        /**
         * 角度转弧度
         * @param {Object} angle
         */
        function degreeToRadian(angle) {
            return angle * _radians;
        }

        /**
         * 弧度转角度
         * @param {Object} angle
         */
        function radianToDegree(angle) {
            return angle / _radians;
        }

        return {
            sin: sin,
            cos: cos,
            degreeToRadian: degreeToRadian,
            radianToDegree: radianToDegree
        };
    });
    /**
     * zrender
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：文字
     * 可配图形属性：
       {
           // 基础属性
           shape  : 'text',         // 必须，shape类标识，需要显式指定
           id     : {string},       // 必须，图形唯一标识，可通过zrender实例方法newShapeId生成
           zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
           invisible : {boolean},   // 默认为false，是否可见

           // 样式属性，默认状态样式样式属性
           style  : {
               x             : {number},  // 必须，横坐标
               y             : {number},  // 必须，纵坐标
               brushType     : {string},  // 默认为fill，绘画方式
                                          // fill(填充) | stroke(描边) | both(填充+描边)
               color         : {color},   // 默认为'#000'，填充颜色，支持rgba
               strokeColor   : {color},   // 默认为'#000'，线条颜色（轮廓），支持rgba
               lineWidth     : {number},  // 默认为1，线条宽度

               opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
               shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
               shadowColor   : {color},   // 默认为'#000'，阴影色彩，支持rgba
               shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
               shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

               text          : {string},  // 必须，文本内容
               textFont      : {string},  // 默认为null，文本文字样式，eg:'bold 18px verdana'
               textAlign     : {string},  // 默认为start，文本水平对齐。
                                          // start | end | left | right | center
               textBaseline  : {string},  // 默认为middle，文本垂直对齐。
                                          // top | bottom | middle |
                                          // alphabetic | hanging | ideographic
               maxWidth      : {number}   // 默认为null，最大宽度
           },

           // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
           highlightStyle : {
               // 同style
           }

           // 交互属性，详见shape.Base

           // 事件属性，详见shape.Base
       }
             例子：
       {
           shape  : 'text',
           id     : '123456',
           zlevel : 1,
           style  : {
               x : 200,
               y : 100,
               color : 'red',
               text : 'Baidu'
           },
           myName : 'kener',  //可自带任何有效自定义属性

           clickable : true,
           onClick : function(eventPacket) {
               alert(eventPacket.target.myName);
           }
       }
     */
    define('zrender/shape/text', ['require'], function(require) {
        function Text() {
            this.type = 'text';
        }

        Text.prototype = {
            /**
             * 画刷，重载基类方法
             * @param {Context2D} ctx Canvas 2D上下文
             * @param e 图形形状实体
             * @param isHighlight 是否为高亮状态
             */
            brush: function(ctx, e, isHighlight) {
                var style = e.style || {};
                if (isHighlight) {
                    // 根据style扩展默认高亮样式
                    style = this.getHighlightStyle(
                        style, e.highlightStyle || {}
                    );
                }

                ctx.save();
                this.setContext(ctx, style);

                // 设置transform
                if (e.__needTransform) {
                    ctx.transform.apply(ctx, this.updateTransform(e));
                }

                if (style.textFont) {
                    ctx.font = style.textFont;
                }
                ctx.textAlign = style.textAlign || 'start';
                ctx.textBaseline = style.textBaseline || 'middle';

                if (style.maxWidth) {
                    switch (style.brushType) {
                        case 'fill':
                            ctx.fillText(
                                style.text,
                                style.x, style.y, style.maxWidth
                            );
                            break;
                        case 'stroke':
                            ctx.strokeText(
                                style.text,
                                style.x, style.y, style.maxWidth
                            );
                            break;
                        case 'both':
                            ctx.strokeText(
                                style.text,
                                style.x, style.y, style.maxWidth
                            );
                            ctx.fillText(
                                style.text,
                                style.x, style.y, style.maxWidth
                            );
                            break;
                        default:
                            ctx.fillText(
                                style.text,
                                style.x, style.y, style.maxWidth
                            );
                    }
                } else {
                    switch (style.brushType) {
                        case 'fill':
                            ctx.fillText(style.text, style.x, style.y);
                            break;
                        case 'stroke':
                            ctx.strokeText(style.text, style.x, style.y);
                            break;
                        case 'both':
                            ctx.strokeText(style.text, style.x, style.y);
                            ctx.fillText(style.text, style.x, style.y);
                            break;
                        default:
                            ctx.fillText(style.text, style.x, style.y);
                    }
                }

                ctx.restore();
                return;
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect: function(style) {
                var area = require('../tool/area');

                var width = area.getTextWidth(style.text, style.textFont);
                var height = area.getTextWidth('国', style.textFont); //比较粗暴

                var textX = style.x; //默认start == left
                if (style.textAlign == 'end' || style.textAlign == 'right') {
                    textX -= width;
                } else if (style.textAlign == 'center') {
                    textX -= (width / 2);
                }

                var textY = style.y - height / 2; //默认middle
                if (style.textBaseline == 'top') {
                    textY += height / 2;
                } else if (style.textBaseline == 'bottom') {
                    textX -= height / 2;
                }

                return {
                    x: textX,
                    y: textY,
                    width: width,
                    height: height
                };
            }
        };

        var base = require('./base');
        base.derive(Text);

        var shape = require('../shape');
        shape.define('text', new Text());

        return Text;
    });
    /**
     * zrender
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：心形
     * 可配图形属性：
       {
           // 基础属性
           shape  : 'heart',       // 必须，shape类标识，需要显式指定
           id     : {string},       // 必须，图形唯一标识，可通过zrender实例方法newShapeId生成
           zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
           invisible : {boolean},   // 默认为false，是否可见

           // 样式属性，默认状态样式样式属性
           style  : {
               x             : {number},  // 必须，心形内部尖端横坐标
               y             : {number},  // 必须，心形内部尖端纵坐标
               a             : {number},  // 必须，心形横宽（中轴线到水平边缘最宽处距离）
               b             : {number},  // 必须，心形纵高（内尖到外尖距离）
               brushType     : {string},  // 默认为fill，绘画方式
                                          // fill(填充) | stroke(描边) | both(填充+描边)
               color         : {color},   // 默认为'#000'，填充颜色，支持rgba
               strokeColor   : {color},   // 默认为'#000'，描边颜色（轮廓），支持rgba
               lineWidth     : {number},  // 默认为1，线条宽度，描边下有效

               shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
               shadowColor   : {color},   // 默认为'#000'，阴影色彩，支持rgba
               shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
               shadowOffsetY : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左

               text          : {string},  // 默认为null，附加文本
               textFont      : {string},  // 默认为null，附加文本样式，eg:'bold 18px verdana'
               textPosition  : {string},  // 默认为outside，附加文本位置。
                                          // outside | inside
               textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                          // start | end | left | right | center
               textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                          // top | bottom | middle |
                                          // alphabetic | hanging | ideographic
               textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                          // 'inside' ? '#fff' : color
           },

           // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
           highlightStyle : {
               // 同style
           }

           // 交互属性，详见shape.Base

           // 事件属性，详见shape.Base
       }
             例子：
       {
           shape  : 'heart',
           id     : '123456',
           zlevel : 1,
           style  : {
               x : 200,
               y : 100,
               a : 50,
               b : 80,
               color : '#eee',
               text : 'Baidu'
           },
           myName : 'kener',  // 可自带任何有效自定义属性

           clickable : true,
           onClick : function(eventPacket) {
               alert(eventPacket.target.myName);
           }
       }
     */
    define('zrender/shape/heart', ['require'], function(require) {
        function Heart() {
            this.type = 'heart';
        }

        Heart.prototype = {
            /**
             * 创建扇形路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style) {
                ctx.moveTo(style.x, style.y);
                ctx.bezierCurveTo(
                    style.x + style.a / 2,
                    style.y - style.b * 2 / 3,
                    style.x + style.a * 2,
                    style.y + style.b / 3,
                    style.x,
                    style.y + style.b
                );
                ctx.bezierCurveTo(
                    style.x - style.a * 2,
                    style.y + style.b / 3,
                    style.x - style.a / 2,
                    style.y - style.b * 2 / 3,
                    style.x,
                    style.y
                );
                return;
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect: function(style) {
                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                } else {
                    lineWidth = 0;
                }
                return {
                    x: Math.round(style.x - style.a - lineWidth / 2),
                    y: Math.round(style.y - style.b / 4 - lineWidth / 2),
                    width: style.a * 2 + lineWidth,
                    height: style.b * 5 / 4 + lineWidth
                };
            }
        };

        var base = require('./base');
        base.derive(Heart);

        var shape = require('../shape');
        shape.define('heart', new Heart());

        return Heart;
    });
    /**
     * zrender
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * shape类：水滴
     * 可配图形属性：
       {
           // 基础属性
           shape  : 'heart',       // 必须，shape类标识，需要显式指定
           id     : {string},       // 必须，图形唯一标识，可通过zrender实例方法newShapeId生成
           zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
           invisible : {boolean},   // 默认为false，是否可见

           // 样式属性，默认状态样式样式属性
           style  : {
               x             : {number},  // 必须，水滴中心横坐标
               y             : {number},  // 必须，水滴中心纵坐标
               a             : {number},  // 必须，水滴横宽（中心到水平边缘最宽处距离）
               b             : {number},  // 必须，水滴纵高（中心到尖端距离）
               brushType     : {string},  // 默认为fill，绘画方式
                                          // fill(填充) | stroke(描边) | both(填充+描边)
               color         : {color},   // 默认为'#000'，填充颜色，支持rgba
               strokeColor   : {color},   // 默认为'#000'，描边颜色（轮廓），支持rgba
               lineWidth     : {number},  // 默认为1，线条宽度，描边下有效

               shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
               shadowColor   : {color},   // 默认为'#000'，阴影色彩，支持rgba
               shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
               shadowOffsetY : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左

               text          : {string},  // 默认为null，附加文本
               textFont      : {string},  // 默认为null，附加文本样式，eg:'bold 18px verdana'
               textPosition  : {string},  // 默认为outside，附加文本位置。
                                          // outside | inside
               textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                          // start | end | left | right | center
               textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                          // top | bottom | middle |
                                          // alphabetic | hanging | ideographic
               textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                          // 'inside' ? '#fff' : color
           },

           // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
           highlightStyle : {
               // 同style
           }

           // 交互属性，详见shape.Base

           // 事件属性，详见shape.Base
       }
             例子：
       {
           shape  : 'droplet',
           id     : '123456',
           zlevel : 1,
           style  : {
               x : 200,
               y : 100,
               a : 50,
               b : 80,
               color : '#eee',
               text : 'Baidu'
           },
           myName : 'kener',  // 可自带任何有效自定义属性

           clickable : true,
           onClick : function(eventPacket) {
               alert(eventPacket.target.myName);
           }
       }
     */
    define('zrender/shape/droplet', ['require'], function(require) {
        function Droplet() {
            this.type = 'droplet';
        }

        Droplet.prototype = {
            /**
             * 创建扇形路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style) {
                ctx.moveTo(style.x, style.y + style.a);
                ctx.bezierCurveTo(
                    style.x + style.a,
                    style.y + style.a,
                    style.x + style.a * 3 / 2,
                    style.y - style.a / 3,
                    style.x,
                    style.y - style.b
                );
                ctx.bezierCurveTo(
                    style.x - style.a * 3 / 2,
                    style.y - style.a / 3,
                    style.x - style.a,
                    style.y + style.a,
                    style.x,
                    style.y + style.a
                );
                return;
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect: function(style) {
                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                } else {
                    lineWidth = 0;
                }
                return {
                    x: Math.round(style.x - style.a - lineWidth / 2),
                    y: Math.round(style.y - style.b - lineWidth / 2),
                    width: style.a * 2 + lineWidth,
                    height: style.a + style.b + lineWidth
                };
            }
        };

        var base = require('./base');
        base.derive(Droplet);

        var shape = require('../shape');
        shape.define('droplet', new Droplet());

        return Droplet;
    });
    /**
     * zrender
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * author: CrossDo (chenhuaimu@baidu.com)
     *
     * shape类：路径
     * 可配图形属性：
       {
           // 基础属性
           shape  : 'path',         // 必须，shape类标识，需要显式指定
           id     : {string},       // 必须，图形唯一标识，可通过zrender实例方法newShapeId生成
           zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
           invisible : {boolean},   // 默认为false，是否可见

           // 样式属性，默认状态样式样式属性
           style  : {
               path          : {string},// 必须，路径。例如:M 0 0 L 0 10 L 10 10 Z (一个三角形)
                                        //M = moveto
                                        //L = lineto
                                        //H = horizontal lineto
                                        //V = vertical lineto
                                        //C = curveto
                                        //S = smooth curveto
                                        //Q = quadratic Belzier curve
                                        //T = smooth quadratic Belzier curveto
                                        //Z = closepath


               x             : {number},  // 必须，x轴坐标
               y             : {number},  // 必须，y轴坐标


               brushType     : {string},  // 默认为fill，绘画方式
                                          // fill(填充) | stroke(描边) | both(填充+描边)
               color         : {color},   // 默认为'#000'，填充颜色，支持rgba
               strokeColor   : {color},   // 默认为'#000'，描边颜色（轮廓），支持rgba
               lineWidth     : {number},  // 默认为1，线条宽度，描边下有效

               opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
               shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
               shadowColor   : {color},   // 默认为'#000'，阴影色彩，支持rgba
               shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
               shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

               text          : {string},  // 默认为null，附加文本
               textFont      : {string},  // 默认为null，附加文本样式，eg:'bold 18px verdana'
               textPosition  : {string},  // 默认为top，附加文本位置。
                                          // inside | left | right | top | bottom
               textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                          // start | end | left | right | center
               textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                          // top | bottom | middle |
                                          // alphabetic | hanging | ideographic
               textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                          // 'inside' ? '#fff' : color
           },

           // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
           highlightStyle : {
               // 同style
           }

           // 交互属性，详见shape.Base

           // 事件属性，详见shape.Base
       }

     **/

    define('zrender/shape/path', ['require'], function(require) {
        function Path() {
            this.type = 'path';
        }

        Path.prototype = {
            _parsePathData: function(data) {
                if (!data) {
                    return [];
                }

                // command string
                var cs = data;

                // command chars
                var cc = [
                    'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',
                    'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'
                ];
                cs = cs.replace(/  /g, ' ');
                cs = cs.replace(/ /g, ',');
                cs = cs.replace(/,,/g, ',');
                var n;
                // create pipes so that we can split the data
                for (n = 0; n < cc.length; n++) {
                    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
                }
                // create array
                var arr = cs.split('|');
                var ca = [];
                // init context point
                var cpx = 0;
                var cpy = 0;
                for (n = 1; n < arr.length; n++) {
                    var str = arr[n];
                    var c = str.charAt(0);
                    str = str.slice(1);
                    str = str.replace(new RegExp('e,-', 'g'), 'e-');

                    var p = str.split(',');
                    if (p.length > 0 && p[0] === '') {
                        p.shift();
                    }

                    for (var i = 0; i < p.length; i++) {
                        p[i] = parseFloat(p[i]);
                    }
                    while (p.length > 0) {
                        if (isNaN(p[0])) {
                            break;
                        }
                        var cmd = null;
                        var points = [];

                        var ctlPtx;
                        var ctlPty;
                        var prevCmd;

                        var rx;
                        var ry;
                        var psi;
                        var fa;
                        var fs;

                        var x1 = cpx;
                        var y1 = cpy;

                        // convert l, H, h, V, and v to L
                        switch (c) {
                            case 'l':
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = 'L';
                                points.push(cpx, cpy);
                                break;
                            case 'L':
                                cpx = p.shift();
                                cpy = p.shift();
                                points.push(cpx, cpy);
                                break;
                            case 'm':
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = 'M';
                                points.push(cpx, cpy);
                                c = 'l';
                                break;
                            case 'M':
                                cpx = p.shift();
                                cpy = p.shift();
                                cmd = 'M';
                                points.push(cpx, cpy);
                                c = 'L';
                                break;

                            case 'h':
                                cpx += p.shift();
                                cmd = 'L';
                                points.push(cpx, cpy);
                                break;
                            case 'H':
                                cpx = p.shift();
                                cmd = 'L';
                                points.push(cpx, cpy);
                                break;
                            case 'v':
                                cpy += p.shift();
                                cmd = 'L';
                                points.push(cpx, cpy);
                                break;
                            case 'V':
                                cpy = p.shift();
                                cmd = 'L';
                                points.push(cpx, cpy);
                                break;
                            case 'C':
                                points.push(p.shift(), p.shift(), p.shift(), p.shift());
                                cpx = p.shift();
                                cpy = p.shift();
                                points.push(cpx, cpy);
                                break;
                            case 'c':
                                points.push(
                                    cpx + p.shift(), cpy + p.shift(),
                                    cpx + p.shift(), cpy + p.shift()
                                );
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = 'C';
                                points.push(cpx, cpy);
                                break;
                            case 'S':
                                ctlPtx = cpx;
                                ctlPty = cpy;
                                prevCmd = ca[ca.length - 1];
                                if (prevCmd.command === 'C') {
                                    ctlPtx = cpx + (cpx - prevCmd.points[2]);
                                    ctlPty = cpy + (cpy - prevCmd.points[3]);
                                }
                                points.push(ctlPtx, ctlPty, p.shift(), p.shift());
                                cpx = p.shift();
                                cpy = p.shift();
                                cmd = 'C';
                                points.push(cpx, cpy);
                                break;
                            case 's':
                                ctlPtx = cpx, ctlPty = cpy;
                                prevCmd = ca[ca.length - 1];
                                if (prevCmd.command === 'C') {
                                    ctlPtx = cpx + (cpx - prevCmd.points[2]);
                                    ctlPty = cpy + (cpy - prevCmd.points[3]);
                                }
                                points.push(
                                    ctlPtx, ctlPty,
                                    cpx + p.shift(), cpy + p.shift()
                                );
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = 'C';
                                points.push(cpx, cpy);
                                break;
                            case 'Q':
                                points.push(p.shift(), p.shift());
                                cpx = p.shift();
                                cpy = p.shift();
                                points.push(cpx, cpy);
                                break;
                            case 'q':
                                points.push(cpx + p.shift(), cpy + p.shift());
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = 'Q';
                                points.push(cpx, cpy);
                                break;
                            case 'T':
                                ctlPtx = cpx, ctlPty = cpy;
                                prevCmd = ca[ca.length - 1];
                                if (prevCmd.command === 'Q') {
                                    ctlPtx = cpx + (cpx - prevCmd.points[0]);
                                    ctlPty = cpy + (cpy - prevCmd.points[1]);
                                }
                                cpx = p.shift();
                                cpy = p.shift();
                                cmd = 'Q';
                                points.push(ctlPtx, ctlPty, cpx, cpy);
                                break;
                            case 't':
                                ctlPtx = cpx, ctlPty = cpy;
                                prevCmd = ca[ca.length - 1];
                                if (prevCmd.command === 'Q') {
                                    ctlPtx = cpx + (cpx - prevCmd.points[0]);
                                    ctlPty = cpy + (cpy - prevCmd.points[1]);
                                }
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = 'Q';
                                points.push(ctlPtx, ctlPty, cpx, cpy);
                                break;
                            case 'A':
                                rx = p.shift();
                                ry = p.shift();
                                psi = p.shift();
                                fa = p.shift();
                                fs = p.shift();

                                x1 = cpx, y1 = cpy;
                                cpx = p.shift(), cpy = p.shift();
                                cmd = 'A';
                                points = this._convertPoint(
                                    x1, y1, cpx, cpy, fa, fs, rx, ry, psi
                                );
                                break;
                            case 'a':
                                rx = p.shift();
                                ry = p.shift();
                                psi = p.shift();
                                fa = p.shift();
                                fs = p.shift();

                                x1 = cpx, y1 = cpy;
                                cpx += p.shift();
                                cpy += p.shift();
                                cmd = 'A';
                                points = this._convertPoint(
                                    x1, y1, cpx, cpy, fa, fs, rx, ry, psi
                                );
                                break;

                        }

                        ca.push({
                            command: cmd || c,
                            points: points
                        });
                    }

                    if (c === 'z' || c === 'Z') {
                        ca.push({
                            command: 'z',
                            points: []
                        });
                    }
                }

                return ca;

            },

            _convertPoint: function(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg) {
                var psi = psiDeg * (Math.PI / 180.0);
                var xp = Math.cos(psi) * (x1 - x2) / 2.0 + Math.sin(psi) * (y1 - y2) / 2.0;
                var yp = -1 * Math.sin(psi) * (x1 - x2) / 2.0 + Math.cos(psi) * (y1 - y2) / 2.0;

                var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);

                if (lambda > 1) {
                    rx *= Math.sqrt(lambda);
                    ry *= Math.sqrt(lambda);
                }

                var f = Math.sqrt((((rx * rx) * (ry * ry)) - ((rx * rx) * (yp * yp)) - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp) + (ry * ry) * (xp * xp)));

                if (fa === fs) {
                    f *= -1;
                }
                if (isNaN(f)) {
                    f = 0;
                }

                var cxp = f * rx * yp / ry;
                var cyp = f * -ry * xp / rx;

                var cx = (x1 + x2) / 2.0 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
                var cy = (y1 + y2) / 2.0 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;

                var vMag = function(v) {
                    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
                };
                var vRatio = function(u, v) {
                    return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
                };
                var vAngle = function(u, v) {
                    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
                };
                var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
                var u = [(xp - cxp) / rx, (yp - cyp) / ry];
                var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
                var dTheta = vAngle(u, v);

                if (vRatio(u, v) <= -1) {
                    dTheta = Math.PI;
                }
                if (vRatio(u, v) >= 1) {
                    dTheta = 0;
                }
                if (fs === 0 && dTheta > 0) {
                    dTheta = dTheta - 2 * Math.PI;
                }
                if (fs === 1 && dTheta < 0) {
                    dTheta = dTheta + 2 * Math.PI;
                }
                return [cx, cy, rx, ry, theta, dTheta, psi, fs];
            },

            /**
             * 创建路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style) {
                var path = style.path;

                var pathArray = this._parsePathData(path);

                // 平移坐标
                var x = style.x || 0;
                var y = style.y || 0;

                var p;
                // 记录边界点，用于判断inside
                var pointList = style.pointList = [];
                var singlePointList = [];
                for (var i = 0, l = pathArray.length; i < l; i++) {
                    if (pathArray[i].command.toUpperCase() == 'M') {
                        singlePointList.length > 0 && pointList.push(singlePointList);
                        singlePointList = [];
                    }
                    p = pathArray[i].points;
                    for (var j = 0, k = p.length; j < k; j += 2) {
                        singlePointList.push([p[j] + x, p[j + 1] + y]);
                    }
                }
                singlePointList.length > 0 && pointList.push(singlePointList);

                var c;
                for (var i = 0, l = pathArray.length; i < l; i++) {
                    c = pathArray[i].command;
                    p = pathArray[i].points;
                    // 平移变换
                    for (var j = 0, k = p.length; j < k; j++) {
                        if (j % 2 === 0) {
                            p[j] += x;
                        } else {
                            p[j] += y;
                        }
                    }
                    switch (c) {
                        case 'L':
                            ctx.lineTo(p[0], p[1]);
                            break;
                        case 'M':
                            ctx.moveTo(p[0], p[1]);
                            break;
                        case 'C':
                            ctx.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
                            break;
                        case 'Q':
                            ctx.quadraticCurveTo(p[0], p[1], p[2], p[3]);
                            break;
                        case 'A':
                            var cx = p[0];
                            var cy = p[1];
                            var rx = p[2];
                            var ry = p[3];
                            var theta = p[4];
                            var dTheta = p[5];
                            var psi = p[6];
                            var fs = p[7];
                            var r = (rx > ry) ? rx : ry;
                            var scaleX = (rx > ry) ? 1 : rx / ry;
                            var scaleY = (rx > ry) ? ry / rx : 1;

                            ctx.translate(cx, cy);
                            ctx.rotate(psi);
                            ctx.scale(scaleX, scaleY);
                            ctx.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
                            ctx.scale(1 / scaleX, 1 / scaleY);
                            ctx.rotate(-psi);
                            ctx.translate(-cx, -cy);
                            break;
                        case 'z':
                            ctx.closePath();
                            break;
                    }
                }

                return;
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style 样式
             */
            getRect: function(style) {
                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                } else {
                    lineWidth = 0;
                }

                var minX = Number.MAX_VALUE;
                var maxX = Number.MIN_VALUE;

                var minY = Number.MAX_VALUE;
                var maxY = Number.MIN_VALUE;

                // 平移坐标
                var x = style.x || 0;
                var y = style.y || 0;

                var pathArray = this._parsePathData(style.path);
                for (var i = 0; i < pathArray.length; i++) {
                    var p = pathArray[i].points;

                    for (var j = 0; j < p.length; j++) {
                        if (j % 2 === 0) {
                            if (p[j] + x < minX) {
                                minX = p[j] + x;
                            }
                            if (p[j] + x > maxX) {
                                maxX = p[j] + x;
                            }
                        } else {
                            if (p[j] + y < minY) {
                                minY = p[j] + y;
                            }
                            if (p[j] + y > maxY) {
                                maxY = p[j] + y;
                            }
                        }
                    }
                }

                var rect;
                if (minX === Number.MAX_VALUE || maxX === Number.MIN_VALUE || minY === Number.MAX_VALUE || maxY === Number.MIN_VALUE) {
                    rect = {
                        x: 0,
                        y: 0,
                        width: 0,
                        height: 0
                    };
                } else {
                    rect = {
                        x: Math.round(minX - lineWidth / 2),
                        y: Math.round(minY - lineWidth / 2),
                        width: maxX - minX + lineWidth,
                        height: maxY - minY + lineWidth
                    };
                }
                return rect;
            }
        };

        var base = require('./base');
        base.derive(Path);

        var shape = require('../shape');
        shape.define('path', new Path());

        return Path;
    });

    /**
     * zrender
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * @author lang( shenyi01@baidu.com )
     *
     * shape类：图片
     * 可配图形属性：
       {
           // 基础属性
           shape  : 'image',       // 必须，shape类标识，需要显式指定
           id     : {string},       // 必须，图形唯一标识，可通过zrender实例方法newShapeId生成
           zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
           invisible : {boolean},   // 默认为false，是否可见

           // 样式属性，默认状态样式样式属性
           style  : {
               x             : {number},  // 必须，左上角横坐标
               y             : {number},  // 必须，左上角纵坐标
               width         : {number},  // 可选，宽度
               height        : {number},  // 可选，高度
               sx            : {number},  // 可选, 从图片中裁剪的x
               sy            : {number},  // 可选, 从图片中裁剪的y
               sWidth        : {number},  // 可选, 从图片中裁剪的宽度
               sHeight       : {number},  // 可选, 从图片中裁剪的高度
               image         : {string|Image} // 必须，图片url或者图片对象
               lineWidth     : {number},  // 默认为1，线条宽度，描边下有效

               opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
               shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
               shadowColor   : {color},   // 默认为'#000'，阴影色彩，支持rgba
               shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
               shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

               text          : {string},  // 默认为null，附加文本
               textFont      : {string},  // 默认为null，附加文本样式，eg:'bold 18px verdana'
               textPosition  : {string},  // 默认为top，附加文本位置。
                                          // inside | left | right | top | bottom
               textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                          // start | end | left | right | center
               textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                          // top | bottom | middle |
                                          // alphabetic | hanging | ideographic
               textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                          // 'inside' ? '#fff' : color
           },

           // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
           highlightStyle : {
               // 同style
           }

           // 交互属性，详见shape.Base

           // 事件属性，详见shape.Base
       }
             例子：
       {
           shape  : 'image',
           id     : '123456',
           zlevel : 1,
           style  : {
               x : 200,
               y : 100,
               width : 150,
               height : 50,
               image : 'tests.jpg',
               text : 'Baidu'
           },
           myName : 'kener',  // 可自带任何有效自定义属性

           clickable : true,
           onClick : function(eventPacket) {
               alert(eventPacket.target.myName);
           }
       }
     */
    define('zrender/shape/image', ['require'], function(require) {

        var _cache = {};
        var _needsRefresh = [];
        var _refreshTimeout;

        function ZImage() {
            this.type = 'image';
        }

        ZImage.prototype = {
            brush: function(ctx, e, isHighlight, refresh) {
                var style = e.style || {};

                if (isHighlight) {
                    // 根据style扩展默认高亮样式
                    style = this.getHighlightStyle(
                        style, e.highlightStyle || {}
                    );
                }

                var image = style.image;

                if (typeof(image) === 'string') {
                    var src = image;
                    if (_cache[src]) {
                        image = _cache[src];
                    } else {
                        // image = document.createElement('image');//new Image();
                        image = new Image();
                        image.onload = function() {
                            image.onload = null;
                            clearTimeout(_refreshTimeout);
                            _needsRefresh.push(e);
                            // 防止因为缓存短时间内触发多次onload事件
                            _refreshTimeout = setTimeout(function() {
                                refresh(_needsRefresh);
                                // 清空needsRefresh
                                _needsRefresh = [];
                            }, 10);
                        };
                        _cache[src] = image;

                        image.src = src;
                    }
                }
                if (image) {
                    //图片已经加载完成
                    if (window.ActiveXObject) {
                        if (image.readyState != 'complete') {
                            return;
                        }
                    } else {
                        if (!image.complete) {
                            return;
                        }
                    }

                    ctx.save();
                    this.setContext(ctx, style);

                    // 设置transform
                    if (e.__needTransform) {
                        ctx.transform.apply(ctx, this.updateTransform(e));
                    }

                    var width = style.width || image.width;
                    var height = style.height || image.height;
                    var x = style.x;
                    var y = style.y;
                    if (style.sWidth && style.sHeight) {
                        var sx = style.sx || 0;
                        var sy = style.sy || 0;
                        ctx.drawImage(
                            image,
                            sx, sy, style.sWidth, style.sHeight,
                            x, y, width, height
                        );
                    } else if (style.sx && style.sy) {
                        var sx = style.sx;
                        var sy = style.sy;
                        var sWidth = width - sx;
                        var sHeight = height - sy;
                        ctx.drawImage(
                            image,
                            sx, sy, sWidth, sHeight,
                            x, y, width, height
                        );
                    } else {
                        ctx.drawImage(image, x, y, width, height);
                    }
                    // 如果没设置宽和高的话自动根据图片宽高设置
                    style.width = width;
                    style.height = height;
                    e.style.width = width;
                    e.style.height = height;


                    if (style.text) {
                        this.drawText(ctx, style, e.style);
                    }

                    ctx.restore();
                }

                return;
            },

            /**
             * 创建路径，用于判断hover时调用isPointInPath~
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style) {
                ctx.rect(style.x, style.y, style.width, style.height);
                return;
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect: function(style) {
                return {
                    x: style.x,
                    y: style.y,
                    width: style.width,
                    height: style.height
                };
            }
        };

        var base = require('./base');
        base.derive(ZImage);

        var shape = require('../shape');
        shape.define('image', new ZImage());

        return ZImage;
    });
    /**
     * zrender
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * @author Neil (杨骥, yangji01@baidu.com)
     *
     * shape类：贝塞尔曲线
     * 可配图形属性：
       {
           // 基础属性
           shape  : 'beziercurve',         // 必须，shape类标识，需要显式指定
           id     : {string},       // 必须，图形唯一标识，可通过zrender实例方法newShapeId生成
           zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
           invisible : {boolean},   // 默认为false，是否可见

           // 样式属性，默认状态样式样式属性
           style  : {
               xStart        : {number},  // 必须，起点横坐标
               yStart        : {number},  // 必须，起点纵坐标
               cpX1          : {number},  // 必须，第一个关联点横坐标
               cpY1          : {number},  // 必须，第一个关联点纵坐标
               cpX2          : {number},  // 可选，第二个关联点横坐标  缺省即为二次贝塞尔曲线
               cpY2          : {number},  // 可选，第二个关联点纵坐标
               xEnd          : {number},  // 必须，终点横坐标
               yEnd          : {number},  // 必须，终点纵坐标
               strokeColor   : {color},   // 默认为'#000'，线条颜色（轮廓），支持rgba

               lineWidth     : {number},  // 默认为1，线条宽度
               lineCap       : {string},  // 默认为butt，线帽样式。butt | round | square

               opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
               shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
               shadowColor   : {color},   // 默认为'#000'，阴影色彩，支持rgba
               shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
               shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

               text          : {string},  // 默认为null，附加文本
               textFont      : {string},  // 默认为null，附加文本样式，eg:'bold 18px verdana'
               textPosition  : {string},  // 默认为end，附加文本位置。
                                          // inside | start | end
               textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                          // start | end | left | right | center
               textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                          // top | bottom | middle |
                                          // alphabetic | hanging | ideographic
               textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                          // 'inside' ? '#000' : color
           },

           // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
           highlightStyle : {
               // 同style
           }

           // 交互属性，详见shape.Base

           // 事件属性，详见shape.Base
       }
             例子：
       {
           shape  : 'beziercurve',
           id     : '123456',
           zlevel : 1,
           style  : {
               xStart : 100,
               yStart : 100,
               xEnd : 200,
               yEnd : 200,
               strokeColor : '#eee',
               lineWidth : 20,
               text : 'Baidu'
           },
           myName : 'kener',  //可自带任何有效自定义属性

           clickable : true,
           onClick : function(eventPacket) {
               alert(eventPacket.target.myName);
           }
       }
     */
    define('zrender/shape/beziercurve', ['require'], function(require) {
        function Beziercurve() {
            this.type = 'beziercurve';
            this.brushTypeOnly = 'stroke'; //线条只能描边，填充后果自负
            this.textPosition = 'end';
        }

        Beziercurve.prototype = {
            /**
             * 创建线条路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style) {
                ctx.moveTo(style.xStart, style.yStart);
                if (typeof style.cpX2 != 'undefined' && typeof style.cpY2 != 'undefined') {
                    ctx.bezierCurveTo(
                        style.cpX1, style.cpY1,
                        style.cpX2, style.cpY2,
                        style.xEnd, style.yEnd
                    );
                } else {
                    ctx.quadraticCurveTo(
                        style.cpX1, style.cpY1,
                        style.xEnd, style.yEnd
                    );
                }

            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect: function(style) {
                var _minX = Math.min(style.xStart, style.xEnd, style.cpX1);
                var _minY = Math.min(style.yStart, style.yEnd, style.cpY1);
                var _maxX = Math.max(style.xStart, style.xEnd, style.cpX1);
                var _maxY = Math.max(style.yStart, style.yEnd, style.cpY1);
                var _x2 = style.cpX2;
                var _y2 = style.cpY2;

                if (typeof _x2 != 'undefined' && typeof _y2 != 'undefined') {
                    _minX = Math.min(_minX, _x2);
                    _minY = Math.min(_minY, _y2);
                    _maxX = Math.max(_maxX, _x2);
                    _maxY = Math.max(_maxY, _y2);
                }

                var lineWidth = style.lineWidth || 1;
                return {
                    x: _minX - lineWidth,
                    y: _minY - lineWidth,
                    width: _maxX - _minX + lineWidth,
                    height: _maxY - _minY + lineWidth
                };
            }
        };

        var base = require('./base');
        base.derive(Beziercurve);

        var shape = require('../shape');
        shape.define('beziercurve', new Beziercurve());

        return Beziercurve;
    });

    /**
     * zrender
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * @author sushuang (宿爽, sushuang@baidu.com)
     *
     * shape类：n角星（n>3）
     * 可配图形属性：
       {
           // 基础属性
           shape  : 'star',       // 必须，shape类标识，需要显式指定
           id     : {string},       // 必须，图形唯一标识，可通过zrender实例方法newShapeId生成
           zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
           invisible : {boolean},   // 默认为false，是否可见

           // 样式属性，默认状态样式样式属性
           style  : {
               x             : {number},  // 必须，n角星外接圆心横坐标
               y             : {number},  // 必须，n角星外接圆心纵坐标
               r             : {number},  // 必须，n角星外接圆半径
               r0            : {number},  // n角星内部顶点（凹点）的外接圆半径，
                                          // 如果不指定此参数，则自动计算：取相隔外部顶点连线的交点作内部顶点
               n             : {number},  // 必须，指明几角星
               brushType     : {string},  // 默认为fill，绘画方式
                                          // fill(填充) | stroke(描边) | both(填充+描边)
               color         : {color},   // 默认为'#000'，填充颜色，支持rgba
               strokeColor   : {color},   // 默认为'#000'，描边颜色（轮廓），支持rgba
               lineWidth     : {number},  // 默认为1，线条宽度，描边下有效
               lineJoin      : {string},  // 默认为miter，线段连接样式。miter | round | bevel

               shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
               shadowColor   : {color},   // 默认为'#000'，阴影色彩，支持rgba
               shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
               shadowOffsetY : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左

               text          : {string},  // 默认为null，附加文本
               textFont      : {string},  // 默认为null，附加文本样式，eg:'bold 18px verdana'
               textPosition  : {string},  // 默认为outside，附加文本位置。
                                          // outside | inside
               textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                          // start | end | left | right | center
               textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                          // top | bottom | middle |
                                          // alphabetic | hanging | ideographic
               textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                          // 'inside' ? '#fff' : color
           },

           // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
           highlightStyle : {
               // 同style
           }

           // 交互属性，详见shape.Base

           // 事件属性，详见shape.Base
       }
             例子：
       {
           shape  : 'star',
           id     : '123456',
           zlevel : 1,
           style  : {
               x : 200,
               y : 100,
               r : 150,
               n : 5,
               color : '#eee'
           },
           myName : 'kener',   // 可自带任何有效自定义属性

           clickable : true,
           onClick : function(eventPacket) {
               alert(eventPacket.target.myName);
           }
       }
     */
    define('zrender/shape/star', ['require'], function(require) {

        var math = require('../tool/math');
        var sin = math.sin;
        var cos = math.cos;
        var PI = Math.PI;

        function Star() {
            this.type = 'heart';
        }

        Star.prototype = {
            /**
             * 创建n角星（n>3）路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style) {
                var n = style.n;
                if (!n || n < 2) {
                    return;
                }

                var x = style.x;
                var y = style.y;
                var r = style.r;
                var r0 = style.r0;

                // 如果未指定内部顶点外接圆半径，则自动计算
                if (r0 == null) {
                    r0 = n > 4
                        // 相隔的外部顶点的连线的交点，
                        // 被取为内部交点，以此计算r0
                        ? r * cos(2 * PI / n) / cos(PI / n)
                        // 二三四角星的特殊处理
                        : r / 3;
                }

                var dStep = PI / n;
                var deg = -PI / 2;
                var xStart = x + r * cos(deg);
                var yStart = y + r * sin(deg);
                deg += dStep;

                // 记录边界点，用于判断inside
                var pointList = style.pointList = [];
                pointList.push([xStart, yStart]);
                for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {
                    ri = i % 2 === 0 ? r0 : r;
                    pointList.push([x + ri * cos(deg), y + ri * sin(deg)]);
                    deg += dStep;
                }
                pointList.push([xStart, yStart]);

                // 绘制
                ctx.moveTo(pointList[0][0], pointList[0][1]);
                for (var i = 0; i < pointList.length; i++) {
                    ctx.lineTo(pointList[i][0], pointList[i][1]);
                }

                return;
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect: function(style) {
                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                } else {
                    lineWidth = 0;
                }
                return {
                    x: Math.round(style.x - style.r - lineWidth / 2),
                    y: Math.round(style.y - style.r - lineWidth / 2),
                    width: style.r * 2 + lineWidth,
                    height: style.r * 2 + lineWidth
                };
            }
        };

        var base = require('./base');
        base.derive(Star);

        var shape = require('../shape');
        shape.define('star', new Star());

        return Star;
    });
    /**
     * zrender
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * @author sushuang (宿爽, sushuang@baidu.com)
     *
     * shape类：正n边形（n>=3）
     * 可配图形属性：
       {
           // 基础属性
           shape  : 'isogon',       // 必须，shape类标识，需要显式指定
           id     : {string},       // 必须，图形唯一标识，可通过zrender实例方法newShapeId生成
           zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
           invisible : {boolean},   // 默认为false，是否可见

           // 样式属性，默认状态样式样式属性
           style  : {
               x             : {number},  // 必须，正n边形外接圆心横坐标
               y             : {number},  // 必须，正n边形外接圆心纵坐标
               r             : {number},  // 必须，正n边形外接圆半径
               n             : {number},  // 必须，指明正几边形
               brushType     : {string},  // 默认为fill，绘画方式
                                          // fill(填充) | stroke(描边) | both(填充+描边)
               color         : {color},   // 默认为'#000'，填充颜色，支持rgba
               strokeColor   : {color},   // 默认为'#000'，描边颜色（轮廓），支持rgba
               lineWidth     : {number},  // 默认为1，线条宽度，描边下有效
               lineJoin      : {string},  // 默认为miter，线段连接样式。miter | round | bevel

               shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
               shadowColor   : {color},   // 默认为'#000'，阴影色彩，支持rgba
               shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
               shadowOffsetY : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左

               text          : {string},  // 默认为null，附加文本
               textFont      : {string},  // 默认为null，附加文本样式，eg:'bold 18px verdana'
               textPosition  : {string},  // 默认为outside，附加文本位置。
                                          // outside | inside
               textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                          // start | end | left | right | center
               textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                          // top | bottom | middle |
                                          // alphabetic | hanging | ideographic
               textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                          // 'inside' ? '#fff' : color
           },

           // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
           highlightStyle : {
               // 同style
           }

           // 交互属性，详见shape.Base

           // 事件属性，详见shape.Base
       }
             例子：
       {
           shape  : 'isogon',
           id     : '123456',
           zlevel : 1,
           style  : {
               x : 400,
               y : 100,
               r : 150,
               n : 7,
               color : '#eee'
           },
           myName : 'kener',   // 可自带任何有效自定义属性

           clickable : true,
           onClick : function(eventPacket) {
               alert(eventPacket.target.myName);
           }
       }
     */
    define('zrender/shape/isogon', ['require'], function(require) {

        var math = require('../tool/math');
        var sin = math.sin;
        var cos = math.cos;
        var PI = Math.PI;

        function Isogon() {
            this.type = 'isogon';
        }

        Isogon.prototype = {
            /**
             * 创建n角星（n>=3）路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style) {
                var n = style.n;
                if (!n || n < 2) {
                    return;
                }

                var x = style.x;
                var y = style.y;
                var r = style.r;

                var dStep = 2 * PI / n;
                var deg = -PI / 2;
                var xStart = x + r * cos(deg);
                var yStart = y + r * sin(deg);
                deg += dStep;

                // 记录边界点，用于判断insight
                var pointList = style.pointList = [];
                pointList.push([xStart, yStart]);
                for (var i = 0, end = n - 1; i < end; i++) {
                    pointList.push([x + r * cos(deg), y + r * sin(deg)]);
                    deg += dStep;
                }
                pointList.push([xStart, yStart]);

                // 绘制
                ctx.moveTo(pointList[0][0], pointList[0][1]);
                for (var i = 0; i < pointList.length; i++) {
                    ctx.lineTo(pointList[i][0], pointList[i][1]);
                }

                return;
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect: function(style) {
                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                } else {
                    lineWidth = 0;
                }
                return {
                    x: Math.round(style.x - style.r - lineWidth / 2),
                    y: Math.round(style.y - style.r - lineWidth / 2),
                    width: style.r * 2 + lineWidth,
                    height: style.r * 2 + lineWidth
                };
            }
        };

        var base = require('./base');
        base.derive(Isogon);

        var shape = require('../shape');
        shape.define('isogon', new Isogon());

        return Isogon;
    });

    define('zrender/config', [], function() {
        /**
         * config默认配置项
         * @exports zrender/config
         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
         */
        var config = {
            loadingEffect: 'spin', // 默认loading特效
            EVENT: { // 支持事件列表
                RESIZE: 'resize', // 窗口大小变化
                CLICK: 'click', // 鼠标按钮被（手指）按下，事件对象是：目标图形元素或空

                MOUSEWHEEL: 'mousewheel', // 鼠标滚轮变化，事件对象是：目标图形元素或空
                MOUSEMOVE: 'mousemove', // 鼠标（手指）被移动，事件对象是：目标图形元素或空
                MOUSEOVER: 'mouseover', // 鼠标移到某图形元素之上，事件对象是：目标图形元素
                MOUSEOUT: 'mouseout', // 鼠标从某图形元素移开，事件对象是：目标图形元素
                MOUSEDOWN: 'mousedown', // 鼠标按钮（手指）被按下，事件对象是：目标图形元素或空
                MOUSEUP: 'mouseup', // 鼠标按键（手指）被松开，事件对象是：目标图形元素或空

                // 一次成功元素拖拽的行为事件过程是：
                // dragstart > dragenter > dragover [> dragleave] > drop > dragend
                DRAGSTART: 'dragstart', // 开始拖拽时触发，事件对象是：被拖拽图形元素
                DRAGEND: 'dragend', // 拖拽完毕时触发（在drop之后触发），事件对象是：被拖拽图形元素
                DRAGENTER: 'dragenter', // 拖拽图形元素进入目标图形元素时触发，事件对象是：目标图形元素
                DRAGOVER: 'dragover', // 拖拽图形元素在目标图形元素上移动时触发，事件对象是：目标图形元素
                DRAGLEAVE: 'dragleave', // 拖拽图形元素离开目标图形元素时触发，事件对象是：目标图形元素
                DROP: 'drop', // 拖拽图形元素放在目标图形元素内时触发，事件对象是：目标图形元素

                touchClickDelay: 300 // touch end - start < delay is click
            }
        }
        return config;
    });

    /**
     * zrender: 公共辅助函数
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * clone：深度克隆
     * merge：合并源对象的属性到目标对象
     * getContext：获取一个自由使用的canvas 2D context，使用原生方法，如isPointInPath，measureText等
     */
    define('zrender/tool/util', ['require'], function(require) {

        var vec2 = require('./vector');

        /**
         * 对一个object进行深度拷贝
         *
         * @param {Any} source 需要进行拷贝的对象
         * @return {Any} 拷贝后的新对象
         */
        function clone(source) {
            // buildInObject, 用于处理无法遍历Date等对象的问题
            var buildInObject = {
                '[object Function]': 1,
                '[object RegExp]': 1,
                '[object Date]': 1,
                '[object Error]': 1,
                '[object CanvasGradient]': 1
            };
            var result = source;
            var i;
            var len;
            if (!source || source instanceof Number || source instanceof String || source instanceof Boolean) {
                return result;
            } else if (source instanceof Array) {
                result = [];
                var resultLen = 0;
                for (i = 0, len = source.length; i < len; i++) {
                    result[resultLen++] = this.clone(source[i]);
                }
            } else if ('object' == typeof source) {
                if (buildInObject[Object.prototype.toString.call(source)] || source.__nonRecursion) {
                    return result;
                }
                result = {};
                for (i in source) {
                    if (source.hasOwnProperty(i)) {
                        result[i] = this.clone(source[i]);
                    }
                }
            }
            return result;
        }

        /**
         * 合并源对象的属性到目标对象
         * modify from Tangram
         * @param {*} target 目标对象
         * @param {*} source 源对象
         * @param {Object} optOptions 选项
         * @param {boolean} optOptions.overwrite 是否覆盖
         * @param {boolean} optOptions.recursive 是否递归
         * @param {boolean} optOptions.whiteList 白名单，如果定义，则仅处理白名单属性
         */
        var merge = (function() {
            // buildInObject, 用于处理无法遍历Date等对象的问题
            var buildInObject = {
                '[object Function]': 1,
                '[object RegExp]': 1,
                '[object Date]': 1,
                '[object Error]': 1,
                '[object CanvasGradient]': 1
            };

            function mergeItem(target, source, index, overwrite, recursive) {
                if (source.hasOwnProperty(index)) {
                    if (recursive && typeof target[index] == 'object' && buildInObject[
                            Object.prototype.toString.call(target[index])
                        ] != 1) {
                        // 如果需要递归覆盖，就递归调用merge
                        merge(
                            target[index],
                            source[index], {
                                'overwrite': overwrite,
                                'recursive': recursive
                            }
                        );
                    } else if (overwrite || !(index in target)) {
                        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
                        target[index] = source[index];
                    }
                }
            }

            return function(target, source, optOptions) {
                var i = 0,
                    options = optOptions || {},
                    overwrite = options['overwrite'],
                    whiteList = options['whiteList'],
                    recursive = options['recursive'],
                    len;

                // 只处理在白名单中的属性
                if (whiteList && whiteList.length) {
                    len = whiteList.length;
                    for (; i < len; ++i) {
                        mergeItem(
                            target, source, whiteList[i], overwrite, recursive
                        );
                    }
                } else {
                    for (i in source) {
                        mergeItem(target, source, i, overwrite, recursive);
                    }
                }
                return target;
            };
        })();

        var _ctx;

        function getContext() {
            if (!_ctx) {
                require('../lib/excanvas');
                if (G_vmlCanvasManager) {
                    var _div = document.createElement('div');
                    _div.style.position = 'absolute';
                    _div.style.top = '-1000px';
                    document.body.appendChild(_div);

                    _ctx = G_vmlCanvasManager.initElement(_div)
                        .getContext('2d');
                } else {
                    _ctx = document.createElement('canvas').getContext('2d');
                }
            }
            return _ctx;
        }

        var _canvas;
        var _pixelCtx;
        var _width;
        var _height;
        var _offsetX = 0;
        var _offsetY = 0;

        /**
         * 获取像素拾取专用的上下文
         * @return {Object} 上下文
         */
        function getPixelContext() {
            if (!_pixelCtx) {
                _canvas = document.createElement('canvas');
                _width = _canvas.width;
                _height = _canvas.height;
                _pixelCtx = _canvas.getContext('2d');
            }
            return _pixelCtx;
        }

        /**
         * 如果坐标处在_canvas外部，改变_canvas的大小
         * @param {number} x : 横坐标
         * @param {number} y : 纵坐标
         * 注意 修改canvas的大小 需要重新设置translate
         */
        function adjustCanvasSize(x, y) {
            // 每次加的长度
            var _v = 100;
            var _flag = false;

            if (x + _offsetX > _width) {
                _width = x + _offsetX + _v;
                _canvas.width = _width;
                _flag = true;
            }

            if (y + _offsetY > _height) {
                _height = y + _offsetY + _v;
                _canvas.height = _height;
                _flag = true;
            }

            if (x < -_offsetX) {
                _offsetX = Math.ceil(-x / _v) * _v;
                _width += _offsetX;
                _canvas.width = _width;
                _flag = true;
            }

            if (y < -_offsetY) {
                _offsetY = Math.ceil(-y / _v) * _v;
                _height += _offsetY;
                _canvas.height = _height;
                _flag = true;
            }

            if (_flag) {
                _pixelCtx.translate(_offsetX, _offsetY);
            }
        }

        /**
         * 获取像素canvas的偏移量
         * @return {Object} 偏移量
         */
        function getPixelOffset() {
            return {
                x: _offsetX,
                y: _offsetY
            };
        }

        /**
         * 查询数组中元素的index
         */
        function indexOf(array, value) {
            if (array.indexOf) {
                return array.indexOf(value);
            }
            for (var i = 0, len = array.length; i < len; i++) {
                if (array[i] === value) {
                    return i;
                }
            }
            return -1;
        }

        /**
         * 计算包围盒
         */
        function computeBoundingBox(points, min, max) {
            if (points.length === 0) {
                return;
            }
            var left = points[0][0];
            var right = points[0][0];
            var top = points[0][1];
            var bottom = points[0][1];

            for (var i = 1; i < points.length; i++) {
                var p = points[i];
                if (p[0] < left) {
                    left = p[0];
                }
                if (p[0] > right) {
                    right = p[0];
                }
                if (p[1] < top) {
                    top = p[1];
                }
                if (p[1] > bottom) {
                    bottom = p[1];
                }
            }

            min[0] = left;
            min[1] = top;
            max[0] = right;
            max[1] = bottom;
        }

        /**
         * 计算三阶贝塞尔曲线的包围盒
         * http://pissang.net/blog/?p=91
         */
        function computeCubeBezierBoundingBox(p0, p1, p2, p3, min, max) {
            var xDim = _computeCubeBezierExtremitiesDim(
                p0[0], p1[0], p2[0], p3[0]
            );
            var yDim = _computeCubeBezierExtremitiesDim(
                p0[1], p1[1], p2[1], p3[1]
            );

            xDim.push(p0[0], p3[0]);
            yDim.push(p0[1], p3[1]);

            var left = Math.min.apply(null, xDim);
            var right = Math.max.apply(null, xDim);
            var top = Math.min.apply(null, yDim);
            var bottom = Math.max.apply(null, yDim);

            min[0] = left;
            min[1] = top;
            max[0] = right;
            max[1] = bottom;
        }

        function _computeCubeBezierExtremitiesDim(p0, p1, p2, p3) {
            var extremities = [];

            var b = 6 * p2 - 12 * p1 + 6 * p0;
            var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
            var c = 3 * p1 - 3 * p0;

            var tmp = b * b - 4 * a * c;
            if (tmp > 0) {
                var tmpSqrt = Math.sqrt(tmp);
                var t1 = (-b + tmpSqrt) / (2 * a);
                var t2 = (-b - tmpSqrt) / (2 * a);
                extremities.push(t1, t2);
            } else if (tmp === 0) {
                extremities.push(-b / (2 * a));
            }
            var result = [];
            for (var i = 0; i < extremities.length; i++) {
                var t = extremities[i];
                if (Math.abs(2 * a * t + b) > 0.0001 && t < 1 && t > 0) {
                    var ct = 1 - t;
                    var val = ct * ct * ct * p0 + 3 * ct * ct * t * p1 + 3 * ct * t * t * p2 + t * t * t * p3;

                    result.push(val);
                }
            }

            return result;
        }

        /**
         * 计算二阶贝塞尔曲线的包围盒
         * http://pissang.net/blog/?p=91
         */
        function computeQuadraticBezierBoundingBox(p0, p1, p2, min, max) {
            // Find extremities, where derivative in x dim or y dim is zero
            var tmp = (p0[0] + p2[0] - 2 * p1[0]);
            // p1 is center of p0 and p2 in x dim
            var t1;
            if (tmp === 0) {
                t1 = 0.5;
            } else {
                t1 = (p0[0] - p1[0]) / tmp;
            }

            tmp = (p0[1] + p2[1] - 2 * p1[1]);
            // p1 is center of p0 and p2 in y dim
            var t2;
            if (tmp === 0) {
                t2 = 0.5;
            } else {
                t2 = (p0[1] - p1[1]) / tmp;
            }

            t1 = Math.max(Math.min(t1, 1), 0);
            t2 = Math.max(Math.min(t2, 1), 0);

            var ct1 = 1 - t1;
            var ct2 = 1 - t2;

            var x1 = ct1 * ct1 * p0[0] + 2 * ct1 * t1 * p1[0] + t1 * t1 * p2[0];
            var y1 = ct1 * ct1 * p0[1] + 2 * ct1 * t1 * p1[1] + t1 * t1 * p2[1];

            var x2 = ct2 * ct2 * p0[0] + 2 * ct2 * t2 * p1[0] + t2 * t2 * p2[0];
            var y2 = ct2 * ct2 * p0[1] + 2 * ct2 * t2 * p1[1] + t2 * t2 * p2[1];

            return computeBoundingBox(
                [p0.slice(), p2.slice(), [x1, y1],
                    [x2, y2]
                ],
                min, max
            );
        }


        /**
         * 计算圆弧的包围盒
         * http://pissang.net/blog/?p=91
         */
        var computeArcBoundingBox = (function() {
            var start = [];
            var end = [];
            // At most 4 extremities
            var extremities = [
                [],
                [],
                [],
                []
            ];
            return function(
                center, radius, startAngle, endAngle, clockwise, min, max
            ) {
                clockwise = clockwise ? 1 : -1;
                start[0] = Math.cos(startAngle);
                start[1] = Math.sin(startAngle) * clockwise;
                vec2.scale(start, start, radius);
                vec2.add(start, start, center);

                end[0] = Math.cos(endAngle);
                end[1] = Math.sin(endAngle) * clockwise;
                vec2.scale(end, end, radius);
                vec2.add(end, end, center);

                startAngle = startAngle % (Math.PI * 2);
                if (startAngle < 0) {
                    startAngle = startAngle + Math.PI * 2;
                }
                endAngle = endAngle % (Math.PI * 2);
                if (endAngle < 0) {
                    endAngle = endAngle + Math.PI * 2;
                }

                if (startAngle > endAngle) {
                    endAngle += Math.PI * 2;
                }
                var number = 0;
                for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
                    if (angle > startAngle) {
                        var extremity = extremities[number++];
                        extremity[0] = Math.cos(angle);
                        extremity[1] = Math.sin(angle) * clockwise;
                        vec2.scale(extremity, extremity, radius);
                        vec2.add(extremity, extremity, center);
                    }
                }
                var points = extremities.slice(0, number);
                points.push(start, end);
                computeBoundingBox(points, min, max);
            };
        })();

        return {
            clone: clone,
            merge: merge,
            getContext: getContext,

            getPixelContext: getPixelContext,
            getPixelOffset: getPixelOffset,
            adjustCanvasSize: adjustCanvasSize,

            computeBoundingBox: computeBoundingBox,
            computeCubeBezierBoundingBox: computeCubeBezierBoundingBox,
            computeQuadraticBezierBoundingBox: computeQuadraticBezierBoundingBox,
            computeArcBoundingBox: computeArcBoundingBox,

            indexOf: indexOf
        };
    });


    /**
     * zrender: core核心类
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * @desc zrender是一个轻量级的Canvas类库，MVC封装，数据驱动，提供类Dom事件模型。
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     */
    define('zrender/zrender', ['require'],
        function(require) {
            /*
             * HTML5 Canvas for Internet Explorer!
             * Modern browsers like Firefox, Safari, Chrome and Opera support
             * the HTML5 canvas tag to allow 2D command-based drawing.
             * ExplorerCanvas brings the same functionality to Internet Explorer.
             * To use, web developers only need to include a single script tag
             * in their existing web pages.
             *
             * https://code.google.com/p/explorercanvas/
             * http://explorercanvas.googlecode.com/svn/trunk/excanvas.js
             */
            require('./lib/excanvas');

            var self = {};
            var zrender = self; // 提供MVC内部反向使用静态方法；

            var _idx = 0; //ZRender instance's id
            var _instances = {}; //ZRender实例map索引

            /**
             * zrender初始化
             * 不让外部直接new ZRender实例，为啥？
             * 不为啥，提供全局可控同时减少全局污染和降低命名冲突的风险！
             *
             * @param {HTMLElement} dom dom对象，不帮你做document.getElementById了
             * @param {Object=} params 个性化参数，如自定义shape集合，带进来就好
             *
             * @return {ZRender} ZRender实例
             */
            self.init = function(dom, params) {
                var zi = new ZRender(++_idx + '', dom, params || {});
                _instances[_idx] = zi;
                return zi;
            };

            /**
             * zrender实例销毁，记在_instances里的索引也会删除了
             * 管生就得管死，可以通过zrender.dispose(zi)销毁指定ZRender实例
             * 当然也可以直接zi.dispose()自己销毁
             *
             * @param {ZRender=} zi ZRender对象，不传则销毁全部
             */
            self.dispose = function(zi) {
                if (zi) {
                    zi.dispose();
                } else {
                    for (var z in _instances) {
                        _instances[z].dispose();
                    }
                    _instances = {};
                }
                return self;
            };

            /**
             * 获取zrender实例
             *
             * @param {string} id ZRender对象索引
             */
            self.getInstance = function(id) {
                return _instances[id];
            };

            /**
             * 删除zrender实例，ZRender实例dispose时会调用，
             * 删除后getInstance则返回undefined
             * ps: 仅是删除，删除的实例不代表已经dispose了~~
             *     这是一个摆脱全局zrender.dispose()自动销毁的后门，
             *     take care of yourself~
             *
             * @param {string} id ZRender对象索引
             */
            self.delInstance = function(id) {
                if (_instances[id]) {
                    //只是对垃圾回收上的友好照顾，不写也大不了~
                    _instances[id] = null;
                    delete _instances[id];
                }
                return self;
            };

            // 是否异常捕获
            self.catchBrushException = false;

            /**
             * debug日志选项：catchBrushException为true下有效
             * 0 : 不生成debug数据，发布用
             * 1 : 异常抛出，调试用
             * 2 : 控制台输出，调试用
             */
            self.debugMode = 0;
            self.log = function() {
                if (self.debugMode === 0) {
                    return;
                } else if (self.debugMode == 1) {
                    for (var k in arguments) {
                        throw new Error(arguments[k]);
                    }
                } else if (self.debugMode > 1) {
                    for (var k in arguments) {
                        console.log(arguments[k]);
                    }
                }

                return self;
            };

            /**
             * ZRender接口类，对外可用的所有接口都在这里！！
             * storage（M）、painter（V）、handler（C）为内部私有类，外部接口不可见
             * 非get接口统一返回self支持链式调用~
             *
             * @param {string} id 唯一标识
             * @param {HTMLElement} dom dom对象，不帮你做document.getElementById
             * @param {Object=} params 个性化参数，如自定义shape集合，带进来就好
             *
             * @return {ZRender} ZRender实例
             */
            function ZRender(id, dom, params) {
                var self = this;
                var shape = require('./shape');
                // 内置图形注册
                require('./shape/circle');
                require('./shape/ellipse');
                require('./shape/line');
                require('./shape/polygon');
                require('./shape/brokenLine');
                require('./shape/rectangle');
                require('./shape/ring');
                require('./shape/sector');
                require('./shape/text');
                require('./shape/heart');
                require('./shape/droplet');
                require('./shape/path');
                require('./shape/image');
                require('./shape/beziercurve');
                require('./shape/star');
                require('./shape/isogon');

                var shapeLibrary;

                if (typeof params.shape == 'undefined') {
                    //默认图形库
                    shapeLibrary = shape;
                } else {
                    //自定义图形库，私有化，实例独占
                    shapeLibrary = {};
                    for (var s in params.shape) {
                        shapeLibrary[s] = params.shape[s];
                    }
                    shapeLibrary.get = function(name) {
                        return shapeLibrary[name] || shape.get(name);
                    };
                }

                var storage = new Storage(shapeLibrary);
                var painter = new Painter(dom, storage, shapeLibrary);
                var handler = new Handler(dom, storage, painter, shapeLibrary);

                // 动画控制
                var Animation = require('./animation/animation');
                var animatingShapes = [];
                var animation = new Animation({
                    stage: {
                        update: function() {
                            self.update(animatingShapes);
                        }
                    }
                });
                animation.start();

                /**
                 * 获取实例唯一标识
                 */
                self.getId = function() {
                    return id;
                };

                /**
                 * 添加图形形状
                 * @param {Object} shape 形状对象，可用属性全集，详见各shape
                 */
                self.addShape = function(shape) {
                    storage.add(shape);
                    return self;
                };

                /**
                 * 删除图形形状
                 * @param {string} shapeId 形状对象唯一标识
                 */
                self.delShape = function(shapeId) {
                    storage.del(shapeId);
                    return self;
                };

                /**
                 * 修改图形形状
                 * @param {string} shapeId 形状对象唯一标识
                 * @param {Object} shape 形状对象
                 */
                self.modShape = function(shapeId, shape) {
                    storage.mod(shapeId, shape);
                    return self;
                };

                /**
                 * 添加额外高亮层显示，仅提供添加方法，每次刷新后高亮层图形均被清空
                 * @param {Object} shape 形状对象
                 */
                self.addHoverShape = function(shape) {
                    storage.addHover(shape);
                    return self;
                };

                /**
                 * 渲染
                 * @param {Function} callback  渲染结束后回调函数
                 * todo:增加缓动函数
                 */
                self.render = function(callback) {
                    painter.render(callback);
                    return self;
                };

                /**
                 * 视图更新
                 * @param {Function} callback  视图更新后回调函数
                 */
                self.refresh = function(callback) {
                    painter.refresh(callback);
                    return self;
                };

                /**
                 * 视图更新
                 * @param {Array} shapeList 需要更新的图形元素列表
                 * @param {Function} callback  视图更新后回调函数
                 */
                self.update = function(shapeList, callback) {
                    painter.update(shapeList, callback);
                    return self;
                };

                self.resize = function() {
                    painter.resize();
                    return self;
                };

                /**
                 * 动画
                 * @param {string} shapeId 形状对象唯一标识
                 * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性
                 * @param {boolean} loop 动画是否循环
                 * @return {Object} 动画的Deferred对象
                 * Example:
                 * zr.animate( circleId, 'style', false)
                 *   .when(1000, { x: 10} )
                 *   .done( function(){ console.log('Animation done')})
                 *   .start()
                 */
                self.animate = function(shapeId, path, loop) {
                    var util = require('./tool/util');
                    var shape = storage.get(shapeId);
                    if (shape) {
                        var target;
                        if (path) {
                            var pathSplitted = path.split('.');
                            var prop = shape;
                            for (var i = 0, l = pathSplitted.length; i < l; i++) {
                                if (!prop) {
                                    continue;
                                }
                                prop = prop[pathSplitted[i]];
                            }
                            if (prop) {
                                target = prop;
                            }
                        } else {
                            target = shape;
                        }
                        if (!target) {
                            zrender.log(
                                'Property "' + path + '" is not existed in shape ' + shapeId
                            );
                            return;
                        }

                        if (typeof(shape.__aniCount) === 'undefined') {
                            // 正在进行的动画记数
                            shape.__aniCount = 0;
                        }
                        if (shape.__aniCount === 0) {
                            animatingShapes.push(shape);
                        }
                        shape.__aniCount++;

                        return animation.animate(target, loop)
                            .done(function() {
                                shape.__aniCount--;
                                if (shape.__aniCount === 0) {
                                    // 从animatingShapes里移除
                                    var idx = util.indexOf(animatingShapes, shape);
                                    animatingShapes.splice(idx, 1);
                                }
                            });
                    } else {
                        zrender.log('Shape "' + shapeId + '" not existed');
                    }
                };

                /**
                 * loading显示
                 * @param  {Object} loadingOption 参数
                 * {
                 *     effect,
                 *     //loading话术
                 *     text:'',
                 *     // 水平安放位置，默认为 'center'，可指定x坐标
                 *     x:'center' || 'left' || 'right' || {number},
                 *     // 垂直安放位置，默认为'top'，可指定y坐标
                 *     y:'top' || 'bottom' || {number},
                 *
                 *     textStyle:{
                 *         textFont: 'normal 20px Arial' || {textFont}, //文本字体
                 *         color: {color}
                 *     }
                 * }
                 */
                self.showLoading = function(loadingOption) {
                    painter.showLoading(loadingOption);
                    return self;
                };

                /**
                 * loading结束
                 */
                self.hideLoading = function() {
                    painter.hideLoading();
                    return self;
                };

                /**
                 * 生成形状唯一ID
                 * @param {string} [idPrefix] id前缀
                 * @return {string} 不重复ID
                 */
                self.newShapeId = function(idPrefix) {
                    return storage.newShapeId(idPrefix);
                };

                /**
                 * 获取视图宽度
                 */
                self.getWidth = function() {
                    return painter.getWidth();
                };

                /**
                 * 获取视图高度
                 */
                self.getHeight = function() {
                    return painter.getHeight();
                };

                self.toDataURL = function(type, args) {
                    return painter.toDataURL(type, args);
                };
                /**
                 * 事件绑定
                 * @param {string} eventName 事件名称
                 * @param {Function} eventHandler 响应函数
                 */
                self.on = function(eventName, eventHandler) {
                    handler.on(eventName, eventHandler);
                    return self;
                };

                /**
                 * 事件解绑定，参数为空则解绑所有自定义事件
                 * @param {string} eventName 事件名称
                 * @param {Function} eventHandler 响应函数
                 */
                self.un = function(eventName, eventHandler) {
                    handler.un(eventName, eventHandler);
                    return self;
                };

                /**
                 * 清除当前ZRender下所有类图的数据和显示，clear后MVC和已绑定事件均还存在在，ZRender可用
                 */
                self.clear = function() {
                    storage.del();
                    painter.clear();
                    return self;
                };

                /**
                 * 释放当前ZR实例（删除包括dom，数据、显示和事件绑定），dispose后ZR不可用
                 */
                self.dispose = function() {
                    animation.stop();
                    animation = null;
                    animatingShapes = null;

                    self.clear();
                    self = null;

                    storage.dispose();
                    storage = null;

                    painter.dispose();
                    painter = null;

                    handler.dispose();
                    handler = null;

                    //释放后告诉全局删除对自己的索引，没想到啥好方法
                    zrender.delInstance(id);

                    return;
                };
            }

            /**
             * 内容仓库 (M)
             * @param {Object} shape 图形库
             */
            function Storage(shape) {
                var util = require('./tool/util');
                var self = this;

                var _idBase = 0; //图形数据id自增基础

                //所有常规形状，id索引的map
                var _elements = {};

                //所有形状的z轴方向排列，提高遍历性能，zElements[0]的形状在zElements[1]形状下方
                var _zElements = [];

                //高亮层形状，不稳定，动态增删，数组位置也是z轴方向，靠前显示在下方
                var _hoverElements = [];

                var _maxZlevel = 0; //最大zlevel
                var _changedZlevel = {}; //有数据改变的zlevel

                /**
                 * 快速判断标志~
                 * e.__silent 是否需要hover判断
                 * e.__needTransform 是否需要进行transform
                 * e.style.__rect 区域矩阵缓存，修改后清空，重新计算一次
                 */
                function _mark(e) {
                    if (e.hoverable || e.onclick || e.draggable || e.onmousemove || e.onmouseover || e.onmouseout || e.onmousedown || e.onmouseup || e.ondragenter || e.ondragover || e.ondragleave || e.ondrop) {
                        e.__silent = false;
                    } else {
                        e.__silent = true;
                    }

                    if (Math.abs(e.rotation[0]) > 0.0001 || Math.abs(e.position[0]) > 0.0001 || Math.abs(e.position[1]) > 0.0001 || Math.abs(e.scale[0] - 1) > 0.0001 || Math.abs(e.scale[1] - 1) > 0.0001) {
                        e.__needTransform = true;
                    } else {
                        e.__needTransform = false;
                    }

                    e.style = e.style || {};
                    e.style.__rect = null;
                }
                /**
                 * 唯一标识id生成
                 * @param {string=} idHead 标识前缀
                 */
                function newShapeId(idHead) {
                    return (idHead || '') + (++_idBase);
                }

                /**
                 * 添加
                 * @param {Object} params 参数
                 */
                function add(params) {
                    //默认&必须的参数
                    var e = {
                        'shape': 'circle', // 形状
                        'id': params.id || self.newShapeId(), // 唯一标识
                        'zlevel': 0, // z轴位置
                        'draggable': false, // draggable可拖拽
                        'clickable': false, // clickable可点击响应
                        'hoverable': true, // hoverable可悬浮响应
                        'position': [0, 0],
                        'rotation': [0, 0, 0],
                        'scale': [1, 1, 0, 0]
                    };
                    util.merge(
                        e,
                        params, {
                            'overwrite': true,
                            'recursive': true
                        }
                    );
                    _mark(e);
                    _elements[e.id] = e;
                    _zElements[e.zlevel] = _zElements[e.zlevel] || [];
                    _zElements[e.zlevel].push(e);

                    _maxZlevel = Math.max(_maxZlevel, e.zlevel);
                    _changedZlevel[e.zlevel] = true;

                    return self;
                }

                /**
                 * 根据指定的shapeId获取相应的shape属性
                 * @param {string=} idx 唯一标识
                 */
                function get(shapeId) {
                    return _elements[shapeId];
                }
                /**
                 * 删除，shapeId不指定则全清空
                 * @param {string=} idx 唯一标识
                 */
                function del(shapeId) {
                    if (typeof shapeId != 'undefined') {
                        if (_elements[shapeId]) {
                            _changedZlevel[_elements[shapeId].zlevel] = true;
                            var oldList = _zElements[_elements[shapeId].zlevel];
                            var newList = [];
                            for (var i = 0, l = oldList.length; i < l; i++) {
                                if (oldList[i].id != shapeId) {
                                    newList.push(oldList[i]);
                                }
                            }
                            _zElements[_elements[shapeId].zlevel] = newList;
                            delete _elements[shapeId];
                        }
                    } else {
                        //不指定shapeId清空
                        _elements = {};
                        _zElements = [];
                        _hoverElements = [];
                        _maxZlevel = 0; //最大zlevel
                        _changedZlevel = { //有数据改变的zlevel
                            all: true
                        };
                    }

                    return self;
                }

                /**
                 * 修改
                 * @param {string} idx 唯一标识
                 * @param {Object} params]参数
                 */
                function mod(shapeId, params) {
                    var e = _elements[shapeId];
                    if (e) {
                        _changedZlevel[e.zlevel] = true;
                        util.merge(
                            e,
                            params, {
                                'overwrite': true,
                                'recursive': true
                            }
                        );
                        _mark(e);
                        _changedZlevel[e.zlevel] = true;
                        _maxZlevel = Math.max(_maxZlevel, e.zlevel);
                    }

                    return self;
                }

                /**
                 * 常规形状位置漂移，形状自身定义漂移函数
                 * @param {string} idx 形状唯一标识
                 *
                 */
                function drift(shapeId, dx, dy) {
                    var e = _elements[shapeId];
                    e.__needTransform = true;
                    if (!e.ondrift //ondrift
                        //有onbrush并且调用执行返回false或undefined则继续
                        || (e.ondrift && !e.ondrift(e, dx, dy))
                    ) {
                        if (zrender.catchBrushException) {
                            try {
                                shape.get(e.shape).drift(e, dx, dy);
                            } catch (error) {
                                zrender.log(error, 'drift error of ' + e.shape, e);
                            }
                        } else {
                            shape.get(e.shape).drift(e, dx, dy);
                        }
                    }

                    _changedZlevel[e.zlevel] = true;

                    return self;
                }

                /**
                 * 添加高亮层数据
                 * @param {Object} params 参数
                 */
                function addHover(params) {
                    if ((params.rotation && Math.abs(params.rotation[0]) > 0.0001) || (params.position && (Math.abs(params.position[0]) > 0.0001 || Math.abs(params.position[1]) > 0.0001)) || (params.scale && (Math.abs(params.scale[0] - 1) > 0.0001 || Math.abs(params.scale[1] - 1) > 0.0001))) {
                        params.__needTransform = true;
                    } else {
                        params.__needTransform = false;
                    }

                    _hoverElements.push(params);
                    return self;
                }

                /**
                 * 删除高亮层数据
                 */
                function delHover() {
                    _hoverElements = [];
                    return self;
                }

                function hasHoverShape() {
                    return _hoverElements.length > 0;
                }

                /**
                 * 遍历迭代器
                 * @param {Function} fun 迭代回调函数，return true终止迭代
                 * @param {Object=} option 迭代参数，缺省为仅降序遍历常规形状
                 *     hover : true 是否迭代高亮层数据
                 *     normal : 'down' | 'up' | 'free' 是否迭代常规数据，迭代时是否指定及z轴顺序
                 */
                function iterShape(fun, option) {
                    if (!option) {
                        option = {
                            hover: false,
                            normal: 'down'
                        };
                    }
                    if (option.hover) {
                        //高亮层数据遍历
                        for (var i = 0, l = _hoverElements.length; i < l; i++) {
                            if (fun(_hoverElements[i])) {
                                return self;
                            }
                        }
                    }

                    var zlist;
                    var len;
                    if (typeof option.normal != 'undefined') {
                        //z轴遍历: 'down' | 'up' | 'free'
                        switch (option.normal) {
                            case 'down':
                                //降序遍历，高层优先
                                for (var l = _zElements.length - 1; l >= 0; l--) {
                                    zlist = _zElements[l];
                                    if (zlist) {
                                        len = zlist.length;
                                        while (len--) {
                                            if (fun(zlist[len])) {
                                                return self;
                                            }
                                        }
                                    }
                                }
                                break;
                            case 'up':
                                //升序遍历，底层优先
                                for (var i = 0, l = _zElements.length; i < l; i++) {
                                    zlist = _zElements[i];
                                    if (zlist) {
                                        len = zlist.length;
                                        for (var k = 0; k < len; k++) {
                                            if (fun(zlist[k])) {
                                                return self;
                                            }
                                        }
                                    }
                                }
                                break;
                                // case 'free':
                            default:
                                //无序遍历
                                for (var i in _elements) {
                                    if (fun(_elements[i])) {
                                        return self;
                                    }
                                }
                                break;
                        }
                    }

                    return self;
                }

                function getMaxZlevel() {
                    return _maxZlevel;
                }

                function getChangedZlevel() {
                    return _changedZlevel;
                }

                function clearChangedZlevel() {
                    _changedZlevel = {};
                    return self;
                }

                function setChangedZlevle(level) {
                    _changedZlevel[level] = true;
                    return self;
                }

                /**
                 * 释放
                 */
                function dispose() {
                    _elements = null;
                    _zElements = null;
                    _hoverElements = null;
                    self = null;

                    return;
                }

                self.newShapeId = newShapeId;
                self.add = add;
                self.get = get;
                self.del = del;
                self.addHover = addHover;
                self.delHover = delHover;
                self.hasHoverShape = hasHoverShape;
                self.mod = mod;
                self.drift = drift;
                self.iterShape = iterShape;
                self.getMaxZlevel = getMaxZlevel;
                self.getChangedZlevel = getChangedZlevel;
                self.clearChangedZlevel = clearChangedZlevel;
                self.setChangedZlevle = setChangedZlevle;
                self.dispose = dispose;
            }

            /**
             * 绘图类 (V)
             * @param {HTMLElement} root 绘图区域
             * @param {storage} storage Storage实例
             * @param {Object} shape 图形库
             */
            function Painter(root, storage, shape) {
                var config = require('./config');
                var self = this;

                var _domList = {}; //canvas dom元素
                var _ctxList = {}; //canvas 2D context对象，与domList对应

                var _maxZlevel = 0; //最大zlevel，缓存记录
                var _loadingTimer;

                var _domRoot = document.createElement('div');
                // 避免页面选中的尴尬
                _domRoot.onselectstart = function() {
                    return false;
                };

                //宽，缓存记录
                var _width;
                //高，缓存记录
                var _height;

                //retina 屏幕优化
                var _devicePixelRatio = window.devicePixelRatio || 1;

                function _getWidth() {
                    var stl = root.currentStyle || document.defaultView.getComputedStyle(root);

                    return root.clientWidth - stl.paddingLeft.replace(/\D/g, '') // 请原谅我这比较粗暴
                        - stl.paddingRight.replace(/\D/g, '');
                }

                function _getHeight() {
                    var stl = root.currentStyle || document.defaultView.getComputedStyle(root);

                    return root.clientHeight - stl.paddingTop.replace(/\D/g, '') // 请原谅我这比较粗暴
                        - stl.paddingBottom.replace(/\D/g, '');
                }

                function _init() {
                    _domRoot.innerHTML = '';
                    root.innerHTML = '';

                    _width = _getWidth();
                    _height = _getHeight();

                    //没append呢，原谅我这样写，清晰~
                    _domRoot.style.position = 'relative';
                    _domRoot.style.overflow = 'hidden';
                    _domRoot.style.width = _width + 'px';
                    _domRoot.style.height = _height + 'px';

                    root.appendChild(_domRoot);

                    _domList = {};
                    _ctxList = {};

                    _maxZlevel = storage.getMaxZlevel();

                    //创建各层canvas
                    //背景
                    _domList['bg'] = _createDom('bg', 'div');
                    _domRoot.appendChild(_domList['bg']);

                    //实体
                    for (var i = 0; i <= _maxZlevel; i++) {
                        _domList[i] = _createDom(i, 'canvas');
                        _domRoot.appendChild(_domList[i]);
                        if (G_vmlCanvasManager) {
                            G_vmlCanvasManager.initElement(_domList[i]);
                        }
                        _ctxList[i] = _domList[i].getContext('2d');
                        _devicePixelRatio != 1 && _ctxList[i].scale(_devicePixelRatio, _devicePixelRatio);
                    }

                    //高亮
                    _domList['hover'] = _createDom('hover', 'canvas');
                    _domList['hover'].id = '_zrender_hover_';
                    _domRoot.appendChild(_domList['hover']);
                    if (G_vmlCanvasManager) {
                        G_vmlCanvasManager.initElement(_domList['hover']);
                    }
                    _ctxList['hover'] = _domList['hover'].getContext('2d');
                    _devicePixelRatio != 1 && _ctxList['hover'].scale(
                        _devicePixelRatio, _devicePixelRatio
                    );
                }

                /**
                 * 检查_maxZlevel是否变大，如是则同步创建需要的Canvas
                 */
                function _syncMaxZlevelCanvase() {
                    var curMaxZlevel = storage.getMaxZlevel();
                    if (_maxZlevel < curMaxZlevel) {
                        //实体
                        for (var i = _maxZlevel + 1; i <= curMaxZlevel; i++) {
                            _domList[i] = _createDom(i, 'canvas');
                            _domRoot.insertBefore(_domList[i], _domList['hover']);
                            if (G_vmlCanvasManager) {
                                G_vmlCanvasManager.initElement(_domList[i]);
                            }
                            _ctxList[i] = _domList[i].getContext('2d');
                            _devicePixelRatio != 1 && _ctxList[i].scale(
                                _devicePixelRatio, _devicePixelRatio
                            );
                        }
                        _maxZlevel = curMaxZlevel;
                    }
                }

                /**
                 * 创建dom
                 * @param {string} id dom id 待用
                 * @param {string} type : dom type， such as canvas, div etc.
                 */
                function _createDom(id, type) {
                    var newDom = document.createElement(type);

                    //没append呢，请原谅我这样写，清晰~
                    newDom.style.position = 'absolute';
                    newDom.style.width = _width + 'px';
                    newDom.style.height = _height + 'px';
                    newDom.setAttribute('width', _width * _devicePixelRatio);
                    newDom.setAttribute('height', _height * _devicePixelRatio);
                    //id不作为索引用，避免可能造成的重名，定义为私有属性
                    newDom.setAttribute('data-id', id);
                    return newDom;
                }

                /**
                 * 刷画图形
                 * @param {Object} changedZlevel 需要更新的zlevel索引
                 */
                function _brush(changedZlevel) {
                    return function(e) {
                        if ((changedZlevel.all || changedZlevel[e.zlevel]) && !e.invisible) {
                            var ctx = _ctxList[e.zlevel];
                            if (ctx) {
                                if (!e.onbrush //没有onbrush
                                    //有onbrush并且调用执行返回false或undefined则继续粉刷
                                    || (e.onbrush && !e.onbrush(ctx, e, false))
                                ) {
                                    if (zrender.catchBrushException) {
                                        try {
                                            shape.get(e.shape).brush(
                                                ctx, e, false, update
                                            );
                                        } catch (error) {
                                            zrender.log(
                                                error,
                                                'brush error of ' + e.shape,
                                                e
                                            );
                                        }
                                    } else {
                                        shape.get(e.shape).brush(
                                            ctx, e, false, update
                                        );
                                    }
                                }
                            } else {
                                zrender.log(
                                    'can not find the specific zlevel canvas!'
                                );
                            }
                        }
                    };
                }

                /**
                 * 鼠标悬浮刷画
                 */
                function _brushHover(e) {
                    var ctx = _ctxList['hover'];
                    if (!e.onbrush //没有onbrush
                        //有onbrush并且调用执行返回false或undefined则继续粉刷
                        || (e.onbrush && !e.onbrush(ctx, e, true))
                    ) {
                        // Retina 优化
                        if (zrender.catchBrushException) {
                            try {
                                shape.get(e.shape).brush(ctx, e, true, update);
                            } catch (error) {
                                zrender.log(
                                    error, 'hoverBrush error of ' + e.shape, e
                                );
                            }
                        } else {
                            shape.get(e.shape).brush(ctx, e, true, update);
                        }
                    }
                }

                /**
                 * 首次绘图，创建各种dom和context
                 * @param {Function=} callback 绘画结束后的回调函数
                 */
                function render(callback) {
                    if (isLoading()) {
                        hideLoading();
                    }
                    //检查_maxZlevel是否变大，如是则同步创建需要的Canvas
                    _syncMaxZlevelCanvase();

                    //升序遍历，shape上的zlevel指定绘画图层的z轴层叠
                    storage.iterShape(
                        _brush({ all: true }), { normal: 'up' }
                    );

                    //update到最新则清空标志位
                    storage.clearChangedZlevel();

                    if (typeof callback == 'function') {
                        callback();
                    }

                    return self;
                }

                /**
                 * 刷新
                 * @param {Function=} callback 刷新结束后的回调函数
                 */
                function refresh(callback) {
                    //检查_maxZlevel是否变大，如是则同步创建需要的Canvas
                    _syncMaxZlevelCanvase();

                    //仅更新有修改的canvas
                    var changedZlevel = storage.getChangedZlevel();
                    //擦除有修改的canvas
                    if (changedZlevel.all) {
                        clear();
                    } else {
                        for (var k in changedZlevel) {
                            if (_ctxList[k]) {
                                _ctxList[k].clearRect(
                                    0, 0,
                                    _width * _devicePixelRatio,
                                    _height * _devicePixelRatio
                                );
                            }
                        }
                    }
                    //重绘内容，升序遍历，shape上的zlevel指定绘画图层的z轴层叠
                    storage.iterShape(
                        _brush(changedZlevel), { normal: 'up' }
                    );

                    //update到最新则清空标志位
                    storage.clearChangedZlevel();

                    if (typeof callback == 'function') {
                        callback();
                    }

                    return self;
                }


                /**
                 * 视图更新
                 * @param {Array} shapeList 需要更新的图形元素列表
                 * @param {Function} callback  视图更新后回调函数
                 */
                function update(shapeList, callback) {
                    var shape;
                    for (var i = 0, l = shapeList.length; i < l; i++) {
                        shape = shapeList[i];
                        storage.mod(shape.id, shape);
                    }
                    refresh(callback);
                    return self;
                }

                /**
                 * 清除hover层外所有内容
                 */
                function clear() {
                    for (var k in _ctxList) {
                        if (k == 'hover') {
                            continue;
                        }
                        _ctxList[k].clearRect(
                            0, 0,
                            _width * _devicePixelRatio,
                            _height * _devicePixelRatio
                        );
                    }
                    return self;
                }

                /**
                 * 刷新hover层
                 */
                function refreshHover() {
                    clearHover();

                    storage.iterShape(_brushHover, { hover: true });

                    storage.delHover();

                    return self;
                }

                /**
                 * 清除hover层所有内容
                 */
                function clearHover() {
                    _ctxList
                        && _ctxList['hover'] && _ctxList['hover'].clearRect(
                            0, 0,
                            _width * _devicePixelRatio,
                            _height * _devicePixelRatio
                        );

                    return self;
                }

                /**
                 * 显示loading
                 * @param {Object} loadingOption 选项，内容见下
                 * @param {color} -.backgroundColor 背景颜色
                 * @param {Object} -.textStyle 文字样式，同shape/text.style
                 * @param {number=} -.progress 进度参数，部分特效有用
                 * @param {Object=} -.effectOption 特效参数，部分特效有用
                 * @param {string | function} -.effect 特效依赖tool/loadingEffect，
                 *                                     可传入自定义特效function
                 */
                function showLoading(loadingOption) {
                    var effect = require('./tool/loadingEffect');
                    effect.stop(_loadingTimer);

                    loadingOption = loadingOption || {};
                    loadingOption.effect = loadingOption.effect || config.loadingEffect;
                    loadingOption.canvasSize = {
                        width: _width,
                        height: _height
                    };

                    _loadingTimer = effect.start(
                        loadingOption,
                        storage.addHover,
                        refreshHover
                    );
                    self.loading = true;

                    return self;
                }

                /**
                 * loading结束
                 * 乱来的，待重写
                 */
                function hideLoading() {
                    var effect = require('./tool/loadingEffect');
                    effect.stop(_loadingTimer);
                    clearHover();
                    self.loading = false;
                    return self;
                }

                /**
                 * loading结束判断
                 */
                function isLoading() {
                    return self.loading;
                }

                /**
                 * 获取绘图区域宽度
                 */
                function getWidth() {
                    return _width;
                }

                /**
                 * 获取绘图区域高度
                 */
                function getHeight() {
                    return _height;
                }

                /**
                 * 区域大小变化后重绘
                 */
                function resize() {
                    var width;
                    var height;
                    var dom;

                    _domRoot.style.display = 'none';

                    width = _getWidth();
                    height = _getHeight();

                    _domRoot.style.display = '';

                    //优化没有实际改变的resize
                    if (_width != width || height != _height) {
                        _width = width;
                        _height = height;

                        _domRoot.style.width = _width + 'px';
                        _domRoot.style.height = _height + 'px';

                        for (var i in _domList) {
                            dom = _domList[i];
                            dom.setAttribute('width', _width);
                            dom.setAttribute('height', _height);
                            dom.style.width = _width + 'px';
                            dom.style.height = _height + 'px';
                        }

                        storage.setChangedZlevle('all');
                        refresh();
                    }

                    return self;
                }

                /**
                 * 释放
                 */
                function dispose() {
                    if (isLoading()) {
                        hideLoading();
                    }
                    root.innerHTML = '';

                    root = null;
                    storage = null;
                    shape = null;

                    _domRoot = null;
                    _domList = null;
                    _ctxList = null;

                    self = null;

                    return;
                }

                function getDomHover() {
                    return _domList['hover'];
                }

                function toDataURL(type, args) {
                    if (G_vmlCanvasManager) {
                        return null;
                    }
                    var imageDom = _createDom('image', 'canvas');
                    _domList['bg'].appendChild(imageDom);
                    var ctx = imageDom.getContext('2d');
                    _devicePixelRatio != 1 && ctx.scale(_devicePixelRatio, _devicePixelRatio);

                    ctx.fillStyle = '#fff';
                    ctx.rect(
                        0, 0,
                        _width * _devicePixelRatio,
                        _height * _devicePixelRatio
                    );
                    ctx.fill();
                    //升序遍历，shape上的zlevel指定绘画图层的z轴层叠
                    storage.iterShape(
                        function(e) {
                            if (!e.invisible) {
                                if (!e.onbrush //没有onbrush
                                    //有onbrush并且调用执行返回false或undefined则继续粉刷
                                    || (e.onbrush && !e.onbrush(ctx, e, false))
                                ) {
                                    if (zrender.catchBrushException) {
                                        try {
                                            shape.get(e.shape).brush(
                                                ctx, e, false, update
                                            );
                                        } catch (error) {
                                            zrender.log(
                                                error,
                                                'brush error of ' + e.shape,
                                                e
                                            );
                                        }
                                    } else {
                                        shape.get(e.shape).brush(
                                            ctx, e, false, update
                                        );
                                    }
                                }
                            }
                        }, { normal: 'up' }
                    );
                    var image = imageDom.toDataURL(type, args);
                    ctx = null;
                    _domList['bg'].removeChild(imageDom);
                    return image;
                }

                self.render = render;
                self.refresh = refresh;
                self.update = update;
                self.clear = clear;
                self.refreshHover = refreshHover;
                self.clearHover = clearHover;
                self.showLoading = showLoading;
                self.hideLoading = hideLoading;
                self.isLoading = isLoading;
                self.getWidth = getWidth;
                self.getHeight = getHeight;
                self.resize = resize;
                self.dispose = dispose;
                self.getDomHover = getDomHover;
                self.toDataURL = toDataURL;
                _init();
            }

            /**
             * 控制类 (C)
             * @param {HTMLElement} root 绘图区域
             * @param {storage} storage Storage实例
             * @param {painter} painter Painter实例
             * @param {Object} shape 图形库
             *
             * 分发事件支持详见config.EVENT
             */
            function Handler(root, storage, painter, shape) {
                var config = require('./config');
                //添加事件分发器特性
                var eventTool = require('./tool/event');
                eventTool.Dispatcher.call(this);

                var self = this;

                //常用函数加速
                var getX = eventTool.getX;
                var getY = eventTool.getY;

                //各种事件标识的私有变量
                var _event; //原生dom事件
                var _hasfound = false; //是否找到hover图形元素
                var _lastHover = null; //最后一个hover图形元素
                var _mouseDownTarget = null;
                var _draggingTarget = null; //当前被拖拽的图形元素
                var _isMouseDown = false;
                var _isDragging = false;
                var _lastTouchMoment;

                var _lastX = 0;
                var _lastY = 0;
                var _mouseX = 0;
                var _mouseY = 0;


                var _domHover = painter.getDomHover();

                /**
                 * 初始化，事件绑定，支持的所有事件都由如下原生事件计算得来
                 */
                function _init() {
                    if (window.addEventListener) {
                        window.addEventListener('resize', _resizeHandler);

                        root.addEventListener('click', _clickHandler);
                        root.addEventListener('mousewheel', _mouseWheelHandler);
                        root.addEventListener('DOMMouseScroll', _mouseWheelHandler);
                        root.addEventListener('mousemove', _mouseMoveHandler);
                        root.addEventListener('mouseout', _mouseOutHandler);
                        root.addEventListener('mousedown', _mouseDownHandler);
                        root.addEventListener('mouseup', _mouseUpHandler);

                        // mobile支持
                        root.addEventListener('touchstart', _touchStartHandler);
                        root.addEventListener('touchmove', _touchMoveHandler);
                        root.addEventListener('touchend', _touchEndHandler);
                    } else {
                        window.attachEvent('onresize', _resizeHandler);

                        root.attachEvent('onclick', _clickHandler);
                        root.attachEvent('onmousewheel', _mouseWheelHandler);
                        root.attachEvent('onmousemove', _mouseMoveHandler);
                        root.attachEvent('onmouseout', _mouseOutHandler);
                        root.attachEvent('onmousedown', _mouseDownHandler);
                        root.attachEvent('onmouseup', _mouseUpHandler);
                    }
                }

                /**
                 * 窗口大小改变响应函数
                 * @param {event} event dom事件对象
                 */
                function _resizeHandler(event) {
                    _event = event || window.event;
                    _lastHover = null;
                    _isMouseDown = false;
                    //分发config.EVENT.RESIZE事件，global
                    self.dispatch(config.EVENT.RESIZE, _event);
                }

                /**
                 * 点击事件
                 * @param {event} event dom事件对象
                 */
                function _clickHandler(event) {
                    _event = _zrenderEventFixed(event);
                    //分发config.EVENT.CLICK事件
                    if (!_lastHover) {
                        _dispatchAgency(_lastHover, config.EVENT.CLICK);
                    } else if (_lastHover && _lastHover.clickable) {
                        _dispatchAgency(_lastHover, config.EVENT.CLICK);
                    }
                    _mouseMoveHandler(_event);
                }

                /**
                 * 鼠标滚轮响应函数
                 * @param {event} event dom事件对象
                 */
                function _mouseWheelHandler(event) {
                    _event = _zrenderEventFixed(event);
                    //分发config.EVENT.MOUSEWHEEL事件
                    _dispatchAgency(_lastHover, config.EVENT.MOUSEWHEEL);
                    _mouseMoveHandler(_event);
                }

                /**
                 * 鼠标（手指）移动响应函数
                 * @param {event} event dom事件对象
                 */
                function _mouseMoveHandler(event) {
                    if (painter.isLoading()) {
                        return;
                    }
                    _event = _zrenderEventFixed(event);
                    _lastX = _mouseX;
                    _lastY = _mouseY;
                    _mouseX = getX(_event);
                    _mouseY = getY(_event);

                    // 可能出现config.EVENT.DRAGSTART事件
                    // 避免手抖点击误认为拖拽
                    //if (_mouseX - _lastX > 1 || _mouseY - _lastY > 1) {
                    _dragStartHandler();
                    //}

                    _hasfound = false;
                    storage.iterShape(_findHover, { normal: 'down' });

                    //找到的在迭代函数里做了处理，没找到得在迭代完后处理
                    if (!_hasfound) {
                        //过滤首次拖拽产生的mouseout和dragLeave
                        if (!_draggingTarget || (_lastHover && _lastHover.id != _draggingTarget.id)) {
                            //可能出现config.EVENT.MOUSEOUT事件
                            _outShapeHandler();

                            //可能出现config.EVENT.DRAGLEAVE事件
                            _dragLeaveHandler();
                        }

                        _lastHover = null;
                        storage.delHover();
                        painter.clearHover();
                    }
                    //如果存在拖拽中元素，被拖拽的图形元素最后addHover
                    if (_draggingTarget) {
                        storage.drift(
                            _draggingTarget.id,
                            _mouseX - _lastX,
                            _mouseY - _lastY
                        );
                        storage.addHover(_draggingTarget);
                    }

                    //分发config.EVENT.MOUSEMOVE事件
                    _dispatchAgency(_lastHover, config.EVENT.MOUSEMOVE);

                    if (_draggingTarget || _hasfound || storage.hasHoverShape()) {
                        painter.refreshHover();
                    }

                    if (_draggingTarget || (_hasfound && _lastHover.draggable)) {
                        root.style.cursor = 'move';
                    } else if (_hasfound && _lastHover.clickable) {
                        root.style.cursor = 'pointer';
                    } else {
                        root.style.cursor = 'default';
                    }
                }

                /**
                 * 鼠标（手指）离开响应函数
                 * @param {event} event dom事件对象
                 */
                function _mouseOutHandler(event) {
                    _event = _zrenderEventFixed(event);

                    var element = _event.toElement || _event.relatedTarget;
                    if (element != root) {
                        while (element && element.nodeType != 9) {
                            if (element == root) {
                                // 忽略包含在root中的dom引起的mouseOut
                                _mouseMoveHandler(event);
                                return;
                            }
                            element = element.parentNode;
                        }
                    }
                    _event.zrenderX = _lastX;
                    _event.zrenderY = _lastY;
                    root.style.cursor = 'default';
                    _isMouseDown = false;

                    _outShapeHandler();
                    _dropHandler();
                    _dragEndHandler();
                    if (!painter.isLoading()) {
                        painter.refreshHover();
                    }
                }

                /**
                 * 鼠标在某个图形元素上移动
                 */
                function _overShapeHandler() {
                    //分发config.EVENT.MOUSEOVER事件
                    _dispatchAgency(_lastHover, config.EVENT.MOUSEOVER);
                }

                /**
                 * 鼠标离开某个图形元素
                 */
                function _outShapeHandler() {
                    //分发config.EVENT.MOUSEOUT事件
                    _dispatchAgency(_lastHover, config.EVENT.MOUSEOUT);
                }

                /**
                 * 鼠标（手指）按下响应函数
                 * @param {event} event dom事件对象
                 */
                function _mouseDownHandler(event) {
                    _event = _zrenderEventFixed(event);
                    _isMouseDown = true;
                    //分发config.EVENT.MOUSEDOWN事件
                    _mouseDownTarget = _lastHover;
                    _dispatchAgency(_lastHover, config.EVENT.MOUSEDOWN);
                }

                /**
                 * 鼠标（手指）抬起响应函数
                 * @param {event} event dom事件对象
                 */
                function _mouseUpHandler(event) {
                    _event = _zrenderEventFixed(event);
                    root.style.cursor = 'default';
                    _isMouseDown = false;
                    _mouseDownTarget = null;

                    //分发config.EVENT.MOUSEUP事件
                    _dispatchAgency(_lastHover, config.EVENT.MOUSEUP);
                    _dropHandler();
                    _dragEndHandler();
                }

                /**
                 * Touch开始响应函数
                 * @param {event} event dom事件对象
                 */
                function _touchStartHandler(event) {
                    eventTool.stop(event); // 阻止浏览器默认事件，重要
                    _event = _zrenderEventFixed(event, true);
                    _lastTouchMoment = new Date();
                    _mouseDownHandler(_event);
                }

                /**
                 * Touch移动响应函数
                 * @param {event} event dom事件对象
                 */
                function _touchMoveHandler(event) {
                    eventTool.stop(event); // 阻止浏览器默认事件，重要
                    _event = _zrenderEventFixed(event, true);
                    _mouseMoveHandler(_event);
                }

                /**
                 * Touch结束响应函数
                 * @param {event} event dom事件对象
                 */
                function _touchEndHandler(event) {
                    eventTool.stop(event); // 阻止浏览器默认事件，重要
                    _event = _zrenderEventFixed(event, true);
                    _mouseUpHandler(_event);
                    painter.clearHover();

                    if (new Date() - _lastTouchMoment < config.EVENT.touchClickDelay) {
                        _lastHover = null;
                        _mouseX = _event.zrenderX;
                        _mouseY = _event.zrenderY;
                        // touch有指尖错觉，四向尝试，让touch上的点击更好触发事件
                        storage.iterShape(_findHover, { normal: 'down' });
                        if (!_lastHover) {
                            _mouseX += 10;
                            storage.iterShape(_findHover, { normal: 'down' });
                        }
                        if (!_lastHover) {
                            _mouseX -= 20;
                            storage.iterShape(_findHover, { normal: 'down' });
                        }
                        if (!_lastHover) {
                            _mouseX += 10;
                            _mouseY += 10;
                            storage.iterShape(_findHover, { normal: 'down' });
                        }
                        if (!_lastHover) {
                            _mouseY -= 20;
                            storage.iterShape(_findHover, { normal: 'down' });
                        }
                        if (_lastHover) {
                            _event.zrenderX = _mouseX;
                            _event.zrenderY = _mouseY;
                        }
                        _clickHandler(_event);
                    }
                }

                /**
                 * 拖拽开始
                 */
                function _dragStartHandler() {
                    if (_isMouseDown && _lastHover && _lastHover.draggable && !_draggingTarget && _mouseDownTarget == _lastHover) {
                        _draggingTarget = _lastHover;
                        _isDragging = true;

                        _draggingTarget.invisible = true;
                        storage.mod(_draggingTarget.id, _draggingTarget);

                        //分发config.EVENT.DRAGSTART事件
                        _dispatchAgency(
                            _draggingTarget,
                            config.EVENT.DRAGSTART
                        );
                        painter.refresh();
                    }
                }

                /**
                 * 拖拽进入目标元素
                 */
                function _dragEnterHandler() {
                    if (_draggingTarget) {
                        //分发config.EVENT.DRAGENTER事件
                        _dispatchAgency(
                            _lastHover,
                            config.EVENT.DRAGENTER,
                            _draggingTarget
                        );
                    }
                }

                /**
                 * 拖拽在目标元素上移动
                 */
                function _dragOverHandler() {
                    if (_draggingTarget) {
                        //分发config.EVENT.DRAGOVER事件
                        _dispatchAgency(
                            _lastHover,
                            config.EVENT.DRAGOVER,
                            _draggingTarget
                        );
                    }
                }

                /**
                 * 拖拽离开目标元素
                 */
                function _dragLeaveHandler() {
                    if (_draggingTarget) {
                        //分发config.EVENT.DRAGLEAVE事件
                        _dispatchAgency(
                            _lastHover,
                            config.EVENT.DRAGLEAVE,
                            _draggingTarget
                        );
                    }
                }

                /**
                 * 拖拽在目标元素上完成
                 */
                function _dropHandler() {
                    if (_draggingTarget) {
                        _draggingTarget.invisible = false;
                        storage.mod(_draggingTarget.id, _draggingTarget);
                        painter.refresh();
                        //分发config.EVENT.DROP事件
                        _dispatchAgency(
                            _lastHover,
                            config.EVENT.DROP,
                            _draggingTarget
                        );
                    }
                }

                /**
                 * 拖拽结束
                 */
                function _dragEndHandler() {
                    if (_draggingTarget) {
                        //分发config.EVENT.DRAGEND事件
                        _dispatchAgency(
                            _draggingTarget,
                            config.EVENT.DRAGEND
                        );
                        _lastHover = null;
                    }
                    _isDragging = false;
                    _draggingTarget = null;
                }

                /**
                 * 事件分发代理
                 * @param {Object} targetShape 目标图形元素
                 * @param {string} eventName 事件名称
                 * @param {Object=} draggedShape 拖拽事件特有，当前被拖拽图形元素
                 */
                function _dispatchAgency(targetShape, eventName, draggedShape) {
                    var eventHandler = 'on' + eventName;
                    var eventPacket = {
                        type: eventName,
                        event: _event,
                        target: targetShape
                    };

                    if (draggedShape) {
                        eventPacket.dragged = draggedShape;
                    }

                    if (targetShape) {
                        //“不存在shape级事件”或“存在shape级事件但事件回调返回非true”
                        if (!targetShape[eventHandler] || !targetShape[eventHandler](eventPacket)) {
                            self.dispatch(
                                eventName,
                                _event,
                                eventPacket
                            );
                        }
                    } else if (!draggedShape) {
                        //无hover目标，无拖拽对象，原生事件分发
                        self.dispatch(eventName, _event);
                    }
                }

                /**
                 * 迭代函数，查找hover到的图形元素并即时做些事件分发
                 * @param {Object} e 图形元素
                 */
                function _findHover(e) {
                    if (_draggingTarget && _draggingTarget.id == e.id) {
                        //迭代到当前拖拽的图形上
                        return false;
                    }

                    //打酱油的路过，啥都不响应的shape~
                    if (e.__silent) {
                        return false;
                    }

                    var shapeInstance = shape.get(e.shape);
                    if (shapeInstance.isCover(e, _mouseX, _mouseY)) {
                        if (e.hoverable) {
                            storage.addHover(e);
                        }

                        if (_lastHover != e) {
                            _outShapeHandler();

                            //可能出现config.EVENT.DRAGLEAVE事件
                            _dragLeaveHandler();

                            _lastHover = e;

                            //可能出现config.EVENT.DRAGENTER事件
                            _dragEnterHandler();
                        }
                        _overShapeHandler();

                        //可能出现config.EVENT.DRAGOVER
                        _dragOverHandler();

                        _hasfound = true;

                        return true; //找到则中断迭代查找
                    }

                    return false;
                }

                // 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标
                function _zrenderEventFixed(event, isTouch) {
                    if (!isTouch) {
                        _event = event || window.event;
                        // 进入对象优先~
                        var target = _event.toElement || _event.relatedTarget || _event.srcElement || _event.target;
                        if (target && target != _domHover) {
                            _event.zrenderX = (typeof _event.offsetX != 'undefined' ? _event.offsetX : _event.layerX) + target.offsetLeft;
                            _event.zrenderY = (typeof _event.offsetY != 'undefined' ? _event.offsetY : _event.layerY) + target.offsetTop;
                        }
                    } else {
                        _event = event;
                        var touch = _event.type != 'touchend' ? _event.targetTouches[0] : _event.changedTouches[0];
                        if (touch) {
                            // touch事件坐标是全屏的~
                            _event.zrenderX = touch.clientX - root.offsetLeft + document.body.scrollLeft;
                            _event.zrenderY = touch.clientY - root.offsetTop + document.body.scrollTop;
                        }
                    }

                    return _event;
                }

                /**
                 * 自定义事件绑定
                 * @param {string} eventName 事件名称，resize，hover，drag，etc~
                 * @param {Function} handler 响应函数
                 */
                function on(eventName, handler) {
                    self.bind(eventName, handler);

                    return self;
                }

                /**
                 * 自定义事件解绑
                 * @param {string} event 事件名称，resize，hover，drag，etc~
                 * @param {Function} handler 响应函数
                 */
                function un(eventName, handler) {
                    self.unbind(eventName, handler);
                    return self;
                }

                /**
                 * 比较不可控，先不开放了~
                 * 触发原生dom事件，用于自定义元素在顶层截获事件后触发zrender行为
                 * @param {string} event 事件名称，resize，hover，drag，etc~
                 * @param {event=} event event dom事件对象
                function trigger(eventName, event) {
                    switch (eventName) {
                        case config.EVENT.RESIZE :
                            _resizeHandler(event);
                            break;
                        case config.EVENT.CLICK :
                            _clickHandler(event);
                            break;
                        case config.EVENT.MOUSEWHEEL :
                            _mouseWheelHandler(event);
                            break;
                        case config.EVENT.MOUSEMOVE :
                            _mouseMoveHandler(event);
                            break;
                        case config.EVENT.MOUSEDOWN :
                            _mouseDownHandler(event);
                            break;
                        case config.EVENT.MOUSEUP :
                            _mouseUpHandleru(event);
                            break;
                    }
                }
                 */

                /**
                 * 释放
                 */
                function dispose() {
                    if (window.removeEventListener) {
                        window.removeEventListener('resize', _resizeHandler);

                        root.removeEventListener('click', _clickHandler);
                        root.removeEventListener('mousewheel', _mouseWheelHandler);
                        root.removeEventListener(
                            'DOMMouseScroll', _mouseWheelHandler
                        );
                        root.removeEventListener('mousemove', _mouseMoveHandler);
                        root.removeEventListener('mouseout', _mouseOutHandler);
                        root.removeEventListener('mousedown', _mouseDownHandler);
                        root.removeEventListener('mouseup', _mouseUpHandler);

                        // mobile支持
                        root.removeEventListener('touchstart', _touchStartHandler);
                        root.removeEventListener('touchmove', _touchMoveHandler);
                        root.removeEventListener('touchend', _touchEndHandler);
                    } else {
                        window.detachEvent('onresize', _resizeHandler);

                        root.detachEvent('onclick', _clickHandler);
                        root.detachEvent('onmousewheel', _mouseWheelHandler);
                        root.detachEvent('onmousemove', _mouseMoveHandler);
                        root.detachEvent('onmouseout', _mouseOutHandler);
                        root.detachEvent('onmousedown', _mouseDownHandler);
                        root.detachEvent('onmouseup', _mouseUpHandler);
                    }

                    root = null;
                    _domHover = null;
                    storage = null;
                    painter = null;
                    shape = null;

                    un();

                    self = null;

                    return;
                }

                self.on = on;
                self.un = un;
                // self.trigger = trigger;
                self.dispose = dispose;

                _init();
            }

            return self;
        }
    );

    /**
     * zrender: 事件辅助类
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * getX：获取事件横坐标
     * getY：或者事件纵坐标
     * getDelta：或者鼠标滚轮变化
     * stop：停止事件传播
     * Dispatcher：事件分发器
     */
    define('zrender/tool/event', ['require'], function() {
        /**
         * 提取鼠标（手指）x坐标
         * @param  {event} e 事件.
         * @return {number} 鼠标（手指）x坐标.
         */
        function getX(e) {
            return typeof e.zrenderX != 'undefined' && e.zrenderX || typeof e.offsetX != 'undefined' && e.offsetX || typeof e.layerX != 'undefined' && e.layerX || typeof e.clientX != 'undefined' && e.clientX;
        }

        /**
         * 提取鼠标y坐标
         * @param  {event} e 事件.
         * @return {number} 鼠标（手指）y坐标.
         */
        function getY(e) {
            return typeof e.zrenderY != 'undefined' && e.zrenderY || typeof e.offsetY != 'undefined' && e.offsetY || typeof e.layerY != 'undefined' && e.layerY || typeof e.clientY != 'undefined' && e.clientY;
        }

        /**
         * 提取鼠标滚轮变化
         * @param  {event} e 事件.
         * @return {number} 滚轮变化，正值说明滚轮是向上滚动，如果是负值说明滚轮是向下滚动
         */
        function getDelta(e) {
            return typeof e.wheelDelta != 'undefined' && e.wheelDelta || typeof e.detail != 'undefined' && -e.detail;
        }

        /**
         * 停止冒泡和阻止默认行为
         * @param {Object} e : event对象
         */
        function stop(e) {
            if (e.preventDefault) {
                e.preventDefault();
                e.stopPropagation();
            } else {
                e.returnValue = false;
            }
        }

        /**
         * 事件分发器
         */
        function Dispatcher() {
            var _self = this;
            var _h = {};

            /**
             * 单次触发绑定，dispatch后销毁
             * @param {string} event 事件字符串
             * @param {function} handler 响应函数
             */
            function one(event, handler) {
                if (!handler || !event) {
                    return _self;
                }

                if (!_h[event]) {
                    _h[event] = [];
                }

                _h[event].push({
                    h: handler,
                    one: true
                });

                return _self;
            }

            /**
             * 事件绑定
             * @param {string} event 事件字符串
             * @param {function} handler : 响应函数
             */
            function bind(event, handler) {
                if (!handler || !event) {
                    return _self;
                }

                if (!_h[event]) {
                    _h[event] = [];
                }

                _h[event].push({
                    h: handler,
                    one: false
                });

                return _self;
            }

            /**
             * 事件解绑定
             * @param {string} event 事件字符串
             * @param {function} handler : 响应函数
             */
            function unbind(event, handler) {
                if (!event) {
                    _h = {};
                    return _self;
                }

                if (handler) {
                    if (_h[event]) {
                        var newList = [];
                        for (var i = 0, l = _h[event].length; i < l; i++) {
                            if (_h[event][i]['h'] != handler) {
                                newList.push(_h[event][i]);
                            }
                        }
                        _h[event] = newList;
                    }

                    if (_h[event] && _h[event].length === 0) {
                        delete _h[event];
                    }
                } else {
                    delete _h[event];
                }

                return _self;
            }

            /**
             * 事件分发
             * @param {string} type : 事件类型
             * @param {Object} event : event对象
             * @param {Object} [attachment] : 附加信息
             */
            function dispatch(type, event, attachment) {
                if (_h[type]) {
                    var newList = [];
                    var eventPacket = attachment || {};
                    eventPacket.type = type;
                    eventPacket.event = event;
                    //eventPacket._target = self;
                    for (var i = 0, l = _h[type].length; i < l; i++) {
                        _h[type][i]['h'](eventPacket);
                        if (!_h[type][i]['one']) {
                            newList.push(_h[type][i]);
                        }
                    }

                    if (newList.length != _h[type].length) {
                        _h[type] = newList;
                    }
                }

                return _self;
            }

            _self.one = one;
            _self.bind = bind;
            _self.unbind = unbind;
            _self.dispatch = dispatch;
        }

        return {
            getX: getX,
            getY: getY,
            getDelta: getDelta,
            stop: stop,
            Dispatcher: Dispatcher
        };
    });

    /**
     * 动画主类, 调度和管理所有动画控制器
     *
     * @author lang(shenyi01@baidu.com)
     *
     * @class : Animation
     * @config : stage(optional) 绘制类, 需要提供update接口
     * @config : fps(optional) 帧率, 是自动更新动画的时候需要提供
     * @config : onframe(optional)
     * @method : add
     * @method : remove
     * @method : update
     * @method : start
     * @method : stop
     */
    define('zrender/animation/animation', ['require'], function(require) {
        var Controller = require('./controller');
        var util = require('../tool/util');

        var requrestAnimationFrame = window.requrestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function(callback) {
            window.setTimeout(
                callback, 1000 / 60
            );
        };

        var Animation = function(options) {

            options = options || {};

            this.stage = options.stage || {};

            this.onframe = options.onframe || function() {};

            // private properties
            this._controllerPool = [];

            this._running = false;
        };

        Animation.prototype = {
            add: function(controller) {
                this._controllerPool.push(controller);
            },
            remove: function(controller) {
                var idx = util.indexOf(this._controllerPool, controller);
                if (idx >= 0) {
                    this._controllerPool.splice(idx, 1);
                }
            },
            update: function() {
                var time = new Date().getTime();
                var cp = this._controllerPool;
                var len = cp.length;

                var deferredEvents = [];
                var deferredCtls = [];
                for (var i = 0; i < len; i++) {
                    var controller = cp[i];
                    var e = controller.step(time);
                    // 需要在stage.update之后调用的事件，例如destroy
                    if (e) {
                        deferredEvents.push(e);
                        deferredCtls.push(controller);
                    }
                }
                if (this.stage && this.stage.update && this._controllerPool.length) {
                    this.stage.update();
                }

                // 删除动画完成的控制器
                var newArray = [];
                for (var i = 0; i < len; i++) {
                    if (!cp[i]._needsRemove) {
                        newArray.push(cp[i]);
                        cp[i]._needsRemove = false;
                    }
                }
                this._controllerPool = newArray;

                len = deferredEvents.length;
                for (var i = 0; i < len; i++) {
                    deferredCtls[i].fire(deferredEvents[i]);
                }

                this.onframe();

            },
            // 启用start函数之后每个1000/fps事件就会刷新
            // 也可以不使用animation的start函数
            // 手动每一帧去调用update函数更新状态
            start: function() {
                var self = this;

                this._running = true;

                function step() {
                    if (self._running) {
                        self.update();
                        requrestAnimationFrame(step);
                    }
                }

                requrestAnimationFrame(step);
            },
            stop: function() {
                this._running = false;
            },
            clear: function() {
                this._controllerPool = [];
            },
            animate: function(target, loop, getter, setter) {
                var deferred = new Deferred(target, loop, getter, setter);
                deferred.animation = this;
                return deferred;
            }
        };
        Animation.prototype.constructor = Animation;

        function _defaultGetter(target, key) {
            return target[key];
        }

        function _defaultSetter(target, key, value) {
            target[key] = value;
        }
        // 递归做插值
        // TODO 对象的插值
        function _interpolate(
            prevValue,
            nextValue,
            percent,
            target,
            propName,
            getter,
            setter
        ) {
            // 遍历数组做插值
            if (prevValue instanceof Array && nextValue instanceof Array) {
                var minLen = Math.min(prevValue.length, nextValue.length);
                var largerArray;
                var maxLen;
                var result = [];
                if (minLen === prevValue.length) {
                    maxLen = nextValue.length;
                    largerArray = nextValue;
                } else {
                    maxLen = prevValue.length;
                    largerArray = prevValue.length;
                }
                for (var i = 0; i < minLen; i++) {
                    // target[propName] 作为新的target,
                    // i 作为新的propName递归进行插值
                    result.push(_interpolate(
                        prevValue[i],
                        nextValue[i],
                        percent,
                        getter(target, propName),
                        i,
                        getter,
                        setter
                    ));
                }
                // 赋值剩下不需要插值的数组项
                for (var i = minLen; i < maxLen; i++) {
                    result.push(largerArray[i]);
                }

                setter(target, propName, result);
            } else {
                prevValue = parseFloat(prevValue);
                nextValue = parseFloat(nextValue);
                if (!isNaN(prevValue) && !isNaN(nextValue)) {
                    var value = (nextValue - prevValue) * percent + prevValue;
                    setter(target, propName, value);
                    return value;
                }
            }
        }

        function Deferred(target, loop, getter, setter) {
            this._tracks = {};
            this._target = target;

            this._loop = loop || false;

            this._getter = getter || _defaultGetter;
            this._setter = setter || _defaultSetter;

            this._controllerCount = 0;

            this._doneList = [];

            this._onframeList = [];

            this._controllerList = [];
        }

        Deferred.prototype = {
            when: function(time /* ms */ , props, easing) {
                for (var propName in props) {
                    if (!this._tracks[propName]) {
                        this._tracks[propName] = [];
                        // 初始状态
                        this._tracks[propName].push({
                            time: 0,
                            value: this._getter(this._target, propName)
                        });
                    }
                    this._tracks[propName].push({
                        time: time,
                        value: props[propName],
                        easing: easing
                    });
                }
                return this;
            },
            during: function(callback) {
                this._onframeList.push(callback);
                return this;
            },
            start: function() {
                var self = this;
                var delay;
                var track;
                var trackMaxTime;

                function createOnframe(now, next, propName) {
                    // 复制出新的数组，不然动画的时候改变数组的值也会影响到插值
                    var prevValue = clone(now.value);
                    var nextValue = clone(next.value);
                    return function(target, schedule) {
                        _interpolate(
                            prevValue,
                            nextValue,
                            schedule,
                            target,
                            propName,
                            self._getter,
                            self._setter
                        );
                        for (var i = 0; i < self._onframeList.length; i++) {
                            self._onframeList[i](target, schedule);
                        }
                    };
                }

                function ondestroy() {
                    self._controllerCount--;
                    if (self._controllerCount === 0) {
                        var len = self._doneList.length;
                        // 所有动画完成
                        for (var i = 0; i < len; i++) {
                            self._doneList[i]();
                        }
                    }
                }

                for (var propName in this._tracks) {
                    delay = 0;
                    track = this._tracks[propName];
                    if (track.length) {
                        trackMaxTime = track[track.length - 1].time;
                    } else {
                        continue;
                    }
                    for (var i = 0; i < track.length - 1; i++) {
                        var now = track[i],
                            next = track[i + 1];

                        var controller = new Controller({
                            target: self._target,
                            life: next.time - now.time,
                            delay: delay,
                            loop: self._loop,
                            gap: trackMaxTime - (next.time - now.time),
                            easing: next.easing,
                            onframe: createOnframe(now, next, propName),
                            ondestroy: ondestroy
                        });
                        this._controllerList.push(controller);

                        this._controllerCount++;
                        delay = next.time;

                        self.animation.add(controller);
                    }
                }
                return this;
            },
            stop: function() {
                for (var i = 0; i < this._controllerList.length; i++) {
                    var controller = this._controllerList[i];
                    this.animation.remove(controller);
                }
            },
            done: function(func) {
                this._doneList.push(func);
                return this;
            }
        };

        function clone(value) {
            if (value && value instanceof Array) {
                return Array.prototype.slice.call(value);
            } else {
                return value;
            }
        }

        return Animation;
    });


    /**
     * 动画主控制器
     * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
     * @config life(1000) 动画时长
     * @config delay(0) 动画延迟时间
     * @config loop(true)
     * @config gap(0) 循环的间隔时间
     * @config onframe
     * @config easing(optional)
     * @config ondestroy(optional)
     * @config onrestart(optional)
     */
    define('zrender/animation/controller', ['require'], function(require) {

        var Easing = require('./easing');

        var Controller = function(options) {

            this._targetPool = options.target || {};
            if (this._targetPool.constructor != Array) {
                this._targetPool = [this._targetPool];
            }

            //生命周期
            this._life = options.life || 1000;
            //延时
            this._delay = options.delay || 0;
            //开始时间
            this._startTime = new Date().getTime() + this._delay; //单位毫秒

            //结束时间
            this._endTime = this._startTime + this._life * 1000;

            //是否循环
            this.loop = typeof(options.loop) == 'undefined' ? false : options.loop;

            this.gap = options.gap || 0;

            this.easing = options.easing || 'Linear';

            this.onframe = options.onframe || null;

            this.ondestroy = options.ondestroy || null;

            this.onrestart = options.onrestart || null;
        };

        Controller.prototype = {
            step: function(time) {
                var percent = (time - this._startTime) / this._life;

                //还没开始
                if (percent < 0) {
                    return;
                }

                percent = Math.min(percent, 1);

                var easingFunc = typeof(this.easing) == 'string' ? Easing[this.easing] : this.easing;
                var schedule;
                if (typeof easingFunc === 'function') {
                    schedule = easingFunc(percent);
                } else {
                    schedule = percent;
                }
                this.fire('frame', schedule);

                //结束
                if (percent == 1) {
                    if (this.loop) {
                        this.restart();
                        // 重新开始周期
                        // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
                        return 'restart';

                    } else {
                        // 动画完成将这个控制器标识为待删除
                        // 在Animation.update中进行批量删除
                        this._needsRemove = true;

                        return 'destroy';
                    }
                } else {
                    return null;
                }
            },
            restart: function() {
                this._startTime = new Date().getTime() + this.gap;
            },
            fire: function(eventType, arg) {
                for (var i = 0, len = this._targetPool.length; i < len; i++) {
                    if (this['on' + eventType]) {
                        this['on' + eventType](this._targetPool[i], arg);
                    }
                }
            }
        };
        Controller.prototype.constructor = Controller;

        return Controller;
    });

    /**
     * zrender
     *
     * @author liuxiaoli (刘晓黎, liuxiaoli@geostar.com.cn)
     *
     * shape类：六边形
     * 可配图形属性：
       {
           // 基础属性
           shape  : 'myPolygon',       // 必须，shape类标识，需要显式指定
           id     : {string},       // 必须，图形唯一标识，可通过zrender实例方法newShapeId生成
           zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
           invisible : {boolean},   // 默认为false，是否可见

           // 样式属性，默认状态样式样式属性
           style  : {
               x             : {number},  // 必须，正n边形外接圆心横坐标
               y             : {number},  // 必须，正n边形外接圆心纵坐标
               r             : {number},  // 必须，正n边形外接圆半径
               n             : {number},  // 必须，指明正几边形
               brushType     : {string},  // 默认为fill，绘画方式
                                          // fill(填充) | stroke(描边) | both(填充+描边)
               color         : {color},   // 默认为'#000'，填充颜色，支持rgba
               strokeColor   : {color},   // 默认为'#000'，描边颜色（轮廓），支持rgba
               lineWidth     : {number},  // 默认为1，线条宽度，描边下有效
               lineJoin      : {string},  // 默认为miter，线段连接样式。miter | round | bevel

               shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
               shadowColor   : {color},   // 默认为'#000'，阴影色彩，支持rgba
               shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
               shadowOffsetY : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左

               text          : {string},  // 默认为null，附加文本
               textFont      : {string},  // 默认为null，附加文本样式，eg:'bold 18px verdana'
               textPosition  : {string},  // 默认为outside，附加文本位置。
                                          // outside | inside
               textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                          // start | end | left | right | center
               textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                          // top | bottom | middle |
                                          // alphabetic | hanging | ideographic
               textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                          // 'inside' ? '#fff' : color
           },

           // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
           highlightStyle : {
               // 同style
           }

           // 交互属性，详见shape.Base

           // 事件属性，详见shape.Base
       }
             例子：
       {
           shape  : 'myPolygon',
           id     : '123456',
           zlevel : 1,
           style  : {
               x : 400,
               y : 100,
               r : 150,
               n : 7,
               color : '#eee'
           },
           myName : 'kener',   // 可自带任何有效自定义属性

           clickable : true,
           onClick : function(eventPacket) {
               alert(eventPacket.target.myName);
           }
       }
     */
    define('zrender/shape/myPolygon', ['require'],
        function(require) {

            var math = require('../tool/math');
            var sin = math.sin;
            var cos = math.cos;
            var PI = Math.PI;

            function MyPolygon() {
                this.type = 'myPolygon';
            }

            MyPolygon.prototype = {
                /**
                 * 创建六边形的路径
                 * @param {Context2D} ctx Canvas 2D上下文
                 * @param {Object} style 样式
                 */
                buildPath: function(ctx, style) {
                    var n = style.n;
                    if (!n || n < 2) {
                        return;
                    }

                    var x = style.x;
                    var y = style.y;
                    var r = style.r;

                    ctx.moveTo(x, y - r / 2);
                    ctx.lineTo(x + r / 2, y - r / 4);
                    ctx.lineTo(x + r / 2, y + r / 4);
                    ctx.lineTo(x, y + r / 2);
                    ctx.lineTo(x - r / 2, y + r / 4);
                    ctx.lineTo(x - r / 2, y - r / 4);
                    return;
                },

                /**
                 * 返回矩形区域，用于局部刷新和文字定位
                 * @param {Object} style
                 */
                getRect: function(style) {
                    var lineWidth;
                    if (style.brushType == 'stroke' || style.brushType == 'fill') {
                        lineWidth = style.lineWidth || 1;
                    } else {
                        lineWidth = 0;
                    }
                    return {
                        x: Math.round(style.x - style.r - lineWidth / 2),
                        y: Math.round(style.y - style.r - lineWidth / 2),
                        width: style.r * 2 + lineWidth,
                        height: style.r * 2 + lineWidth
                    };
                }
            };

            var base = require('./base');
            base.derive(MyPolygon);

            var shape = require('../shape');
            shape.define('myPolygon', new MyPolygon());

            return MyPolygon;
        }
    );
    /**
     * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
     * author: lang(shenyi01@baidu.com)
     */
    define('zrender/animation/easing', [],
        function() {
            var Easing = {
                // 线性
                Linear: function(k) {
                    return k;
                },

                // 二次方的缓动（t^2）
                QuadraticIn: function(k) {
                    return k * k;
                },
                QuadraticOut: function(k) {
                    return k * (2 - k);
                },
                QuadraticInOut: function(k) {
                    if ((k *= 2) < 1) {
                        return 0.5 * k * k;
                    }
                    return -0.5 * (--k * (k - 2) - 1);
                },

                // 三次方的缓动（t^3）
                CubicIn: function(k) {
                    return k * k * k;
                },
                CubicOut: function(k) {
                    return --k * k * k + 1;
                },
                CubicInOut: function(k) {
                    if ((k *= 2) < 1) {
                        return 0.5 * k * k * k;
                    }
                    return 0.5 * ((k -= 2) * k * k + 2);
                },

                // 四次方的缓动（t^4）
                QuarticIn: function(k) {
                    return k * k * k * k;
                },
                QuarticOut: function(k) {
                    return 1 - (--k * k * k * k);
                },
                QuarticInOut: function(k) {
                    if ((k *= 2) < 1) {
                        return 0.5 * k * k * k * k;
                    }
                    return -0.5 * ((k -= 2) * k * k * k - 2);
                },

                // 五次方的缓动（t^5）
                QuinticIn: function(k) {
                    return k * k * k * k * k;
                },

                QuinticOut: function(k) {
                    return --k * k * k * k * k + 1;
                },
                QuinticInOut: function(k) {
                    if ((k *= 2) < 1) {
                        return 0.5 * k * k * k * k * k;
                    }
                    return 0.5 * ((k -= 2) * k * k * k * k + 2);
                },

                // 正弦曲线的缓动（sin(t)）
                SinusoidalIn: function(k) {
                    return 1 - Math.cos(k * Math.PI / 2);
                },
                SinusoidalOut: function(k) {
                    return Math.sin(k * Math.PI / 2);
                },
                SinusoidalInOut: function(k) {
                    return 0.5 * (1 - Math.cos(Math.PI * k));
                },

                // 指数曲线的缓动（2^t）
                ExponentialIn: function(k) {
                    return k === 0 ? 0 : Math.pow(1024, k - 1);
                },
                ExponentialOut: function(k) {
                    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
                },
                ExponentialInOut: function(k) {
                    if (k === 0) {
                        return 0;
                    }
                    if (k === 1) {
                        return 1;
                    }
                    if ((k *= 2) < 1) {
                        return 0.5 * Math.pow(1024, k - 1);
                    }
                    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
                },

                // 圆形曲线的缓动（sqrt(1-t^2)）
                CircularIn: function(k) {
                    return 1 - Math.sqrt(1 - k * k);
                },
                CircularOut: function(k) {
                    return Math.sqrt(1 - (--k * k));
                },
                CircularInOut: function(k) {
                    if ((k *= 2) < 1) {
                        return -0.5 * (Math.sqrt(1 - k * k) - 1);
                    }
                    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
                },

                // 创建类似于弹簧在停止前来回振荡的动画
                ElasticIn: function(k) {
                    var s, a = 0.1,
                        p = 0.4;
                    if (k === 0) {
                        return 0;
                    }
                    if (k === 1) {
                        return 1;
                    }
                    if (!a || a < 1) {
                        a = 1;
                        s = p / 4;
                    } else {
                        s = p * Math.asin(1 / a) / (2 * Math.PI);
                    }
                    return -(a * Math.pow(2, 10 * (k -= 1)) *
                        Math.sin((k - s) * (2 * Math.PI) / p));
                },
                ElasticOut: function(k) {
                    var s, a = 0.1,
                        p = 0.4;
                    if (k === 0) {
                        return 0;
                    }
                    if (k === 1) {
                        return 1;
                    }
                    if (!a || a < 1) {
                        a = 1;
                        s = p / 4;
                    } else {
                        s = p * Math.asin(1 / a) / (2 * Math.PI);
                    }
                    return (a * Math.pow(2, -10 * k) *
                        Math.sin((k - s) * (2 * Math.PI) / p) + 1);
                },
                ElasticInOut: function(k) {
                    var s, a = 0.1,
                        p = 0.4;
                    if (k === 0) {
                        return 0;
                    }
                    if (k === 1) {
                        return 1;
                    }
                    if (!a || a < 1) {
                        a = 1;
                        s = p / 4;
                    } else {
                        s = p * Math.asin(1 / a) / (2 * Math.PI);
                    }
                    if ((k *= 2) < 1) {
                        return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
                    }
                    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;

                },

                // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
                BackIn: function(k) {
                    var s = 1.70158;
                    return k * k * ((s + 1) * k - s);
                },
                BackOut: function(k) {
                    var s = 1.70158;
                    return --k * k * ((s + 1) * k + s) + 1;
                },
                BackInOut: function(k) {
                    var s = 1.70158 * 1.525;
                    if ((k *= 2) < 1) {
                        return 0.5 * (k * k * ((s + 1) * k - s));
                    }
                    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
                },

                // 创建弹跳效果
                BounceIn: function(k) {
                    return 1 - Easing.BounceOut(1 - k);
                },
                BounceOut: function(k) {
                    if (k < (1 / 2.75)) {
                        return 7.5625 * k * k;
                    } else if (k < (2 / 2.75)) {
                        return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
                    } else if (k < (2.5 / 2.75)) {
                        return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
                    } else {
                        return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
                    }
                },
                BounceInOut: function(k) {
                    if (k < 0.5) {
                        return Easing.BounceIn(k * 2) * 0.5;
                    }
                    return Easing.BounceOut(k * 2 - 1) * 0.5 + 0.5;
                }
            };

            return Easing;
        }
    );


    /**
     * zrender
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * @author Neil (杨骥, yangji01@baidu.com)
     *
     * shape类：玫瑰线
     * 可配图形属性：
       {
           // 基础属性
           shape  : 'rose', // 必须，shape类标识，需要显式指定
           id     : {string},       // 必须，图形唯一标识，可通过zrender实例方法newShapeId生成
           zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
           invisible : {boolean},   // 默认为false，是否可见

           // 样式属性，默认状态样式样式属性
           style  : {
               x             : {number},  // 默认为0， 圆心的横坐标
               y             : {number},  // 默认为0， 圆心的纵坐标
               r             : {Array<number>},  // 必须，每个线条的最大长度
               k             : {number},  // 必须，决定花瓣数量，当n为1时，奇数即为花瓣数，偶数时花瓣数量翻倍
               n             : {number=},  // 默认为1，必须为整数，与k共同决定花瓣的数量
               strokeColor   : {color},   // 默认为'#000'，线条颜色（轮廓），支持rgba
               lineWidth     : {number},  // 默认为1，线条宽度
               lineCap       : {string},  // 默认为butt，线帽样式。butt | round | square

               opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
               shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
               shadowColor   : {color},   // 默认为'#000'，阴影色彩，支持rgba
               shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
               shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

               text          : {string},  // 默认为null，附加文本
               textFont      : {string},  // 默认为null，附加文本样式，eg:'bold 18px verdana'
               textPosition  : {string},  // 默认为end，附加文本位置。
                                          // inside | start | end
               textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                          // start | end | left | right | center
               textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                          // top | bottom | middle |
                                          // alphabetic | hanging | ideographic
               textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                          // 'inside' ? '#000' : color
           },

           // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
           highlightStyle : {
               // 同style
           }

           // 交互属性，详见shape.Base

           // 事件属性，详见shape.Base
       }
             例子：
       {
           shape  : 'rose',
           id     : '123456',
           zlevel : 1,
           style  : {
               x : 100,
               y : 100,
               r1 : 50,
               r2 : 30,
               d  : 50,
               strokeColor : '#eee',
               lineWidth : 20,
               text : 'Baidu'
           },
           myName : 'kener',  //可自带任何有效自定义属性

           clickable : true,
           onClick : function(eventPacket) {
               alert(eventPacket.target.myName);
           }
       }
     */
    define('zrender/shape/rose', ['require'], function(require) {
        function Rose() {
            this.type = 'rose';
            this.brushTypeOnly = 'stroke'; //线条只能描边，填充后果自负
        }

        Rose.prototype = {
            /**
             * 创建线条路径
             * @param {Context2D} ctx Canvas 2D上下文
             * @param {Object} style 样式
             */
            buildPath: function(ctx, style) {
                var _x;
                var _y;
                var _R = style.r;
                var _r;
                var _k = style.k;
                var _n = style.n || 1;

                var _offsetX = style.x;
                var _offsetY = style.y;

                var _math = require('../tool/math');
                ctx.moveTo(_offsetX, _offsetY);

                for (var i = 0, _len = _R.length; i < _len; i++) {
                    _r = _R[i];

                    for (var j = 0; j <= 360 * _n; j++) {
                        _x = _r * _math.sin(_k / _n * j % 360, true) * _math.cos(j, true) + _offsetX;
                        _y = _r * _math.sin(_k / _n * j % 360, true) * _math.sin(j, true) + _offsetY;
                        ctx.lineTo(_x, _y);
                    }
                }
            },

            /**
             * 返回矩形区域，用于局部刷新和文字定位
             * @param {Object} style
             */
            getRect: function(style) {
                var _R = style.r;
                var _offsetX = style.x;
                var _offsetY = style.y;
                var _max = 0;

                for (var i = 0, _len = _R.length; i < _len; i++) {
                    if (_R[i] > _max) {
                        _max = _R[i];
                    }
                }
                style.maxr = _max;

                var lineWidth;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                } else {
                    lineWidth = 0;
                }
                return {
                    x: -_max - lineWidth + _offsetX,
                    y: -_max - lineWidth + _offsetY,
                    width: 2 * _max + 3 * lineWidth,
                    height: 2 * _max + 3 * lineWidth
                };
            }
        };

        var base = require('./base');
        base.derive(Rose);

        var shape = require('../shape');
        shape.define('rose', new Rose());

        return Rose;
    });

    /**
 * zrender
 * Copyright 2013 Baidu Inc. All rights reserved.
 *
 * @author Neil (杨骥, yangji01@baidu.com)
 *
 * shape类：内外旋轮曲线
 * 可配图形属性：
   {
       // 基础属性
       shape  : 'trochoid', // 必须，shape类标识，需要显式指定
       id     : {string},       // 必须，图形唯一标识，可通过zrender实例方法newShapeId生成
       zlevel : {number},       // 默认为0，z层level，决定绘画在哪层canvas中
       invisible : {boolean},   // 默认为false，是否可见

       // 样式属性，默认状态样式样式属性
       style  : {
           x             : {number},  // 默认为0， 圆心的横坐标
           y             : {number},  // 默认为0， 圆心的纵坐标
           r            : {number},   // 必须，固定圆半径 内旋曲线时必须大于转动圆半径
           r0            : {number},  // 必须，转动圆半径
           d             : {number},  // 必须，点到内部转动圆的距离，等于r时曲线为摆线
           location      : {string},  // 默认为‘in’ 内旋 out 外旋
           strokeColor   : {color},   // 默认为'#000'，线条颜色（轮廓），支持rgba
           lineWidth     : {number},  // 默认为1，线条宽度
           lineCap       : {string},  // 默认为butt，线帽样式。butt | round | square

           opacity       : {number},  // 默认为1，透明度设置，如果color为rgba，则最终透明度效果叠加
           shadowBlur    : {number},  // 默认为0，阴影模糊度，大于0有效
           shadowColor   : {color},   // 默认为'#000'，阴影色彩，支持rgba
           shadowOffsetX : {number},  // 默认为0，阴影横向偏移，正值往右，负值往左
           shadowOffsetY : {number},  // 默认为0，阴影纵向偏移，正值往下，负值往上

           text          : {string},  // 默认为null，附加文本
           textFont      : {string},  // 默认为null，附加文本样式，eg:'bold 18px verdana'
           textPosition  : {string},  // 默认为end，附加文本位置。
                                      // inside | start | end
           textAlign     : {string},  // 默认根据textPosition自动设置，附加文本水平对齐。
                                      // start | end | left | right | center
           textBaseline  : {string},  // 默认根据textPosition自动设置，附加文本垂直对齐。
                                      // top | bottom | middle |
                                      // alphabetic | hanging | ideographic
           textColor     : {color},   // 默认根据textPosition自动设置，默认策略如下，附加文本颜色
                                      // 'inside' ? '#000' : color
       },

       // 样式属性，高亮样式属性，当不存在highlightStyle时使用基于默认样式扩展显示
       highlightStyle : {
           // 同style
       }

       // 交互属性，详见shape.Base

       // 事件属性，详见shape.Base
   }
         例子：
   {
       shape  : 'hypotrochoid',
       id     : '123456',
       zlevel : 1,
       style  : {
           x : 100,
           y : 100,
           r : 50,
           r0 : 30,
           d  : 50,
           strokeColor : '#eee',
           lineWidth : 20,
           text : 'Baidu'
       },
       myName : 'kener',  //可自带任何有效自定义属性

       clickable : true,
       onClick : function(eventPacket) {
           alert(eventPacket.target.myName);
       }
   }
 */
    define('zrender/shape/trochoid', ['require'],
        function(require) {
            function Trochoid() {
                this.type = 'trochoid';
                this.brushTypeOnly = 'stroke'; //线条只能描边，填充后果自负
            }

            Trochoid.prototype = {
                /**
                 * 创建线条路径
                 * @param {Context2D} ctx Canvas 2D上下文
                 * @param {Object} style 样式
                 */
                buildPath: function(ctx, style) {
                    var _x1;
                    var _y1;
                    var _x2;
                    var _y2;
                    var _R = style.r;
                    var _r = style.r0;
                    var _d = style.d;
                    var _offsetX = style.x;
                    var _offsetY = style.y;
                    var _delta = style.location == 'out' ? 1 : -1;

                    var _math = require('../tool/math');

                    if (style.location && _R <= _r) {
                        alert('参数错误');
                        return;
                    }

                    var _num = 0;
                    var i = 1;
                    var _theta;

                    _x1 = (_R + _delta * _r) * _math.cos(0) - _delta * _d * _math.cos(0) + _offsetX;
                    _y1 = (_R + _delta * _r) * _math.sin(0) - _d * _math.sin(0) + _offsetY;

                    ctx.moveTo(_x1, _y1);

                    //计算结束时的i
                    do {
                        _num++;
                    }
                    while ((_r * _num) % (_R + _delta * _r) !== 0);

                    do {
                        _theta = Math.PI / 180 * i;
                        _x2 = (_R + _delta * _r) * _math.cos(_theta) - _delta * _d * _math.cos((_R / _r + _delta) * _theta) + _offsetX;
                        _y2 = (_R + _delta * _r) * _math.sin(_theta) - _d * _math.sin((_R / _r + _delta) * _theta) + _offsetY;
                        ctx.lineTo(_x2, _y2);
                        i++;
                    }
                    while (i <= (_r * _num) / (_R + _delta * _r) * 360);


                },

                /**
                 * 返回矩形区域，用于局部刷新和文字定位
                 * @param {Object} style
                 */
                getRect: function(style) {
                    var _R = style.r;
                    var _r = style.r0;
                    var _d = style.d;
                    var _delta = style.location == 'out' ? 1 : -1;
                    var _s = _R + _d + _delta * _r;
                    var _offsetX = style.x;
                    var _offsetY = style.y;

                    var lineWidth;
                    if (style.brushType == 'stroke' || style.brushType == 'fill') {
                        lineWidth = style.lineWidth || 1;
                    } else {
                        lineWidth = 0;
                    }
                    return {
                        x: -_s - lineWidth + _offsetX,
                        y: -_s - lineWidth + _offsetY,
                        width: 2 * _s + 2 * lineWidth,
                        height: 2 * _s + 2 * lineWidth
                    };
                }
            };

            var base = require('./base');
            base.derive(Trochoid);

            var shape = require('../shape');
            shape.define('trochoid', new Trochoid());

            return Trochoid;
        }
    );
    /**
     * zrender: loading特效
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * @author Kener (@Kener-林峰, linzhifeng@baidu.com)
     *
     * 扩展loading effect：
     * getBackgroundShape：获取背景图形
     * getTextShape：获取文字
     * define : 定义效果
     *
     * 内置效果
     * bar：进度条
     * whirling：旋转水滴
     * dynamicLine：动态线条
     * bubble：气泡
     */
    define('zrender/tool/loadingEffect', ['require'],
        function(require) {
            var util = require('./util');
            var self;
            var _defaultText = 'Loading...';
            var _defaultTextFont = 'normal 16px Arial';

            var _width;
            var _height;

            function define(name, fun) {
                self[name] = fun;
            }

            /**
             * 获取loading文字图形
             * @param {Object} textStyle 文字style，同shape/text.style
             */
            function getTextShape(textStyle) {
                return {
                    shape: 'text',
                    highlightStyle: util.merge({
                            x: _width / 2,
                            y: _height / 2,
                            text: _defaultText,
                            textAlign: 'center',
                            textBaseline: 'middle',
                            textFont: _defaultTextFont,
                            color: '#333',
                            brushType: 'fill'
                        },
                        textStyle, { 'overwrite': true, 'recursive': true }
                    )
                };
            }

            /**
             * 获取loading背景图形
             * @param {color} color 背景颜色
             */
            function getBackgroundShape(color) {
                return {
                    shape: 'rectangle',
                    highlightStyle: {
                        x: 0,
                        y: 0,
                        width: _width,
                        height: _height,
                        brushType: 'fill',
                        color: color
                    }
                };
            }

            // 调整值区间
            function _adjust(value, region) {
                if (value <= region[0]) {
                    value = region[0];
                } else if (value >= region[1]) {
                    value = region[1];
                }
                return value;
            }

            /**
             * 进度条
             * @param {Object} loadingOption
             * @param {Object} addShapeHandle
             * @param {Object} refreshHandle
             */
            function bar(loadingOption, addShapeHandle, refreshHandle) {
                var zrColor = require('./color');
                // 特效默认配置
                loadingOption = util.merge(
                    loadingOption, {
                        textStyle: {
                            color: '#888'
                        },
                        backgroundColor: 'rgba(250, 250, 250, 0.8)',
                        effectOption: {
                            x: 0,
                            y: _height / 2 - 30,
                            width: _width,
                            height: 5,
                            brushType: 'fill',
                            timeInterval: 100
                        }
                    }, { 'overwrite': false, 'recursive': true }
                );

                var textShape = getTextShape(loadingOption.textStyle);

                var background = getBackgroundShape(loadingOption.backgroundColor);

                var effectOption = loadingOption.effectOption;
                // 初始化动画元素
                var barShape = {
                    shape: 'rectangle',
                    highlightStyle: util.clone(effectOption)
                };
                barShape.highlightStyle.color =
                    effectOption.color || zrColor.getLinearGradient(
                        effectOption.x,
                        effectOption.y,
                        effectOption.x + effectOption.width,
                        effectOption.y + effectOption.height, [
                            [0, '#ff6400'],
                            [0.5, '#ffe100'],
                            [1, '#b1ff00']
                        ]
                    );

                if (typeof loadingOption.progress != 'undefined') {
                    // 指定进度
                    addShapeHandle(background);

                    barShape.highlightStyle.width =
                        _adjust(loadingOption.progress, [0, 1]) * loadingOption.effectOption.width;
                    addShapeHandle(barShape);

                    addShapeHandle(textShape);

                    refreshHandle();
                    return;
                } else {
                    // 循环显示
                    barShape.highlightStyle.width = 0;
                    return setInterval(
                        function() {
                            addShapeHandle(background);

                            if (barShape.highlightStyle.width < loadingOption.effectOption.width) {
                                barShape.highlightStyle.width += 8;
                            } else {
                                barShape.highlightStyle.width = 0;
                            }
                            addShapeHandle(barShape);

                            addShapeHandle(textShape);
                            refreshHandle();
                        },
                        effectOption.timeInterval
                    );
                }
            }

            /**
             * 旋转水滴
             * @param {Object} loadingOption
             * @param {Object} addShapeHandle
             * @param {Object} refreshHandle
             */
            function whirling(loadingOption, addShapeHandle, refreshHandle) {
                // 特效默认配置
                loadingOption.effectOption = util.merge(
                    loadingOption.effectOption || {}, {
                        x: _width / 2 - 80,
                        y: _height / 2,
                        r: 18,
                        colorIn: '#fff',
                        colorOut: '#555',
                        colorWhirl: '#6cf',
                        timeInterval: 50
                    }
                );

                var effectOption = loadingOption.effectOption;
                loadingOption = util.merge(
                    loadingOption, {
                        textStyle: {
                            color: '#888',
                            x: effectOption.x + effectOption.r + 10,
                            y: effectOption.y,
                            textAlign: 'start'
                        },
                        backgroundColor: 'rgba(250, 250, 250, 0.8)'
                    }, { 'overwrite': false, 'recursive': true }
                );

                var textShape = getTextShape(loadingOption.textStyle);

                var background = getBackgroundShape(loadingOption.backgroundColor);

                // 初始化动画元素
                var droplet = {
                    shape: 'droplet',
                    highlightStyle: {
                        a: Math.round(effectOption.r / 2),
                        b: Math.round(effectOption.r - effectOption.r / 6),
                        brushType: 'fill',
                        color: effectOption.colorWhirl
                    }
                };
                var circleIn = {
                    shape: 'circle',
                    highlightStyle: {
                        r: Math.round(effectOption.r / 6),
                        brushType: 'fill',
                        color: effectOption.colorIn
                    }
                };
                var circleOut = {
                    shape: 'ring',
                    highlightStyle: {
                        r0: Math.round(effectOption.r - effectOption.r / 3),
                        r: effectOption.r,
                        brushType: 'fill',
                        color: effectOption.colorOut
                    }
                };

                var pos = [0, effectOption.x, effectOption.y];

                droplet.highlightStyle.x = circleIn.highlightStyle.x = circleOut.highlightStyle.x = pos[1];
                droplet.highlightStyle.y = circleIn.highlightStyle.y = circleOut.highlightStyle.y = pos[2];

                return setInterval(
                    function() {
                        addShapeHandle(background);
                        addShapeHandle(circleOut);
                        pos[0] -= 0.3;
                        droplet.rotation = pos;
                        addShapeHandle(droplet);
                        addShapeHandle(circleIn);
                        addShapeHandle(textShape);
                        refreshHandle();
                    },
                    effectOption.timeInterval
                );
            }

            /**
             * 动态线
             * @param {Object} loadingOption
             * @param {Object} addShapeHandle
             * @param {Object} refreshHandle
             */
            function dynamicLine(loadingOption, addShapeHandle, refreshHandle) {
                var zrColor = require('./color');
                // 特效默认配置
                loadingOption = util.merge(
                    loadingOption, {
                        textStyle: {
                            color: '#fff'
                        },
                        backgroundColor: 'rgba(0, 0, 0, 0.8)',
                        effectOption: {
                            n: 30,
                            lineWidth: 1,
                            color: 'random',
                            timeInterval: 100
                        }
                    }, { 'overwrite': false, 'recursive': true }
                );

                var textShape = getTextShape(loadingOption.textStyle);

                var background = getBackgroundShape(loadingOption.backgroundColor);

                var effectOption = loadingOption.effectOption;
                var n = effectOption.n;
                var lineWidth = effectOption.lineWidth;

                var shapeList = [];
                var pos;
                var len;
                var xStart;
                var color;
                // 初始化动画元素
                for (var i = 0; i < n; i++) {
                    xStart = -Math.ceil(Math.random() * 1000);
                    len = Math.ceil(Math.random() * 400);
                    pos = Math.ceil(Math.random() * _height);

                    if (effectOption.color == 'random') {
                        color = zrColor.random();
                    } else {
                        color = effectOption.color;
                    }
                    shapeList[i] = {
                        shape: 'line',
                        highlightStyle: {
                            xStart: xStart,
                            yStart: pos,
                            xEnd: xStart + len,
                            yEnd: pos,
                            strokeColor: color,
                            lineWidth: lineWidth
                        },
                        animationX: Math.ceil(Math.random() * 100),
                        len: len
                    };
                }

                return setInterval(
                    function() {
                        addShapeHandle(background);
                        var style;
                        for (var i = 0; i < n; i++) {
                            style = shapeList[i].highlightStyle;

                            if (style.xStart >= _width) {
                                shapeList[i].len = Math.ceil(Math.random() * 400);
                                shapeList[i].highlightStyle.xStart = -400;
                                shapeList[i].highlightStyle.xEnd = -400 + shapeList[i].len;
                                shapeList[i].highlightStyle.yStart =
                                    Math.ceil(Math.random() * _height);
                                shapeList[i].highlightStyle.yEnd =
                                    shapeList[i].highlightStyle.yStart;
                            }
                            shapeList[i].highlightStyle.xStart +=
                                shapeList[i].animationX;
                            shapeList[i].highlightStyle.xEnd +=
                                shapeList[i].animationX;

                            addShapeHandle(shapeList[i]);
                        }

                        addShapeHandle(textShape);
                        refreshHandle();
                    },
                    effectOption.timeInterval
                );
            }

            /**
             * 泡泡
             * @param {Object} loadingOption
             * @param {Object} addShapeHandle
             * @param {Object} refreshHandle
             */
            function bubble(loadingOption, addShapeHandle, refreshHandle) {
                var zrColor = require('./color');
                // 特效默认配置
                loadingOption = util.merge(
                    loadingOption, {
                        textStyle: {
                            color: '#888'
                        },
                        backgroundColor: 'rgba(250, 250, 250, 0.8)',
                        effectOption: {
                            n: 50,
                            lineWidth: 2,
                            brushType: 'stroke',
                            color: 'random',
                            timeInterval: 100
                        }
                    }, { 'overwrite': false, 'recursive': true }
                );

                var textShape = getTextShape(loadingOption.textStyle);

                var background = getBackgroundShape(loadingOption.backgroundColor);

                var effectOption = loadingOption.effectOption;
                var n = effectOption.n;
                var brushType = effectOption.brushType;
                var lineWidth = effectOption.lineWidth;

                var shapeList = [];
                var color;
                // 初始化动画元素
                for (var i = 0; i < n; i++) {
                    if (effectOption.color == 'random') {
                        color = zrColor.alpha(zrColor.random(), 0.3);
                    } else {
                        color = effectOption.color;
                    }
                    shapeList[i] = {
                        shape: 'circle',
                        highlightStyle: {
                            x: Math.ceil(Math.random() * _width),
                            y: Math.ceil(Math.random() * _height),
                            r: Math.ceil(Math.random() * 40),
                            brushType: brushType,
                            color: color,
                            strokeColor: color,
                            lineWidth: lineWidth
                        },
                        animationY: Math.ceil(Math.random() * 20)
                    };
                }

                return setInterval(
                    function() {
                        addShapeHandle(background);
                        var style;
                        for (var i = 0; i < n; i++) {
                            style = shapeList[i].highlightStyle;

                            if (style.y - shapeList[i].animationY + style.r <= 0) {
                                shapeList[i].highlightStyle.y = _height + style.r;
                                shapeList[i].highlightStyle.x = Math.ceil(
                                    Math.random() * _width
                                );
                            }
                            shapeList[i].highlightStyle.y -=
                                shapeList[i].animationY;

                            addShapeHandle(shapeList[i]);
                        }

                        addShapeHandle(textShape);
                        refreshHandle();
                    },
                    effectOption.timeInterval
                );
            }

            /**
             * 旋转
             * @param {Object} loadingOption
             * @param {Object} addShapeHandle
             * @param {Object} refreshHandle
             */
            function spin(loadingOption, addShapeHandle, refreshHandle) {
                var zrColor = require('./color');
                // 特效默认配置
                loadingOption.effectOption = util.merge(
                    loadingOption.effectOption || {}, {
                        x: _width / 2 - 80,
                        y: _height / 2,
                        r0: 9,
                        r: 15,
                        n: 18,
                        color: '#fff',
                        timeInterval: 100
                    }
                );

                var effectOption = loadingOption.effectOption;
                loadingOption = util.merge(
                    loadingOption, {
                        textStyle: {
                            color: '#fff',
                            x: effectOption.x + effectOption.r + 10,
                            y: effectOption.y,
                            textAlign: 'start'
                        },
                        backgroundColor: 'rgba(0, 0, 0, 0.8)'
                    }, { 'overwrite': false, 'recursive': true }
                );

                var textShape = getTextShape(loadingOption.textStyle);

                var background = getBackgroundShape(loadingOption.backgroundColor);

                var n = effectOption.n;
                var x = effectOption.x;
                var y = effectOption.y;
                var r0 = effectOption.r0;
                var r = effectOption.r;
                var color = effectOption.color;
                // 初始化动画元素
                var shapeList = [];
                var preAngle = Math.round(180 / n);
                for (var i = 0; i < n; i++) {
                    shapeList[i] = {
                        shape: 'sector',
                        highlightStyle: {
                            x: x,
                            y: y,
                            r0: r0,
                            r: r,
                            startAngle: preAngle * i * 2,
                            endAngle: preAngle * i * 2 + preAngle,
                            color: zrColor.alpha(color, (i + 1) / n),
                            brushType: 'fill'
                        }
                    };
                }

                var pos = [0, x, y];

                return setInterval(
                    function() {
                        addShapeHandle(background);
                        pos[0] -= 0.3;
                        for (var i = 0; i < n; i++) {
                            shapeList[i].rotation = pos;
                            addShapeHandle(shapeList[i]);
                        }

                        addShapeHandle(textShape);
                        refreshHandle();
                    },
                    effectOption.timeInterval
                );
            }


            /**
             * 圆环
             * @param {Object} loadingOption
             * @param {Object} addShapeHandle
             * @param {Object} refreshHandle
             */
            function ring(loadingOption, addShapeHandle, refreshHandle) {
                var zrColor = require('./color');
                var zrMath = require('./math');
                // 特效默认配置
                loadingOption = util.merge(
                    loadingOption, {
                        textStyle: {
                            color: '#07a'
                        },
                        backgroundColor: 'rgba(250, 250, 250, 0.8)',
                        effectOption: {
                            x: _width / 2,
                            y: _height / 2,
                            r0: 60,
                            r: 100,
                            color: '#bbdcff',
                            brushType: 'fill',
                            textPosition: 'inside',
                            textFont: 'normal 30px verdana',
                            textColor: 'rgba(30, 144, 255, 0.6)',
                            timeInterval: 100
                        }
                    }, { 'overwrite': false, 'recursive': true }
                );

                var effectOption = loadingOption.effectOption;
                var textStyle = loadingOption.textStyle;
                textStyle.x = typeof textStyle.x != 'undefined' ? textStyle.x : effectOption.x;
                textStyle.y = typeof textStyle.y != 'undefined' ? textStyle.y : (effectOption.y + (effectOption.r0 + effectOption.r) / 2 - 5);
                var textShape = getTextShape(loadingOption.textStyle);

                var background = getBackgroundShape(loadingOption.backgroundColor);

                var x = effectOption.x;
                var y = effectOption.y;
                var r0 = effectOption.r0 + 6;
                var r = effectOption.r - 6;
                var color = effectOption.color;
                var darkColor = zrColor.lift(color, 0.1);

                var shapeRing = {
                    shape: 'ring',
                    highlightStyle: util.clone(effectOption)
                };
                // 初始化动画元素
                var shapeList = [];
                var clolrList = zrColor.getGradientColors(
                    ['#ff6400', '#ffe100', '#97ff00'], 25
                );
                var preAngle = 15;
                var endAngle = 240;

                for (var i = 0; i < 16; i++) {
                    shapeList.push({
                        shape: 'sector',
                        highlightStyle: {
                            x: x,
                            y: y,
                            r0: r0,
                            r: r,
                            startAngle: endAngle - preAngle,
                            endAngle: endAngle,
                            brushType: 'fill',
                            color: darkColor
                        },
                        _color: zrColor.getLinearGradient(
                            x + r0 * zrMath.cos(endAngle, true),
                            y - r0 * zrMath.sin(endAngle, true),
                            x + r0 * zrMath.cos(endAngle - preAngle, true),
                            y - r0 * zrMath.sin(endAngle - preAngle, true), [
                                [0, clolrList[i * 2]],
                                [1, clolrList[i * 2 + 1]]
                            ]
                        )
                    });
                    endAngle -= preAngle;
                }
                endAngle = 360;
                for (var i = 0; i < 4; i++) {
                    shapeList.push({
                        shape: 'sector',
                        highlightStyle: {
                            x: x,
                            y: y,
                            r0: r0,
                            r: r,
                            startAngle: endAngle - preAngle,
                            endAngle: endAngle,
                            brushType: 'fill',
                            color: darkColor
                        },
                        _color: zrColor.getLinearGradient(
                            x + r0 * zrMath.cos(endAngle, true),
                            y - r0 * zrMath.sin(endAngle, true),
                            x + r0 * zrMath.cos(endAngle - preAngle, true),
                            y - r0 * zrMath.sin(endAngle - preAngle, true), [
                                [0, clolrList[i * 2 + 32]],
                                [1, clolrList[i * 2 + 33]]
                            ]
                        )
                    });
                    endAngle -= preAngle;
                }

                var n = 0;
                if (typeof loadingOption.progress != 'undefined') {
                    // 指定进度
                    addShapeHandle(background);

                    n = _adjust(loadingOption.progress, [0, 1]).toFixed(2) * 100 / 5;
                    shapeRing.highlightStyle.text = n * 5 + '%';
                    addShapeHandle(shapeRing);

                    for (var i = 0; i < 20; i++) {
                        shapeList[i].highlightStyle.color = i < n ? shapeList[i]._color : darkColor;
                        addShapeHandle(shapeList[i]);
                    }

                    addShapeHandle(textShape);

                    refreshHandle();
                    return;
                } else {
                    // 循环显示
                    return setInterval(
                        function() {
                            addShapeHandle(background);

                            n += n >= 20 ? -20 : 1;

                            //shapeRing.highlightStyle.text = n * 5 + '%';
                            addShapeHandle(shapeRing);

                            for (var i = 0; i < 20; i++) {
                                shapeList[i].highlightStyle.color = i < n ? shapeList[i]._color : darkColor;
                                addShapeHandle(shapeList[i]);
                            }

                            addShapeHandle(textShape);
                            refreshHandle();
                        },
                        effectOption.timeInterval
                    );
                }
            }

            function start(loadingOption, addShapeHandle, refreshHandle) {
                var loadingEffect = self.ring; // 默认特效
                if (typeof loadingOption.effect == 'function') {
                    // 自定义特效
                    loadingEffect = loadingOption.effect;
                } else if (typeof self[loadingOption.effect] == 'function') {
                    // 指定特效
                    loadingEffect = self[loadingOption.effect];
                }

                _width = loadingOption.canvasSize.width;
                _height = loadingOption.canvasSize.height;

                return loadingEffect(
                    loadingOption, addShapeHandle, refreshHandle
                );
            }

            function stop(loadingTimer) {
                clearInterval(loadingTimer);
            }

            self = {
                // 这三个方法用于扩展loading effect
                getBackgroundShape: getBackgroundShape,
                getTextShape: getTextShape,
                define: define,
                // 内置特效
                bar: bar,
                whirling: whirling,
                dynamicLine: dynamicLine,
                bubble: bubble,
                spin: spin,
                ring: ring,
                // 方法
                start: start,
                stop: stop
            };

            return self;
        }
    );

    /**
     * zrender : 颜色辅助类
     * Copyright 2013 Baidu Inc. All rights reserved.
     *
     * author: CrossDo (chenhuaimu@baidu.com)
     *
     * getColor：获取色板颜色
     * customPalette : 自定义调色板
     * resetPalette : 重置调色板
     *
     * getHighlightColor : 获取默认高亮颜色
     * customHighlight : 自定义默认高亮颜色
     * resetHighlight : 重置默认高亮颜色
     *
     * getRadialGradient : 径向渐变
     * getLinearGradient : 线性渐变
     * getGradientColors : 获取颜色之间渐变颜色数组
     * getStepColors : 获取两种颜色之间渐变颜色数组
     * reverse : 颜色翻转
     * mix : 颜色混合
     * lift : 颜色升降
     * trim : 清除空格
     * random : 随机颜色
     * toRGB  : 转为RGB格式
     * toRGBA : 转为RGBA格式
     * toHex  : 转为#RRGGBB格式
     * toHSL  : 转为HSL格式
     * toHSLA : 转为HSLA格式
     * toHSB  : 转为HSB格式
     * toHSBA : 转为HSBA格式
     * toHSV  : 转为HSV格式
     * toHSVA : 转为HSVA格式
     * toName : 转为颜色名字
     * toColor: 颜色值数组转为指定格式颜色
     * toArray: 返回颜色值数组
     * alpha  : 设置颜色的透明度
     **/
    define('zrender/tool/color', ['require'], function(require) {
        var util = require('../tool/util');

        var _ctx;

        // Color palette is an array containing the default colors for the chart's
        // series.
        // When all colors are used, new colors are selected from the start again.
        // Defaults to:
        // 默认色板
        var palette = [
            '#ff9277', ' #dddd00', ' #ffc877', ' #bbe3ff', ' #d5ffbb',
            '#bbbbff', ' #ddb000', ' #b0dd00', ' #e2bbff', ' #ffbbe3',
            '#ff7777', ' #ff9900', ' #83dd00', ' #77e3ff', ' #778fff',
            '#c877ff', ' #ff77ab', ' #ff6600', ' #aa8800', ' #77c7ff',
            '#ad77ff', ' #ff77ff', ' #dd0083', ' #777700', ' #00aa00',
            '#0088aa', ' #8400dd', ' #aa0088', ' #dd0000', ' #772e00'
        ];
        var _palette = palette;

        var highlightColor = 'rgba(255,255,0,0.5)';
        var _highlightColor = highlightColor;

        // 颜色格式
        /*jshint maxlen: 330 */
        var colorRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i;

        var _nameColors = {
            aliceblue: '#f0f8ff',
            antiquewhite: '#faebd7',
            aqua: '#0ff',
            aquamarine: '#7fffd4',
            azure: '#f0ffff',
            beige: '#f5f5dc',
            bisque: '#ffe4c4',
            black: '#000',
            blanchedalmond: '#ffebcd',
            blue: '#00f',
            blueviolet: '#8a2be2',
            brown: '#a52a2a',
            burlywood: '#deb887',
            cadetblue: '#5f9ea0',
            chartreuse: '#7fff00',
            chocolate: '#d2691e',
            coral: '#ff7f50',
            cornflowerblue: '#6495ed',
            cornsilk: '#fff8dc',
            crimson: '#dc143c',
            cyan: '#0ff',
            darkblue: '#00008b',
            darkcyan: '#008b8b',
            darkgoldenrod: '#b8860b',
            darkgray: '#a9a9a9',
            darkgrey: '#a9a9a9',
            darkgreen: '#006400',
            darkkhaki: '#bdb76b',
            darkmagenta: '#8b008b',
            darkolivegreen: '#556b2f',
            darkorange: '#ff8c00',
            darkorchid: '#9932cc',
            darkred: '#8b0000',
            darksalmon: '#e9967a',
            darkseagreen: '#8fbc8f',
            darkslateblue: '#483d8b',
            darkslategray: '#2f4f4f',
            darkslategrey: '#2f4f4f',
            darkturquoise: '#00ced1',
            darkviolet: '#9400d3',
            deeppink: '#ff1493',
            deepskyblue: '#00bfff',
            dimgray: '#696969',
            dimgrey: '#696969',
            dodgerblue: '#1e90ff',
            firebrick: '#b22222',
            floralwhite: '#fffaf0',
            forestgreen: '#228b22',
            fuchsia: '#f0f',
            gainsboro: '#dcdcdc',
            ghostwhite: '#f8f8ff',
            gold: '#ffd700',
            goldenrod: '#daa520',
            gray: '#808080',
            grey: '#808080',
            green: '#008000',
            greenyellow: '#adff2f',
            honeydew: '#f0fff0',
            hotpink: '#ff69b4',
            indianred: '#cd5c5c',
            indigo: '#4b0082',
            ivory: '#fffff0',
            khaki: '#f0e68c',
            lavender: '#e6e6fa',
            lavenderblush: '#fff0f5',
            lawngreen: '#7cfc00',
            lemonchiffon: '#fffacd',
            lightblue: '#add8e6',
            lightcoral: '#f08080',
            lightcyan: '#e0ffff',
            lightgoldenrodyellow: '#fafad2',
            lightgray: '#d3d3d3',
            lightgrey: '#d3d3d3',
            lightgreen: '#90ee90',
            lightpink: '#ffb6c1',
            lightsalmon: '#ffa07a',
            lightseagreen: '#20b2aa',
            lightskyblue: '#87cefa',
            lightslategray: '#789',
            lightslategrey: '#789',
            lightsteelblue: '#b0c4de',
            lightyellow: '#ffffe0',
            lime: '#0f0',
            limegreen: '#32cd32',
            linen: '#faf0e6',
            magenta: '#f0f',
            maroon: '#800000',
            mediumaquamarine: '#66cdaa',
            mediumblue: '#0000cd',
            mediumorchid: '#ba55d3',
            mediumpurple: '#9370d8',
            mediumseagreen: '#3cb371',
            mediumslateblue: '#7b68ee',
            mediumspringgreen: '#00fa9a',
            mediumturquoise: '#48d1cc',
            mediumvioletred: '#c71585',
            midnightblue: '#191970',
            mintcream: '#f5fffa',
            mistyrose: '#ffe4e1',
            moccasin: '#ffe4b5',
            navajowhite: '#ffdead',
            navy: '#000080',
            oldlace: '#fdf5e6',
            olive: '#808000',
            olivedrab: '#6b8e23',
            orange: '#ffa500',
            orangered: '#ff4500',
            orchid: '#da70d6',
            palegoldenrod: '#eee8aa',
            palegreen: '#98fb98',
            paleturquoise: '#afeeee',
            palevioletred: '#d87093',
            papayawhip: '#ffefd5',
            peachpuff: '#ffdab9',
            peru: '#cd853f',
            pink: '#ffc0cb',
            plum: '#dda0dd',
            powderblue: '#b0e0e6',
            purple: '#800080',
            red: '#f00',
            rosybrown: '#bc8f8f',
            royalblue: '#4169e1',
            saddlebrown: '#8b4513',
            salmon: '#fa8072',
            sandybrown: '#f4a460',
            seagreen: '#2e8b57',
            seashell: '#fff5ee',
            sienna: '#a0522d',
            silver: '#c0c0c0',
            skyblue: '#87ceeb',
            slateblue: '#6a5acd',
            slategray: '#708090',
            slategrey: '#708090',
            snow: '#fffafa',
            springgreen: '#00ff7f',
            steelblue: '#4682b4',
            tan: '#d2b48c',
            teal: '#008080',
            thistle: '#d8bfd8',
            tomato: '#ff6347',
            turquoise: '#40e0d0',
            violet: '#ee82ee',
            wheat: '#f5deb3',
            white: '#fff',
            whitesmoke: '#f5f5f5',
            yellow: '#ff0',
            yellowgreen: '#9acd32'
        };

        /**
         * 自定义调色板
         */
        function customPalette(userPalete) {
            palette = userPalete;
        }

        /**
         * 复位默认色板
         */
        function resetPalette() {
            palette = _palette;
        }

        /**
         * 获取色板颜色
         * @param {number} idx : 色板位置
         * @param {array} [userPalete] : 自定义色板
         *
         * @return {color} 颜色#000000~#ffffff
         */
        function getColor(idx, userPalete) {
            idx = +idx || 0;
            userPalete = userPalete || palette;
            return userPalete[idx % userPalete.length];
        }

        /**
         * 自定义默认高亮颜色
         */
        function customHighlight(userHighlightColor) {
            highlightColor = userHighlightColor;
        }

        /**
         * 重置默认高亮颜色
         */
        function resetHighlight() {
            _highlightColor = highlightColor;
        }

        /**
         * 获取默认高亮颜色
         */
        function getHighlightColor() {
            return highlightColor;
        }

        /**
         * 径向渐变
         * @param {number} x0 渐变起点
         * @param {number} y0
         * @param {number} r0
         * @param {number} x1 渐变终点
         * @param {number} y1
         * @param {number} r1
         * @param {Array} colorList 颜色列表
         */
        function getRadialGradient(x0, y0, r0, x1, y1, r1, colorList) {
            if (!_ctx) {
                _ctx = util.getContext();
            }
            var gradient = _ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
            for (var i = 0, l = colorList.length; i < l; i++) {
                gradient.addColorStop(colorList[i][0], colorList[i][1]);
            }
            gradient.__nonRecursion = true;
            return gradient;
        }

        /**
         * 线性渐变
         * @param {Object} x0 渐变起点
         * @param {Object} y0
         * @param {Object} x1 渐变终点
         * @param {Object} y1
         * @param {Array} colorList 颜色列表
         */
        function getLinearGradient(x0, y0, x1, y1, colorList) {
            if (!_ctx) {
                _ctx = util.getContext();
            }
            var gradient = _ctx.createLinearGradient(x0, y0, x1, y1);
            for (var i = 0, l = colorList.length; i < l; i++) {
                gradient.addColorStop(colorList[i][0], colorList[i][1]);
            }
            gradient.__nonRecursion = true;
            return gradient;
        }

        /**
         * 获取两种颜色之间渐变颜色数组
         * @param {color} start 起始颜色
         * @param {color} end 结束颜色
         * @param {number} step 渐变级数
         * @return {Array}  颜色数组
         */
        function getStepColors(start, end, step) {
            start = toRGBA(start);
            end = toRGBA(end);
            start = getData(start);
            end = getData(end);

            var colors = [];
            var stepR = (end[0] - start[0]) / step;
            var stepG = (end[1] - start[1]) / step;
            var stepB = (end[2] - start[2]) / step;
            // 生成颜色集合
            // fix by linfeng 颜色堆积
            for (var i = 0, r = start[0], g = start[1], b = start[2]; i < step; i++) {
                colors[i] = toColor([
                    adjust(Math.floor(r), [0, 255]),
                    adjust(Math.floor(g), [0, 255]),
                    adjust(Math.floor(b), [0, 255])
                ]);
                r += stepR;
                g += stepG;
                b += stepB;
            }
            r = end[0];
            g = end[1];
            b = end[2];
            colors[i] = toColor([r, g, b]);
            return colors;
        }

        /**
         * 获取指定级数的渐变颜色数组
         * @param {Array} colors 颜色组
         * @param {number=20} step 渐变级数
         * @return {Array}  颜色数组
         */
        function getGradientColors(colors, step) {
            var ret = [];
            var len = colors.length;
            if (step === undefined) {
                step = 20;
            }
            if (len === 1) {
                ret = getStepColors(colors[0], colors[0], step);
            } else if (len > 1) {
                for (var i = 0, n = len - 1; i < n; i++) {
                    var steps = getStepColors(colors[i], colors[i + 1], step);
                    if (i < n - 1) {
                        steps.pop();
                    }
                    ret = ret.concat(steps);
                }
            }
            return ret;
        }

        /**
         * 颜色值数组转为指定格式颜色,例如:<br/>
         * data = [60,20,20,0.1] format = 'rgba'
         * 返回：rgba(60,20,20,0.1)
         * @param {Array} data 颜色值数组
         * @param {string} format 格式,默认rgb
         * @return {string} 颜色
         */
        function toColor(data, format) {
            format = format || 'rgb';
            if (data && (data.length === 3 || data.length === 4)) {
                data = map(data,
                    function(c) {
                        return c > 1 ? Math.ceil(c) : c;
                    });

                if (format.indexOf('hex') > -1) {
                    data = map(data.slice(0, 3),
                        function(c) {
                            c = Number(c).toString(16);
                            return (c.length === 1) ? '0' + c : c;
                        });
                    return '#' + data.join('');
                } else if (format.indexOf('hs') > -1) {
                    var sx = map(data.slice(1, 3),
                        function(c) {
                            return c + '%';
                        });
                    data[1] = sx[0];
                    data[2] = sx[1];
                }

                if (format.indexOf('a') > -1) {
                    if (data.length === 3) {
                        data.push(1);
                    }
                    data[3] = adjust(data[3], [0, 1]);
                    return format + '(' + data.slice(0, 4).join(',') + ')';
                }

                return format + '(' + data.slice(0, 3).join(',') + ')';
            }
        }

        /**
         * 返回颜色值数组
         * @param {string} color 颜色
         * @return {Array} 颜色值数组
         */
        function toArray(color) {
            color = trim(color);
            if (color.indexOf('#') > -1) {
                color = toRGB(color);
            }
            var data = color.replace(/[rgbahsvl%\(\)]/ig, '').split(',');
            data = map(data,
                function(c) {
                    return Number(c);
                });
            return data;
        }

        /**
         * 颜色格式转化
         * @param {Array} data 颜色值数组
         * @param {string} format 格式,默认rgb
         * @return {string} 颜色
         */
        function convert(color, format) {
            var data = getData(color);
            var alpha = data[3];
            if (typeof alpha === 'undefined') {
                alpha = 1;
            }

            if (color.indexOf('hsb') > -1) {
                data = _HSV_2_RGB(data);
            } else if (color.indexOf('hsl') > -1) {
                data = _HSL_2_RGB(data);
            }

            if (format.indexOf('hsb') > -1 || format.indexOf('hsv') > -1) {
                data = _RGB_2_HSB(data);
            } else if (format.indexOf('hsl') > -1) {
                data = _RGB_2_HSL(data);
            }

            data[3] = alpha;

            return toColor(data, format);
        }

        /**
         * 转换为rgba格式的颜色
         * @param {string} color 颜色
         * @return {string} rgba颜色，rgba(r,g,b,a)
         */
        function toRGBA(color) {
            return convert(color, 'rgba');
        }

        /**
         * 转换为rgb数字格式的颜色
         * @param {string} color 颜色
         * @return {string} rgb颜色，rgb(0,0,0)格式
         */
        function toRGB(color) {
            return convert(color, 'rgb');
        }

        /**
         * 转换为16进制颜色
         * @param {string} color 颜色
         * @return {string} 16进制颜色，#rrggbb格式
         */
        function toHex(color) {
            return convert(color, 'hex');
        }

        /**
         * 转换为HSV颜色
         * @param {string} color 颜色
         * @return {string} HSVA颜色，hsva(h,s,v,a)
         */
        function toHSVA(color) {
            return convert(color, 'hsva');
        }

        /**
         * 转换为HSV颜色
         * @param {string} color 颜色
         * @return {string} HSV颜色，hsv(h,s,v)
         */
        function toHSV(color) {
            return convert(color, 'hsv');
        }

        /**
         * 转换为HSBA颜色
         * @param {string} color 颜色
         * @return {string} HSBA颜色，hsba(h,s,b,a)
         */
        function toHSBA(color) {
            return convert(color, 'hsba');
        }

        /**
         * 转换为HSB颜色
         * @param {string} color 颜色
         * @return {string} HSB颜色，hsb(h,s,b)
         */
        function toHSB(color) {
            return convert(color, 'hsb');
        }

        /**
         * 转换为HSLA颜色
         * @param {string} color 颜色
         * @return {string} HSLA颜色，hsla(h,s,l,a)
         */
        function toHSLA(color) {
            return convert(color, 'hsla');
        }

        /**
         * 转换为HSL颜色
         * @param {string} color 颜色
         * @return {string} HSL颜色，hsl(h,s,l)
         */
        function toHSL(color) {
            return convert(color, 'hsl');
        }

        /**
         * 转换颜色名
         * @param {string} color 颜色
         * @return {String} 颜色名
         */
        function toName(color) {
            for (var key in _nameColors) {
                if (toHex(_nameColors[key]) === toHex(color)) {
                    return key;
                }
            }
            return null;
        }

        /**
         * 移除颜色中多余空格
         * @param {String} color 颜色
         * @return {String} 无空格颜色
         */
        function trim(color) {
            color = String(color);
            color = color.replace(/(^\s*)|(\s*$)/g, '');
            if (/^[^#]*?$/i.test(color)) {
                color = color.replace(/\s/g, '');
            }
            return color;
        }

        // 规范化
        function normalize(color) {
            // 颜色名
            if (_nameColors[color]) {
                color = _nameColors[color];
            }
            // 去掉空格
            color = trim(color);
            // hsv与hsb等价
            color = color.replace(/hsv/i, 'hsb');
            // rgb转为rrggbb
            if (/^#[0-9a-f]{3}$/i.test(color)) {
                var d = color.replace('#', '').split('');
                color = '#' + d[0] + d[0] + d[1] + d[1] + d[2] + d[2];
            }
            return color;
        }

        /**
         * 颜色加深或减淡，当level>0加深，当level<0减淡
         * @param {string} color 颜色
         * @param {number} level 升降程度,取值区间[-1,1]
         * @return {string} 加深或减淡后颜色值
         */
        function lift(color, level) {
            var direct = level > 0 ? 1 : -1;
            if (typeof level === 'undefined') {
                level = 0;
            }
            level = Math.abs(level) > 1 ? 1 : Math.abs(level);
            color = toRGB(color);
            var data = getData(color);
            for (var i = 0; i < 3; i++) {
                if (direct === 1) {
                    data[i] = Math.floor(data[i] * (1 - level));
                } else {
                    data[i] = Math.floor((255 - data[i]) * level + data[i]);
                }
            }
            return 'rgb(' + data.join(',') + ')';
        }

        /**
         * 颜色翻转,[255-r,255-g,255-b,1-a]
         * @param {string} color 颜色
         * @return {string} 翻转颜色
         */
        function reverse(color) {
            var data = getData(toRGBA(color));
            data = map(data,
                function(c) {
                    return 255 - c;
                });
            return toColor(data, 'rgb');
        }

        /**
         * 简单两种颜色混合
         * @param {String} color1 第一种颜色
         * @param {String} color2 第二种颜色
         * @param {String} weight 混合权重[0-1]
         * @return {String} 结果色,rgb(r,g,b)或rgba(r,g,b,a)
         */
        function mix(color1, color2, weight) {
            if (typeof weight === 'undefined') {
                weight = 0.5;
            }
            weight = 1 - adjust(weight, [0, 1]);

            var w = weight * 2 - 1;
            var data1 = getData(toRGBA(color1));
            var data2 = getData(toRGBA(color2));

            var d = data1[3] - data2[3];

            var weight1 = (((w * d === -1) ? w : (w + d) / (1 + w * d)) + 1) / 2;
            var weight2 = 1 - weight1;

            var data = [];

            for (var i = 0; i < 3; i++) {
                data[i] = data1[i] * weight1 + data2[i] * weight2;
            }

            var alpha = data1[3] * weight + data2[3] * (1 - weight);
            alpha = Math.max(0, Math.min(1, alpha));

            if (data1[3] === 1 && data2[3] === 1) { // 不考虑透明度
                return toColor(data, 'rgb');
            }
            data[3] = alpha;
            return toColor(data, 'rgba');
        }

        /**
         * 随机颜色
         * @return {string} 颜色值，#rrggbb格式
         */
        function random() {
            return toHex(
                'rgb(' + Math.round(Math.random() * 256) + ',' + Math.round(Math.random() * 256) + ',' + Math.round(Math.random() * 256) + ')'
            );
        }

        /**
         * 获取颜色值数组,返回值范围： <br/>
         * RGB 范围[0-255] <br/>
         * HSL/HSV/HSB 范围[0-1]<br/>
         * A透明度范围[0-1]
         * 支持格式：
         * #rgb
         * #rrggbb
         * rgb(r,g,b)
         * rgb(r%,g%,b%)
         * rgba(r,g,b,a)
         * hsb(h,s,b) // hsv与hsb等价
         * hsb(h%,s%,b%)
         * hsba(h,s,b,a)
         * hsl(h,s,l)
         * hsl(h%,s%,l%)
         * hsla(h,s,l,a)
         * @param {string} color 颜色
         * @return {Array} 颜色值数组或null
         */
        function getData(color) {
            color = normalize(color);
            var r = color.match(colorRegExp);
            if (r === null) {
                throw new Error('The color format error'); // 颜色格式错误
            }
            var d;
            var a;
            var data = [];
            var rgb;

            if (r[2]) {
                // #rrggbb
                d = r[2].replace('#', '').split('');
                rgb = [d[0] + d[1], d[2] + d[3], d[4] + d[5]];
                data = map(rgb,
                    function(c) {
                        return adjust(parseInt(c, 16), [0, 255]);
                    });

            } else if (r[4]) {
                // rgb rgba
                var rgba = (r[4]).split(',');
                a = rgba[3];
                rgb = rgba.slice(0, 3);
                data = map(
                    rgb,
                    function(c) {
                        c = Math.floor(
                            c.indexOf('%') > 0 ? parseInt(c, 0) * 2.55 : c
                        );
                        return adjust(c, [0, 255]);
                    }
                );

                if (typeof a !== 'undefined') {
                    data.push(adjust(parseFloat(a), [0, 1]));
                }
            } else if (r[5] || r[6]) {
                // hsb hsba hsl hsla
                var hsxa = (r[5] || r[6]).split(',');
                var h = parseInt(hsxa[0], 0) / 360;
                var s = hsxa[1];
                var x = hsxa[2];
                a = hsxa[3];
                data = map([s, x],
                    function(c) {
                        return adjust(parseFloat(c) / 100, [0, 1]);
                    });
                data.unshift(h);
                if (typeof a !== 'undefined') {
                    data.push(adjust(parseFloat(a), [0, 1]));
                }
            }
            return data;
        }

        /**
         * 设置颜色透明度
         * @param {string} color 颜色
         * @param {number} alpha 透明度,区间[0,1]
         * @return {string} rgba颜色值
         */
        function alpha(color, a) {
            if (a === null) {
                a = 1;
            }
            var data = getData(toRGBA(color));
            data[3] = adjust(Number(a).toFixed(4), [0, 1]);

            return toColor(data, 'rgba');
        }

        // 数组映射
        function map(array, fun) {
            if (typeof fun !== 'function') {
                throw new TypeError();
            }
            var len = array ? array.length : 0;
            for (var i = 0; i < len; i++) {
                array[i] = fun(array[i]);
            }
            return array;
        }

        // 调整值区间
        function adjust(value, region) {
            // < to <= & > to >=
            // modify by linzhifeng 2014-05-25 because -0 == 0
            if (value <= region[0]) {
                value = region[0];
            } else if (value >= region[1]) {
                value = region[1];
            }
            return value;
        }

        // 参见 http:// www.easyrgb.com/index.php?X=MATH
        function _HSV_2_RGB(data) {
            var H = data[0];
            var S = data[1];
            var V = data[2];
            // HSV from 0 to 1
            var R, G, B;
            if (S === 0) {
                R = V * 255;
                G = V * 255;
                B = V * 255;
            } else {
                var h = H * 6;
                if (h === 6) {
                    h = 0;
                }
                var i = Math.floor(h);
                var v1 = V * (1 - S);
                var v2 = V * (1 - S * (h - i));
                var v3 = V * (1 - S * (1 - (h - i)));
                var r = 0;
                var g = 0;
                var b = 0;

                if (i === 0) {
                    r = V;
                    g = v3;
                    b = v1;
                } else if (i === 1) {
                    r = v2;
                    g = V;
                    b = v1;
                } else if (i === 2) {
                    r = v1;
                    g = V;
                    b = v3;
                } else if (i === 3) {
                    r = v1;
                    g = v2;
                    b = V;
                } else if (i === 4) {
                    r = v3;
                    g = v1;
                    b = V;
                } else {
                    r = V;
                    g = v1;
                    b = v2;
                }

                // RGB results from 0 to 255
                R = r * 255;
                G = g * 255;
                B = b * 255;
            }
            return [R, G, B];
        }

        function _HSL_2_RGB(data) {
            var H = data[0];
            var S = data[1];
            var L = data[2];
            // HSL from 0 to 1
            var R, G, B;
            if (S === 0) {
                R = L * 255;
                G = L * 255;
                B = L * 255;
            } else {
                var v2;
                if (L < 0.5) {
                    v2 = L * (1 + S);
                } else {
                    v2 = (L + S) - (S * L);
                }

                var v1 = 2 * L - v2;

                R = 255 * _HUE_2_RGB(v1, v2, H + (1 / 3));
                G = 255 * _HUE_2_RGB(v1, v2, H);
                B = 255 * _HUE_2_RGB(v1, v2, H - (1 / 3));
            }
            return [R, G, B];
        }

        function _HUE_2_RGB(v1, v2, vH) {
            if (vH < 0) {
                vH += 1;
            }
            if (vH > 1) {
                vH -= 1;
            }
            if ((6 * vH) < 1) {
                return (v1 + (v2 - v1) * 6 * vH);
            }
            if ((2 * vH) < 1) {
                return (v2);
            }
            if ((3 * vH) < 2) {
                return (v1 + (v2 - v1) * ((2 / 3) - vH) * 6);
            }
            return v1;
        }

        function _RGB_2_HSB(data) {
            // RGB from 0 to 255
            var R = (data[0] / 255);
            var G = (data[1] / 255);
            var B = (data[2] / 255);

            var vMin = Math.min(R, G, B); // Min. value of RGB
            var vMax = Math.max(R, G, B); // Max. value of RGB
            var delta = vMax - vMin; // Delta RGB value
            var V = vMax;
            var H;
            var S;

            // HSV results from 0 to 1
            if (delta === 0) {
                H = 0;
                S = 0;
            } else {
                S = delta / vMax;

                var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
                var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
                var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;

                if (R === vMax) {
                    H = deltaB - deltaG;
                } else if (G === vMax) {
                    H = (1 / 3) + deltaR - deltaB;
                } else if (B === vMax) {
                    H = (2 / 3) + deltaG - deltaR;
                }

                if (H < 0) {
                    H += 1;
                }
                if (H > 1) {
                    H -= 1;
                }
            }
            H = H * 360;
            S = S * 100;
            V = V * 100;
            return [H, S, V];
        }

        function _RGB_2_HSL(data) {
            // RGB from 0 to 255
            var R = (data[0] / 255);
            var G = (data[1] / 255);
            var B = (data[2] / 255);

            var vMin = Math.min(R, G, B); // Min. value of RGB
            var vMax = Math.max(R, G, B); // Max. value of RGB
            var delta = vMax - vMin; // Delta RGB value

            var L = (vMax + vMin) / 2;
            var H;
            var S;
            // HSL results from 0 to 1
            if (delta === 0) {
                H = 0;
                S = 0;
            } else {
                if (L < 0.5) {
                    S = delta / (vMax + vMin);
                } else {
                    S = delta / (2 - vMax - vMin);
                }

                var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
                var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
                var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;

                if (R === vMax) {
                    H = deltaB - deltaG;
                } else if (G === vMax) {
                    H = (1 / 3) + deltaR - deltaB;
                } else if (B === vMax) {
                    H = (2 / 3) + deltaG - deltaR;
                }

                if (H < 0) {
                    H += 1;
                }

                if (H > 1) {
                    H -= 1;
                }
            }

            H = H * 360;
            S = S * 100;
            L = L * 100;

            return [H, S, L];
        }

        return {
            customPalette: customPalette,
            resetPalette: resetPalette,
            getColor: getColor,
            getHighlightColor: getHighlightColor,
            customHighlight: customHighlight,
            resetHighlight: resetHighlight,
            getRadialGradient: getRadialGradient,
            getLinearGradient: getLinearGradient,
            getGradientColors: getGradientColors,
            getStepColors: getStepColors,
            reverse: reverse,
            mix: mix,
            lift: lift,
            trim: trim,
            random: random,
            toRGB: toRGB,
            toRGBA: toRGBA,
            toHex: toHex,
            toHSL: toHSL,
            toHSLA: toHSLA,
            toHSB: toHSB,
            toHSBA: toHSBA,
            toHSV: toHSV,
            toHSVA: toHSVA,
            toName: toName,
            toColor: toColor,
            toArray: toArray,
            alpha: alpha,
            getData: getData
        };
    });
    
    define('color', ['zrender/tool/color'], function(color) {
        return color;
    });
    var color = require('color');

    define('zrender', ['zrender/zrender'], function(zrender) {
        return zrender;
    });
    var zrender = require('zrender');
	zrender.version = '1.0.2';

    return { zrender: zrender, color: color };
}));
/**
 * Class: Geo.View2D.Layer.HoneycombLayer
 * 蜂窝图图层类，继承自Geo.View2D.Layer类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 *
 * Inherits from:
 *  - <Geo.View2D.Layer>
 */
Geo.View2D.Layer.HoneycombLayer = Geo.Class(Geo.View2D.Layer, {

    config: null,

    honeydiv: null,

    onclick: function(value) {},

    /**
     * Constructor: Geo.View2D.Layer.HoneycombLayer
     * 创建图层对象实例。
     *
     * Parameters:
     * name - {String} 图层名称。
     * options - {Object} 对象构造参数。
     */
    initialize: function(name, options) {
        Geo.View2D.Layer.prototype.initialize.apply(this, [name, options]);
    },

    /** 
     * Method: setMap
     * 设置地图对象。
     * 
     * Parameters:
     * map - {<Geo.View2D.Map>} 
     */
    setMap: function(map) {
        Geo.View2D.Layer.prototype.setMap.apply(this, arguments);

        //创建蜂窝DIV
        this.honeydiv = document.createElement("div");
        this.honeydiv.style.cssText = "position:absolute;width:" + this.map.size.w + "px;height:" + this.map.size.h + "px;";
        //追加至图层DIV
        this.div.appendChild(this.honeydiv);
        this.zr = Geo.zrender.init(this.honeydiv);

        // on zoomend and moveend we have to move the canvas element and redraw the datapoints with new positions
        //注册事件，每次拖动地图或缩放地图时，刷新图形。
        this.map.events.on({
            "zoomend": this.updateLayer,
            "moveend": this.updateLayer,
            scope: this
        });
        //this.map.events.register("zoomend", this, this.updateLayer);
        if (this.config && typeof this.config.onclick == 'function') {
            this.onclick = this.config.onclick;
        }
        //this.refreshHoneycomb(this.config);
        this.updateLayer();
    },

    /** 
     * Method: updateLayer
     * 每次拖动地图或缩放地图时，刷新图形。
     */
    updateLayer: function() {
        var pixelOffset = this.getPixelOffset();
        var el = this.honeydiv;
        // if the pixeloffset e.g. for x was positive move the canvas element to the left by setting left:-offset.y px 
        // otherwise move it the right by setting it a positive value. same for top
        el.style.top = ((pixelOffset.y > 0) ? ('-' + pixelOffset.y) : (Math.abs(pixelOffset.y))) + 'px';
        el.style.left = ((pixelOffset.x > 0) ? ('-' + pixelOffset.x) : (Math.abs(pixelOffset.x))) + 'px';
        this.refreshHoneycomb(this.config);
    },

    /** 
     * Method: getPixelOffset
     */
    getPixelOffset: function() {
        var o = this.map.layerContainerOrigin,
            o_lonlat = new OpenLayers.LonLat(o.lon, o.lat),
            o_pixel = this.getViewPortPxFromLonLat(o_lonlat),
            c = this.map.center,
            c_lonlat = new OpenLayers.LonLat(c.lon, c.lat),
            c_pixel = this.getViewPortPxFromLonLat(c_lonlat);

        return {
            x: o_pixel.x - c_pixel.x,
            y: o_pixel.y - c_pixel.y
        };

    },

    /**
     * 初始化蜂窝图      
     * @param config
     *        config.startPx   起始点（坐标需转换成屏幕坐标）
     *        config.startPx.x 起始点x坐标
     *        config.startPx.y 起始点y坐标
     * @return {[type]}        [description]
     */
    /*
        init: function(mapDiv, config) {
            if (!this._checkConfigDataBeforeRender(mapDiv, config)) {
                return;
            }
            // 蜂窝图所在div的id，默认为‘geo-online-honeycomb-div’
            var mainId = config.mainId || 'geo-online-honeycomb-div';
            this._createDiv(mapDiv, mainId);
            var mainDiv = document.getElementById(mainId);
            var zr = zrender.init(mainDiv);

            // 本作用域内的全局变量
            this.zr = zr;
            // 赋值this.mainId一定要在refreshHoneycomb函数之前，否则refreshHoneycomb中无法获取的值
            this.mainId = mainId;
            this.mapDiv = mapDiv;
            this.onclick = config.onclick;
            this.refreshHoneycomb(config);
        },
        */
    /**
     * 重绘蜂窝图
     * @param  {[type]} config [description]
     * @return {[type]}        [description]
     */
    refreshHoneycomb: function(config, isAnimate) {
        var zr = this.zr;
        zr.clear();
        /*
            var width = Math.ceil(zr.getWidth());
            var height = Math.ceil(zr.getHeight());
            var x = width / 2;
            var y = height / 2;
            */
        // var startPx = config.startPx || { x: 50, y: 50 };
        // var x = startPx.x;
        // var y = startPx.y;
        if (config) {
            this.config = config;
            //地图坐标，转换为屏幕坐标，然后绘制图形
            var px = this.map.getViewPortPxFromLonLat(config.lonlat);
            var x = px.x;
            var y = px.y;
            this._buildPath(this.zr, config, x, y, isAnimate);
            //this._buildImgPath(this.zr, config, x, y);
            // 绘画
            zr.render();
        }
    },
    /**
     * 蜂窝中每个六边形的点击事件
     * @param  {[type]} eventPacket [description]
     * @return {[type]}             [description]
     */
    onclickEvent: function(eventPacket) {
        var target = eventPacket.target;
        console.log(target.id);
        var returnValue = target.nodeData;
        this.onclick && this.onclick.call(this, returnValue);
    },
    /**
     * 创建包含canvas的div
     * @param  {[String]} mapDiv [map对象div]
     * @param  {[String]} mainId [蜂窝图div的id]
     * @return {[type]}        [无返回值]
     */
    /*
        _createDiv: function(mapDiv, mainId) {
            var div = document.createElement('div');
            div.setAttribute('id', mainId);
            div.setAttribute('style', 'width: 600px; height: 400px;background: transparent;position: absolute;outline: 0;left: 0;top: 0px;z-index: 1120;');
            // div.setAttribute('style', 'width: 600px; height: 600px;background: white;position: absolute;outline: 0;left: 0;top: 0px;z-index: 1120;');
            var mapDiv = document.getElementById(mapDiv);
            if (mapDiv) {
                mapDiv.parentElement.appendChild(div);
            } else {
                document.body.appendChild(div);
            }
        },
        */
    /**
     * 显示的高峰图的最大层级
     * 如果配置项设置了最大层级，取改值和数据确定的最大层级较小值
     * 如果没有设置最大层级，取默认最大层级和数据确定的最大层级较小值
     * @param  {[type]} config [description]
     * @return {[type]}        [description]
     */
    _getMaxLevel: function(config) {
        var defaultMaxLevel = 7;
        var maxLevelConfig = config.maxLevel || defaultMaxLevel;
        var maxLevelByDatas = this._getLevelByDatasLength(config.datas.length);
        return Math.min(maxLevelConfig, maxLevelByDatas);
    },
    /**
     * 获取canvas的最小尺寸
     * @param  {[type]} config [description]
     * @return {[type]}        [description]
     */
    /*
        _getMinCanvasSize: function(config) {
            var size = config.size || 50;
            var r = size / 4;
            var maxLevel = this._getMaxLevel(config);
            var minWidth = 2 * (4 * r * (maxLevel + 1));
            var minHeight = 2 * (3 * r * maxLevel + 4 * r);
            // 还要加上padding和margin的值
            return { w: minWidth, h: minHeight };
        },
        */
    /**
     * 设置包含canvas的div的位置
     * @param {[type]} config [description]
     */
    /*
        _setPosition: function(config) {
            //var startPx = config.startPx || { x: 250, y: 250 };
            var startPx = this.map.getViewPortPxFromLonLat(config.lonlat);
            var width = Math.ceil(this.zr.getWidth());
            var height = Math.ceil(this.zr.getHeight());
            //var mainDiv = document.getElementById(this.mainId);
            var mainDiv = this.honeydiv;
            if (mainDiv === null) {
                return;
            }
            mainDiv.style.top = startPx.y - height / 2 + 'px';
            mainDiv.style.left = startPx.x - width / 2 + 'px';
            //mainDiv.style.top = startPx.y +'px';
            //mainDiv.style.left = startPx.x + 'px';

            // var mainSize = this._getMinCanvasSize(config);
            // mainDiv.style.width = mainSize.w + 'px';
            // mainDiv.style.height = mainSize.h + 'px';

            // var mainSize = this._getMinCanvasSize(config);
            // var startPx = config.startPx || { x: 50, y: 50 };
            // // var width = Math.ceil(this.zr.getWidth());
            // // var height = Math.ceil(this.zr.getHeight());
            // var mainDiv = document.getElementById(this.mainId);
            // if (mainDiv === null) {
            //     return;
            // }
            // mainDiv.style.top = startPx.y - mainSize.h / 2 + 'px';
            // mainDiv.style.left = startPx.x - mainSize.w / 2 + 'px';

            // mainDiv.style.width = mainSize.w + 'px';
            // mainDiv.style.height = mainSize.h + 'px';
        },
        */
    /**
     * 构建中心点图片路径
     * @param  {[type]} zr     [description]
     * @param  {[type]} config [description]
     * @param  {[type]} ox     [description]
     * @param  {[type]} oy     [description]
     * @return {[type]}        [description]
     */
    _buildImgPath: function(zr, config, ox, oy) {
        var size = config.size || 50;
        var r = size / 4;
        var x = ox - r;
        var y = oy - r;
        // 图片
        zr.addShape({
            shape: 'image',
            id: zr.newShapeId('image'),
            style: {
                x: x,
                y: y,
                image: "../images/favicon.png",
                width: 2 * r,
                height: 2 * r,
                color: 'red',
                // text: 'imageText',
                textColor: 'black',
                clickable: false
            },
            draggable: false
        });
    },
    /**
     * 构建蜂窝路径
     * @param  {[type]} zr     [zrender对象]
     * @param  {[type]} config [配置数据]
     * @param  {[type]} x      [蜂窝中间点的x轴坐标]
     * @param  {[type]} y      [蜂窝中间点的y轴坐标]
     * @return {[type]}        [无返回值]
     */
    _buildPath: function(zr, config, x, y, isAnimate) {
        var size = config.size;
        var opacity = config.opacity || 0.6;
        var maxLevel = this._getMaxLevel(config);
        // 坐标数据
        var positionDatas = this._calcPosition(x, y, maxLevel, size);
        var colorIdx = 0;
        // 原始传入的填充数据
        var fillDatas = config.datas;
        // 最终填充数据
        var newfillDatas = this._getFillDatas(fillDatas, positionDatas);
        // 加载的六边形个数
        var num = Math.min(positionDatas.length, newfillDatas.length);
        // 六边形的填充颜色
        var fillColors = this._getFillColors(config, num);
        for (var i = 0; i < num; i++) {
            var positionItem = positionDatas[i];
            var fillItem = newfillDatas[i];
            var fillColor = fillColors[i];
       		var pointList = this._genelPointList(positionItem, size);
            // 六边形
            var myPolygonShape = {
                shape: 'polygon',
                id: zr.newShapeId('star_'),
                nodeData: fillItem,
                style: {
                    x: positionItem.x,
                    y: positionItem.y,
                    r: size,
                    n: 6,
                    brushType: 'both',
                    color: fillColor,
                    strokeColor: Geo.zrColor.getColor(colorIdx++),
                    opacity: opacity,
                    lineWidth: 1,
                    text: fillItem.name + "(" + fillItem.num + ")",
                    textColor: 'black',
                    textPosition: 'inside',
                    pointList: pointList
                },
                hoverable: true,
                draggable: false,
                clickable: true,
                onclick: OpenLayers.Function.bind(this.onclickEvent, this),
                // 旋转角度
                rotation: [Math.PI / 12 * 0, x, y]
            };
            zr.addShape(myPolygonShape);
            if (isAnimate) {
                /*
                    'Linear', 'SinusoidalIn', 'SinusoidalOut', 'SinusoidalInOut', 
                    'ExponentialIn', 'ExponentialOut', 'ExponentialInOut', 
                    'CircularIn', 'CircularOut', 'CircularInOut'
                    */
                zr.animate(myPolygonShape.id, "style", false)
                    .when(0, {
                        x: x,
                        y: y
                    }, 'CircularOut')
                    .when(1000, {
                        x: myPolygonShape.style.x,
                        y: myPolygonShape.style.y
                    }, 'CircularOut')
                    .start();
            }
        }
    },
    /**
     * 生成多边形点集合
     * @param  {[type]} positionItem [description]
     * @param  {[type]} size         [description]
     * @return {[type]}              [description]
     */
    _genelPointList: function(positionItem, size) {
        var r = size / 4;
        var x = positionItem.x;
        var y = positionItem.y;
        var pointList = [];
        pointList.push([x, y - 2 * r]);
        pointList.push([x + 2 * r, y - r]);
        pointList.push([x + r * 2, y + r]);
        pointList.push([x, y + 2 * r]);
        pointList.push([x - 2 * r, y + r]);
        pointList.push([x - 2 * r, y - r]);
        return pointList;
    },
    
    /**
     * 填充数据
     * @param  {[Array]} fillDatas     [原始传入的数据]
     * @param  {[Array]} positionDatas [根据maxLevel构造的坐标数据集]
     * @return {[Array]}               [生成新的填充数据，最后一个用更多表示]
     */
    _getFillDatas: function(fillDatas, positionDatas) {
        var fillDatasLength = fillDatas.length;
        var positionDatasLength = positionDatas.length;
        var newfillDatas;
        if (fillDatasLength <= positionDatasLength) {
            // 所有的都可以展示，不需要做特殊处理
            newfillDatas = fillDatas;
        } else {
            // 多余的不展示，最后一个替换成更多
            newfillDatas = fillDatas.slice(0, positionDatasLength - 1);
            // 更多的id为9999
            newfillDatas.push({ id: 9999, name: '更多' });
        }
        return newfillDatas;
    },
    /**
     * 根据数据集的长度获取最大层级
     * 每层都占满时，层级与总数之间的关系是s=3*level*(level+1)
     * 由于存在最后一层不满的情况，层级又必须是整数，所有用以下方法算出最大层级
     * @param {[type]} length [description]
     */
    _getLevelByDatasLength: function(length) {
        var level = Math.round(Math.sqrt(length / 3));
        return level;
    },
    /**
     * 计算蜂窝中每个六边形的坐标
     * @param  {[int]} ox       [原点x轴坐标]
     * @param  {[int]} oy       [原点y轴坐标]
     * @param  {[int]} maxLevel [最大层级]
     * @param  {[int]} size     [半径]
     * @return {[Array]}        [构成蜂窝的所有六边形坐标及编号数据
     *                             {
     *                                  x: x轴坐标,
     *                                  y: y轴坐标
     *                                  index: 六边形编号，从1开始
     *                                  ...// 可以根据需要自行扩展
     *                             } 
     *                           ]
     * 画图依据：
     *          以给定参考点坐标为原点，向右为x轴正半轴，向下为y轴正半轴；
     *          以右边第一个为起始六边形，顺时针方向旋转；
     *          规律：1.数目规律
     *                  a.第一层6个，第二层12个，第三层18个，
     *                    用数据公式表示为每层的六边形个数为：sl=6*level（其中level表示层级数），
     *                    六边形总数为s=3*level*(level+1)；
     *                  b.其中第一层共6个，x轴正半轴1个，第二象限1个，y轴正半轴0个，第三象限1个，x轴负半轴1个，第四象限1个，y轴负半轴0个，第一象限1个，
     *                    第二层共12个，x轴正半轴1个，第二象限2个，y轴正半轴1个，第三象限2个，x轴负半轴1个，第四象限2个，y轴负半轴1个，第一象限2个，
     *                    第三层共18个，x轴正半轴1个，第二象限4个，y轴正半轴0个，第三象限4个，x轴负半轴1个，第四象限4个，y轴负半轴0个，第一象限4个，                  
     *                    第四层共24个，x轴正半轴1个，第二象限5个，y轴正半轴1个，第三象限5个，x轴负半轴1个，第四象限5个，y轴负半轴1个，第一象限5个，
     *                    用数学公式表示为(个数分布顺序：x轴正半轴，第二象限，y轴正半轴，第三象限，x轴负半轴，第四象限，y轴负半轴，第一象限)：
     *                          奇数层：p=(sl-2)/4 （其中p表示每个象限中六边形的个数，sl表示本层公共的六边形个数sl=6*level；个数分布为：1+p+0+p+1+p+0+p）
     *                          偶数层：p=(sl-4)/4 （其中p表示每个象限中六边形的个数，sl表示本层公共的六边形个数sl=6*level；个数分布为：1+p+1+p+1+p+1+p）
     *                2.坐标规律(r=size/4,size表示设定的六面形边长)
     *                  a.x轴正半轴：x坐标4*r*level，y坐标为0（x坐标为起始坐标也是最大值）
     *                  b.第二象限：最大值依次向左移动六边形的一半，如果y轴超过y坐标最大值，那么该六边形的中心点坐标和上一个六边形y坐标相同，x坐标向左偏移一个六边形
     *                  c.y轴正半轴：x坐标为0，y坐标为3*r*level
     *                  d.第三象限：最大值依次向左移动六边形的一半，如果y轴超过y坐标最大值，那么该六边形的中心点坐标和上一个六边形y坐标相同，x坐标向左偏移一个六边形
     *                  e.x轴负半轴：x坐标-4*r*level，y坐标为0
     *                  f.第四象限：最大值依次向左移动六边形的一半，如果y轴超过y坐标最大值，那么该六边形的中心点坐标和上一个六边形y坐标相同，x坐标向右偏移一个六边形
     *                  g.y轴负半轴：x坐标为0，y坐标为-3*r*level
     *                  h.第一象限：最大值依次向左移动六边形的一半，如果y轴超过y坐标最大值，那么该六边形的中心点坐标和上一个六边形y坐标相同，x坐标向右偏移一个六边形
     * 注:该方法计算坐标的方式依赖myPolygon中六边形的的画法buildPath方法，画法不同计算方式不同。
     */
    _calcPosition: function(ox, oy, maxLevel, size) {
        var r = size / 4;
        var s, p;
        var datas = [];
        var maxX, xStart;
        var maxY;
        var index = 1;
        for (var l = 1; l <= maxLevel; l++) {
            s = 6 * l;
            xStart = maxX = 4 * l * r;
            var lastData;
            maxY = 3 * r * l;
            if (l % 2 === 0) {
                p = (s - 4) / 4;
                datas.push({ x: ox + xStart, y: oy, index: index++ });
                for (var k2 = 1; k2 <= p; k2++) {
                    if (3 * r * k2 <= maxY) {
                        datas.push({ x: ox + xStart - 2 * r * k2, y: oy + 3 * r * k2, index: index++ });
                    } else {
                        // 平级，y坐标相同，x坐标向左偏移4r
                        lastData = datas[datas.length - 1];
                        datas.push({ x: lastData.x - 4 * r, y: lastData.y, index: index++ });
                    }
                }
                datas.push({ x: ox, y: oy + maxY, index: index++ });
                for (var k3 = p; k3 >= 1; k3--) {
                    if (3 * r * k3 <= maxY) {
                        datas.push({ x: ox + 2 * r * k3 - xStart, y: oy + 3 * r * k3, index: index++ });
                    } else {
                        // 平级，y坐标相同，x坐标向左偏移4r
                        lastData = datas[datas.length - 1];
                        datas.push({ x: lastData.x - 4 * r, y: lastData.y, index: index++ });
                    }
                }
                datas.push({ x: ox - xStart, y: oy, index: index++ });
                for (var k4 = 1; k4 <= p; k4++) {
                    if (3 * r * k4 <= maxY) {
                        datas.push({ x: ox + 2 * r * k4 - xStart, y: oy - 3 * r * k4, index: index++ });
                    } else {
                        // 平级，y坐标相同，x坐标向右偏移4r
                        lastData = datas[datas.length - 1];
                        datas.push({ x: lastData.x + 4 * r, y: lastData.y, index: index++ });
                    }
                }
                datas.push({ x: ox, y: oy - maxY, index: index++ });
                for (var k1 = p; k1 >= 1; k1--) {
                    if (3 * r * k1 <= maxY) {
                        datas.push({ x: ox + xStart - 2 * r * k1, y: oy - 3 * r * k1, index: index++ });
                    } else {
                        // 平级，y坐标相同，x坐标向左右偏移4r
                        lastData = datas[datas.length - 1];
                        datas.push({ x: lastData.x + 4 * r, y: lastData.y, index: index++ });
                    }
                }
            } else {
                p = (s - 2) / 4;
                datas.push({ x: ox + xStart, y: oy, index: index++ });
                for (var m2 = 1; m2 <= p; m2++) {
                    if (3 * r * m2 <= maxY) {
                        datas.push({ x: ox + xStart - 2 * r * m2, y: oy + 3 * r * m2, index: index++ });
                    } else {
                        // 平级，y坐标相同，x坐标向左偏移4r
                        lastData = datas[datas.length - 1];
                        datas.push({ x: lastData.x - 4 * r, y: lastData.y, index: index++ });
                    }
                }
                for (var m3 = p; m3 >= 1; m3--) {
                    lastData = datas[datas.length - 1];
                    if (3 * r * m3 <= maxY) {
                        datas.push({ x: ox + 2 * r * m3 - xStart, y: oy + 3 * r * m3, index: index++ });
                    } else {
                        // 平级，y坐标相同，x坐标向左偏移4r
                        lastData = datas[datas.length - 1];
                        datas.push({ x: lastData.x - 4 * r, y: lastData.y, index: index++ });
                    }
                }
                datas.push({ x: ox - xStart, y: oy, index: index++ });
                for (var m4 = 1; m4 <= p; m4++) {
                    if (3 * r * m4 <= maxY) {
                        datas.push({ x: ox + 2 * r * m4 - xStart, y: oy - 3 * r * m4, index: index++ });
                    } else {
                        // 平级，y坐标相同，x坐标向右偏移4r
                        lastData = datas[datas.length - 1];
                        datas.push({ x: lastData.x + 4 * r, y: lastData.y, index: index++ });
                    }
                }
                for (var m1 = p; m1 >= 1; m1--) {
                    if (3 * r * m1 <= maxY) {
                        datas.push({ x: ox + xStart - 2 * r * m1, y: oy - 3 * r * m1, index: index++ });
                    } else {
                        // 平级，y坐标相同，x坐标向右偏移4r
                        lastData = datas[datas.length - 1];
                        datas.push({ x: lastData.x + 4 * r, y: lastData.y, index: index++ });
                    }
                }
            }
        }
        return datas;
    },
    /**
     * 获取颜色
     * 如果配置了颜色就按照外面配置的按照六边形加载的顺序或某种规则取颜色
     * 如果没有配置颜色就按照调色板中的颜色顺序取值
     * @param  {[Object]} config [传入的配置参数]
     * @param  {[int]} num       [需要配置的颜色个数，取加载的六边形个数]
     * @return {[Array]}         [返回颜色值数组]
     */
    _getFillColors: function(config, num) {
        var fillColors = [];
        var configColors = config.fillColors;
        if (configColors && configColors instanceof Array) {
            var length = configColors.length;
            if (length >= num) {
                fillColors = configColors.slice(0, num);
            } else {
                for (var i = 0; i < num; i++) {
                    var remainder = i % length;
                    fillColors.push(configColors[remainder]);
                }
            }
        } else {
            for (var j = 0; j < num; j++) {
                fillColors.push(Geo.zrColor.getColor(j));
            }
        }
        return fillColors;
    },
    /**
     * 画蜂窝图之前检查配置项数据是否符合要求
     * @param  {[String]} mapDiv  map所在div的id
     * @param  {[Object]} config  [外部调用初始化方法init时传入的配置项]
     *
     * 规则：
     *     1.config必填
     *     2.config.datas必须为数组，数组中包含id和name属性
     *     3.config.maxLevel不必填，蜂窝图显示最大层级数，默认为7
     *     4.config.opacity不必填，透明图，默认为0.6
     *     5.config.startPX不必填，中心点坐标，结构为{x:num1,y:num2}，值为数组，默认为{ x: 50, y: 50 }
     *     6.config.mainId不必填，蜂窝图所在div的id，默认为‘geo-online-honeycomb-div’
     *     7.config.size不必填，蜂窝图中六边形的边长，默认为50，单位为px不需要加单位，值为数值
     *     8.config.fillColors不必填，蜂窝图中六边形的填充颜色，默认按调色板上的顺序取传数组，值可以是颜色名或者16进制值吗，如"red"或""#40e0d0
     * @return {[Boolean]}        [true表示校验成功，false表示校验失败]
     */
    /*
        _checkConfigDataBeforeRender: function(mapDiv, config) {
            // 地图id不做强制传入，如果不传入将蜂窝图放在body标签下
            if (!mapDiv) {
                console.log('未传入地图对象id！');
            } else if (!document.getElementById(mapDiv)) {
                console.error('地图对象不存在！');
            } else {
                //继续下一项检查
            }

            if (!config) {
                console.error('请输入配置数据！');
                // mainId: 'main',
                // datas: datas,
                // size: 50,
                // maxLevel: 3,
                // opacity: 0.8,
                // //startPx: startPx
                // startPx: { x: 50, y: 50 }
                return false;
            } else {
                return true;
            }
        }
        */

    /**
     * APIMethod: clear
     * 清除数据。
     */
    clear: function() {
        this.config = null;
        this.zr.clear();
    },

    /**
     * APIMethod: destroy
     * 销毁该对象。
     */
    destroy: function() {
        //清除数据。
        this.zr.clear();

        //取消事件监听。
        this.map.events.un({
            "zoomend": this.updateLayer,
            "moveend": this.updateLayer,
            scope: this
        });
        Geo.View2D.Layer.prototype.destroy.apply(this, arguments);
    },


    CLASS_NAME: "Geo.View2D.Layer.HoneycombLayer"
});/**
 * Class: Geo.View2D.BaseLayerGroup
 * 二维视图的底图图层组对象，可以将多个图层对象组合在一起，进行统一的加载和卸载操作。该图层组中的图层将作为地图中的底图置于所有图层的最下方。
 */
Geo.View2D.BaseLayerGroup = Geo.Class({

    /**
     * APIProperty: id
     * ｛String｝唯一标识符。
     */
    id: null,
    
    /**
     * APIProperty: layers
     * {Array} 图层集合。
     */
    layers: null,
    
    /**
     * APIProperty: map
     * 所属的地图对象。
     */
    map: null,
    
    /**
     * Constructor: Geo.View2D.BaseLayerGroup
     * Geo.View2D.BaseLayerGroup构造函数。
     * 
     * Parameters:
     * options - {Object} 相关选项设置。
     * 	layers - {Array} 必选 图层数组。
     * 示例代码：
     * 
     * (code)
     * var vectorGroup = new Geo.View2D.BaseLayerGroup({
     *      layers: [new Geo.View2D.Layer.GlobeTile("全球1:100万矢量底图", "http://tile0.tianditu.com/services/A0512_EMap", {
     *          transitionEffect: "resize",
     *          topLevel: 2,
     *          bottomLevel: 10,
     *          maxExtent: new Geo.Bounds(-180, -90, 180, 90)
     *      }), new Geo.View2D.Layer.GlobeTile("全球1:100万矢量注记", "http://tile0.tianditu.com/services/AB0512_Anno", {
     *          topLevel: 2,
     *          bottomLevel: 12,
     *          maxExtent: new Geo.Bounds(-180, -90, 180, 90)
     *      })]
     *  });
     * (end)
     * 
     */
    initialize: function(options){
        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        this.layers = [];
        OpenLayers.Util.extend(this, options);
    },
    
    /**
     * APIMethod: setMap
     * 将底图图层组关联到地图对象。
     *
     * Parameters:
     * map - {OpenLayers.Map} 地图对象。
     */
    setMap: function(map){
        if (map && !this.map) {
            this.map = map;
            for (var i = this.layers.length - 1; i >= 0; i--) {
                this.map.insertLayerIndex(this.layers[i], 1);
            }
        }
    },
    
    /**
     * APIMethod: removeMap
     * 解除底图图层组与地图对象的关联。
     */
    removeMap: function(){
        if (this.map) {
            for (var i = 0; i < this.layers.length; i++) {
                var layer = this.layers[i];
                //如果图层已经被移除地图了，则不再被移除
                if(layer.map){
                    this.map.removeLayer(this.layers[i]);
                }
            }
            this.map = null;
        }
    },
    
     
    /**
     * APIMethod: getMaxResolution
     * 获取底图图层组中最大分辨率。
     *
     * Returns:
     * {Float} 分辨率
     */   
    getMaxResolution: function(){
        var layers = this.layers, res = null;
        for (var i = 0; i < layers.length; i++) {
            var layerOptions = layers[i].getOptions();
            var layerMaxRes = layerOptions.maxResolution;
            res = (res == null) ? layerMaxRes : Math.max(res, layerMaxRes);
        }
        return res;
    },
      
    /**
     * APIMethod: getMinResolution
     * 获取底图图层组中最小分辨率。
     *
     * Returns:
     * {Float} 分辨率
     */      
    getMinResolution: function(){
        var layers = this.layers, res = null;
        for (var i = 0; i < layers.length; i++) {
            var layerOptions = layers[i].getOptions();
            var layerMinRes = layerOptions.minResolution;
            res = (res == null) ? layerMinRes : Math.min(res, layerMinRes);
        }
        return res;
    },
      
    /**
     * APIMethod: getMaxExtent
     * 获取底图图层组中最大范围。
     *
     * Returns:
     * {Float} 范围
     */     
    getMaxExtent: function(){
        var bounds = null;
        for (var i = 0; i < this.layers.length; i++) {
            if (bounds) {
                bounds.extend(this.layers[i].getDataExtent());
            }
            else {
                bounds = this.layers[i].getDataExtent();
            }
        }
        return bounds;
    },
    
    /**
     * APIMethod: destroy
     * 销毁对象。
     *
     */
    destroy: function(){
		this.removeMap();
        for (var i = 0; i < layers.length; i++) {
            layers[i].destroy();
        }
		this.layers = null;
    },
    
    CLASS_NAME: "Geo.View2D.BaseLayerGroup"

});

Geo.View2D.BaseLayerGroup.getTianDiTuGroup = function(type, options){
    
    //TODO: 让Geo.View2D.BaseLayerGroup.getTianDiTuGroup支持更多设置选项
    //须将服务信息与图层对象的实例化分离
    
    /*
     * 服务相关信息定义
     * 1.影像层有缩放效果，标记层没有
     * 2.可以设置是否使用镜像服务地址，提高瓦片读取效率
     * 3.实际服务地址根据服务名和主机地址拼出
     */
    var serviceInfo = {
        "img":[
            {
                title:"全球影像底图(2-10)",
                serviceName: "sbsm0210",
                transitionEffect: "resize",
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180, -90, 180, 90),
                isMirror: true
            },{
                title:"全球影像注记(2-10)",
                serviceName: "A0610_ImgAnno",
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180, -90, 180, 90),
                isMirror: true
            }
            
        ],
        "dlg":[]
    };
    
    var typeMapping = {
        "img":[
            new Geo.View2D.Layer.GlobeTile("全球影像底图(2-10)", "http://tile0.tianditu.com/services/sbsm0210", {
                transitionEffect: "resize",
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180, -90, 180, 90),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/sbsm0210",
    				"http://tile1.tianditu.com/services/sbsm0210",
    				"http://tile2.tianditu.com/services/sbsm0210",
    				"http://tile3.tianditu.com/services/sbsm0210",
    				"http://tile4.tianditu.com/services/sbsm0210",
    				"http://tile5.tianditu.com/services/sbsm0210",
    				"http://tile6.tianditu.com/services/sbsm0210",
    				"http://tile7.tianditu.com/services/sbsm0210"
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全球影像注记(2-10)", "http://tile0.tianditu.com/services/A0104_ImgAnnoE", {
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180, -90, 180, 90),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/A0610_ImgAnno",
                    "http://tile1.tianditu.com/services/A0610_ImgAnno",
    				"http://tile2.tianditu.com/services/A0610_ImgAnno",
    				"http://tile3.tianditu.com/services/A0610_ImgAnno",
    				"http://tile4.tianditu.com/services/A0610_ImgAnno",
    				"http://tile5.tianditu.com/services/A0610_ImgAnno",
    				"http://tile6.tianditu.com/services/A0610_ImgAnno",
    				"http://tile7.tianditu.com/services/A0610_ImgAnno"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国影像(14)", "http://tile0.tianditu.com/services/eastdawnall", {
                transitionEffect: "resize",
                topLevel: 14,
                bottomLevel: 14,
                maxExtent: new Geo.Bounds(73.30078125,17.9296875,135.17578125,53.701171875),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/eastdawnall",
                    "http://tile1.tianditu.com/services/eastdawnall",
    				"http://tile2.tianditu.com/services/eastdawnall",
    				"http://tile3.tianditu.com/services/eastdawnall",
    				"http://tile4.tianditu.com/services/eastdawnall",
    				"http://tile5.tianditu.com/services/eastdawnall",
    				"http://tile6.tianditu.com/services/eastdawnall",
    				"http://tile7.tianditu.com/services/eastdawnall"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全球影像(15-18)", "http://tile0.tianditu.com/services/sbsm1518", {
                transitionEffect: "resize",
                topLevel: 15,
                bottomLevel: 18,
                maxExtent: new Geo.Bounds(-180, -90, 180, 90),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/sbsm1518",
                    "http://tile1.tianditu.com/services/sbsm1518",
    				"http://tile2.tianditu.com/services/sbsm1518",
    				"http://tile3.tianditu.com/services/sbsm1518",
    				"http://tile4.tianditu.com/services/sbsm1518",
    				"http://tile5.tianditu.com/services/sbsm1518",
    				"http://tile6.tianditu.com/services/sbsm1518",
    				"http://tile7.tianditu.com/services/sbsm1518"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国影像(13)", "http://tile0.tianditu.com/services/e13", {
                transitionEffect: "resize",
                topLevel: 13,
                bottomLevel: 13,
                maxExtent: new Geo.Bounds(73.30078125,17.9736328125,135.1318359375,53.6572265625),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/e13",
                    "http://tile1.tianditu.com/services/e13",
    				"http://tile2.tianditu.com/services/e13",
    				"http://tile3.tianditu.com/services/e13",
    				"http://tile4.tianditu.com/services/e13",
    				"http://tile5.tianditu.com/services/e13",
    				"http://tile6.tianditu.com/services/e13",
    				"http://tile7.tianditu.com/services/e13"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国影像(12)", "http://tile0.tianditu.com/services/e12", {
                transitionEffect: "resize",
                topLevel: 12,
                bottomLevel: 12,
                maxExtent: new Geo.Bounds(73.30078125,17.9296875,135.17578125,53.701171875),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/e12",
                    "http://tile1.tianditu.com/services/e12",
    				"http://tile2.tianditu.com/services/e12",
    				"http://tile3.tianditu.com/services/e12",
    				"http://tile4.tianditu.com/services/e12",
    				"http://tile5.tianditu.com/services/e12",
    				"http://tile6.tianditu.com/services/e12",
    				"http://tile7.tianditu.com/services/e12"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国影像(11)", "http://tile0.tianditu.com/services/e11", {
                transitionEffect: "resize",
                topLevel: 11,
                bottomLevel: 11,
                maxExtent: new Geo.Bounds(73.30078125,17.9296875,135.17578125,53.7890625),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/e11",
                    "http://tile1.tianditu.com/services/e11",
    				"http://tile2.tianditu.com/services/e11",
    				"http://tile3.tianditu.com/services/e11",
    				"http://tile4.tianditu.com/services/e11",
    				"http://tile5.tianditu.com/services/e11",
    				"http://tile6.tianditu.com/services/e11",
    				"http://tile7.tianditu.com/services/e11"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国影像注记(11-14)", "http://tile0.tianditu.com/services/B0530_eImgAnno", {
                topLevel: 11,
                bottomLevel: 14,
                maxExtent: new Geo.Bounds(73.4765625,2.8125,135.439453125,53.7890625),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/B0530_eImgAnno",
                    "http://tile1.tianditu.com/services/B0530_eImgAnno",
    				"http://tile2.tianditu.com/services/B0530_eImgAnno",
    				"http://tile3.tianditu.com/services/B0530_eImgAnno",
    				"http://tile4.tianditu.com/services/B0530_eImgAnno",
    				"http://tile5.tianditu.com/services/B0530_eImgAnno",
    				"http://tile6.tianditu.com/services/B0530_eImgAnno",
    				"http://tile7.tianditu.com/services/B0530_eImgAnno"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国影像注记(15-18)", "http://tile0.tianditu.com/services/siweiAnno68", {
                topLevel: 15,
                bottomLevel: 18,
                maxExtent: new Geo.Bounds(73.4765625,2.8125,135.439453125,53.7890625),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/siweiAnno68",
                    "http://tile1.tianditu.com/services/siweiAnno68",
    				"http://tile2.tianditu.com/services/siweiAnno68",
    				"http://tile3.tianditu.com/services/siweiAnno68",
    				"http://tile4.tianditu.com/services/siweiAnno68",
    				"http://tile5.tianditu.com/services/siweiAnno68",
    				"http://tile6.tianditu.com/services/siweiAnno68",
    				"http://tile7.tianditu.com/services/siweiAnno68"
    				
                ]
            })
        ],"dlg":[
            new Geo.View2D.Layer.GlobeTile("全国矢量(2-10)", "http://tile0.tianditu.com/services/A0512_EMap", {
                transitionEffect: "resize",
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180,-90,180,90),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/A0512_EMap",
                    "http://tile1.tianditu.com/services/A0512_EMap",
    				"http://tile2.tianditu.com/services/A0512_EMap",
    				"http://tile3.tianditu.com/services/A0512_EMap",
    				"http://tile4.tianditu.com/services/A0512_EMap",
    				"http://tile5.tianditu.com/services/A0512_EMap",
    				"http://tile6.tianditu.com/services/A0512_EMap",
    				"http://tile7.tianditu.com/services/A0512_EMap"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国矢量注记(2-10)", "http://tile0.tianditu.com/services/AB0512_Anno", {
                topLevel: 2,
                bottomLevel: 10,
                maxExtent: new Geo.Bounds(-180,-90,180,90),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/AB0512_Anno",
                    "http://tile1.tianditu.com/services/AB0512_Anno",
    				"http://tile2.tianditu.com/services/AB0512_Anno",
    				"http://tile3.tianditu.com/services/AB0512_Anno",
    				"http://tile4.tianditu.com/services/AB0512_Anno",
    				"http://tile5.tianditu.com/services/AB0512_Anno",
    				"http://tile6.tianditu.com/services/AB0512_Anno",
    				"http://tile7.tianditu.com/services/AB0512_Anno"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国矢量(11-12)", "http://tile0.tianditu.com/services/B0627_EMap1112", {
                transitionEffect: "resize",
                topLevel: 11,
                bottomLevel: 12,
                maxExtent: new Geo.Bounds(69.9609375,0.87890625,879.9609375,56.25),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/B0627_EMap1112",
                    "http://tile1.tianditu.com/services/B0627_EMap1112",
    				"http://tile2.tianditu.com/services/B0627_EMap1112",
    				"http://tile3.tianditu.com/services/B0627_EMap1112",
    				"http://tile4.tianditu.com/services/B0627_EMap1112",
    				"http://tile5.tianditu.com/services/B0627_EMap1112",
    				"http://tile6.tianditu.com/services/B0627_EMap1112",
    				"http://tile7.tianditu.com/services/B0627_EMap1112"
    				
                ]
            }),
            new Geo.View2D.Layer.GlobeTile("全国矢量(13-18)", "http://tile0.tianditu.com/services/siwei0608", {
                transitionEffect: "resize",
                topLevel: 13,
                bottomLevel: 18,
                maxExtent: new Geo.Bounds(-180,-90,180,90),
                mirrorUrl:[
                    "http://tile0.tianditu.com/services/siwei0608",
                    "http://tile1.tianditu.com/services/siwei0608",
    				"http://tile2.tianditu.com/services/siwei0608",
    				"http://tile3.tianditu.com/services/siwei0608",
    				"http://tile4.tianditu.com/services/siwei0608",
    				"http://tile5.tianditu.com/services/siwei0608",
    				"http://tile6.tianditu.com/services/siwei0608",
    				"http://tile7.tianditu.com/services/siwei0608"
    				
                ]
            })
        ]
    };
    
    var layers = typeMapping[type];
    if(layers){
        return new Geo.View2D.BaseLayerGroup({layers: layers});
    }
    return null;
};

//获取天地图图层组。
Geo.View2D.BaseLayerGroup.getTDTGroup = function(type, options){
    if(type == null || type == undefined || type == ""){
		type = "vec";
	}
	var pyramid = new Geo.Pyramid();
	//比例尺转分辨率
//	function getRes(scales) {
//		var res = [];
//		var scaleStr = scales.split(",");
//		for(var i = 0, j = scaleStr.length; i < j;i++) {
//			res.push(pyramid.getResolutionForScale(parseFloat(scaleStr[i])));
//		}
//		return res;
//	}
//	var scales = "2.958293554545656E8,1.479146777272828E8,7.39573388636414E7,3.69786694318207E7,1.848933471591035E7,9244667.357955175,4622333.678977588,2311166.839488794,1155583.419744397,577791.7098721985,288895.85493609926,144447.92746804963,72223.96373402482,36111.98186701241,18055.990933506204,9027.995466753102,4513.997733376551,2256.998866688275";
//	var resolutions = getRes(scales);
	
	var resolutions = pyramid.getResolutions();
    /*
     * 服务相关信息定义
     */
    var serviceInfo = {
        "vec": [{
			url: [
                "http://t0.tianditu.com/vec_c/wmts",
                "http://t1.tianditu.com/vec_c/wmts",
                "http://t2.tianditu.com/vec_c/wmts",
                "http://t3.tianditu.com/vec_c/wmts",
                "http://t4.tianditu.com/vec_c/wmts",
                "http://t5.tianditu.com/vec_c/wmts",
                "http://t6.tianditu.com/vec_c/wmts",
                "http://t7.tianditu.com/vec_c/wmts"
			],
            name: "1-18级WMTS矢量底图",//名称
            style: "default",//样式标识
            layer: "vec",//图层标识
            format: "tiles",//数据格式
            matrixSet: "c",//矩阵集名称
            zoomOffset: 1,//地图级别偏移量
            resolutions: resolutions.slice(1, 19),//分辨率，取索引1至18的值的数组。
            maxResolution: resolutions[1],//最大分辨率
            minResolution: resolutions[18],//最小分辨率
            tileFullExtent: Geo.Bounds.fromString("-180.0,-90.0,180.0,90.0")//图层范围
		},{
			url: [
                "http://t0.tianditu.com/cva_c/wmts",
                "http://t1.tianditu.com/cva_c/wmts",
                "http://t2.tianditu.com/cva_c/wmts",
                "http://t3.tianditu.com/cva_c/wmts",
                "http://t4.tianditu.com/cva_c/wmts",
                "http://t5.tianditu.com/cva_c/wmts",
                "http://t6.tianditu.com/cva_c/wmts",
                "http://t7.tianditu.com/cva_c/wmts"
			],
            name: "1-18级WMTS矢量中文注记",//名称
            style: "default",//样式标识
            layer: "cva",//图层标识
            format: "tiles",//数据格式
            matrixSet: "c",//矩阵集名称
            zoomOffset: 1,//地图级别偏移量
            resolutions: resolutions.slice(1, 19),//分辨率
            maxResolution: resolutions[1],//最大分辨率
            minResolution: resolutions[18],//最小分辨率
            tileFullExtent: Geo.Bounds.fromString("-180.0,-90.0,180.0,90.0")//图层范围
		}],
        "img": [{
			url: [
                "http://t0.tianditu.com/img_c/wmts",
                "http://t1.tianditu.com/img_c/wmts",
                "http://t2.tianditu.com/img_c/wmts",
                "http://t3.tianditu.com/img_c/wmts",
                "http://t4.tianditu.com/img_c/wmts",
                "http://t5.tianditu.com/img_c/wmts",
                "http://t6.tianditu.com/img_c/wmts",
                "http://t7.tianditu.com/img_c/wmts"
			],
            name: "1-18级WMTS影像底图",//名称
            style: "default",//样式标识
            layer: "img",//图层标识
            format: "tiles",//数据格式
            matrixSet: "c",//矩阵集名称
            zoomOffset: 1,//地图级别偏移量
            resolutions: resolutions.slice(1, 19),//分辨率
            maxResolution: resolutions[1],//最大分辨率
            minResolution: resolutions[18],//最小分辨率
            tileFullExtent: Geo.Bounds.fromString("-180.0,-90.0,180.0,90.0")//图层范围
        }, {
			url: [
                "http://t0.tianditu.com/cia_c/wmts",
                "http://t1.tianditu.com/cia_c/wmts",
                "http://t2.tianditu.com/cia_c/wmts",
                "http://t3.tianditu.com/cia_c/wmts",
                "http://t4.tianditu.com/cia_c/wmts",
                "http://t5.tianditu.com/cia_c/wmts",
                "http://t6.tianditu.com/cia_c/wmts",
                "http://t7.tianditu.com/cia_c/wmts"
			],
            name: "1-18级WMTS影像注记底图",//名称
            style: "default",//样式标识
            layer: "cia",//图层标识
            format: "tiles",//数据格式
            matrixSet: "c",//矩阵集名称
            zoomOffset: 1,//地图级别偏移量
            resolutions: resolutions.slice(1, 19),//分辨率
            maxResolution: resolutions[1],//最大分辨率
            minResolution: resolutions[18],//最小分辨率
            tileFullExtent: Geo.Bounds.fromString("-180.0,-90.0,180.0,90.0")//图层范围
        }]
    };
    
	var layers = [];
	if(serviceInfo[type]){
	    for (var i = 0; i < serviceInfo[type].length; i++) {
	    	layers.push(new Geo.View2D.Layer.WMTS(serviceInfo[type][i]));
	    }
	}
	/*
    var typeMapping = {
		"vec": [
            new Geo.View2D.Layer.WMTS(serviceInfo["vec"][0]),
            new Geo.View2D.Layer.WMTS(serviceInfo["vec"][1])
        ],
        "img":[
            new Geo.View2D.Layer.WMTS(serviceInfo["img"][0]),
            new Geo.View2D.Layer.WMTS(serviceInfo["img"][1])
        ]
    };
    
    var layers = typeMapping[type];
    */
    if(layers && layers.length > 0){
        return new Geo.View2D.BaseLayerGroup({layers: layers});
    }
    return null;
};
//此类已被废弃，推荐使用Geo.View2D.BaseLayerGroup代替
Geo.View2D.LayerGroup = Geo.View2D.BaseLayerGroup;


/**
 * Class: Geo.View2D.FeatureManager
 * 二维视图要素管理器。提供了与矢量要素相关的一系列功能。支持对同一矢量图层上的要素进行分类管理，包含矢量图层样式设置、
 * 要素选择功能、要素浮云显示、要素集客户端分页等功能。
 */
Geo.View2D.FeatureManager = Geo.Class({
	
    /**
     * APIProperty: id
     * {String} 唯一标识。
     */
    id: null,	
    
    /**
     * APIProperty: map
     * {<Geo.View2D.Map>} 所属的地图对象。
     */
    map: null,
	
	//结果类型映射
	_typeMapping: null,
	
	/**
     * APIProperty: featureSortField
     * {String} 标识要素分类的属性名，默认为"featureSort"。
     */
	featureSortField: "featureSort",

	/**
     * APIProperty: orderNumberField
     * {String} 标识要素序号的属性名，默认为"orderNumber"。
     */	
	orderNumberField: "orderNumber",

	/**
     * APIProperty: styleMap
     * {<Geo.StyleMap>} 矢量图层样式。
     */	
	styleMap: null,
    
	/**
     * APIProperty: vectorLayerOptions
     * {Object} 矢量图层对象构造参数。
     */		
	vectorLayerOptions: null,    

	/**
     * APIProperty: vectorLayer
     * {<Geo.View2D.Layer.Vector>} 矢量图层。
     */		
	vectorLayer: null,

	/**
     * APIProperty: selectControlOptions
     * {Object} 要素选择控件对象构造参数。
     */	
	selectControlOptions: null,

	/**
     * APIProperty: selectControl
     * {<Geo.View2D.Control.SelectFeature>} 矢量要素选择控件。
     */	
	selectControl: null,

	/**
     * APIProperty: maxFeaturesPerPage
     * {Integer} 默认的要素分页数量，默认值是15。
     */	
	maxFeaturesPerPage: 15,

    //提示框样式CSS类名。
	topicCSSClass: null,
	
    //提示框div
	topicDiv: null,

    /**
     * Constructor: Geo.View2D.FeatureManager
     * Geo.View2D.FeatureManager对象构造函数。
     * 
     * Parameters:
     * options - {Object} 相关选项设置。
     */
	initialize: function(options){
		this._typeMapping = {};
		this.styleMap = Geo.View2D.FeatureManager.defaultStyleMap;
		this.registerResultType("default");
		OpenLayers.Util.extend(this, options);
	},
	
	/**
     * APIMethod: setMap
     * 将要素管理器关联到相应的二维视图对象。在关联到二维视图对象时,会在二维视图对象中
     * 加入一个矢量图层和选择控件，矢量图层和选择控件的引用可以通过访问vectorLayer和
     * selectControl属性的获得。
     *
     * Parameters:
     * map - {<Geo.View2D.Map>} 地图对象。
     */
	setMap: function(map){
		if(map && !this.map){
			this.map = map;
			
			//添加结果图层
			this.vectorLayer = new OpenLayers.Layer.Vector("GeoGlobeFeatureManagerVector", {
				styleMap: this.styleMap,
				isOnTop: true,
				displayInLayerSwitcher: false,
				//要素的显示级别设置为开启状态，默认为false
				rendererOptions: {zIndexing: true}
			});
			this.map.addLayer(this.vectorLayer);
			this._initSelectControl();
			this._addTopicDiv();
		}
	},

	/**
     * APIMethod: registerFeatureSort
     * 注册要素类别。如果希望对多个分类的要素进行管理，则需要先注册要素类别加以区分，
     * 然后再调用addFeatures方法向分类中添加要素集。
     *
     * Parameters:
     * sort - {String} 要素分类。
     * options - {Object} 参数设置。
     */	
    registerFeatureSort: function(sort,options){
		var DEFAULT_PARAMS = {
			features:[],
			currentPage:0,
			maxFeaturesPerPage: this.maxFeaturesPerPage,
			onTurnToPage: this.onTurnToPage,
			onFeatureSelect: Geo.View2D.FeatureManager.showFramedCloud,
			onFeatureUnselect: Geo.View2D.FeatureManager.closeFramedCloud,
			onFeatureOver: Geo.View2D.FeatureManager.showTopic,
			onFeatureOut: Geo.View2D.FeatureManager.closeTopic
		};
		this._typeMapping[sort] = OpenLayers.Util.extend(DEFAULT_PARAMS,options);        
    }, 
     
    //此方法已被废弃，推荐使用registerResultSort
	registerResultType: function(type,options){
        this.registerFeatureSort(type,options);
	},
	
	/**
     * APIMethod: addFeatures
     * 向类别中添加要素，要素添加到类别后将在要素的外部属性中加上类型标识。
     *
     * Parameters:
     * features - {Array(<Geo.Feature.Vector>)} 添加的要素数组。
     * sort - {String} 要素类别。
     * isAppend - {Boolean} 是否追加要素。
     */		
	addFeatures: function(features,sort,isAppend){
		sort = sort || "default";
		if(!(Geo.Util.isArray(features))) {
			features = [features];
		}
		if(this._typeMapping[sort]){
			var features =  this._addTypeMarker(features,sort);
			
			//为要素添加自定义样式
			var style = this._typeMapping[sort].style;
			if(style){
				this._addStyleForFeatures(features,style);
			}
			
			if(!isAppend){
				this.clearResultFromMap(sort);
				this._typeMapping[sort].features = features;
			} else {
				this._typeMapping[sort].features = this._typeMapping[sort].features.concat(features);
			}
			this._typeMapping[sort].currentPage = 0;
		}
	},
	
	/**
	 * APIMethod: onTurnToPage
	 * 获取当前页的要素，本方法需要用户自己去覆盖。
	 * 
	 */
	onTurnToPage: function(feature){
		
	},
	
	/**
     * APIMethod: turnToPageN。
     * 翻到指定页数。
     *
     * Parameters:
     * page - {Integer} 当前第几页。
     * sort - {String} 要素类别。
     * isDrawToMap - {Boolean} 是否绘制到地图上。
     */	
	turnToPageN: function(page, sort, isDrawToMap){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];

		var pageNum = this.getTotalPageNumber(sort);
		page = (page <= 0) ? 1 : page;
		page = (page > pageNum) ? pageNum : page; 
				
		var features = this._pagingFeatures({
			maxPerPage: mapping.maxFeaturesPerPage,
			pageNum:page,
			resultArr:mapping.features
		});
		
		this.addOrderForFeatures(features);
				
		if(page !== mapping.currentPage){
			this.clearResultFromMap(sort);
			this.drawFeaturesToMap(features);
			mapping.currentPage = page;
		}
		mapping.onTurnToPage(features);
		
		return features;
	},
	
	/**
     * APIMethod: turnToFirst
     * 翻到首页。
     *
     * Parameters:
     * sort - {String} 要素类别。
     * isDrawToMap - {Boolean} 是否绘制到地图上。
     */		
	turnToFirst: function(sort, isDrawToMap){
		sort = sort || "default";
		return this.turnToPageN(1,sort, isDrawToMap);
	},
	
	/**
     * APIMethod: turnToNext
     * 翻到下页。
     *
     * Parameters:
     * sort - {String} 要素类别。
     * isDrawToMap - {Boolean} 是否绘制到地图上。
     */		
	turnToNext: function(sort, isDrawToMap){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		return this.turnToPageN(mapping.currentPage + 1, sort, isDrawToMap);
	},
	
	/**
     * APIMethod: turnToPre
     * 翻到前页。
     *
     * Parameters:
     * sort - {String} 要素类别。
     * isDrawToMap - {Boolean} 是否绘制到地图上。
     */		
	turnToPre: function(sort, isDrawToMap){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		return this.turnToPageN(mapping.currentPage - 1, sort, isDrawToMap);
	},
	
	/**
     * APIMethod: turnToLast
     * 翻到尾页。
     *
     * Parameters:
     * sort - {String} 要素类别。
     * isDrawToMap - {Boolean} 是否绘制到地图上。
     */		
	turnToLast: function(sort, isDrawToMap){
		sort = sort || "default";
		var last = this.getTotalPageNumber(sort);
		this.turnToPageN(last, sort, isDrawToMap);
	},
	
	/**
     * APIMethod: getPageInfo
     * 获取分页相关情况。
     *
     * Parameters:
     * sort - {String} 要素类别。
     */		
	getPageInfo: function(sort){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		var features = mapping.features;
		return Math.ceil(features.length / mapping.maxFeaturesPerPage);
	},
	
	/**
     * APIMethod: getTotalPageNumber
     * 获取指定类别的要素分页页数。
     *
     * Parameters:
     * sort - {String} 要素类别。
     */			
	getTotalPageNumber: function(sort){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		var features = mapping.features;
		return Math.ceil(features.length / mapping.maxFeaturesPerPage);
	},
	
	/**
     * APIMethod: getFeatures
     * 获取指定结果类型的要素。
     *
     * Parameters:
     * sort - {String} 要素类别。
     */		
	getFeatures: function(sort){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		if(mapping && mapping.features) {
			return mapping.features;
		}else {
			return [];
		}
	},
	
	/**
     * APIMethod: drawFeaturesToMap
     * 将要素绘制到地图上，可以是指定类型或指定要素数组。
     *
     * Parameters:
     * content - {String|Array(<Geo.Feature.Vector>)} 要素类别。
     */		
	drawFeaturesToMap: function(content){
		var map, layer, features;
		map = this.map;
		layer = this.vectorLayer;
		
		if( typeof(content) == "string"){
			var sort = content || "default";
			if(this._typeMapping[sort] && map){
				features = this.getFeatures(sort);
			}

		};
		
		if( content instanceof  Array){
			features = content;
		};
		layer.addFeatures(features);
        
        var dataExtent = layer.getDataExtent();
        if(dataExtent){
            layer.map.zoomToExtent(dataExtent);
        }
	},
	
	/**
     * APIMethod: selectFeatureById
     * 通过ID来指定要素,通过选择控件来选择。
     *
     * Parameters:
     * featureid - {String} 要素类别。
     */	
	selectFeatureById: function(featureid){
		this.selectControl.unselectAll();
		var feature = this.vectorLayer.getFeatureById(featureid);
		//重绘的目的是为了解决点重叠的问题
		this.vectorLayer.drawFeature(feature);
		this.selectControl.select(feature);
		feature.selectControl = this.selectControl;
	},

	/**
     * APIMethod: clearFeatureFromMap
     * 清除指定类别要素,如无指定类别则默认清除"default"类别，如果指定值为"allType"则清除所有分类要素。
     *
     * Parameters:
     * sort - {String} 要素类别。
     */		
	clearFeatureFromMap: function(sort){		
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		var features;
		var layer = this.vectorLayer;
		if(sort == "allType"){
			features = this.vectorLayer.features;
		} else {
			features = mapping ? mapping.features : [];
		}
		
		if(layer){
			this.selectControl.unselectAll();
			layer.removeFeatures(features);
		}
		
		
	},

    //此方法被废弃，推荐使用clearFeatureFromMap
	clearResultFromMap: function(sort){		
		this.clearFeatureFromMap(sort);
	},
    
	/**
     * APIMethod: clearFeatures
     * 清除指定类型结果要素,如无指定类型则默认清除"default"类型，如果指定值为"allType"则清除所有分类要素。
     *
     * Parameters:
     * sort - {String} 要素类别。
     */	
    clearFeatures: function(sort){
        sort = sort || "default";
        var mapping = this._typeMapping[sort];
        if(mapping){
            this.clearResultFromMap(sort);
            mapping.features = [];
        }
    },

    //此方法被废弃，推荐使用clearFeatures
    clearResult: function(sort){
        this.clearFeatures(sort);
    },
	
	/**
     * APIMethod: addOrderForFeatures
     * 为要素数组中每个要素按顺序添加编号，编号是记录在“orderNumberField”属性指定的要素。
     * 外部属性中。
     *
     * Parameters:
     * features - {Array<Geo.Feature.Vector>} 要素数组。
     * 
     * Returns:
     * {Array<Geo.Feature.Vector>}
     */	
	addOrderForFeatures: function(features){
		//添加带序号的结果图标
	    for (var i = 0; i < features.length; i++) {
	        features[i].attributes[this.orderNumberField] = i;
	    }
		return features;
	},
	
	//为要素加上样式
	_addStyleForFeatures: function(features, style){
		for(var i=0; i<features.length; i++){
			var f = features[i];
			if(!f.style){
				f.style = style;
			}
		}
	},
	
	//为每个要素添加类型标识属性
	_addTypeMarker: function(features,type){
		for(var i=0; i<features.length; i++){
			var feature = features[i];
			feature.attributes[this.featureSortField] = type;
		}
		return features;
	},
	
	_addTopicDiv: function(){
		var mapid = this.map.id;
		var topicDiv = OpenLayers.Util.getElement(mapid + "featureManagerTopic");
		if(!topicDiv){
			topicDiv = document.createElement("div");
			if(!this.topicCSSClass){
				topicDiv.style.backgroundColor = "#fff";
				topicDiv.style.border = "1px solid #000";
				topicDiv.style.padding = "3px";
				topicDiv.style.position = "absolute";
				topicDiv.style.top = "30px";
				topicDiv.style.left = "30px";
				topicDiv.style.display = "none"
				topicDiv.innerHTML = "test";
				
			}
			this.map.div.appendChild(topicDiv);
			this.topicDiv = topicDiv;
		}
		
	},

	
	/**
	 * 对指定结果要素数组进行分页处理。
	 * options示例:
	 * {
	 * 		maxPerPage:15,
	 * 		pageNum:1,
	 * 		resultArr:[]
	 * }
	 */
	_pagingFeatures: function(options){
	    var start, end, 
			maxPerPage = options.maxPerPage, 
			pageNum = options.pageNum, 
			resultArr = options.resultArr;
	    start = (pageNum - 1) * maxPerPage;
	    end = pageNum * maxPerPage - 1;
	    
		var features = resultArr.slice(start, end + 1);
	    
	    
	    
	    return features;
	},
	
	//根据事件类型分派事件
	_dispatchEvent: function(scope,feature,eventType){
		var resultType = feature.attributes[scope.featureSortField];
		var mapping = scope._typeMapping[resultType];
		mapping[eventType](feature);
	},
	
	//激活选择控件,自动检查是否控件初始化
	_initSelectControl: function(){
		if(!this.map){
			return;
		}
		if(!this.selectControl){
			var DEFAULT_OPTIONS = {
				onSelect: OpenLayers.Function.bind(function(feature){
					this._dispatchEvent(this,feature,"onFeatureSelect");
				},this),
				onUnselect: OpenLayers.Function.bind(function(feature){
					this._dispatchEvent(this,feature,"onFeatureUnselect");
				},this),
				callbacks:{
					over: OpenLayers.Function.bind(function(feature){
						this._dispatchEvent(this,feature,"onFeatureOver");
					},this),
					out: OpenLayers.Function.bind(function(feature){
						this._dispatchEvent(this,feature,"onFeatureOut");
					},this)
				}
			};
            
            var options = OpenLayers.Util.applyDefaults(this.selectControlOptions,DEFAULT_OPTIONS);
			//添加选择控件
			this.selectControl = new Geo.View2D.Control.SelectFeature(this.vectorLayer,options)
			this.map.addControl(this.selectControl);
		}
	}
});

/**
 * APIProperty: Geo.View2D.FeatureManager.defaultStyleMap
 * {<Geo.StyleMap>} FeatureManager中vectorLayer图层的默认要素样式。
 */
Geo.View2D.FeatureManager.defaultStyleMap = new Geo.StyleMap({
    "default": new Geo.Style({
    	externalGraphic: OpenLayers.Util.getImagesLocation() + "marker.png",
    	graphicWidth:21,
		graphicHeight:25,
		graphicXOffset:-10,
		graphicYOffset:-12
    }) ,
    "select": new Geo.Style({
        externalGraphic: OpenLayers.Util.getImagesLocation() + "marker-blue.png",
    	graphicWidth:21,
		graphicHeight:25,
		graphicXOffset:-10,
		graphicYOffset:-12
    })
});

/**
 * APIMethod: Geo.View2D.FeatureManager.showFramedCloud
 * 为要素添加浮云，如果指定内容模板则浮云内空按模板规则生成。
 * 
 * Parameters:
 * feature - 浮云所属的矢量要素。
 * templateString - 字符串内容模板。
 * 
 */
Geo.View2D.FeatureManager.showFramedCloud = function(feature, templateString){
    var layer = feature.layer, map = layer ? layer.map : null;
	if(!layer || !map){
		return;
	}
	var str;
	if(templateString){
		str = templateString;
	} else {
		str = (function(){
	        var str = "";
	        for (var myitem in feature.attributes) {
	            str += myitem + ":" + feature.attributes[myitem] + "<br>";
	        }
	        return str;
	    })();
	}
    
	var lonlat = null;
	if("OpenLayers.Geometry.LineString" == feature.geometry.CLASS_NAME) {
		var location = Math.floor(feature.geometry.components.length / 2) ;
		var tempPoint = feature.geometry.components[location];
		lonlat = new Geo.LonLat(tempPoint.x,tempPoint.y);
	}else {
		lonlat = feature.geometry.getBounds().getCenterLonLat();
	}
    if (map) {
		//直接定位到中心点，没有平滑效果
        map.setCenter(lonlat);
    }
    
    var popup = new Geo.View2D.Popup.FramedCloud(
		"featureInfo", 
		lonlat, 
		null, 
		str, 
		null, 
		true, 
		Geo.View2D.FeatureManager.onPopupClose
	);
    feature.popup = popup;
	//浮云关联到要素，因为关闭浮云的时候需要取消要素的选择
	popup.feature = feature;
	if(this.selectControl) {
		feature.selectControl = this.selectControl;
	}
    map.addPopup(popup);
};

/**
 * APIMethod: Geo.View2D.FeatureManager.closeFramedCloud
 * 关闭并消毁指定要素上添加的浮云。
 * 
 * Parameters:
 * feature - 浮云所属的矢量要素。
 * 
 */
Geo.View2D.FeatureManager.closeFramedCloud = function(feature){
    var layer = feature.layer, map = layer ? layer.map : null;
    if (feature.popup && layer && map) {
        map.removePopup(feature.popup);
        feature.popup.destroy();
        feature.popup = null;
    }
};

/**
 * APIMethod: Geo.View2D.FeatureManager.onPopupClose
 * 浮云关闭时触发的方法。
 */
Geo.View2D.FeatureManager.onPopupClose = function(){
	//关闭浮云的时候取消选择,如果要素关联到控件，则执行取消操作，如果没有，直接清除浮云
	if(this.feature && this.feature.selectControl) {
		this.feature.selectControl.unselect(this.feature);
	}else {
		var map = this.map;
	    if (map) {
	        map.removePopup(this);
	    }
	}
}
	
Geo.View2D.FeatureManager.showTopic = function(feature){
	
};
	
Geo.View2D.FeatureManager.closeTopic = function(feature){
	
};
/**
 * Class: Geo.View2D.MarkerTag
 * 标注的自定义标签类。
 */
Geo.View2D.MarkerTag = Geo.Class({
    
    /** 
     * Property: size 
     * {<Geo.Size>} 自定义标签的尺寸大小。
     */
    size: null,

    /** 
     * Property: offset 
     * {<Geo.Pixel>} 像素对象，表示自定义标签的偏移量。
     */
    offset: null,    
    
    /** 
     * Property: calculateOffset 
     * {Function} 计算偏移量的函数（参数为this.size）。
     */
    calculateOffset: null,    
    
    /** 
     * Property: div
     * {DOMElement} 自定义标签的DIV容器。
     */
    div: null,

    /** 
     * Property: px 
     * {<Geo.Pixel>} 屏幕像素对象，表示在地图上的屏幕位置。
     */
    px: null,
    
    /** 
     * Constructor: Geo.View2D.MarkerTag
     * Geo.View2D.MarkerTag对象构造函数。
     *
     * html - {String} 自定义html字符串。
     * size - {<Geo.Size>} 标签尺寸大小。
     * offset - {<Geo.Pixel>} 标签的偏移量对象。
     * calculateOffset - {Function} 计算偏移量的函数（参数为this.size）。
     */
    initialize: function(html, size, offset, calculateOffset) {
		this.html = html;
		
		var containerElement = (this.map) ? this.map.layerContainerDiv : document.body;
        var realSize = OpenLayers.Util.getRenderedDimensions(html, null, {
            containerElement: containerElement
        });
        this.size = (size) ? size : realSize;
		
		
        this.offset = offset ? offset : new Geo.Pixel(-(this.size.w/2), -(this.size.h/2));
        this.calculateOffset = calculateOffset;

        var id = OpenLayers.Util.createUniqueID("OL_Div_");
		this.div = OpenLayers.Util.createDiv(id, null, null, null, "absolute", null, null, null);
    },
    
    /** 
     * Method: destroy
     * 销毁该对象。
     */
    destroy: function() {
        // erase any drawn elements
        this.erase();

        this.div.innerHTML = "";
        this.div = null;
    },

    /** 
     * Method: clone
     * 返回本对象的副本。
     * 
     * Returns:
     * {<Geo.View2D.MarkerTag>} 该类的实例。
     */
    clone: function(){
        return new Geo.View2D.MarkerTag(this.html, this.size, this.offset, this.calculateOffset);
    },
    
    /**
     * Method: setSize
     * 设置尺寸大小。
     * 
     * Parameters:
     * size - {<Geo.Size>} 尺寸大小对象。
     */
    setSize: function(size) {
        if (size != null) {
            this.size = size;
        }
        this.draw();
    },
    
    /**
     * Method: setContentHTML
     * 设置HTML内容。
     * 
     * Parameters:
     * html - {String} 内容为HTML字符串。
     */
    setContentHTML: function(html) {
        if (html != null) {
            this.html = html;
        }
        this.draw();
    },
	
    /** 
     * Method: draw
     * 绘制该自定义标签。
     * 
     * Parameters:
     * px - {<Geo.Pixel>} 屏幕像素对象。
     * 
     * Returns:
     * {DOMElement} 返回该自定义标签的DIV元素。
     */
    draw: function(px) {
		OpenLayers.Util.modifyDOMElement(this.div, null, null, this.size, "absolute");
		this.div.innerHTML = this.html;
        this.moveTo(px);
        return this.div;
    }, 

    /** 
     * Method: erase
     * 清除自定义标签的DIV元素。
     */
    erase: function() {
        if (this.div != null && this.div.parentNode != null) {
            OpenLayers.Element.remove(this.div);
        }
    }, 
    
    /** 
     * Method: setOpacity
     * 设置透明度。
     *
     * Parameters:
     * opacity - {float} 透明度值，范围：0~1，浮点类型。
     */
    setOpacity: function(opacity) {
		OpenLayers.Util.modifyDOMElement(this.div, null, null, null, null, null, null, opacity);

    },
    
    /**
     * Method: moveTo
     * 移动自定义标签。
     *
     * Parameters:
     * px - {<Geo.Pixel>} 屏幕像素对象。
     */
    moveTo: function (px) {
        //if no px passed in, use stored location
        if (px != null) {
            this.px = px;
        }

        if (this.div != null) {
            if (this.px == null) {
                this.display(false);
			} else {
                if (this.calculateOffset) {
                    this.offset = this.calculateOffset(this.size);
                }
                var offsetPx = this.px.offset(this.offset);
                OpenLayers.Util.modifyDOMElement(this.div, null, offsetPx);
            }
        }
    },
    
    /** 
     * Method: display
     * 显示或隐藏自定义标签。
     *
     * Parameters:
     * display - {Boolean} 是否显示的标识。
     */
    display: function(display) {
        this.div.style.display = (display) ? "" : "none"; 
    },
    

    /**
     * APIMethod: isDrawn
     * 是否已经绘制。
     * 
     * Returns:
     * {Boolean} 是否已经绘制，返回值为布尔类型。
     */
    isDrawn: function() {
        // nodeType 11 for ie, whose nodes *always* have a parentNode
        // (of type document fragment)
        var isDrawn = (this.div && this.div.parentNode && 
                       (this.div.parentNode.nodeType != 11));    

        return isDrawn;   
    },

    CLASS_NAME: "Geo.View2D.MarkerTag"
});
/**
 * Class: Geo.View2D.Control.DrawCircle
 * 几何圆绘制控件类，继承自Geo.View2D.Control类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.DrawCircle = Geo.Class(Geo.View2D.Control, {

    /**
     * APIProperty: type
     * 控件类型
     */    
	type: Geo.View2D.Control.TYPE_TOOL,
    
    /**
     * APIProperty: sides
     * {Integer} 圆是由正多边形构成的，sides是构成圆的正多边形的边的数目，默认值为40。 
     */
	sides: 40,

    /**
     * APIProperty: persist
     * {Boolean} 是否保留绘制上次绘制的要素，默认值为false。如果设置为true，重新开始一个新绘制时，上次绘制的要素仍将保留。
     */ 	
	persist: false,
	
	/**
	 * Constructor: Geo.View2D.Control.DrawCircle
	 * Geo.View2D.Control.DrawCircle构造函数
	 */
    initialize: function(options){
        Geo.View2D.Control.prototype.initialize.apply(this, [options]);
        
        this.handler = new OpenLayers.Handler.RegularPolygon(
							this, 
							{ "done": this.done }, 
							{ "sides": this.sides , persist: this.persist });
    },
	
    /**
     * APIMethod: done
     * 绘制完成的响应函数，用户可以使用自己定义的函数替代。
     * 
     * Parameters:
     * geometry - {<Geo.Geometry>} 绘制的几何对象。
     */
    done: function(geometry){
        
    },
    
	CLASS_NAME: "Geo.View2D.Control.DrawCircle"
});
/**
 * Class: Geo.View2D.Control.DrawPath
 * 几何线绘制控件类，继承自Geo.View2D.Control类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.DrawPath = Geo.Class(Geo.View2D.Control, {

    /**
     * APIProperty: type
     * 控件有一个类型。类型决定了控件生成实例时在控件栏上的存放位置。 
     */  
    type: Geo.View2D.Control.TYPE_TOOL,

    /**
     * APIProperty: persist
     * {Boolean} 是否保留绘制上次绘制的要素，默认值为false。如果设置为true，重新开始一个新绘制时，上次绘制的要素仍将保留。
     */ 	
	persist: false,
    
	/**
	 * Constructor: Geo.View2D.Control.DrawPath
	 * 构造函数。生成一个Geo.View2D.Control.DrawPath的实例。
	 */    
    initialize: function(options){
        Geo.View2D.Control.prototype.initialize.apply(this, [options]);
        
        this.handler = new OpenLayers.Handler.Path(this, {
            "done": this.done
        },{ 
            persist: this.persist 
        });
    },

	
    /**
     * APIMethod: done
     * 绘制完成的响应函数，用户可以使用自己定义的函数替代。
     * 
     * Parameters:
     * geometry - {<Geo.Geometry>} 绘制的几何对象。
     */	
    done: function(geometry){
        
    },
	
	CLASS_NAME: "Geo.View2D.Control.DrawPath"
});
/**
 * Class: Geo.View2D.Control.DrawPoint
 * 几何点绘制控件类，继承自Geo.View2D.Control类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.DrawPoint = Geo.Class(Geo.View2D.Control, {

    /**
     * APIProperty: type
     * 控件有一个类型。类型决定了控件生成实例时在控件栏上的存放位置。 
     */
    type: Geo.View2D.Control.TYPE_TOOL,

    /**
     * APIProperty: persist
     * {Boolean} 是否保留绘制上次绘制的要素，默认值为false。如果设置为true，重新开始一个新绘制时，上次绘制的要素仍将保留。
     */ 	
	persist: false,
       
 	/**
	 * Constructor: Geo.View2D.Control.DrawPoint
	 * 构造函数。生成一个Geo.View2D.Control.DrawPoint的实例。
	 */     
    initialize: function(options){
        Geo.View2D.Control.prototype.initialize.apply(this, [options]);
        
        this.handler = new OpenLayers.Handler.Point(this, {
            "done": this.done
        },{ 
            persist: this.persist 
        });
    },
	
    /**
     * APIMethod: done
     * 绘制完成的响应函数，用户可以使用自己定义的函数替代。
     * 
     * Parameters:
     * geometry - {<Geo.Geometry>} 绘制的几何对象。
     */		
    done: function(geometry){
        
    },
	
	CLASS_NAME: "Geo.View2D.Control.DrawPoint"
});
/**
 * Class: Geo.View2D.Control.DrawPolygon
 * 几何多边形绘制控件类，继承自Geo.View2D.Control类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.DrawPolygon = Geo.Class(Geo.View2D.Control, {

    /**
     * APIProperty: type
     * 控件有一个类型。类型决定了控件生成实例时在控件栏上的存放位置。 
     */
    type: Geo.View2D.Control.TYPE_TOOL,
 
    /**
     * APIProperty: persist
     * {Boolean} 是否保留绘制上次绘制的要素，默认值为false。如果设置为true，重新开始一个新绘制时，上次绘制的要素仍将保留。
     */ 	
	persist: false,
    
 	/**
	 * Constructor: Geo.View2D.Control.DrawPolygon
	 * 构造函数。生成一个Geo.View2D.Control.DrawPolygon的实例。
	 */   
    initialize: function(options){
        Geo.View2D.Control.prototype.initialize.apply(this, [options]);
        
        this.handler = new OpenLayers.Handler.Polygon(this, {
            "done": this.done
        });
    },
	
    /**
     * APIMethod: done
     * 绘制完成的响应函数，用户可以使用自己定义的函数替代。
     * 
     * Parameters:
     * geometry - {<Geo.Geometry>} 
     */		
    done: function(geometry){
        
    },
    
	CLASS_NAME: "Geo.View2D.Control.DrawPolygon"
});
/**
 * Class: Geo.View2D.Control.DrawRectangle
 * 几何矩形绘制控件类，继承自Geo.View2D.Control类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.DrawRectangle = Geo.Class(Geo.View2D.Control, {

    /**
     * APIProperty: type
     * 控件类型。
     */
    type: Geo.View2D.Control.TYPE_TOOL,

    /**
     * APIProperty: persist
     * {Boolean} 是否保留绘制上次绘制的要素，默认值为false。如果设置为true，重新开始一个新绘制时，上次绘制的要素仍将保留。
     */ 	
	persist: false,
 	
	/**
	 * Constructor: Geo.View2D.Control.DrawRectangle
	 * Geo.View2D.Control.DrawRectangle构造函数。
	 */   
    initialize: function(options){
        Geo.View2D.Control.prototype.initialize.apply(this, [options]);
        
        this.handler = new OpenLayers.Handler.RegularPolygon(
			this,
			{ "done": this.done }, 
			{ irregular: true, persist: this.persist }
		);
    },
	
    /**
     * APIMethod: done
     * 绘制完成的响应函数，用户可以使用自己定义的函数替代。
     * 
     * Parameters:
     * geometry - {<Geo.Geometry>} 绘制的几何对象。
     */		
    done: function(geometry){},
	
	CLASS_NAME: "Geo.View2D.Control.DrawRectangle"
});
/**
 * Class: Geo.View2D.Control.MagnifyingGlass
 * 鼠标滚轮滚动时的绘制控件类，继承自Geo.View2D.Control类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * 例如:
 * (code)
 * this.controls = [ new Geo.View2D.Control.Navigation(),
 *                            new Geo.View2D.Control.PanZoomBar(),
 *                            new Geo.View2D.Control.ArgParser(),
 *                            new Geo.View2D.Control.Attribution(),
 *							  new Geo.View2D.Control.MagnifyingGlass()//将其加入控件数组
 *                           ];
 * (end)
 * 
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.MagnifyingGlass = Geo.Class(Geo.View2D.Control, {
	/**
	 * APIProperty: autoActivate
	 * 是否自动激活。
	 */
    autoActivate: true,
	
	/**
	 * Constructor: Geo.View2D.Control.MagnifyingGlass
     * Geo.View2D.Control.MagnifyingGlass构造函数。
	 */
    initialize: function(){
        Geo.View2D.Control.prototype.initialize.apply(this, arguments);
    },
    
	/**
	 * Method: draw
	 */
    draw: function(){
        Geo.View2D.Control.prototype.draw.apply(this, arguments);
        this.handler = new Geo.View2D.Handler.MouseWheel(this, {
            "down": this.magnifyingglassZoomOut,
            "up": this.magnifyingglassZoomIn
        });
        this.initDiv();
        
    },
    
	/**
	 * Method：initDiv
	 */
    initDiv: function(){
        var a = OpenLayers.Util.createDiv("map_magnifyingglass" + this.id.split("_")[1]);
        a.style.borderRight = "medium none";
        a.style.borderTop = "medium none";
        a.style.borderLeft = "medium none";
        a.style.borderBottom = "medium none";
        a.style.width = "111px";
        a.style.height = "74px";
        a.style.display = "none";
        a.style.unselectable = "on";
        var c = OpenLayers.Util.createDiv();
        c.style.lineHeight = "1px";
        c.style.width = "4px";
        c.style.height = "4px";
        c.style.left = "0";
        var b = OpenLayers.Util.createDiv();
        b.style.lineHeight = "1px";
        b.style.width = "4px";
        b.style.height = "4px";
        b.style.right = "0";
        var d = OpenLayers.Util.createDiv();
        d.style.lineHeight = "1px";
        d.style.width = "4px";
        d.style.height = "4px";
        d.style.right = "0";
        d.style.top = "40px";
        var e = OpenLayers.Util.createDiv();
        e.style.lineHeight = "1px";
        e.style.width = "4px";
        e.style.height = "4px";
        e.style.left = "0";
        e.style.top = "40px";
        a.appendChild(c);
        a.appendChild(b);
        a.appendChild(d);
        a.appendChild(e);
        this.map.viewPortDiv.appendChild(a)
    },
    
    bw_out: null,
    bw_in: null,
    variable: 1,
	
	/**
	 * Method：getTimeout
	 * Parameters:
	 * a - {Object} 
	 * b - {Object} 
	 * c - {Object} 
	 */
    getTimeout: function(a, b, c){
        return window.setTimeout(function(){
            b.apply(a)
        }, c)
    },
	/**
	 * Method：magnifyingglassZoomOut
	 * Parameters:
	 * a - {Object}
	 */
    magnifyingglassZoomOut: function(a){
        if (this.variable == 1) {
            var b = OpenLayers.Util.getElement("map_magnifyingglass" + this.id.split("_")[1]);
            if (b) {
                b.style.width = 111;
                b.style.height = 74;
                this.evt = a;
                this.out()
            }
        }
    },
	
	/**
	 * Method：magnifyingglassZoomIn
	 * Parameters:
	 * a - {Object}
	 */
    magnifyingglassZoomIn: function(a){
        if (this.variable == 1) {
            var b = OpenLayers.Util.getElement("map_magnifyingglass" + this.id.split("_")[1]);
            if (b) {
                b.style.width = "27px";
                b.style.height = "24px";
                this.evt = a;
                this.in_()
            }
        }
    },
	
	/**
	 * Method：out
	 */
    out: function(){
        this.Rx1(true)
    },
	
	/**
	 * Method：in_
	 */
    in_: function(){
        this.Rx1(false)
    },
	
	/**
	 * Method：Rx1
	 * Parameters:
	 * a - {Object}
	 */
    Rx1: function(a){
        var b = OpenLayers.Util.getElement("map_magnifyingglass" + this.id.split("_")[1]);
        if (this.variable <= 4) {
            if (b) {
                var c = 1, d;
                if (a) {
                    d = parseInt(b.style.width);
                    obj_h = parseInt(b.style.height);
                    c *= 15;
                    if (d >= 30) {
                        if (d && c) 
                            b.style.width = Math.abs(d - (c + 6)) + "px";
                        if (obj_h >= 25) 
                            if (obj_h && c) 
                                b.style.height = Math.abs(obj_h - c) + "px";
                        b.style.left = this.evt.xy.x -
                        parseInt(b.style.width) /
                        2 +
                        "px";
                        b.style.top = this.evt.xy.y -
                        parseInt(b.style.height) /
                        2 +
                        "px";
                        b.childNodes[0].style.borderWidth = "0px 2px 2px 0px";
                        b.childNodes[0].style.borderStyle = "solid";
                        b.childNodes[0].style.borderColor = "red";
                        b.childNodes[1].style.borderWidth = "0px 0px 2px 2px";
                        b.childNodes[1].style.borderStyle = "solid";
                        b.childNodes[1].style.borderColor = "red";
                        b.childNodes[2].style.borderWidth = "2px 0px 0px 2px";
                        b.childNodes[2].style.borderStyle = "solid";
                        b.childNodes[2].style.borderColor = "red";
                        b.childNodes[3].style.borderWidth = "2px 2px 0px 0px";
                        b.childNodes[3].style.borderStyle = "solid";
                        b.childNodes[3].style.borderColor = "red";
                        b.childNodes[2].style.top = b.style.height;
                        b.childNodes[3].style.top = b.style.height;
                        b.style.display = "";
                        b.style.zIndex = 1010
                    }
                    this.variable++;
                    this.bw_out = this.getTimeout(this, a ? this.out : this.in_, 60)
                }
                else {
                    d = parseInt(b.style.width);
                    obj_h = parseInt(b.style.height);
                    c *= 15;
                    if (d <= 111) {
                        b.style.width = Math.abs(d + c) + "px";
                        if (obj_h <= 64) 
                            b.style.height = Math.abs(obj_h + c) + "px";
                        b.style.left = this.evt.xy.x -
                        parseInt(b.style.width) /
                        2 +
                        "px";
                        b.style.top = this.evt.xy.y -
                        parseInt(b.style.height) /
                        2 +
                        "px";
                        b.childNodes[0].style.borderWidth = "2px 0px 0px 2px";
                        b.childNodes[0].style.borderStyle = "solid";
                        b.childNodes[0].style.borderColor = "red";
                        b.childNodes[1].style.borderWidth = "2px 2px 0px 0px";
                        b.childNodes[1].style.borderStyle = "solid";
                        b.childNodes[1].style.borderColor = "red";
                        b.childNodes[2].style.borderWidth = "0px 2px 2px 0px";
                        b.childNodes[2].style.borderStyle = "solid";
                        b.childNodes[2].style.borderColor = "red";
                        b.childNodes[3].style.borderWidth = "0px 0px 2px 2px";
                        b.childNodes[3].style.borderStyle = "solid";
                        b.childNodes[3].style.borderColor = "red";
                        b.childNodes[2].style.top = b.style.height;
                        b.childNodes[3].style.top = b.style.height;
                        b.style.display = "";
                        b.style.zIndex = 1010
                    }
                    this.variable++;
                    this.bw_in = this.getTimeout(this, a ? this.out : this.in_, 100)
                }
            }
        }
        else {
            if (a) {
                window.clearTimeout(this.bw_out);
                this.bw_out = null
            }
            else {
                window.clearTimeout(this.bw_in);
                this.bw_in = null
            }
            this.variable = 1;
            b.style.display = "none";
            b.style.zIndex = 0;
            b.style.width = "111px";
            b.style.height = "74px"
        }
    },
	
	CLASS_NAME: "Geo.View2D.Control.MagnifyingGlass"
});
/**
 * Class: Geo.View2D.Control.PanZoomBarTitle
 * 带标题的导航控件类，继承自Geo.View2D.Control.PanZoom类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control.PanZoom>
 */
Geo.View2D.Control.PanZoomBarTitle = Geo.Class(Geo.View2D.Control.PanZoom, {
	/** 
     * APIProperty: zoomStopWidth
     * 缩放停止的宽度，默认为：18。
     */
    zoomStopWidth: 18,   

    /** 
     * APIProperty: zoomStopHeight
     * 缩放停止的高度，默认为：11。
     */
    zoomStopHeight: 11,
	
	/** 
     * Property: slider
     */
    slider: null,
	
	/** 
     * Property: sliderEvents
     * {<Geo.Events>}
     */
    sliderEvents: null,
	
	/** 
     * Property: zoombarDiv
     * {DOMElement}
     */
    zoomBarDiv: null,
	
	/** 
     * Property: divEvents
     * {<Geo.Events>}
     */
    divEvents: null,
	
	/** 
     * APIProperty: zoomWorldIcon
     * {Boolean} 是否在导航栏上显示一个定位至全球范围的图标。默认为false。
     */
    zoomWorldIcon: false,
	
	/** 
     * Property: leftTip
     * {Array(DOMElement)} 
     */
    leftTip: [],
	
	/** 
     * Property: leftTooltips
     * {String} 
     */
    leftTooltips: null,
	
	/** 
     * APIProperty: imageLocation
     * > {String} 显示地图导航杆控件的页面与引用地图导航杆图片资源文件（panzoombar_blue）的相对路径。
     * > 例如：地图导航杆图片资源文件（panzoombar_blue）在当前页面的上三级目录，则路径设置为"../../../"。
     * 
     * Examples:
	 * (code)
	 * var panZoomBarTitle = new Geo.View2D.Control.PanZoomBarTitle({
	 *     imageLocation: "../../../"
	 * });
	 * (end)
     */
    imageLocation: "",

    /**
     * Constructor: Geo.View2D.Control.PanZoomBarTitle
     * 构造一个新的<Geo.View2D.Control.PanZoomBarTitle>对象实例。
     */ 
    initialize: function(options){
		this.imageLocation = Geo.getScriptLocation() + "images/";
        OpenLayers.Control.PanZoom.prototype.initialize.apply(this, arguments);
    },
	
    /**
     * APIMethod: destroy
     * 销毁本对象。
     */
    destroy: function() {
        this._removeZoomBar();
        this.map.events.un({
            "changebaselayer": this.redraw,
            scope: this
        });
        OpenLayers.Control.PanZoom.prototype.destroy.apply(this, arguments);
    },
	
    /**
     * Method: setMap
     * 
     * Parameters:
     * map - {<Geo.View2D.Map>} 
     */
    setMap: function(map){
        OpenLayers.Control.PanZoom.prototype.setMap.apply(this, arguments);
        this.map.events.register("changebaselayer", this, this.redraw);
    },
	
    /** 
     * Method: redraw
     * clear the div and start over.
     */
    redraw: function(){
        if (this.div != null) {
            this.removeButtons();
            this._removeZoomBar();
        }
        this.draw();
    },
	
    /**
    * Method: draw 
    *
    * Parameters:
    * px - {<Geo.Pixel>} 
    */
    draw: function(px){
        // initialize our internal div
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        px = this.position.clone();
        
        // place the controls
        this.buttons = [];
        this.leftTip = [];
        var sz = new OpenLayers.Size(24, 24);
        var centered = new OpenLayers.Pixel(px.x + sz.w / 2, px.y);
        var wposition = sz.w;
        
        if (this.zoomWorldIcon) {
            centered = new OpenLayers.Pixel(px.x + sz.w, px.y);
        }
        
        this._addButton("panup", "panzoombar_blue/north-mini.png", centered, sz, "向上平移");
        px.y = centered.y + sz.h;
        this._addButton("panleft", "panzoombar_blue/west-mini.png", px, sz, "向左平移");
        if (this.zoomWorldIcon) {
            this._addButton("zoomworld", "panzoombar_blue/zoom-world-mini.png", px.add(sz.w, 0), sz, "全部地图");
            
            wposition *= 2;
        }
        this._addButton("panright", "panzoombar_blue/east-mini.png", px.add(wposition, 0), sz, "向右平移");
        this._addButton("pandown", "panzoombar_blue/south-mini.png", centered.add(0, sz.h * 2), sz, "向下平移");
        this._addButton("zoomin", "panzoombar_blue/zoom-plus-mini.png", centered.add(0, sz.h * 3 + 5), sz, "放大一级");
        centered = this._addZoomBar(centered.add(3, sz.h * 4 + 5));
        this._addButton("zoomout", "panzoombar_blue/zoom-minus-mini.png", centered.add(-3, 0), sz, "缩小一级");
        //添加 zoomToolTip
        var tooltipSZ = new OpenLayers.Size(62, 12);
        this._addZoomToolTip("zoomtooltip", "panzoombar_blue/zoom_0.png", centered.add(20, 0), tooltipSZ);
        
        //x :图片的宽度
		/** 金字塔的分辨率如下
        RESOLUTIONS: [
        1.40625, 
        0.703125, 
        0.3515625, 
        0.17578125, 
        0.087890625, 
        0.0439453125,
        0.02197265625, 
        0.010986328125, 
        0.0054931640625, 
        0.00274658203125,
        0.001373291015625, 
        0.0006866455078125, 
        0.00034332275390625,
        0.000171661376953125, 
        0.0000858306884765625, 
        0.00004291534423828125,
        0.00002145767211914062, 
        0.00001072883605957031,
        0.00000536441802978515, 
        0.00000268220901489257,
        0.0000013411045074462891,
        0.00000067055225372314453]
        **/
        
        this.leftTooltips = {
			/*
            zltGlb: {
                url: "panzoombar_blue/zoom_Global.png",
                x: 33,
                res: 0.3515625
            },
            zltContinent: {
                url: "panzoombar_blue/zoom_Continent.png",
                x: 23,
                res: 0.087890625
            },
            */
            zltCountry: {
                url: "panzoombar_blue/zoom_Country.png",
                x: 23,
                res: 0.087890625
            },
            zltPro: {
                url: "panzoombar_blue/zoom_Province.png",
                x: 23,
                res: 0.010986328125
            },
            zltCity: {
                url: "panzoombar_blue/zoom_City.png",
                x: 23,
                res: 0.001373291015625
            },
            zltStr: {
                url: "panzoombar_blue/zoom_Street.png",
                x: 23,
                res: 0.00001072883605957031
            }
        };
        for (var myitem in this.leftTooltips) {
            var leftTooltipObj = this.leftTooltips[myitem];
            this._addZoomLeftTip(myitem, leftTooltipObj.url, centered.add(-leftTooltipObj.x, 0), new OpenLayers.Size(leftTooltipObj.x, 17), leftTooltipObj.res);
        }
        //centred, slider位置(x,y)
        return this.div;
    },
	
	/**
     * Method: _addButton
     * 
     * Parameters:
     * id - {String} 
     * img - {String} 
     * xy - {<Geo.Pixel>} 
     * sz - {<Geo.Size>} 
     * 
     * Returns:
     * {DOMElement} A Div (an alphaImageDiv, to be precise) that contains the
     *     image of the button, and has all the proper event handlers set.
     */
    _addButton:function(id, img, xy, sz) {
        var btn = OpenLayers.Util.createAlphaImageDiv(
                                    this.id + "_" + id, 
                                    xy, sz, this.imageLocation + img, "absolute");
 		btn.style.cursor = "pointer";
        //we want to add the outer div
        this.div.appendChild(btn);

        OpenLayers.Event.observe(btn, "mousedown", 
            OpenLayers.Function.bindAsEventListener(this.onButtonClick, btn));
        OpenLayers.Event.observe(btn, "dblclick", 
            OpenLayers.Function.bindAsEventListener(this.doubleClick, btn));
        OpenLayers.Event.observe(btn, "click", 
            OpenLayers.Function.bindAsEventListener(this.doubleClick, btn));
        btn.action = id;
        btn.map = this.map;
    
        if(!this.slideRatio){
            var slideFactorPixels = this.slideFactor;
            var getSlideFactor = function() {
                return slideFactorPixels;
            };
        } else {
            var slideRatio = this.slideRatio;
            var getSlideFactor = function(dim) {
                return this.map.getSize()[dim] * slideRatio;
            };
        }

        btn.getSlideFactor = getSlideFactor;

        //we want to remember/reference the outer div
        this.buttons.push(btn);
        return btn;
    },
	
	/**
     * Method: _addZoomToolTip
     * 添加 zoomToolTip。
     * 
     * Parameters:
     * id - {String} 
     * img - {String} 
     * xy - {<Geo.Pixel>} 
     * sz - {<Geo.Size>} 
     * 
     * Returns:
     * {DOMElement} A Div (an alphaImageDiv, to be precise) that contains the
     *     image of the button, and has all the proper event handlers set.
     */
    _addZoomToolTip: function(id, img, xy, sz){
        var tooltip = OpenLayers.Util.createAlphaImageDiv("OpenLayers_Control_PanZoom_" + id, xy, sz, this.imageLocation + img, "absolute");
        //初始化不显示
        OpenLayers.Control.PanZoomBarTitle.isVisible = false;
        this.tooltip = tooltip;
        this.tooltip.style.display = "none";
        this.div.appendChild(tooltip);
        return tooltip;
    },
	
	/**
     * Method: _addZoomToolTip
     * 添加 _addZoomLeftTip。
     * 
     * Parameters:
     * id - {String} 
     * img - {String} 
     * xy - {<Geo.Pixel>} 
     * sz - {<Geo.Size>} 
     * res - {Float} 地图分辨率（单位：度 /像素）。
     * 
     * Returns:
     * {DOMElement} A Div (an alphaImageDiv, to be precise) that contains the
     *     image of the button, and has all the proper event handlers set.
     */
    _addZoomLeftTip: function(id, img, xy, sz, res){
        if (res <= this.map.baseLayer.maxResolution && res >= this.map.baseLayer.minResolution) {
            var tooltipLeft = OpenLayers.Util.createAlphaImageDiv("OpenLayers_Control_PanZoom_" + id, xy, sz, this.imageLocation + img, "absolute");
            this.tipEvents = new OpenLayers.Events(this, tooltipLeft, null, true, {
                includeXY: true
            });
            
            var mapMaxZoom = this.getCurrentZoomNumFromResolution(this.map.baseLayer.maxResolution, this.map.baseLayer.minResolution);
            var zoom = this.map.getZoomForResolution(res);
            var tipTop = (mapMaxZoom - zoom) * this.zoomStopHeight + this.startTop;
            this.tipEvents.on({
                "click": this.tipClick,
                "mouseover": this.slideMouseOver,
                "mouseout": this.mouseOut
            });
            
            this.leftTip.push(tooltipLeft);
            this.tooltipLeft = tooltipLeft;
            tooltipLeft.res = res;
            tooltipLeft.style.top = (tipTop - 3) + "px";
            tooltipLeft.style.display = "none";
            tooltipLeft.style.cursor = "hand";
            
            this.div.appendChild(tooltipLeft);
            return tooltipLeft;
        }
        else {
            return;
        }
    },
	
	/**
	 * Method: tipClick
	 * 
     * Parameters:
	 * evt - {Object} 
	 */
    tipClick: function(evt){
        var srcElement = evt.srcElement ? evt.srcElement : evt.target;
        var leftTipName = srcElement.id.split("_")[3];
        var res = this.leftTooltips[leftTipName]["res"];
        var zoom = this.map.getZoomForResolution(res);
        if (res == 0.3515625) {
            this.map.setCenter(new OpenLayers.LonLat(104.293175, 0), zoom);
        }
        else {
            this.map.zoomTo(zoom);
        }
        OpenLayers.Event.stop(evt);
    },
	
	/** 
	 * Method: _addZoomBar
     * 
     * Parameters:
     * location - {<Geo.Pixel>} where zoombar drawing is to start.
     */
    _addZoomBar: function(centered){
        
        
        var id = this.id + "_" + this.map.id;
        var zoomsToEnd = this.map.getNumZoomLevels() - 1 - this.map.getZoom();
        var slider = OpenLayers.Util.createAlphaImageDiv(id, centered.add(-1, zoomsToEnd * this.zoomStopHeight), new OpenLayers.Size(20, 9), this.imageLocation + "panzoombar_blue/slider.png", "absolute");
        this.slider = slider;
        
        this.sliderEvents = new OpenLayers.Events(this, slider, null, true, {
            includeXY: true
        });
        this.sliderEvents.on({
            "mousedown": this.zoomBarDown,
            "mousemove": this.zoomBarDrag,
            "mouseup": this.zoomBarUp,
            "dblclick": this.doubleClick,
            "click": this.doubleClick,
            "mouseover": this.slideMouseOver,
            "mouseout": this.mouseOut
        });
        
        var sz = new OpenLayers.Size();
        sz.h = this.zoomStopHeight * this.map.getNumZoomLevels();//zoombar 的高度
        sz.w = this.zoomStopWidth;
        var div = null;
        
        if (OpenLayers.Util.alphaHack()) {
            var id = this.id + "_" + this.map.id;
            div = OpenLayers.Util.createAlphaImageDiv(id, centered, new OpenLayers.Size(sz.w, this.zoomStopHeight), this.imageLocation + "panzoombar_blue/zoombar.png", "absolute", null, "crop");
            div.style.height = sz.h + "px";
        }
        else {
            div = OpenLayers.Util.createDiv('OpenLayers_Control_PanZoomBar_Zoombar' + this.map.id, centered, sz, this.imageLocation + "panzoombar_blue/zoombar.png");
        }
        
        this.zoombarDiv = div;
        
        this.divEvents = new OpenLayers.Events(this, div, null, true, {
            includeXY: true
        });
        this.divEvents.on({
            "mousedown": this.divClick,
            "mousemove": this.passEventToSlider,
            "dblclick": this.doubleClick,
            "click": this.doubleClick,
            "mouseout": this.mouseOut
        });
        
        this.div.appendChild(div);
        
        this.startTop = parseInt(div.style.top);
        this.div.appendChild(slider);
        
        this.map.events.register("zoomend", this, this.moveZoomBar);
        
        centered = centered.add(0, this.zoomStopHeight * this.map.getNumZoomLevels());
        return centered;
    },
	
	/**
	 * Method: _removeZoomBar
	 */
    _removeZoomBar: function(){
        this.sliderEvents.un({
            "mousedown": this.zoomBarDown,
            "mousemove": this.zoomBarDrag,
            "mouseup": this.zoomBarUp,
            "dblclick": this.doubleClick,
            "click": this.doubleClick,
            "mouseover": this.slideMouseOver,
            "mouseout": this.mouseOut
        });
        this.sliderEvents.destroy();
        this.divEvents.un({
            "mousedown": this.divClick,
            "mousemove": this.passEventToSlider,
            "dblclick": this.doubleClick,
            "click": this.doubleClick,
            "mouseout": this.mouseOut
        });
        this.divEvents.destroy();
        for (var i = 0; i < this.leftTip.length; i++) {
        
            this.div.removeChild(this.leftTip[i]);
        }
        this.tooltipLeft = null;
        
        this.div.removeChild(this.zoombarDiv);
        this.zoombarDiv = null;
        this.div.removeChild(this.slider);
        this.slider = null;
        this.map.events.unregister("zoomend", this, this.moveZoomBar);
    },
	
	/**
	 * Method: slideMouseOver
	 * 
     * Parameters:
	 * evt - {Object} 
	 */
    slideMouseOver: function(evt){
        OpenLayers.Control.PanZoomBarTitle.isVisible = true;
        this.tooltip.style.display = "";
        for (var i = 0; i < this.leftTip.length; i++) {
            this.leftTip[i].style.display = "";
        }
        var fixZoom = this.getCurrentZoomNum();
        var fixTop = ((this.map.getNumZoomLevels() - 1) - this.map.getZoom()) *
        this.zoomStopHeight +
        this.startTop +
        1;
        
        
        var toolTipTop = fixTop;
        this.tooltip.style.top = (toolTipTop - 3) + "px";
        
        var img = this.tooltip.childNodes[0];
        img.src = this.imageLocation + "panzoombar_blue/zoom_" + (parseInt(fixZoom) + 0) + ".png";
    },
	
	/**
	 * Method: passEventToSlider
	 * 鼠标移动响应。
	 * 
     * Parameters:
	 * evt - {Object} 
	 */
    passEventToSlider: function(evt){
		OpenLayers.Control.PanZoomBarTitle.isVisible = true;
		this.tooltip.style.display = "";
		for (var i = 0; i < this.leftTip.length; i++) {
		  this.leftTip[i].style.display = "";
		}
		var newTop = ((this.map.getNumZoomLevels() - 1) - this.map.getZoom()) *
		this.zoomStopHeight +
		this.startTop +
		1;
		
		var overZoom = this.getFixZoom(evt.xy.y) - 10;
		if (overZoom == -1) {
		  overZoom = 0;
		}
		
		//计算当前分辨率相对金字塔级别
		var topTileSize = this.map.pyramid.getTopTileSize();
		var pyramidMaxResolution = (topTileSize.w / this.map.pyramid.tileSize.w) /
		Math.pow(2, this.map.pyramid.topLevelIndex);
		var currentResolution = this.map.getResolutionForZoom(overZoom);
		var fixZoom = this.getCurrentZoomNumFromResolution(pyramidMaxResolution, currentResolution);
		
		var fixTop = ((this.map.getNumZoomLevels() - 1) - overZoom) *
		this.zoomStopHeight +
		this.startTop +
		1;
		
		
		var toolTipTop = fixTop;
		this.tooltip.style.top = (toolTipTop - 3) + "px";
		
		var img = this.tooltip.childNodes[0];
		img.src = this.imageLocation + "panzoombar_blue/zoom_" + (parseInt(fixZoom) + 0) + ".png";
		
		this.sliderEvents.handleBrowserEvent(evt);
    },
    
	/**
	 * Method: getDataExtent
	 * 计算当前分辨率相对于金字塔的级别数
	 */
    getCurrentZoomNum: function(){
        var topTileSize = this.map.pyramid.getTopTileSize();
        var pyramidMaxResolution = (topTileSize.w / this.map.pyramid.tileSize.w) /
        Math.pow(2, this.map.pyramid.topLevelIndex);
        
        var fixZoom = this.getCurrentZoomNumFromResolution(pyramidMaxResolution, this.map.getResolution());
        return fixZoom;
    },
	
    /**
     * Method: getCurrentZoomNumFromResolution
     * 从给定金字塔最大分辨率和地图当前分辨率计算当前级别数
     * 
     * Parameters:
	 * maxRes - {Float} 地图分辨率（单位：度 /像素）
	 * currentRes - {Float} 地图分辨率（单位：度 /像素）
     */
	getCurrentZoomNumFromResolution: function(maxRes,currentRes){
	
		//原计算方法直接取地图当前级别：parseInt(this.map.getZoom());
		//现在的方法计算当前分辨率相对于金字塔最大分辨率的级别
        var zoomRatio =  maxRes / currentRes;
        
        //如果当前分辨率比金字塔最大分辨率还大，说明出错
        if(zoomRatio < 1) return 0;
        
        var zoom = 0;
        while( (zoomRatio / 2) >= 1 ){
        	zoom++;
        	zoomRatio = zoomRatio/2;
        };
        return zoom ;
	},
	
    /**
     * Method: getFixZoom
     * 
     * 
     * Parameters:
	 * height - {Number} 
     */
    getFixZoom: function(height) {
    	var currentZoom = this.map.getZoom();
		var newTop = 
        	((this.map.getNumZoomLevels()-1) - currentZoom) * 
        	this.zoomStopHeight + this.startTop + 6;
        while(true) {
        	var tmp = height - newTop;
        	if(tmp>=0) {
        		if(tmp<this.zoomStopHeight/2) {
        			break;
        		}
        		currentZoom--;
        		newTop = newTop + this.zoomStopHeight;
        	} else {
        		if(tmp>=-this.zoomStopHeight/2) {
        			break;
        		}
        		currentZoom++;
        		newTop = newTop - this.zoomStopHeight;
        	}
        }
        return currentZoom;
    },
	
    /**
     * Method: mouseOut
     * 
     * Parameters:
	 * evt - {Object} 
     */
    mouseOut: function(evt) {
    	var tooltip = this.tooltip;
    	OpenLayers.Control.PanZoomBarTitle.isVisible = false;
    	var callfn = OpenLayers.Function.bind(function() {
			if(!OpenLayers.Control.PanZoomBarTitle.isVisible) {
				tooltip.style.display = "none";
				for(var i=0;i<this.leftTip.length;i++){
		    		this.leftTip[i].style.display = "none";
		    	}
			}
    	},this);
    	
    	window.setTimeout(callfn,1000);
    	OpenLayers.Event.stop(evt);
    },
	
    /**
     * Method: divClick
     * 
     * Parameters:
	 * evt - {Object} 
     */
    divClick: function (evt) {
        if (!OpenLayers.Event.isLeftClick(evt)) {
            return;
        }
        var y = evt.xy.y;
        var top = OpenLayers.Util.pagePosition(evt.object)[1];
        var levels = (y - top)/this.zoomStopHeight;
        if(!this.map.fractionalZoom) {
            levels = Math.floor(levels);
        }
        var zoom = (this.map.getNumZoomLevels() - 1) - levels;
        zoom = Math.min(Math.max(zoom, 0), this.map.getNumZoomLevels() - 1);
        this.map.zoomTo(zoom);
        
        OpenLayers.Event.stop(evt);
    },
	
    /**
     * Method: zoomBarDown
     * 
     * Parameters:
	 * evt - {Object} 
     */
    zoomBarDown:function(evt) {
        if (!OpenLayers.Event.isLeftClick(evt)) {
            return;
        }
        this.map.events.on({
            "mousemove": this.passEventToSlider,
            "mouseup": this.passEventToSlider,
            scope: this
        });
        this.mouseDragStart = evt.xy.clone();
        this.zoomStart = evt.xy.clone();
        this.div.style.cursor = "move";
        this.zoombarDiv.offsets = null;
        OpenLayers.Event.stop(evt);
    },
	
    /**
     * Method: zoomBarDrag
     * 
     * Parameters:
	 * evt - {Object} 
     */
    zoomBarDrag:function(evt) {
        if (this.mouseDragStart != null) {
            var deltaY = this.mouseDragStart.y - evt.xy.y;
            var offsets = OpenLayers.Util.pagePosition(this.zoombarDiv);
            if ((evt.clientY - offsets[1]) > 0 &&
                (evt.clientY - offsets[1]) < parseInt(this.zoombarDiv.style.height) - 2) {
                var newTop = parseInt(this.slider.style.top) - deltaY;
                this.slider.style.top = newTop+"px";
                this.mouseDragStart = evt.xy.clone();
            }
            OpenLayers.Event.stop(evt);
        }
    },
	
    /**
     * Method: zoomBarUp
     * 
     * Parameters:
	 * evt - {Object} 
     */
    zoomBarUp:function(evt) {
        if (!OpenLayers.Event.isLeftClick(evt)) {
            return;
        }
        if (this.zoomStart) {
            this.div.style.cursor="";
            this.map.events.un({
                "mouseup": this.passEventToSlider,
                "mousemove": this.passEventToSlider,
                scope: this
            });
            var deltaY = this.zoomStart.y - evt.xy.y;
            var zoomLevel = this.map.zoom;
            if (this.map.fractionalZoom) {
                zoomLevel += deltaY/this.zoomStopHeight;
                zoomLevel = Math.min(Math.max(zoomLevel, 0),
                                     this.map.getNumZoomLevels() - 1);
            } else {
                zoomLevel += Math.round(deltaY/this.zoomStopHeight);
            }
            this.map.zoomTo(zoomLevel);
            this.moveZoomBar();
            this.mouseDragStart = null;
            OpenLayers.Event.stop(evt);
        }
    },
	
    /**
     * Method: moveZoomBar
     * 
     */
    moveZoomBar: function(){
        OpenLayers.Control.PanZoomBarTitle.isVisible = false;
        this.tooltip.style.display = "";
        //获取当前级别相对于金字塔级别
        var inPyramidZoom = this.getCurrentZoomNum();
        
        var newTop = ((this.map.getNumZoomLevels() - 1) - this.map.getZoom()) *
        this.zoomStopHeight +
        this.startTop +
        1;
        
        this.tooltip.style.top = (newTop - 3) + "px";
        var img = this.tooltip.childNodes[0];
        
        img.src = this.imageLocation + "panzoombar_blue/zoom_" + (parseInt(inPyramidZoom) + 0) + ".png";
        
        this.slider.style.top = newTop + "px";
        
        var tooltip = this.tooltip;
        var callfn = OpenLayers.Function.bind(function(){
            if (!OpenLayers.Control.PanZoomBarTitle.isVisible) {
                tooltip.style.display = "none";
                for (var i = 0; i < this.leftTip.length; i++) {
                    this.leftTip[i].style.display = "none";
                }
            }
        }, this);
        
        window.setTimeout(callfn, 1000);
    },
	
	/**
     * Method: doubleClick
     *
     * Parameters:
     * evt - {Event} 
     *
     * Returns:
     * {Boolean}
     */
    doubleClick: function (evt) {
        OpenLayers.Event.stop(evt);
        return false;
    },
	
	/**
     * Method: onButtonClick
     *
     * Parameters:
     * evt - {Event}
     */
    onButtonClick: function(evt) {
        switch (this.action) {
            case "panup": 
                this.map.pan(0, -this.getSlideFactor("h"));
                break;
            case "pandown": 
                this.map.pan(0, this.getSlideFactor("h"));
                break;
            case "panleft": 
                this.map.pan(-this.getSlideFactor("w"), 0);
                break;
            case "panright": 
                this.map.pan(this.getSlideFactor("w"), 0);
                break;
            case "zoomin": 
                this.map.zoomIn(); 
                break;
            case "zoomout": 
                this.map.zoomOut(); 
                break;
            case "zoomworld": 
                this.map.zoomToMaxExtent(); 
                break;
        }
    },
	
    CLASS_NAME: "Geo.View2D.Control.PanZoomBarTitle"
});/**
 * Class: Geo.View2D.Control.GeoOverviewMap
 * 鹰眼图类，继承自Geo.View2D.Control.OverviewMap类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control.OverviewMap>
 */
Geo.View2D.Control.GeoOverviewMap = Geo.Class(Geo.View2D.Control.OverviewMap,{
	
	/**
	 * Constructor: Geo.View2D.Control.GeoOverviewMap
	 * Geo.View2D.Control.GeoOverviewMap对象构造函数。
	 * 
	 * Parameters:
     * options - {Object} 相关选项设置
     * 
     * (code)
     * 	// 鹰眼控件
     *      var overviewMap = new Geo.View2D.Control.GeoOverviewMap({
     *          maximized: true,//true表示鹰眼图是展开的
     *          layers: [tileLayer] //设置鹰眼图层
     *      });
     * (end)
	 */
	initialize : function(options) {
		options = options || {};
		if(options.layers && options.layers.length > 0) {
			//将参数中的图层设置成覆盖层，isBaseLayer都强制设置为false
			for(var i = 0,len = options.layers.length; i < len; i++) {
				if(options.layers[i] instanceof Geo.View2D.Layer.Vector) {
					//禁止添加矢量图层，如果是矢量图层，则进入下一次循环
					continue;
				}
				//添加的图层不能受外部操作的影响，需要克隆
				options.layers[i] = options.layers[i].clone();
				options.layers[i].isBaseLayer = false;
			}
			//添加基础图层
			/*
			 * 在创建鹰眼图的时候必须要有个基础图层。本来可以利用主地图的基础图层的，但是当用户使用自定义的图层后，主地图中的基础图层就被这个参数layers
			 * 给覆盖了
			 */
			var baseLayer = new Geo.View2D.Layer("GeoGlobeBaseLayer", {
	            displayInLayerSwitcher: false,
	            isBaseLayer: true
	        });
			options.layers.push(baseLayer);
		}
		
		Geo.View2D.Control.OverviewMap.prototype.initialize.apply(this, [options]);
	},
	
	/**
	 * Method: draw
	 * 该方法由API类自动调用。
	 */
    draw: function(){
       var div = Geo.View2D.Control.OverviewMap.prototype.draw.apply(this, arguments);
	   return div;
    },
    
	/**
	 * Method: createMap
	 * 该方法由API类自动调用。
	 */
    createMap: function(){
        Geo.View2D.Control.OverviewMap.prototype.createMap.apply(this,arguments);
		//如果图层长度为1则表示用户没有设置layers参数。
		if(this.layers.length == 1) {
			if(this.map && this.map.layerGroup) {
				this._loadLayers(this.map);
			}
			//监听图层组加载事件
			this.map.events.on({
	        "loadlayergroup":function(mainMap){
				this._unloadLayers(mainMap.map);
				this._loadLayers(mainMap.map);
			},
	        scope: this
	    	});
		}else if(this.layers.length > 1) {//如果图层长度大于1则表示用户自己添加图层参数
			//同步鹰眼图中的基础图层
			this._updateBaseLayer(this.map);
		}
		
		
    },
	
	//加载图层组
    _loadLayers : function(mainMap) {
		this.layers = [];
        var maplayers = mainMap.layerGroup.layers;
        for(var i=0; i<maplayers.length; i++){
			if(maplayers[i] instanceof Geo.View2D.Layer.Vector) {
				continue;
			}
			var layer = maplayers[i].clone();
			this.layers.push(layer);
        }
		this.ovmap.addLayers(this.layers);
		//同步鹰眼图中的基础图层
		this._updateBaseLayer(mainMap);

	},
	
	//更新基础图层
	_updateBaseLayer: function(mainMap) {
		var ovmap = this.ovmap;
		//同步鹰眼图中的基础图层
		if(mainMap.baseLayer) {
			var baseLayer = mainMap.baseLayer.clone();
			for(var i = 0,len = this.layers.length; i < len; i++) {
				if(this.layers[i].baseLayer) {
					OpenLayers.Util.removeItem(this.layers,this.layers[i]);
				}
			}
			this.layers.push(baseLayer);
			if (ovmap.baseLayer) {
           		ovmap.removeLayer(ovmap.baseLayer);
        	}
			ovmap.addLayer(baseLayer);
		}
	},
	
	//卸载图层组
    _unloadLayers: function(mainMap){
		var ovmap = this.ovmap;
		var layers = ovmap.layers;
		var layersTemp = [];
	    for(var i=0,len = layers.length; i < len; i++){
			if(!layers[i].isBaseLayer) {
				layersTemp.push(layers[i]);
			}
	    }
		for(var i=0,len = layersTemp.length; i < len; i++) {
			ovmap.removeLayer(layersTemp[i]);
		}
    },
	
	/**
	 * Method: destroy
	 * 该方法由API类自动调用。
	 */
	destroy : function() {
		this.map.events.un({
	        "loadlayergroup" : this.loadLayerGroup,
	        scope: this
    	});
		Geo.View2D.Control.OverviewMap.prototype.destroy.apply(this,arguments);
	}
});/**
 * Class: Geo.View2D.Control.GeoPanZoom
 * 迷你地图导航控件类，该类的实例是一个可定义的迷你地图导航控件类，默认画在地图的左上角。
 *
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.GeoPanZoom = Geo.Class(Geo.View2D.Control, {

    /** 
     * APIProperty: slideFactor
     * {Integer} 点击地图上任意方向上的箭头按钮后地图平移的像素数。
     * 如果你想通过地图尺寸的比率平移，请使用slideRatio代替。
     */
    slideFactor: 50,

    /** 
     * APIProperty: slideRatio
     * {Number} 地图宽与高的比值，是我们通过点击箭头按钮来平移地图的数量。默认为null。
     * 如果设置将会覆盖<slideFactor>。例如如果slideRatio为5,那么向上平移将会平移地图高度的一半。
     */
    slideRatio: null,

    /** 
     * Property: buttons
     * {Array(DOMElement)} Array of Button Divs 
     */
    buttons: null,

    /** 
     * Property: position
     * {<Geo.Pixel>} 
     */
    position: null,
	
    /** 
     * APIProperty: zoomWorldIcon
     * {Boolean} 是否显示缩放至世界范围的按钮图标。
     * 
     */
    zoomWorldIcon: false,
	
    /**
     * Constructor: Geo.View2D.Control.GeoPanZoom
     * 
     * Parameters:
     * options - {Object}
     */
    initialize: function(options) {
        this.position = new OpenLayers.Pixel(Geo.View2D.Control.GeoPanZoom.X,
                                             Geo.View2D.Control.GeoPanZoom.Y);
        OpenLayers.Control.prototype.initialize.apply(this, arguments);
    },

    /**
     * APIMethod: destroy
     * 销毁本对象。
     */
    destroy: function() {
        this.removeButtons();
        this.buttons = null;
        this.position = null;
        OpenLayers.Control.prototype.destroy.apply(this, arguments);
    },

    /**
     * Method: draw
     *
     * Parameters:
     * px - {<Geo.Pixel>} 
     * 
     * Returns:
     * {DOMElement} A reference to the container div for the PanZoom control.
     */
    draw: function(px) {
        // initialize our internal div
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        px = this.position;

        // place the controls
        this.buttons = [];

        var sz = new OpenLayers.Size(18,18);
        var centered = new OpenLayers.Pixel(px.x+sz.w/2, px.y);

        this._addButton("panup", "north-mini.png", centered, sz);
        px.y = centered.y+sz.h;
        this._addButton("panleft", "west-mini.png", px, sz);
        this._addButton("panright", "east-mini.png", px.add(sz.w, 0), sz);
        this._addButton("pandown", "south-mini.png", 
                        centered.add(0, sz.h*2), sz);
        this._addButton("zoomin", "zoom-plus-mini.png", 
                        centered.add(0, sz.h*3+5), sz);
						
		var num = 4;
		if(this.zoomWorldIcon){
            this._addButton("zoomworld", "zoom-world-mini.png", centered.add(0, sz.h * num++ + 5), sz);
		}
        this._addButton("zoomout", "zoom-minus-mini.png", centered.add(0, sz.h * num++ + 5), sz);
        return this.div;
    },
    
    /**
     * Method: _addButton
     * 
     * Parameters:
     * id - {String} 
     * img - {String} 
     * xy - {<Geo.Pixel>} 
     * sz - {<Geo.Size>} 
     * 
     * Returns:
     * {DOMElement} A Div (an alphaImageDiv, to be precise) that contains the
     *     image of the button, and has all the proper event handlers set.
     */
    _addButton:function(id, img, xy, sz) {
        var imgLocation = OpenLayers.Util.getImagesLocation() + img;
        var btn = OpenLayers.Util.createAlphaImageDiv(
                                    this.id + "_" + id, 
                                    xy, sz, imgLocation, "absolute");
        btn.style.cursor = "pointer";
        //we want to add the outer div
        this.div.appendChild(btn);

        OpenLayers.Event.observe(btn, "mousedown", 
            OpenLayers.Function.bindAsEventListener(this.buttonDown, btn));
        OpenLayers.Event.observe(btn, "dblclick", 
            OpenLayers.Function.bindAsEventListener(this.doubleClick, btn));
        OpenLayers.Event.observe(btn, "click", 
            OpenLayers.Function.bindAsEventListener(this.doubleClick, btn));
        btn.action = id;
        btn.map = this.map;
    
        if(!this.slideRatio){
            var slideFactorPixels = this.slideFactor;
            var getSlideFactor = function() {
                return slideFactorPixels;
            };
        } else {
            var slideRatio = this.slideRatio;
            var getSlideFactor = function(dim) {
                return this.map.getSize()[dim] * slideRatio;
            };
        }

        btn.getSlideFactor = getSlideFactor;

        //we want to remember/reference the outer div
        this.buttons.push(btn);
        return btn;
    },
    
    /**
     * Method: _removeButton
     * 
     * Parameters:
     * btn - {Object}
     */
    _removeButton: function(btn) {
        OpenLayers.Event.stopObservingElement(btn);
        btn.map = null;
        btn.getSlideFactor = null;
        this.div.removeChild(btn);
        OpenLayers.Util.removeItem(this.buttons, btn);
    },
    
    /**
     * Method: removeButtons
     */
    removeButtons: function() {
        for(var i=this.buttons.length-1; i>=0; --i) {
            this._removeButton(this.buttons[i]);
        }
    },
    
    /**
     * Method: doubleClick
     *
     * Parameters:
     * evt - {Event} 
     *
     * Returns:
     * {Boolean}
     */
    doubleClick: function (evt) {
        OpenLayers.Event.stop(evt);
        return false;
    },
    
    /**
     * Method: buttonDown
     *
     * Parameters:
     * evt - {Event} 
     */
    buttonDown: function (evt) {
        if (!OpenLayers.Event.isLeftClick(evt)) {
            return;
        }

        switch (this.action) {
            case "panup": 
                this.map.pan(0, -this.getSlideFactor("h"));
                break;
            case "pandown": 
                this.map.pan(0, this.getSlideFactor("h"));
                break;
            case "panleft": 
                this.map.pan(-this.getSlideFactor("w"), 0);
                break;
            case "panright": 
                this.map.pan(this.getSlideFactor("w"), 0);
                break;
            case "zoomin": 
                this.map.zoomIn(); 
                break;
            case "zoomout": 
                this.map.zoomOut(); 
                break;
            case "zoomworld": 
                this.map.zoomToMaxExtent(); 
                break;
        }

        OpenLayers.Event.stop(evt);
    },

    CLASS_NAME: "Geo.View2D.Control.GeoPanZoom"
});

/**
 * Constant: X
 * {Integer}
 */
Geo.View2D.Control.GeoPanZoom.X = 4;

/**
 * Constant: Y
 * {Integer}
 */
Geo.View2D.Control.GeoPanZoom.Y = 4;
/**
 * Class: Geo.View2D.Control.GeoSelectFeature
 * 选择要素控件，实现拉框，绘制多边形，点击或停留在指定的图层上选择矢量要素的功能。
 *
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
OpenLayers.Control.GeoSelectFeature = Geo.Class(Geo.View2D.Control, {

    /**
     * Constant: EVENT_TYPES
     * 事件类型。
     * 支持的事件类型:
     *  - *beforefeaturehighlighted* 
     *  要素在高亮以前触发。
     *  - *featurehighlighted* 
     *  要素高亮后触发。
     *  - *featureunhighlighted* 
     *  取消高亮时触发。
     */
    EVENT_TYPES: ["beforefeaturehighlighted", "featurehighlighted", "featureunhighlighted"],
    
    /**
     * Property: multipleKey
     * {String} An event modifier ('altKey' or 'shiftKey') that temporarily sets
     *     the <multiple> property to true.  Default is null.
     */
    multipleKey: null,
    
    /**
     * Property: toggleKey
     * {String} An event modifier ('altKey' or 'shiftKey') that temporarily sets
     *     the <toggle> property to true.  Default is null.
     */
    toggleKey: null,
    
    /**
     * APIProperty: multiple
     * {Boolean} 允许选择多个几何要素，默认为false。
     */
    multiple: false, 

    /**
     * APIProperty: clickout
     * {Boolean} 在任何要素以外点击的时候取消选择，默认为true。
     */
    clickout: true,

    /**
     * APIProperty: toggle
     * {Boolean} 点击取消选择一个选定的要素，默认值为false。
     */
    toggle: false,

    /**
     * APIProperty: hover
     * {Boolean} 在鼠标经过时选择，鼠标移除时取消选择。如果是true,将会忽视点击动作，仅监听鼠标经过动作。
     */
    hover: false,

    /**
     * APIProperty: highlightOnly
     * {Boolean} 如果设置为true,要素不会被选择仅仅会高亮。如果hover为false,本属性不会受影响。默认是false。
     */
    highlightOnly: false,
    
    /**
     * APIProperty: handlerSelection
     * {<Geo.View2D.Handler>} 控件动作监听类。允许通过拉框，鼠标绘制多边形或规则多边形来选择要素。
     */
    handlerSelection: null,
	
    /**
     * APIProperty: handlerOptions
     * {Object} 选取要素控件的动作监听对象需要设置的属性。
     */
    handlerSelOptions: null,
    
    /**
     * Property: onBeforeSelect 
     * {Function} Optional function to be called before a feature is selected.
     *     The function should expect to be called with a feature.
     */
    onBeforeSelect: function() {},
    
    /**
     * APIProperty: onSelect 
     * {Function} 当要素被选择后触发本函数。
     */
    onSelect: function() {},

    /**
     * APIProperty: onUnselect
     * {Function} 当要素被取消选择的时候触发本函数。
     */
    onUnselect: function() {},
    
    /**
     * Property: scope
     * {Object} The scope to use with the onBeforeSelect, onSelect, onUnselect
     *     callbacks. If null the scope will be this control.
     */
    scope: null,

    /**
     * APIProperty: geometryTypes
     * {Array(String)} 本数组用于存放需要被限制选择的几何对象名称。
     */
    geometryTypes: null,

    /**
     * Property: layer
     * {<Geo.View2D.Layer.Vector>} The vector layer with a common renderer
     * root for all layers this control is configured with (if an array of
     * layers was passed to the constructor), or the vector layer the control
     * was configured with (if a single layer was passed to the constructor).
     */
    layer: null,
    
    /**
     * Property: layers
     * {Array(<Geo.View2D.Layer.Vector>)} The layers this control will work on,
     * or null if the control was configured with a single layer
     */
    layers: null,
    
    /**
     * APIProperty: callbacks
     * {Object} 包含监听类型以及监听动作的对象。例如： {"onSelect": function(){}}
     */
    callbacks: null,
    
    /**
     * APIProperty: selectStyle 
     * {Object} 样式的json表示。
     */
    selectStyle: null,
    
    /**
     * Property: renderIntent
     * {String} key used to retrieve the select style from the layer's
     * style map.
     */
    renderIntent: "select",

    /**
     * Property: handlers
     * {Object} Object with references to multiple <Geo.View2D.Handler>
     *     instances.
     */
    handlers: null,

    /**
     * Constructor: Geo.View2D.Control.GeoSelectFeature
     * 构造一个新的<OpenLayers.Control.GeoSelectFeature>对象实例。
     *
     * Parameters:
     * layers - {<Geo.View2D.Layer.Vector>} 图层或图层数组。
     * options - {Object} 参数选项。
     */
    initialize: function(layers, options) {
        // concatenate events specific to this control with those from the base
        this.EVENT_TYPES =
            OpenLayers.Control.GeoSelectFeature.prototype.EVENT_TYPES.concat(
            OpenLayers.Control.prototype.EVENT_TYPES
        );
        OpenLayers.Control.prototype.initialize.apply(this, [options]);
        
        if(this.scope === null) {
            this.scope = this;
        }
        this.initLayer(layers);
        var callbacks = {
            click: this.clickFeature,
            clickout: this.clickoutFeature
        };
        if (this.hover) {
            callbacks.over = this.overFeature;
            callbacks.out = this.outFeature;
        }
             
        this.callbacks = OpenLayers.Util.extend(callbacks, this.callbacks);
        this.handlers = {
            feature: new OpenLayers.Handler.Feature(
                this, this.layer, this.callbacks,
                {geometryTypes: this.geometryTypes}
            )
        };

        if (this.handlerSelection) {
            this.handlerSelOptions = this.handlerSelOptions || {};
            
			// 拉框选取控件
            if (this.handlerSelection == OpenLayers.Handler.Box) {
                if (!this.handlerSelOptions.boxDivClassName) {
                    this.handlerSelOptions.boxDivClassName = "olHandlerBoxSelectFeature";
                }
				this.handlers.handlerSelection = new OpenLayers.Handler.Box(
	                this, {done: this.selectBox}, this.handlerSelOptions
	            ); 
            }
			
            // 多边形选取要素
            if (this.handlerSelection == OpenLayers.Handler.Polygon || this.handlerSelection == OpenLayers.Handler.RegularPolygon) {
                this.handlers.handlerSelection = new this.handlerSelection(this, {
                    done: this.selectPolygon
                }, this.handlerSelOptions);
            }
        }
    },

    /**
     * Method: initLayer
     * Assign the layer property. If layers is an array, we need to use
     *     a RootContainer.
     *
     * Parameters:
     * layers - {<Geo.View2D.Layer.Vector>}, or an array of vector layers.
     */
    initLayer: function(layers) {
        if(OpenLayers.Util.isArray(layers)) {
            this.layers = layers;
            this.layer = new OpenLayers.Layer.Vector.RootContainer(
                this.id + "_container", {
                    layers: layers
                }
            );
        } else {
            this.layer = layers;
        }
    },
    
    /**
     * Method: destroy
     */
    destroy: function() {
        if(this.active && this.layers) {
            this.map.removeLayer(this.layer);
        }
        OpenLayers.Control.prototype.destroy.apply(this, arguments);
        if(this.layers) {
            this.layer.destroy();
        }
    },

    /**
     * Method: activate
     * Activates the control.
     * 
     * Returns:
     * {Boolean} The control was effectively activated.
     */
    activate: function () {
        if (!this.active) {
            if(this.layers) {
                this.map.addLayer(this.layer);
            }
            this.handlers.feature.activate();
            if(this.handlerSelection && this.handlers.handlerSelection) {
                this.handlers.handlerSelection.activate();
            }
        }
        return OpenLayers.Control.prototype.activate.apply(
            this, arguments
        );
    },

    /**
     * Method: deactivate
     * Deactivates the control.
     * 
     * Returns:
     * {Boolean} The control was effectively deactivated.
     */
    deactivate: function () {
        if (this.active) {
            this.handlers.feature.deactivate();
            if(this.handlers.handlerSelection) {
                this.handlers.handlerSelection.deactivate();
            }
            if(this.layers) {
                this.map.removeLayer(this.layer);
            }
        }
        return OpenLayers.Control.prototype.deactivate.apply(
            this, arguments
        );
    },

    /**
     * Method: unselectAll
     * Unselect all selected features.  To unselect all except for a single
     *     feature, set the options.except property to the feature.
     *
     * Parameters:
     * options - {Object} Optional configuration object.
     */
    unselectAll: function(options) {
        // we'll want an option to supress notification here
        var layers = this.layers || [this.layer];
        var layer, feature;
        for(var l=0; l<layers.length; ++l) {
            layer = layers[l];
            for(var i=layer.selectedFeatures.length-1; i>=0; --i) {
                feature = layer.selectedFeatures[i];
                if(!options || options.except != feature) {
                    this.unselect(feature);
                }
            }
        }
    },

    /**
     * Method: clickFeature
     * Called on click in a feature
     * Only responds if this.hover is false.
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    clickFeature: function(feature) {
        if(!this.hover) {
            var selected = (OpenLayers.Util.indexOf(
                feature.layer.selectedFeatures, feature) > -1);
            if(selected) {
                if(this.toggleSelect()) {
                    this.unselect(feature);
                } else if(!this.multipleSelect()) {
                    this.unselectAll({except: feature});
                }
            } else {
                if(!this.multipleSelect()) {
                    this.unselectAll({except: feature});
                }
                this.select(feature);
            }
        }
    },

    /**
     * Method: multipleSelect
     * Allow for multiple selected features based on <multiple> property and
     *     <multipleKey> event modifier.
     *
     * Returns:
     * {Boolean} Allow for multiple selected features.
     */
    multipleSelect: function() {
        return this.multiple || (this.handlers.feature.evt &&
                                 this.handlers.feature.evt[this.multipleKey]);
    },
    
    /**
     * Method: toggleSelect
     * Event should toggle the selected state of a feature based on <toggle>
     *     property and <toggleKey> event modifier.
     *
     * Returns:
     * {Boolean} Toggle the selected state of a feature.
     */
    toggleSelect: function() {
        return this.toggle || (this.handlers.feature.evt &&
                               this.handlers.feature.evt[this.toggleKey]);
    },

    /**
     * Method: clickoutFeature
     * Called on click outside a previously clicked (selected) feature.
     * Only responds if this.hover is false.
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    clickoutFeature: function(feature) {
        if(!this.hover && this.clickout) {
            this.unselectAll();
        }
    },

    /**
     * Method: overFeature
     * Called on over a feature.
     * Only responds if this.hover is true.
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    overFeature: function(feature) {
        var layer = feature.layer;
        if(this.hover) {
            if(this.highlightOnly) {
                this.highlight(feature);
            } else if(OpenLayers.Util.indexOf(
                layer.selectedFeatures, feature) == -1) {
                this.select(feature);
            }
        }
    },

    /**
     * Method: outFeature
     * Called on out of a selected feature.
     * Only responds if this.hover is true.
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    outFeature: function(feature) {
        if(this.hover) {
            if(this.highlightOnly) {
                // we do nothing if we're not the last highlighter of the
                // feature
                if(feature._lastHighlighter == this.id) {
                    // if another select control had highlighted the feature before
                    // we did it ourself then we use that control to highlight the
                    // feature as it was before we highlighted it, else we just
                    // unhighlight it
                    if(feature._prevHighlighter &&
                       feature._prevHighlighter != this.id) {
                        delete feature._lastHighlighter;
                        var control = this.map.getControl(
                            feature._prevHighlighter);
                        if(control) {
                            control.highlight(feature);
                        }
                    } else {
                        this.unhighlight(feature);
                    }
                }
            } else {
                this.unselect(feature);
            }
        }
    },

    /**
     * Method: highlight
     * Redraw feature with the select style.
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    highlight: function(feature) {
        var layer = feature.layer;
        var cont = this.events.triggerEvent("beforefeaturehighlighted", {
            feature : feature
        });
        if(cont !== false) {
            feature._prevHighlighter = feature._lastHighlighter;
            feature._lastHighlighter = this.id;
            var style = this.selectStyle || this.renderIntent;
            layer.drawFeature(feature, style);
            this.events.triggerEvent("featurehighlighted", {feature : feature});
        }
    },

    /**
     * Method: unhighlight
     * Redraw feature with the "default" style
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    unhighlight: function(feature) {
        var layer = feature.layer;
        // three cases:
        // 1. there's no other highlighter, in that case _prev is undefined,
        //    and we just need to undef _last
        // 2. another control highlighted the feature after we did it, in
        //    that case _last references this other control, and we just
        //    need to undef _prev
        // 3. another control highlighted the feature before we did it, in
        //    that case _prev references this other control, and we need to
        //    set _last to _prev and undef _prev
        if(feature._prevHighlighter == undefined) {
            delete feature._lastHighlighter;
        } else if(feature._prevHighlighter == this.id) {
            delete feature._prevHighlighter;
        } else {
            feature._lastHighlighter = feature._prevHighlighter;
            delete feature._prevHighlighter;
        }
        layer.drawFeature(feature, feature.style || feature.layer.style ||
            "default");
        this.events.triggerEvent("featureunhighlighted", {feature : feature});
    },
    
    /**
     * Method: select
     * Add feature to the layer's selectedFeature array, render the feature as
     * selected, and call the onSelect function.
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 
     */
    select: function(feature) {
        var cont = this.onBeforeSelect.call(this.scope, feature);
        var layer = feature.layer;
        if(cont !== false) {
            cont = layer.events.triggerEvent("beforefeatureselected", {
                feature: feature
            });
            if(cont !== false) {
                layer.selectedFeatures.push(feature);
                this.highlight(feature);
                // if the feature handler isn't involved in the feature
                // selection (because the box handler is used or the
                // feature is selected programatically) we fake the
                // feature handler to allow unselecting on click
                if(!this.handlers.feature.lastFeature) {
                    this.handlers.feature.lastFeature = layer.selectedFeatures[0];
                }
                layer.events.triggerEvent("featureselected", {feature: feature});
                this.onSelect.call(this.scope, feature);
            }
        }
    },

    /**
     * Method: unselect
     * Remove feature from the layer's selectedFeature array, render the feature as
     * normal, and call the onUnselect function.
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>}
     */
    unselect: function(feature) {
        var layer = feature.layer;
        // Store feature style for restoration later
        this.unhighlight(feature);
        OpenLayers.Util.removeItem(layer.selectedFeatures, feature);
        layer.events.triggerEvent("featureunselected", {feature: feature});
        this.onUnselect.call(this.scope, feature);
    },
    
    /**
     * Method: selectBox
     * Callback from the handlers.box set up when <box> selection is true
     *     on.
     *
     * Parameters:
     * position - {<Geo.Bounds> || <Geo.Pixel> }  
     */
    selectBox: function(position) {
        if (position instanceof OpenLayers.Bounds) {
            var minXY = this.map.getLonLatFromPixel(
                new OpenLayers.Pixel(position.left, position.bottom)
            );
            var maxXY = this.map.getLonLatFromPixel(
                new OpenLayers.Pixel(position.right, position.top)
            );
            var bounds = new OpenLayers.Bounds(
                minXY.lon, minXY.lat, maxXY.lon, maxXY.lat
            );
            
            // if multiple is false, first deselect currently selected features
            if (!this.multipleSelect()) {
                this.unselectAll();
            }
            
            // because we're using a box, we consider we want multiple selection
            var prevMultiple = this.multiple;
            this.multiple = true;
            var layers = this.layers || [this.layer];
            var layer;
            for(var l=0; l<layers.length; ++l) {
                layer = layers[l];
                for(var i=0, len = layer.features.length; i<len; ++i) {
                    var feature = layer.features[i];
                    // check if the feature is displayed
                    if (!feature.getVisibility()) {
                        continue;
                    }

                    if (this.geometryTypes == null || OpenLayers.Util.indexOf(
                            this.geometryTypes, feature.geometry.CLASS_NAME) > -1) {
                        if (bounds.toGeometry().intersects(feature.geometry)) {
                            if (OpenLayers.Util.indexOf(layer.selectedFeatures, feature) == -1) {
                                this.select(feature);
                            }
                        }
                    }
                }
            }
            this.multiple = prevMultiple;
        }
    },

	/**
     * Method: selectPolygon
     * Callback from the handlers.handlerSelection set up when <polygon> selection has been setted.
     *
     * Parameters:
     * geometry - {<Geo.Geometry>}  
     */
    selectPolygon: function(geometry) {
		if (geometry instanceof OpenLayers.Geometry) {
			// if multiple is false, first deselect currently selected features
            if (!this.multipleSelect()) {
                this.unselectAll();
            }
            
            // because we're using a polygon, we consider we want multiple selection
            var prevMultiple = this.multiple;
            this.multiple = true;
			var layers = this.layers || [this.layer];
            var layer;
            for(var l=0; l<layers.length; ++l) {
                layer = layers[l];
                for(var i=0, len = layer.features.length; i<len; ++i) {
                    var feature = layer.features[i];
                    // check if the feature is displayed
                    if (!feature.getVisibility()) {
                        continue;
                    }

                    if (this.geometryTypes == null || OpenLayers.Util.indexOf(
                            this.geometryTypes, feature.geometry.CLASS_NAME) > -1) {
                        if (geometry.intersects(feature.geometry)) {
                            if (OpenLayers.Util.indexOf(layer.selectedFeatures, feature) == -1) {
                                this.select(feature);
                            }
                        }
                    }
                }
            }
			this.multiple = prevMultiple;
        }
	},
	
    /** 
     * Method: setMap
     * Set the map property for the control. 
     * 
     * Parameters:
     * map - {<Geo.View2D.Map>} 
     */
    setMap: function(map) {
        this.handlers.feature.setMap(map);
        if (this.handlerSelection) {
            this.handlers.handlerSelection.setMap(map);
        }
        OpenLayers.Control.prototype.setMap.apply(this, arguments);
    },
    
    /**
     * APIMethod: setLayer
     * 将一个新的图层添加到本控件上，这样会覆盖所有已经存在的图层。
     * 
     * Parameters:
     * layers - {<Geo.View2D.Layer.Vector>}数组 或单个{<Geo.View2D.Layer.Vector>}对象。
     */
    setLayer: function(layers) {
        var isActive = this.active;
        this.unselectAll();
        this.deactivate();
        if(this.layers) {
            this.layer.destroy();
            this.layers = null;
        }
        this.initLayer(layers);
        this.handlers.feature.layer = this.layer;
        if (isActive) {
            this.activate();
        }
    },
    
    CLASS_NAME: "Geo.View2D.Control.GeoSelectFeature"
});
/**
 * Class: Geo.View2D.Control.ZoomBar
 * 简单的缩放工具条。
 * 制作图片时，放大缩小工具zoomin zoomout的宽度和缩放条zoombar宽度一致。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control.PanZoom>
 */
Geo.View2D.Control.ZoomBar = Geo.Class(Geo.View2D.Control.PanZoom, {
    /** 
     * APIProperty: zoomStopWidth
     * 缩放条停止的宽度，默认为18。
     */
    //zoomStopWidth: 18,
	zoombarWidth: 18,

    /** 
     * APIProperty: zoomStopHeight
     * 缩放条刻度的高度，默认为14。
     */
    zoomStopHeight: 14,

    /** 
     * Property: slider
     * 定义滑动对象。
     */
    slider: null,

    /** 
     * Property: sliderEvents
     * {<OpenLayers.Events>}
     * 滑动事件。
     */
    sliderEvents: null,

    /** 
     * Property: zoombarDiv
     * {DOMElement} 缩放条DIV对象。
     */
    zoombarDiv: null,

    /** 
     * Property: divEvents
     * {<OpenLayers.Events>} div事件对象。
     */
    divEvents: null,

    /** 
     * APIProperty: zoomWorldIcon
     * {Boolean} 是否显示全图，默认为不显示false。
     */
    zoomWorldIcon: false,

    /**
     * APIProperty: panIcons
     * {Boolean} 设置属性为false不显示上下左右工具，设置为true显示，默认为false。
     */
    panIcons: false,

    /**
     * APIProperty: forceFixedZoomLevel
     * {Boolean} Force a fixed zoom level even though the map has 
     *     fractionalZoom
     */
    forceFixedZoomLevel: false,

    /**
     * Property: mouseDragStart
     * {<OpenLayers.Pixel>}
     */
    mouseDragStart: null,

    /**
     * Property: deltaY
     * {Number} The cumulative vertical pixel offset during a zoom bar drag.
     */
    deltaY: null,

    /**
     * Property: zoomStart
     * {<OpenLayers.Pixel>}
     */
    zoomStart: null,
    
    /**
     * Property: imgLocation
     * @type String 设置工具使用的图标位置,如："img/",默认为空，使用openlayers下面的图片。
     */
    imgLocation:"",
    
    /**
     * Property: zoomIcon
     * @type Boolean  设置这个属性true显示放大缩小工具,如果设置false不显示放大缩小工具，默认为false。
     */
    zoomIcon:false,
    
    /**
     * Property: defaultIcon
     * @type Boolean  设置这个属性true显示默认的缩放工具条,如果设置false显示自定义工具条，默认为true。
     */
    defaultIcon:true,
    
     /** 
     * APIProperty: zoomWidth
     * 放大缩小工具zoomin zoomout的宽度，默认为18。
     */
    zoomWidth: 18,
    
     /** 
     * APIProperty: zoomHeight
     * 放大缩小工具zoomin zoomout的高度，默认为18。
     */
    zoomHeight: 18,
    
    /** 
     * APIProperty: sliderWidth
     * 滑动条slider的宽度，默认为20。
     */
    sliderWidth:20,
    
    /** 
     * APIProperty: sliderHeight
     * 滑动条slider的高度，默认为9。
     */
    sliderHeight:9,
    
    /** 
     * APIProperty: zoombarWidth
     * 缩放条zoombar的宽度，默认为18。
     */
    zoombarWidth:18,
    
    /**
     * APIMethod: destroy
     * 销毁本对象。
     */
    destroy: function() {

        this._removeZoomBar();

        this.map.events.un({
            "changebaselayer": this.redraw,
            scope: this
        });

        OpenLayers.Control.PanZoom.prototype.destroy.apply(this, arguments);

        delete this.mouseDragStart;
        delete this.zoomStart;
    },
    
    /**
     * Method: setMap
     * 关联地图。
     * 
     * Parameters:
     * map - {<OpenLayers.Map>} 
     */
    setMap: function(map) {
        OpenLayers.Control.PanZoom.prototype.setMap.apply(this, arguments);
        this.map.events.register("changebaselayer", this, this.redraw);
    },

    /** 
     * Method: redraw
     * clear the div and start over.
     */
    redraw: function() {
        if (this.div != null) {
            this.removeButtons();
            this._removeZoomBar();
        }  
        this.draw();
    },
    
    /**
    * Method: draw
    * 绘制方法。
    *
    * Parameters:
    * px - {<OpenLayers.Pixel>} 
    */
    draw: function(px) {
        // initialize our internal div
        OpenLayers.Control.prototype.draw.apply(this, arguments);
        px = this.position.clone();

        // place the controls
        this.buttons = [];
        
        
        var sz = new OpenLayers.Size(this.zoomWidth,this.zoomHeight);
        
        /**
        if (this.panIcons) {
            var centered = new OpenLayers.Pixel(px.x+sz.w/2, px.y);
            var wposition = sz.w;

            if (this.zoomWorldIcon) {
                centered = new OpenLayers.Pixel(px.x+sz.w, px.y);
            }

            this._addButton("panup", "north-mini.png", centered, sz);
            px.y = centered.y+sz.h;
            this._addButton("panleft", "west-mini.png", px, sz);
            if (this.zoomWorldIcon) {
                this._addButton("zoomworld", "zoom-world-mini.png", px.add(sz.w, 0), sz);

                wposition *= 2;
            }
            this._addButton("panright", "east-mini.png", px.add(wposition, 0), sz);
            this._addButton("pandown", "south-mini.png", centered.add(0, sz.h*2), sz);
            this._addButton("zoomin", "zoom-plus-mini.png", centered.add(0, sz.h*3+5), sz);
            centered = this._addZoomBar(centered.add(0, sz.h*4 + 5));
            this._addButton("zoomout", "zoom-minus-mini.png", centered, sz);
        }
        else */
        if(this.zoomIcon){
        	/**
        	 var centered = new OpenLayers.Pixel(px.x + sz.w / 2, px.y);
        	  this._addButton("zoomin", "zoom-plus-mini.png", centered.add(0, sz.h * 3 + 5), sz, "放大一级");
		      centered = this._addZoomBar(centered.add(0, sz.h * 4 + 5));
		      this._addButton("zoomout", "zoom-minus-mini.png", centered.add(0, sz.h * 4 + 10), sz, "缩小一级");
        	*/
        	
        	/**
        	var centered = new OpenLayers.Pixel(px.x + sz.w / 2, px.y);
    	    this._addButton("zoomin", "zoom-plus-mini.png", centered.add(0, sz.h * 3 + 5), sz, "放大一级");
    	    centered = this._addZoomBar(centered.add(3, sz.h * 4 + 5));
   		    this._addButton("zoomout", "zoom-minus-mini.png", centered.add(-3, 0), sz, "缩小一级");
        	            */
        	
        	var centered = new OpenLayers.Pixel(px.x+sz.w/2, px.y);
            this._addButton("zoomin", "zoom-plus-mini.png", px, sz);
            
            centered = this._addZoomBar(px.add(0, sz.h));
            
            this._addButton("zoomout", "zoom-minus-mini.png", centered, sz);

//            if (this.zoomWorldIcon) {
//                centered = centered.add(0, sz.h+3);
//                this._addButton("zoomworld", "zoom-world-mini.png", centered, sz);
//            }
        } else {
            centered = this._addZoomBar(px.add(0, sz.h));
//            if (this.zoomWorldIcon) {
//                centered = centered.add(0, sz.h+3);
//                this._addButton("zoomworld", "zoom-world-mini.png", centered, sz);
//            }
        }
        return this.div;
    },
    
    /**
     * Method: _addButton
     * 
     * Parameters:
     * id - {String} 
     * img - {String} 
     * xy - {<OpenLayers.Pixel>} 
     * sz - {<OpenLayers.Size>} 
     * 
     * Returns:
     * {DOMElement} A Div (an alphaImageDiv, to be precise) that contains the
     *     image of the button, and has all the proper event handlers set.
     */
    _addButton:function(id, img, xy, sz) {
        var imgLocation = OpenLayers.Util.getImagesLocation() + img;
        if(this.defaultIcon){
        	var btn = OpenLayers.Util.createAlphaImageDiv(this.id + "_" + id, 
                                    xy, sz, imgLocation, "absolute");
        }else{
        	var className = id;
        	var btn = OpenLayers.Util.createAlphaImageDiv(this.id + "_" + id, 
                                    xy, sz, "", "absolute");
            btn.className = className;                        
        }
        btn.style.cursor = "pointer";
        //we want to add the outer div
        this.div.appendChild(btn);

        OpenLayers.Event.observe(btn, "mousedown", 
            OpenLayers.Function.bindAsEventListener(this.buttonDown, btn));
        OpenLayers.Event.observe(btn, "dblclick", 
            OpenLayers.Function.bindAsEventListener(this.doubleClick, btn));
        OpenLayers.Event.observe(btn, "click", 
            OpenLayers.Function.bindAsEventListener(this.doubleClick, btn));
        btn.action = id;
        btn.map = this.map;
    
        if(!this.slideRatio){
            var slideFactorPixels = this.slideFactor;
            var getSlideFactor = function() {
                return slideFactorPixels;
            };
        } else {
            var slideRatio = this.slideRatio;
            var getSlideFactor = function(dim) {
                return this.map.getSize()[dim] * slideRatio;
            };
        }

        btn.getSlideFactor = getSlideFactor;
		
        //we want to remember/reference the outer div
        this.buttons.push(btn);
        return btn;
    },
    /** 
    * Method: _addZoomBar
    * 
    * Parameters:
    * location - {<OpenLayers.Pixel>} where zoombar drawing is to start.
    */
    _addZoomBar:function(centered) {
    	var imgLocation = this.imgLocation;
        if(this.imgLocation == ""){
        	 imgLocation = OpenLayers.Util.getImagesLocation();
        }
        var id = this.id + "_" + this.map.id;
        var zoomsToEnd = this.map.getNumZoomLevels() - 1 - this.map.getZoom();
        if(this.defaultIcon){
        	var slider = OpenLayers.Util.createAlphaImageDiv(id,
                       centered.add(-1, zoomsToEnd * this.zoomStopHeight),
                       //centered.add(-1, zoomsToEnd * this.zoomStopHeight),
                       //centered.add(8, zoomsToEnd * this.zoomStopHeight),
                       new OpenLayers.Size(20,9),
                       //new OpenLayers.Size(18,18),
                       imgLocation+"slider.png",
                       "absolute");
        }else{
        	var slider = OpenLayers.Util.createAlphaImageDiv(id,
                       centered.add((this.zoomWidth - this.sliderWidth) / 2, zoomsToEnd * this.zoomStopHeight),
                       new OpenLayers.Size(this.sliderWidth,this.sliderHeight),
                       "",
                       "absolute");
            slider.className = "slider";
        }
        
        slider.style.cursor = "move";
        this.slider = slider;
        
        this.sliderEvents = new OpenLayers.Events(this, slider, null, true,
                                            {includeXY: true});
        this.sliderEvents.on({
            "touchstart": this.zoomBarDown,
            "touchmove": this.zoomBarDrag,
            "touchend": this.zoomBarUp,
            "mousedown": this.zoomBarDown,
            "mousemove": this.zoomBarDrag,
            "mouseup": this.zoomBarUp,
            "dblclick": this.doubleClick,
            "click": this.doubleClick
        });
        
        var sz = new OpenLayers.Size();
        sz.h = this.zoomStopHeight * this.map.getNumZoomLevels();
        //sz.w = this.zoomStopWidth;
        sz.w = this.zoombarWidth;
        var div = null;
        
        if (OpenLayers.Util.alphaHack()) {
            var id = this.id + "_" + this.map.id;
            div = OpenLayers.Util.createAlphaImageDiv(id, centered,
                                      new OpenLayers.Size(sz.w, 
                                              this.zoomStopHeight),
                                      imgLocation + "zoombar.png", 
                                      "absolute", null, "crop");
            div.style.height = sz.h + "px";
        } else {
        	if(this.defaultIcon){
        		 div = OpenLayers.Util.createDiv(
                        'OpenLayers_Control_PanZoomBar_Zoombar' + this.map.id,
                        centered,
                        sz,
                        imgLocation+"zoombar.png");
        	}else{
            	div = OpenLayers.Util.createDiv(
                        'OpenLayers_Control_PanZoomBar_Zoombar' + this.map.id,
                        centered,
                        sz
                       );
        		div.className = "zoombar";
        	}
        }
        div.style.cursor = "pointer";
        
        
        this.zoombarDiv = div;
        
        
        this.divEvents = new OpenLayers.Events(this, div, null, true, 
                                                {includeXY: true});
        this.divEvents.on({
            "touchmove": this.passEventToSlider,
            "mousedown": this.divClick,
            "mousemove": this.passEventToSlider,
            "dblclick": this.doubleClick,
            "click": this.doubleClick
        });
        
        this.div.appendChild(div);

        this.startTop = parseInt(div.style.top);
        this.div.appendChild(slider);
        
        this.div.onmouseover = this._onmouseover;
        this.div.onmouseout = this._onmouseout;

        this.map.events.register("zoomend", this, this.moveZoomBar);

        centered = centered.add(0,
        //centered = centered.add((this.zoomWidth-this.zoomStopWidth)/2,
            this.zoomStopHeight * this.map.getNumZoomLevels());
        return centered; 
    },
    
    //移在上面触发
    _onmouseover:function(){
    		for (var i = 0; i < this.childNodes.length; i ++) {
				var div = this.childNodes[i];
				if(div.className == "zoomin"){
					div.className="zoomin_";
				}
				if(div.className == "zoomout"){
					div.className="zoomout_";
				}
				if(div.className == "zoombar"){
					div.className="zoombar_";
				}
				if(div.className == "slider"){
					div.className="slider_";
				}
			}
    },
    //移出触发
    _onmouseout:function(){
    		for (var i = 0; i < this.childNodes.length; i ++) {
				var div = this.childNodes[i];
				
				if(div.className == "zoomin_"){
					
					div.className="zoomin";
				}
				if(div.className == "zoomout_"){
					div.className="zoomout";
				}
				if(div.className == "zoombar_"){
					div.className="zoombar";
				}
				if(div.className == "slider_"){
					div.className="slider";
				}
			}
    },
    
    /**
     * Method: _removeZoomBar
     */
    _removeZoomBar: function() {
        this.sliderEvents.un({
            "touchmove": this.zoomBarDrag,
            "mousedown": this.zoomBarDown,
            "mousemove": this.zoomBarDrag,
            "mouseup": this.zoomBarUp,
            "dblclick": this.doubleClick,
            "click": this.doubleClick
        });
        this.sliderEvents.destroy();

        this.divEvents.un({
            "touchmove": this.passEventToSlider,
            "mousedown": this.divClick,
            "mousemove": this.passEventToSlider,
            "dblclick": this.doubleClick,
            "click": this.doubleClick
        });
        this.divEvents.destroy();
        
        this.div.removeChild(this.zoombarDiv);
        this.zoombarDiv = null;
        this.div.removeChild(this.slider);
        this.slider = null;
        
        this.map.events.unregister("zoomend", this, this.moveZoomBar);
    },
    
    /**
     * Method: passEventToSlider
     * This function is used to pass events that happen on the div, or the map,
     * through to the slider, which then does its moving thing.
     *
     * Parameters:
     * evt - {<OpenLayers.Event>} 
     */
    passEventToSlider:function(evt) {
        this.sliderEvents.handleBrowserEvent(evt);
    },
    
    /**
     * Method: divClick
     * Picks up on clicks directly on the zoombar div
     *           and sets the zoom level appropriately.
     */
    divClick: function (evt) {
        if (!OpenLayers.Event.isLeftClick(evt)) {
            return;
        }
        var levels = evt.xy.y / this.zoomStopHeight;
        if(this.forceFixedZoomLevel || !this.map.fractionalZoom) {
            levels = Math.floor(levels);
        }    
        var zoom = (this.map.getNumZoomLevels() - 1) - levels; 
        zoom = Math.min(Math.max(zoom, 0), this.map.getNumZoomLevels() - 1);
        this.map.zoomTo(zoom);
        OpenLayers.Event.stop(evt);
    },
    
    /**
     * Method: zoomBarDown
     * event listener for clicks on the slider
     *
     * Parameters:
     * evt - {<OpenLayers.Event>} 
     */
    zoomBarDown:function(evt) {
        if (!OpenLayers.Event.isLeftClick(evt) && !OpenLayers.Event.isSingleTouch(evt)) {
            return;
        }
        this.map.events.on({
            "touchmove": this.passEventToSlider,
            "mousemove": this.passEventToSlider,
            "mouseup": this.passEventToSlider,
            scope: this
        });
        this.mouseDragStart = evt.xy.clone();
        this.zoomStart = evt.xy.clone();
        this.div.style.cursor = "move";
        // reset the div offsets just in case the div moved
        this.zoombarDiv.offsets = null; 
        OpenLayers.Event.stop(evt);
    },
    
    /**
     * Method: zoomBarDrag
     * This is what happens when a click has occurred, and the client is
     * dragging.  Here we must ensure that the slider doesn't go beyond the
     * bottom/top of the zoombar div, as well as moving the slider to its new
     * visual location
     *
     * Parameters:
     * evt - {<OpenLayers.Event>} 
     */
    zoomBarDrag:function(evt) {
        if (this.mouseDragStart != null) {
            var deltaY = this.mouseDragStart.y - evt.xy.y;
            var offsets = OpenLayers.Util.pagePosition(this.zoombarDiv);
            if ((evt.clientY - offsets[1]) > 0 && 
                (evt.clientY - offsets[1]) < parseInt(this.zoombarDiv.style.height) - 2) {
                var newTop = parseInt(this.slider.style.top) - deltaY;
                this.slider.style.top = newTop+"px";
                this.mouseDragStart = evt.xy.clone();
            }
            // set cumulative displacement
            this.deltaY = this.zoomStart.y - evt.xy.y;
            OpenLayers.Event.stop(evt);
        }
    },
    
    /**
     * Method: zoomBarUp
     * Perform cleanup when a mouseup event is received -- discover new zoom
     * level and switch to it.
     *
     * Parameters:
     * evt - {<OpenLayers.Event>} 
     */
    zoomBarUp:function(evt) {
        if (!OpenLayers.Event.isLeftClick(evt) && evt.type !== "touchend") {
            return;
        }
        if (this.mouseDragStart) {
            this.div.style.cursor="";
            this.map.events.un({
                "touchmove": this.passEventToSlider,
                "mouseup": this.passEventToSlider,
                "mousemove": this.passEventToSlider,
                scope: this
            });
            var zoomLevel = this.map.zoom;
            if (!this.forceFixedZoomLevel && this.map.fractionalZoom) {
                zoomLevel += this.deltaY/this.zoomStopHeight;
                zoomLevel = Math.min(Math.max(zoomLevel, 0), 
                                     this.map.getNumZoomLevels() - 1);
            } else {
                zoomLevel += this.deltaY/this.zoomStopHeight;
                zoomLevel = Math.max(Math.round(zoomLevel), 0);      
            }
            this.map.zoomTo(zoomLevel);
            this.mouseDragStart = null;
            this.zoomStart = null;
            this.deltaY = 0;
            OpenLayers.Event.stop(evt);
        }
    },
    
   /**
    * Method: moveZoomBar
    * Change the location of the slider to match the current zoom level.
    */
    moveZoomBar:function() {
        var newTop = 
            ((this.map.getNumZoomLevels()-1) - this.map.getZoom()) * 
            this.zoomStopHeight + this.startTop + 1;
        this.slider.style.top = newTop + "px";
    },    
    
    CLASS_NAME: "Geo.View2D.Control.ZoomBar"
});
/**
 * Class: Geo.View2D.Control.GeoNavigationHistory
 * 操作历史导航控件类。用户使用鼠标操作地图或者在地图上绘制要素，
 * 此控件能记录地图的平移和缩放操作、矢量要素，并将这些信息存放到本地浏览器的localStorage对象中。
 * 当用户关闭浏览器再次打开时读取这些信息，并通过控件的“前进”、“后退”按钮进行浏览查看。
 *
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.GeoNavigationHistory = Geo.Class(Geo.View2D.Control, {

    /**
     * Property: type
     * {String} Note that this control is not intended to be added directly
     *     to a control panel.  Instead, add the sub-controls previous and
     *     next.  These sub-controls are button type controls that activate
     *     and deactivate themselves.  If this parent control is added to
     *     a panel, it will act as a toggle.
     */
    type: Geo.View2D.Control.TYPE_TOGGLE,

    /**
     * APIProperty: previous
     * {<Geo.View2D.Control>} "上一步"的控件按钮对象。
     */
    previous: null,
    
    /**
     * APIProperty: previousOptions
     * {Object} 设置"上一步"的控件对象的构造参数对象。
     */
    previousOptions: null,
    
    /**
     * APIProperty: next
     * {<Geo.View2D.Control>} "下一步"的控件按钮对象。
     */
    next: null,

    /**
     * APIProperty: nextOptions
     * {Object} 设置"下一步"的控件对象的构造参数对象。
     */
    nextOptions: null,

    /**
     * APIProperty: limit
     * {Integer} 历史操作的记录限制数量。
     */
    limit: 50,

    /**
     * APIProperty: autoActivate
     * {Boolean} 是否在控件添加至地图后自动激活。
     */
    autoActivate: true,

    /**
     * Property: clearOnDeactivate
     * {Boolean} Clear the history when the control is deactivated.  Default
     *     is false.
     */
    clearOnDeactivate: false,

    /**
     * Property: registry
     * {Object} An object with keys corresponding to event types.  Values
     *     are functions that return an object representing the current state.
     */
    registry: null,

    /**
     * Property: nextStack
     * {Array} Array of items in the history.
     */
    nextStack: null,

    /**
     * Property: previousStack
     * {Array} List of items in the history.  First item represents the current
     *     state.
     */
    previousStack: null,
    
    /**
     * Property: listeners
     * {Object} An object containing properties corresponding to event types.
     *     This object is used to configure the control and is modified on
     *     construction.
     */
    listeners: null,
    
    /**
     * Property: restoring
     * {Boolean} Currently restoring a history state.  This is set to true
     *     before calling restore and set to false after restore returns.
     */
    restoring: false,
    
    /**
     * Constructor: Geo.View2D.Control.GeoNavigationHistory
     * Geo.View2D.Control.GeoNavigationHistory对象构造函数。
     * 
     * Parameters:
     * options - {Object} 参数对象。
     * vectorLayer - {<Geo.View2D.Layer.Vector>} 矢量要素图层。
     */
    initialize: function(options, vectorLayer) {
        Geo.View2D.Control.prototype.initialize.apply(this, [options]);
		this.vectorLayer = vectorLayer;
        this.registry = OpenLayers.Util.extend({
            "moveend": this.getState,
			"featureadded": this.getState,
			"featureremoved": this.getState
        }, this.registry);
        
        var previousOptions = {
            trigger: OpenLayers.Function.bind(this.previousTrigger, this),
            displayClass: this.displayClass + " " + this.displayClass + "Previous"
        };
        OpenLayers.Util.extend(previousOptions, this.previousOptions);
        this.previous = new Geo.View2D.Control.Button(previousOptions);
        
        var nextOptions = {
            trigger: OpenLayers.Function.bind(this.nextTrigger, this),
            displayClass: this.displayClass + " " + this.displayClass + "Next"
        };
        OpenLayers.Util.extend(nextOptions, this.nextOptions);
        this.next = new Geo.View2D.Control.Button(nextOptions);

        this.clear();
		
        this.format = this.format ? this.format : new Geo.Format.GML();
        this.jsonParser = new OpenLayers.Format.JSON();
		
		//window.localStorage.clear();
		try {
			this.previousStack = this.readStack(window.localStorage.getItem("previousStack"));
			this.nextStack = this.readStack(window.localStorage.getItem("nextStack"));
		} catch (e) {
		}
		
		this.initFlag = true;
    },
    
    /**
     * Method: onPreviousChange
     * Called when the previous history stack changes.
     *
     * Parameters:
     * state - {Object} An object representing the state to be restored
     *     if previous is triggered again or null if no previous states remain.
     * length - {Integer} The number of remaining previous states that can
     *     be restored.
     */
    onPreviousChange: function(state, length) {
        if(state && !this.previous.active) {
            this.previous.activate();
        } else if(!state && this.previous.active) {
            this.previous.deactivate();
        }
    },
    
    /**
     * Method: onNextChange
     * Called when the next history stack changes.
     *
     * Parameters:
     * state - {Object} An object representing the state to be restored
     *     if next is triggered again or null if no next states remain.
     * length - {Integer} The number of remaining next states that can
     *     be restored.
     */
    onNextChange: function(state, length) {
        if(state && !this.next.active) {
            this.next.activate();
        } else if(!state && this.next.active) {
            this.next.deactivate();
        }
    },
    
    /**
     * APIMethod: destroy
     * 销毁这个控件。
     */
    destroy: function() {
        Geo.View2D.Control.prototype.destroy.apply(this);
        this.previous.destroy();
        this.next.destroy();
        this.deactivate();
        for(var prop in this) {
            this[prop] = null;
        }
    },
    
    /** 
     * Method: setMap
     * Set the map property for the control and <previous> and <next> child
     *     controls.
     *
     * Parameters:
     * map - {<Geo.View2D.Map>} 
     */
    setMap: function(map) {
        this.map = map;
        this.next.setMap(map);
        this.previous.setMap(map);
    },

    /**
     * Method: draw
     * Called when the control is added to the map.
     */
    draw: function() {
        Geo.View2D.Control.prototype.draw.apply(this, arguments);
        this.next.draw();
        this.previous.draw();
    },
    
    /**
     * Method: previousTrigger
     * Restore the previous state.  If no items are in the previous history
     *     stack, this has no effect.
     *
     * Returns:
     * {Object} Item representing state that was restored.  Undefined if no
     *     items are in the previous history stack.
     */
    previousTrigger: function() {
        var current = this.previousStack.shift();
        var state = this.previousStack.shift();
        if(state != undefined) {
            this.nextStack.unshift(current);
            this.previousStack.unshift(state);
            this.restoring = true;
            this.restore(state);
            this.restoring = false;
            this.onNextChange(this.nextStack[0], this.nextStack.length);
            this.onPreviousChange(
                this.previousStack[1], this.previousStack.length - 1
            );
        } else {
            this.previousStack.unshift(current);
        }
		try {
			window.localStorage.setItem("previousStack", this.writeStack(this.previousStack));
			window.localStorage.setItem("nextStack", this.writeStack(this.nextStack));
		}catch(e){
		}
        return state;
    },
    
    /**
     * APIMethod: nextTrigger
     * 点击“前进”按钮触发的函数。
     *
     * Returns:
     * {Object} 返回“前进”后的状态对象。
     */
    nextTrigger: function() {
        var state = this.nextStack.shift();
        if(state != undefined) {
            this.previousStack.unshift(state);
            this.restoring = true;
            this.restore(state);
            this.restoring = false;
            this.onNextChange(this.nextStack[0], this.nextStack.length);
            this.onPreviousChange(
                this.previousStack[1], this.previousStack.length - 1
            );
        }
		try {
			window.localStorage.setItem("previousStack", this.writeStack(this.previousStack));
			window.localStorage.setItem("nextStack", this.writeStack(this.nextStack));
		}catch(e){
		}
        return state;
    },
    
    /**
     * APIMethod: clear
     * 清除内存中该控件记录的操作信息。
     */
    clear: function() {
        this.previousStack = [];
        this.previous.deactivate();
        this.nextStack = [];
        this.next.deactivate();
    },

    /**
     * Method: getState
     * Get the current state and return it.
     *
     * Returns:
     * {Object} An object representing the current state.
     */
    getState: function() {
		var features = OpenLayers.Util.extend([], this.vectorLayer.features);
        return {
            center: this.map.getCenter(),
            resolution: this.map.getResolution(),
            projection: this.map.getProjectionObject(),
            units: this.map.getProjectionObject().getUnits() || 
                this.map.units || this.map.baseLayer.units,
			features: features//OpenLayers.Util.extend({}, this.vectorLayer.features)
        };
    },

    /**
     * Method: restore
     * Update the state with the given object.
     *
     * Parameters:
     * state - {Object} An object representing the state to restore.
     */
    restore: function(state) {
        var center, zoom;
        if (this.map.getProjectionObject() == state.projection) { 
            zoom = this.map.getZoomForResolution(state.resolution);
            center = state.center;
        } else {
            center = state.center.clone();
            center.transform(state.projection, this.map.getProjectionObject());
            var sourceUnits = state.units;
            var targetUnits = this.map.getProjectionObject().getUnits() || 
                this.map.units || this.map.baseLayer.units;
            var resolutionFactor = sourceUnits && targetUnits ? 
                OpenLayers.INCHES_PER_UNIT[sourceUnits] / OpenLayers.INCHES_PER_UNIT[targetUnits] : 1;
            zoom = this.map.getZoomForResolution(resolutionFactor*state.resolution); 
        }
        this.map.setCenter(center, zoom);
		
		var features;
		features = state.features;
		this.vectorLayer.removeFeatures(this.vectorLayer.features);
		if(features && features.length){
			this.vectorLayer.addFeatures(features);
		}
		
    },
    
    /**
     * Method: writeStack
     */
    writeStack: function(stack) {
		var preStack = new Array();
        for (var i = 0; i < stack.length; i++) {
			var features = this.format.write(stack[i].features);
            var item = {
                center: stack[i].center,
                resolution: stack[i].resolution,
                projection: stack[i].projection,
                units: stack[i].units,
                features: features
            }
			preStack.push(item);
        }
		this.preStackJsonStr = this.jsonParser.write(preStack);
		return this.preStackJsonStr;
	},
    
    /**
     * Method: readStack
     */
    readStack: function(stackStr) {
		var preStack = new Array();
		if(!stackStr){
			return [];
		}
        var jsonObj = this.jsonParser.read(stackStr);
        for (var i = 0; i < jsonObj.length; i++) {
			 var item = {
                center: new OpenLayers.LonLat(jsonObj[i].center.lon, jsonObj[i].center.lat),
                resolution: jsonObj[i].resolution,
                projection: new OpenLayers.Projection(jsonObj[i].projection.projCode),
                units: jsonObj[i].units,
                features: this.format.read(jsonObj[i].features)
            }
			preStack.push(item);
        }
		return preStack;
	},
	
    /**
     * Method: setListeners
     * Sets functions to be registered in the listeners object.
     */
    setListeners: function() {
        this.listeners = {};
        for(var type in this.registry) {
            if (type == "featureadded" && this.vectorLayer) {
				//要素被添加后，触发该函数。保存这次操作。
				this.listeners["featureadded"] = OpenLayers.Function.bind(function(){
					if (!this.restoring) {
                        var state = this.registry["featureadded"].apply(this, arguments);
                        this.previousStack.unshift(state);
                        if (this.previousStack.length > 1) {
                            this.onPreviousChange(this.previousStack[1], this.previousStack.length - 1);
                        }
                        if (this.previousStack.length > (this.limit + 1)) {
                            this.previousStack.pop();
                        }
                        if (this.nextStack.length > 0) {
                            this.nextStack = [];
                            this.onNextChange(null, 0);
                        }
						
						/* 保存至localStorage。HTML5的功能 */
						try{
							window.localStorage.setItem("previousStack", this.writeStack(this.previousStack));
							window.localStorage.setItem("nextStack", this.writeStack(this.nextStack));
						}catch(e){
							
						}
                    }
                    return true;
				}, this);
            } else if(type == "featureremoved" && this.vectorLayer){
				//要素被添加后，触发该函数。保存这次操作。
				this.listeners["featureremoved"] = OpenLayers.Function.bind(function(){
					if (!this.restoring) {
						if(!this.registry){
							return true;
						}
                        var state = this.registry["featureremoved"].apply(this, arguments);
                        this.previousStack.unshift(state);
                        if (this.previousStack.length > 1) {
                            this.onPreviousChange(this.previousStack[1], this.previousStack.length - 1);
                        }
                        if (this.previousStack.length > (this.limit + 1)) {
                            this.previousStack.pop();
                        }
                        if (this.nextStack.length > 0) {
                            this.nextStack = [];
                            this.onNextChange(null, 0);
                        }
						
						/* 保存至localStorage。HTML5的功能 */
						try{
							window.localStorage.setItem("previousStack", this.writeStack(this.previousStack));
							window.localStorage.setItem("nextStack", this.writeStack(this.nextStack));
						}catch(e){
							
						}
                    }
                    return true;
				}, this);
			} else if(type == "moveend"){
				//地图被操作后，触发该函数。保存这次操作。
                this.listeners["moveend"] = OpenLayers.Function.bind(function(){
                    if (!this.restoring) {
						// 不支持HTML5
						if (!window.localStorage) {
							var state = this.registry["moveend"].apply(this, arguments);
	                        this.previousStack.unshift(state);
	                        if (this.previousStack.length > 1) {
	                            this.onPreviousChange(this.previousStack[1], this.previousStack.length - 1);
	                        }
	                        if (this.previousStack.length > (this.limit + 1)) {
	                            this.previousStack.pop();
	                        }
	                        if (this.nextStack.length > 0) {
	                            this.nextStack = [];
	                            this.onNextChange(null, 0);
	                        }
						}
						
						// 支持HTML5
						if (window.localStorage) {
							//第一进入时，有要素则绘制在地图上。
							if (this.initFlag) {
								//this.previousTrigger();
								if (this.previousStack.length > 0) {
									var state = this.previousStack[0]
									if (state != undefined) {
										//this.nextStack.unshift(current);
										//this.previousStack.unshift(state);
										this.restoring = true;
										this.restore(state);
										this.restoring = false;
									}
								}
							}
							//不是第一次进入时
							if (!this.initFlag) {
								var state = this.registry["moveend"].apply(this, arguments);
								this.previousStack.unshift(state);
							}
							if (this.previousStack.length > 1) {
								this.onPreviousChange(this.previousStack[1], this.previousStack.length - 1);
							}
							if (this.previousStack.length > (this.limit + 1)) {
								this.previousStack.pop();
							}
							
							//不是第一次进入时
							if (this.nextStack.length > 0 && !this.initFlag) {
								this.nextStack = [];
								this.onNextChange(null, 0);
							}
							else 
								if (this.initFlag) {//第一次进入时，是否可用前进。
									this.onNextChange(this.nextStack[0], this.nextStack.length);
									this.initFlag = false;
								}
								
							/* 保存至localStorage。HTML5的功能 */
							try{
								window.localStorage.setItem("previousStack", this.writeStack(this.previousStack));
								window.localStorage.setItem("nextStack", this.writeStack(this.nextStack));
							}catch(e){
								
							}
						}
                    }
                    return true;
                }, this);
			}
        }
    },

    /**
     * APIMethod: activate
     * 激活控件。
     *
     * Returns:
     * {Boolean} 是否激活成功。
     */
    activate: function() {
        var activated = false;
        if(this.map) {
            if(Geo.View2D.Control.prototype.activate.apply(this)) {
                if(this.listeners == null) {
                    this.setListeners();
                }
                for(var type in this.listeners) {
                    if (type == "featureadded" && this.vectorLayer) {
                        this.vectorLayer.events.register(type, this, this.listeners[type]);
                    } if (type == "featureremoved" && this.vectorLayer) {
						this.vectorLayer.events.register(type, this, this.listeners[type]);
                    } else {
                        this.map.events.register(type, this, this.listeners[type]);
                    }
                }
                activated = true;
                if(this.previousStack.length == 0) {
                    this.initStack();
                }
            }
        }
        return activated;
    },
    
    /**
     * Method: initStack
     * Called after the control is activated if the previous history stack is
     *     empty.
     */
    initStack: function() {
        if(this.map.getCenter()) {
            this.listeners.moveend();
        }
    },
    
    /**
     * APIMethod: deactivate
     * 关闭控件。
     *
     * Returns:
     * {Boolean} 是否关闭成功。
     */
    deactivate: function() {
        var deactivated = false;
        if(this.map) {
            if(Geo.View2D.Control.prototype.deactivate.apply(this)) {
                for(var type in this.listeners) {
                    this.map.events.unregister(
                        type, this, this.listeners[type]
                    );
                }
                if(this.clearOnDeactivate) {
                    this.clear();
                }
                deactivated = true;
            }
        }
        return deactivated;
    },
    
    /**
     * APIMethod: clearRecordStack
     * 清除localStorage对象中该控件记录的操作信息。
     */
    clearRecordStack: function() {
        window.localStorage.removeItem("previousStack");
        window.localStorage.removeItem("nextStack");
    },
	
    CLASS_NAME: "Geo.View2D.Control.GeoNavigationHistory"
});
/**
 * Class: Geo.View2D.Control.Measure.AreaMeasure
 * 面积量算类，继承自Geo.View2D.Control.Measure类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control.Measure>
 */
Geo.View2D.Control.Measure.AreaMeasure = Geo.Class(OpenLayers.Control.Measure, {
	
	/**
     * APIProperty: result
     * {Array} 量算结果集合，用于存放量算结果和popup。
	 */
	result: null,
    
	/**
     * Property: currentPopups
     * {Array} 用于存放popup的数组。
	 */
    currentPopups: null,

    /**
     * APIProperty: persist
     * {Boolean} 如果设置为true，则在一次测量绘制完成后，保持这个临时的测量结果的几何要素。
     *  直到一个新的测量操作开始，几何要素被清除。
     *  如果设置为false，则在一次测量绘制完成后，清除几何要素。默认值为false。
     */
    persist: false,
	
	/**
     * Constructor: Geo.View2D.Control.Measure.AreaMeasure
     * 构造函数。生成一个Geo.View2D.Control.Measure.AreaMeasure的实例。
     */
    initialize: function(options){
    
        var areaMeatureHandler = OpenLayers.Class(OpenLayers.Handler.Polygon, {
        
            moveTitleDiv: null,
            
            deactivate: function(){
                if (!OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {
                    return false;
                }
				
				//清除所有的量算结果。
                this.control.destoryAllResult();
				if(this.moveTitleDiv){
					this.moveTitleDiv.style.display = "none";
				}
				
                // call the cancel callback if mid-drawing
                if (this.lastUp) {
                    this.cancel();
                }
                
                 this.destroyFeature();
                 // If a layer's map property is set to null, it means that that layer
                 // isn't added to the map. Since we ourself added the layer to the map
                 // in activate(), we can assume that if this.layer.map is null it means
                 // that the layer has been destroyed (as a result of map.destroy() for
                 // example.
                 if (this.layer.map != null) {
                 	this.layer.destroy(false);
                 }
                 this.layer = null;
                 
                return true;
            },
            
			/**
             * 绘制结束后不立即清除本次量算线段。
             * @param {Object} cancel
             */
            finalize: function(cancel){
				OpenLayers.Handler.Path.prototype.finalize.apply(this, arguments);
				if(this.layer && (cancel || !this.persist)) {
		            this.control.destoryAllResult();
		        }
            },
			
            /**
			 * 鼠标移动时光标显示提示信息，当未开始点击时显示"单击确定起点"。
			 * 点击起点后显示"单击确定中间点，双击结束量算"。
			 * 提示信息距光标位置有一定偏移量。
			 * @param {Object} evt
			 */
            mousemove: function(evt){
                var result = OpenLayers.Handler.Path.prototype.mousemove.apply(this, arguments);
                if (!this.moveTitleDiv) {
                    this.moveTitleDiv = document.createElement("div");
                    this.map.viewPortDiv.appendChild(this.moveTitleDiv);
                }else {
                    this.moveTitleDiv.style.display = "";
                }
                
                var msg = "";
                if (this.lastUp) {
                    msg = "单击确定起点，双击结束量算";
                }
                else {
                    msg = "单击确定起点";
                }
                
                this.moveTitleDiv.innerHTML = msg;
                this.moveTitleDiv.style.position = "absolute";
                this.moveTitleDiv.style.zIndex = this.control.div.style.zIndex;
                this.moveTitleDiv.style.left = evt.xy.x + 15 + "px";
                this.moveTitleDiv.style.top = evt.xy.y + 15 + "px";
                
                return result;
            },
			up: function(){
				var result = OpenLayers.Handler.Path.prototype.up.apply(this, arguments);
				if(this.persist) {
					this.control.destoryResult(this.control.result.length - 1);
				}
				return result;
			}
        });
        var handler = areaMeatureHandler;
        
        this.result = [];
        this.currentPopups = [];
        OpenLayers.Control.Measure.prototype.initialize.apply(this, [handler, options]);
        
        this.events.on({
            "measure": this.handleMeasurementsEnd,
            "measurepartial": this.handleMeasurements
        });
    },
    
    /**
     * Method: measurePartial
     * 判断第一次点击时节点提示为"起点"。
     * 
     * point - {<Geo.Geometry.Point>} 几何点对象。
     * geometry - {<Geo.Geometry>} 几何对象。
     */
    measurePartial: function(point, geometry){
        OpenLayers.Control.Measure.prototype.measurePartial.apply(this, arguments);
    },
    
    /**
     * Method: addNodePopup
     * 添加节点提示框，并保存到currentPopups数组。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 坐标对象。
     * out - {String} 输出的HTML内容。
     */
    addNodePopup: function(lonlat, out){
    
        var popup = new OpenLayers.Popup("chicken", lonlat, null, "<span class='rightBg'>" + out + "<span>", false);
        popup.autoSize = true;
        popup.setBackgroundColor("transparent");
        this.map.addPopup(popup);
        this.currentPopups.push(popup);
    },
    
    /**
     * Method: destoryResult
     * 清除指定索引号的量算结果。
     * 
     * Parameters:
     * resultIndex - {Number} 指定索引号。
     */
    destoryResult: function(resultIndex){
        var result = this.result[resultIndex];
		if(!result){
			return;
		}
        var feature = result.feature;
        var popups = result.popups;
        if (typeof(feature) == "string") {
            feature = this.handler.layer.getFeatureById(feature);
        }
        this.handler.layer.destroyFeatures([feature]);
        for (var i = 0; i < popups.length; i++) {
            this.map.removePopup(popups[i]);
        }
        
    },
	
    /**
     * Method: destoryResult
     * 清除所有的量算结果。
     */
    destoryAllResult: function(){
		for (var i = 0; i < this.result.length; i++) {
            this.destoryResult(i);
        }
		this.result = [];
    },
	
    /**
     * APIMethod: handleMeasurements
     * 量算结束响应方法。
     * 
     * Parameters:
     * event - {<Geo.View2D.Event>} 事件对象。
     */
    handleMeasurements: function(event){
        var geometry = event.geometry;
        
        var units = event.units;
        var order = event.order;
        var measure = event.measure;
        //var element = document.getElementById('output');
        var out = "";
        if (order == 1) {
            out += measure.toFixed(3) + " " + units;
        }
        else {
            out += measure.toFixed(3) + " " + units + "<sup>2</" + "sup>";
        }
        //element.innerHTML = out;
    },
	
    /**
     * APIMethod: handleMeasurementsEnd
     * 量算结束响应方法。
     * 
     * Parameters:
     * event - {<Geo.View2D.Event>} 事件对象。
     */
    handleMeasurementsEnd: function(event){
        var geometry = event.geometry;
        
        var units = event.units;
        var order = event.order;
        var measure = event.measure;
		if(!measure){
			return;
		}
        //var element = document.getElementById('output');
        var out = "";
        if (order == 1) {
            out += measure.toFixed(3) + " " + units;
        }
        else {
            out += measure.toFixed(3) + " " + units + "<sup>2</" + "sup>";
        }
        //element.innerHTML = out;
        
        //getCentroid取质心点
        var point = geometry.getCentroid();
        var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 10, point.y - this.map.getResolution() * 10);
        var currentPolygon = this.handler.polygon;
        this.addNodePopup(ll, "总面积：" + out + "<a id = '" + geometry.id + "_a' class='result_close' href='#' style=''> X</a>");
        
        var resultIndex = this.result.length;
        document.getElementById(geometry.id + "_a").onclick = OpenLayers.Function.bind(function(){
            this.destoryResult(resultIndex);
        }, this);
        
        this.result.push({
            feature: currentPolygon,
            popups: this.currentPopups
        });
        this.currentPopups = [];
    }
    
});
/**
 * Class: Geo.View2D.Control.Measure.DistanceMeasure
 * 距离量算类，继承自Geo.View2D.Control.Measure类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 
 * Inherits from:
 *  - <Geo.View2D.Control.Measure>
 */
Geo.View2D.Control.Measure.DistanceMeasure = Geo.Class(Geo.View2D.Control.Measure, {
    
	/**
     * APIProperty: result
     * {Array} 量算结果集合，用于存放量算结果和popup。
	 */
	result: null,
    
	/**
     * Property: currentPopups
     * {Array} 用于存放popup的数组。
	 */
    currentPopups: null,

    /**
     * APIProperty: persist
     * {Boolean} 如果设置为true，则在一次测量绘制完成后，保持这个临时的测量结果的几何要素。
     *  直到一个新的测量操作开始，几何要素被清除。
     *  如果设置为false，则在一次测量绘制完成后，清除几何要素。默认值为false。
     */
    persist: false,
	
    /**
     * Constructor: Geo.View2D.Control.Measure.DistanceMeasure
     * 构造函数。生成一个Geo.View2D.Control.Measure.DistanceMeasure的实例。
     */
    initialize: function(options){
        var distanceMeatureHandler = OpenLayers.Class(OpenLayers.Handler.Path, {
        
            //量算过程所有中间点
            points: null,
            
            //移动时光标提示框
            moveTitleDiv: null,
            
            //关闭控件时需要手工来清除绘制的多个距离量算结果
            deactivate: function(){
                if (!OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {
                    return false;
                }
				
				//清除所有的量算结果。
                this.control.destoryAllResult();
				this.control.removerNodePopups();
				if(this.moveTitleDiv){
					this.moveTitleDiv.style.display = "none";
				}
                // call the cancel callback if mid-drawing
                if (this.lastUp) {
                    this.cancel();
                }
                
                 this.destroyFeature();
                 // If a layer's map property is set to null, it means that that layer
                 // isn't added to the map. Since we ourself added the layer to the map
                 // in activate(), we can assume that if this.layer.map is null it means
                 // that the layer has been destroyed (as a result of map.destroy() for
                 // example.
                 if (this.layer.map != null) {
                     this.layer.destroy(false);
                 }
                 this.layer = null;
                 
                return true;
            },
            
            /**
             * 绘制结束后不立即清除本次量算线段。
             * @param {Object} cancel
             */
            finalize: function(cancel){
				OpenLayers.Handler.Path.prototype.finalize.apply(this, arguments);
				if(this.layer && (cancel || !this.persist)) {
		            this.control.destoryAllResult();
		        }

//				var key = cancel ? "cancel" : "done";
//		        this.mouseDown = false;
//		        this.lastDown = null;
//		        this.lastUp = null;
//		        this.lastTouchPx = null;
//		        this.callback(key, [this.geometryClone()]);
//		        //this.destroyFeature(cancel);
//				this.line = null;
//				this.point = null;
            },
            
			/**
			 * 鼠标移动时光标显示提示信息，当未开始点击时显示"单击确定起点"。
			 * 点击起点后显示"单击确定中间点，双击结束量算"。
			 * 提示信息距光标位置有一定偏移量。
			 * @param {Object} evt
			 */
            mousemove: function(evt){
                var result = OpenLayers.Handler.Path.prototype.mousemove.apply(this, arguments);
                if (!this.moveTitleDiv) {
                    this.moveTitleDiv = document.createElement("div");
                    this.map.viewPortDiv.appendChild(this.moveTitleDiv);
                }else{
					this.moveTitleDiv.style.display = "";
				}
                
                var msg = "";
                if (this.lastUp) {
                    msg = "单击确定中间点，双击结束量算";
                }
                else {
                    msg = "单击确定起点";
                }
                this.moveTitleDiv.innerHTML = msg;
                this.moveTitleDiv.style.position = "absolute";
                this.moveTitleDiv.style.zIndex = this.control.div.style.zIndex;
                this.moveTitleDiv.style.left = evt.xy.x + 15 + "px";
                this.moveTitleDiv.style.top = evt.xy.y + 15 + "px";
                return result;
            },
			up: function(){
				var result = OpenLayers.Handler.Path.prototype.up.apply(this, arguments);
				if(this.persist) {
					this.control.destoryResult(this.control.result.length - 1);
				}
				return result;
			}
        });
        var handler = distanceMeatureHandler;
        
        //支持保存多个距离结果，保存当前所有节点提示框
        this.result = [];
        this.currentPopups = [];
        
        OpenLayers.Control.Measure.prototype.initialize.apply(this, [handler, options]);
        
        //量算过程中和结束有不同处理
        this.events.on({
            "measure": this.handleMeasurementsEnd,
            "measurepartial": this.handleMeasurements
        });
    },
    
    /**
     * Method: measurePartial
     * 判断第一次点击时节点提示为"起点"。
     * 
     * point - {<Geo.Geometry.Point>} 几何点对象。
     * geometry - {<Geo.Geometry>} 几何对象。
     */
    measurePartial: function(point, geometry){
        if (geometry.getLength() == 0) {
            var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 10, point.y - this.map.getResolution() * 10);
            this.addNodePopup(ll, "起点");
        }
        
        OpenLayers.Control.Measure.prototype.measurePartial.apply(this, arguments);
    },
    
    /**
     * Method: addNodePopup
     * 添加节点提示框，并保存到currentPopups数组。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 坐标对象。
     * out - {String} 输出的HTML内容。
     */
    addNodePopup: function(lonlat, out){
    
        var popup = new OpenLayers.Popup("chicken", lonlat, null, "<span class='rightBg'>" + out + "<span>", false);
        popup.autoSize = true;
        popup.setBackgroundColor("transparent");
        this.map.addPopup(popup);
        this.currentPopups.push(popup);
    },
    
    /**
     * Method: removerNodePopups
     * 删除节点提示框。
     */
    removerNodePopups: function(){
		var popups = this.currentPopups;
		for (var i = 0; i < popups.length; i++) {
            this.map.removePopup(popups[i]);
        }
    },
    
    /**
     * Method: destoryResult
     * 清除指定索引号的量算结果。
     * 
     * Parameters:
     * resultIndex - {Number} 指定索引号。
     */
    destoryResult: function(resultIndex){
        var result = this.result[resultIndex];
		if(!result){
			return;
		}
        var feature = result.feature;
        var popups = result.popups;
        if (typeof(feature) == "string") {
            feature = this.handler.layer.getFeatureById(feature);
        }
        this.handler.layer.destroyFeatures([feature]);
        for (var i = 0; i < popups.length; i++) {
            this.map.removePopup(popups[i]);
        }
    },
	
    /**
     * Method: destoryResult
     * 清除所有的量算结果。
     */
    destoryAllResult: function(){
		for (var i = 0; i < this.result.length; i++) {
            this.destoryResult(i);
        }
		this.result = [];
    },
    
    /**
     * APIMethod: handleMeasurements
     * 量算结束响应方法。
     * 
     * Parameters:
     * event - {<Geo.View2D.Event>} 事件对象。
     */
    handleMeasurements: function(event){
        var geometry = event.geometry;
        
        var units = event.units;
        var order = event.order;
        var measure = event.measure;
		if(measure == 0){
			return;
		}
        //var element = document.getElementById('output');
        var out = "";
        if (order == 1) {
            out += measure.toFixed(3) + " " + units;
        }
        else {
            out += measure.toFixed(3) + " " + units + "<sup>2</" + "sup>";
        }
        //element.innerHTML = out;
        
        var point = geometry.components[geometry.components.length - 1];
        var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 5, point.y - this.map.getResolution() * 5);
        this.addNodePopup(ll, out);
    },
    
    /**
     * APIMethod: handleMeasurementsEnd
     * 量算结束响应方法。
     * 
     * Parameters:
     * event - {<Geo.View2D.Event>} 事件对象。
     */
    handleMeasurementsEnd: function(event){
        var geometry = event.geometry;
        
        var units = event.units;
        var order = event.order;
        var measure = event.measure;
        //var element = document.getElementById('output');
        var out = "";
        if (order == 1) {
            out += measure.toFixed(3) + " " + units;
        }
        else {
            out += measure.toFixed(3) + " " + units + "<sup>2</" + "sup>";
        }
        //element.innerHTML = out;
        
        var point = geometry.components[geometry.components.length - 1];
        var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 10, point.y - this.map.getResolution() * 10);
        var currentPath = this.handler.line;
        this.addNodePopup(ll, "总长：" + out + "<a id = '" + geometry.id + "_a' class='result_close' href='#' style=''> X</a>");
        
        var resultIndex = this.result.length;
        document.getElementById(geometry.id + "_a").onclick = OpenLayers.Function.bind(function(){
            this.destoryResult(resultIndex);
        }, this);
        
        this.result.push({
            feature: currentPath,
            popups: this.currentPopups
        });
        this.currentPopups = [];
    }


});
/**
 * Class: Geo.View2D.Control.Measure.Angle
 * 角度量算类，继承自Geo.View2D.Control.Measure类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 *
 * Inherits from:
 *  - <Geo.View2D.Control.Measure>
 */
Geo.View2D.Control.Measure.Angle = Geo.Class(Geo.View2D.Control.Measure, {
	
    /**
     * Constructor: Geo.View2D.Control.Measure.Angle
     * 构造函数。生成一个Geo.View2D.Control.Measure.Angle的实例。
     * 
     * Parameters:
     * options - {Object} 构造参数选项。
     */
    initialize: function(options){
        var handler = Geo.View2D.Handler.Path;
        Geo.View2D.Control.Measure.prototype.initialize.apply(this, [handler, options]);
    },
	
	/**
     * Method: measure
     *
     * Parameters:
     * geometry - {<Geo.View2D.Geometry>}
     * eventType - {String}
     */
    measure: function(geometry, eventType) {
        var stat, order;
        if(geometry.CLASS_NAME.indexOf('LineString') > -1) {
            //stat = this.getBestLength(geometry);
            stat = this.getAngle(geometry);
            order = 3;
        }
        this.events.triggerEvent(eventType, {
            measure: stat[0],
            units: stat[1],
			angles: stat[2],
            order: order,
            geometry: geometry
        });
    },
	
	/**
     * Method: getAngle
     * 获取当前绘制的线段与前一绘制的线段之间的角度值。
     *
     * Parameters:
     * geometry - {<Geo.View2D.Geometry>}
     *
     * Returns:
     * {Array([Float, String, Array])}
     * 返回一个数组，包含3个选项，最后量算的角度值，角度单位，所有量算的角度值的数组。
     */
    getAngle: function(geometry) {
        var unit = "°";
        var angle = 0;
        var angles = new Array();
		var kqs = [];
		var length = geometry.components.length;
        length = (geometry.components[length - 1].x == geometry.components[length - 2].x && geometry.components[length - 1].y == geometry.components[length - 2].y) ? length - 1 : length;
		for (var i = 0; i < length; i++) {
            if (i) {
                var x1 = geometry.components[i - 1].x;
                var y1 = geometry.components[i - 1].y;
                var x2 = geometry.components[i].x;
                var y2 = geometry.components[i].y;
				//直线的斜率
                var k = (y2 - y1) / (x2 - x1);
                
                var quadrant = "";
                if (y2 > y1 && x2 > x1) {
                    quadrant = 1;//"rt";//第一象限
                }
                if (y2 > y1 && x2 < x1) {
                    quadrant = 2;//"lt";//第二象限
                }
                if (y2 < y1 && x2 < x1) {
                    quadrant = 3;//"lb";//第三象限
                }
                if (y2 < y1 && x2 > x1) {
                    quadrant = 4;//"rb";//第四象限
                }
                
                kqs.push({
                    k: k,
                    quadrant: quadrant
                });
                if (i > 1) {
                    var k1 = kqs[i - 2].k;
                    var k2 = kqs[i - 1].k;
                    //两直线的斜率分别用k1与k2表示，则两直线夹角x的正切值可用下述公式表示：
                    //var tanx = Math.abs((k2 - k1) / (1 + (k2 * k1)));
                    var tanx = (k2 - k1) / (1 + (k2 * k1));
                    //反正切值。返回的值是 -PI/2 到 PI/2 之间的弧度值。
                    var radian = Math.atan(tanx);
                    //算角度值。弧度=角度*（2PI/360）
                    var angle = radian / ((2 * Math.PI) / 360);
                    
                    var q1 = kqs[i - 2].quadrant;
                    var q2 = kqs[i - 1].quadrant;
                    
//					一 一：正数则180-，负数则+180
//					一 二：正数则180-，负数则取绝对值
//					一 三：正负数都取绝对值
//					一 四：正数取绝对值，负数则+180
//					
//					二 一：正数取绝对值，负数则+180
//					二 二：正数则180-，负数则+180
//					二 三：正数则180-，负数则取绝对值
//					二 四：正负数都取绝对值
//					
//					三 一：正负数都取绝对值
//					三 二：正数取绝对值，负数则+180
//					三 三：正数则180-，负数则+180
//					三 四：正数则180-，负数则取绝对值
//					
//					四 一：正数则180-，负数则取绝对值
//					四 二：正负数都取绝对值
//					四 三：正数取绝对值，负数则+180
//					四 四：正数则180-，负数则+180
                    var res = (q2 - q1) < 0 ? (q2 - q1) + 4 : (q2 - q1);
                    switch (res) {
                        case 0:
                            angle = (angle > 0) ? (180 - angle) : (180 + angle);
                            break;
                        case 1:
                            angle = (angle > 0) ? (180 - angle) : Math.abs(angle);
                            break;
                        case 2:
                            angle = Math.abs(angle);
                            break;
                        case 3:
                            angle = (angle > 0) ? angle : (180 + angle);
                            break;
                    }
					angles.push(angle);
					
                }
            }
        }
        return [angle, unit, angles];
    }
});
/**
 * Class: Geo.View2D.Control.Measure.AngleMeasure
 * 角度量算类，继承自Geo.View2D.Control.Measure.Angle类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 在地图上动态显示每次测量的角度。
 *
 * Inherits from:
 *  - <Geo.View2D.Control.Measure.Angle>
 */
Geo.View2D.Control.Measure.AngleMeasure = Geo.Class(Geo.View2D.Control.Measure.Angle, {
    
	/**
     * APIProperty: result
     * {Array} 量算结果集合，用于存放量算结果和popup。
	 */
	result: null,
    
	/**
     * Property: currentPopups
     * {Array} 用于存放popup的数组。
	 */
    currentPopups: null,

    /**
     * APIProperty: persist
     * {Boolean} 如果设置为true，则在一次测量绘制完成后，保持这个临时的测量结果的几何要素。
     *  直到一个新的测量操作开始，几何要素被清除。
     *  如果设置为false，则在一次测量绘制完成后，清除几何要素。默认值为false。
     */
    persist: false,
	
    /**
     * Constructor: Geo.View2D.Control.Measure.DistanceMeasure
     * 构造函数。生成一个Geo.View2D.Control.Measure.DistanceMeasure的实例。
     */
    initialize: function(options){
        var distanceMeatureHandler = OpenLayers.Class(OpenLayers.Handler.Path, {
        
            //量算过程所有中间点
            points: null,
            
            //移动时光标提示框
            moveTitleDiv: null,
            
            //关闭控件时需要手工来清除绘制的多个距离量算结果
            deactivate: function(){
                if (!OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {
                    return false;
                }
				
				//清除所有的量算结果。
                this.control.destoryAllResult();
				this.control.removerNodePopups();
				if(this.moveTitleDiv){
					this.moveTitleDiv.style.display = "none";
				}
                // call the cancel callback if mid-drawing
                if (this.lastUp) {
                    this.cancel();
                }
                
                 this.destroyFeature();
                 // If a layer's map property is set to null, it means that that layer
                 // isn't added to the map. Since we ourself added the layer to the map
                 // in activate(), we can assume that if this.layer.map is null it means
                 // that the layer has been destroyed (as a result of map.destroy() for
                 // example.
                 if (this.layer.map != null) {
                     this.layer.destroy(false);
                 }
                 this.layer = null;
                 
                return true;
            },
            
            /**
             * 绘制结束后不立即清除本次量算线段。
             */
            finalize: function(cancel){
				OpenLayers.Handler.Path.prototype.finalize.apply(this, arguments);
				if(this.layer && (cancel || !this.persist)) {
		            this.control.destoryAllResult();
		        }
            },
            
			/**
			 * 鼠标移动时光标显示提示信息，当未开始点击时显示"单击确定起点"。
			 * 点击起点后显示"单击确定中间点，双击结束量算"。
			 * 提示信息距光标位置有一定偏移量。
			 */
            mousemove: function(evt){
                var result = OpenLayers.Handler.Path.prototype.mousemove.apply(this, arguments);
                if (!this.moveTitleDiv) {
                    this.moveTitleDiv = document.createElement("div");
                    this.map.viewPortDiv.appendChild(this.moveTitleDiv);
                }else{
					this.moveTitleDiv.style.display = "";
				}
                
                var msg = "";
                if (this.lastUp) {
                    msg = "单击确定中间点，双击结束量算";
                }
                else {
                    msg = "单击确定起点";
                }
                this.moveTitleDiv.innerHTML = msg;
                this.moveTitleDiv.style.position = "absolute";
                this.moveTitleDiv.style.zIndex = this.control.div.style.zIndex;
                this.moveTitleDiv.style.left = evt.xy.x + 15 + "px";
                this.moveTitleDiv.style.top = evt.xy.y + 15 + "px";
                return result;
            },
			up: function(){
				var result = OpenLayers.Handler.Path.prototype.up.apply(this, arguments);
				if(this.persist) {
					this.control.destoryResult(this.control.result.length - 1);
				}
				return result;
			}
        });
        var handler = distanceMeatureHandler;
        
        //支持保存多个距离结果，保存当前所有节点提示框
        this.result = [];
        this.currentPopups = [];
        
        OpenLayers.Control.Measure.prototype.initialize.apply(this, [handler, options]);
        
        //量算过程中和结束有不同处理
        this.events.on({
            "measure": this.handleMeasurementsEnd,
            "measurepartial": this.handleMeasurements
        });
    },
    
    /**
     * Method: measurePartial
     * 判断第一次点击时节点提示为"起点"。
     * 
     * point - {<Geo.Geometry.Point>} 几何点对象。
     * geometry - {<Geo.Geometry>} 几何对象。
     */
    measurePartial: function(point, geometry){
        if (geometry.getLength() == 0) {
            var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 10, point.y - this.map.getResolution() * 10);
            this.addNodePopup(ll, "起点");
        }
        
        OpenLayers.Control.Measure.prototype.measurePartial.apply(this, arguments);
    },
    
    /**
     * Method: addNodePopup
     * 添加节点提示框，并保存到currentPopups数组。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 坐标对象。
     * out - {String} 输出的HTML内容。
     */
    addNodePopup: function(lonlat, out){
    
        var popup = new OpenLayers.Popup("chicken", lonlat, null, "<span class='rightBg'>" + out + "<span>", false);
        popup.autoSize = true;
        popup.setBackgroundColor("transparent");
        this.map.addPopup(popup);
        this.currentPopups.push(popup);
    },
    
    /**
     * Method: removerNodePopups
     * 删除节点提示框。
     */
    removerNodePopups: function(){
		var popups = this.currentPopups;
		for (var i = 0; i < popups.length; i++) {
            this.map.removePopup(popups[i]);
        }
    },
    
    /**
     * Method: destoryResult
     * 清除指定索引号的量算结果。
     * 
     * Parameters:
     * resultIndex - {Number} 指定索引号。
     */
    destoryResult: function(resultIndex){
        var result = this.result[resultIndex];
		if(!result){
			return;
		}
        var feature = result.feature;
        var popups = result.popups;
        if (typeof(feature) == "string") {
            feature = this.handler.layer.getFeatureById(feature);
        }
        this.handler.layer.destroyFeatures([feature]);
        for (var i = 0; i < popups.length; i++) {
            this.map.removePopup(popups[i]);
        }
    },
	
    /**
     * Method: destoryResult
     * 清除所有的量算结果。
     */
    destoryAllResult: function(){
		for (var i = 0; i < this.result.length; i++) {
            this.destoryResult(i);
        }
		this.result = [];
    },
    
    /**
     * APIMethod: handleMeasurements
     * 量算结束响应方法。
     * 
     * Parameters:
     * event - {<Geo.View2D.Event>} 事件对象。
     */
    handleMeasurements: function(event){
        var geometry = event.geometry;
        
        var units = event.units;
        var order = event.order;
        var measure = event.measure;
		if(measure == 0){
			return;
		}
        //var element = document.getElementById('output');
        var out = "";
        if (order == 1) {
            out += measure.toFixed(3) + " " + units;
        }else if(order == 2){
            out += measure.toFixed(3) + " " + units + "<sup>2</" + "sup>";
        }else if(order == 3){
			out += measure.toFixed(3) + " " + units;
		}
        //element.innerHTML = out;
        var point = geometry.components[geometry.components.length - 3];
        var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 5, point.y - this.map.getResolution() * 5);
        this.addNodePopup(ll, out);
    },
    
    /**
     * APIMethod: handleMeasurementsEnd
     * 量算结束响应方法。
     * 
     * Parameters:
     * event - {<Geo.View2D.Event>} 事件对象。
     */
    handleMeasurementsEnd: function(event){
        var geometry = event.geometry;
        
        var units = event.units;
        var order = event.order;
        var measure = event.measure;
        //var element = document.getElementById('output');
        var out = "";
        if (order == 1) {
            out += measure.toFixed(3) + " " + units;
        }else if(order == 2){
            out += measure.toFixed(3) + " " + units + "<sup>2</" + "sup>";
        }else if(order == 3){
			out += measure.toFixed(3) + " " + units;
		}
        //element.innerHTML = out;
        
        var point = geometry.components[geometry.components.length - 2];
        var ll = new OpenLayers.LonLat(point.x + this.map.getResolution() * 10, point.y - this.map.getResolution() * 10);
        var currentPath = this.handler.line;
        this.addNodePopup(ll, "" + out + "<a id = '" + geometry.id + "_a' class='result_close' href='#' style=''> X</a>");
        
        var resultIndex = this.result.length;
        document.getElementById(geometry.id + "_a").onclick = OpenLayers.Function.bind(function(){
            this.destoryResult(resultIndex);
        }, this);
        
        this.result.push({
            feature: currentPath,
            popups: this.currentPopups
        });
        this.currentPopups = [];
    }
});
/**
 * Class: Geo.View2D.Control.MapContextMenu
 * 鼠标右键地图菜单控件类。
 *
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.MapContextMenu = Geo.Class(Geo.View2D.Control, {

    /**
     * APIProperty: autoActivate
     * {Boolean} 是否自动激活。默认为true。
     */
    autoActivate: true,
    
    /** 
     * APIProperty: menuDiv
     * {DOMElement} 鼠标右键地图菜单容器。
     */
    menuDiv: null,
    
    /** 
     * APIProperty: contentHTML
     * {String} 鼠标右键地图菜单的内容。
     */
    contentHTML: null,
	
    /** 
     * APIProperty: lastRightClickXY
     * {<Geo.Pixel>} 最后一次右键点击的地图屏幕坐标信息。
     */
    lastRightClickXY: null,
	
    /** 
     * APIProperty: lastRightClickLonLat
     * {<Geo.LonLat>} 最后一次右键点击的经纬度坐标信息。
     */
    lastRightClickLonLat: null,
    
    /** 
     * Property: handlerOptions
     * {object}
     */
    handlerOptions: null,
    
    /**
     * Property: handleRightClicks
     * {Boolean} 是否开启鼠标右键点击事件。默认为true。
     */
    handleRightClicks: true,
    
    /**
     * Constructor: Geo.View2D.Control.MapContextMenu
     * 鼠标右键地图菜单控件的构造函数。
     * 
     * Parameters:
     * options - {Object} 构造参数选项。
     */
    initialize: function(options){
        Geo.View2D.Control.prototype.initialize.apply(this, arguments);
        this.handlerOptions = OpenLayers.Util.extend({}, this.handlerOptions);
        this.handler = new Geo.View2D.Handler.Click(this, {
            'rightclick': this.showContextMenu,
            'click': this.leftClick
        }, this.handlerOptions);
        this.handler.mousedown = function(evt){
            this.control.hide();
            return Geo.View2D.Handler.Click.prototype.mousedown.apply(this, arguments);
        }
    },
    
    /**
     * Method: setMap
     */
    setMap: function(map){
        Geo.View2D.Control.prototype.setMap.apply(this, [map]);
    },
    
    /**
     * Method: destroy
     */
    destroy: function(){
        this.deactivate();
        Geo.View2D.Control.prototype.destroy.apply(this, arguments);
    },
    
    /**
     * APIMethod: activate
     * 激活地图的右键菜单。
     * 
     * Returns:
     * {Boolean} 是否激活成功。
     */
    activate: function(){
        if (Geo.View2D.Control.prototype.activate.apply(this, arguments)) {
            this.map.viewPortDiv.oncontextmenu = OpenLayers.Function.False;
            return true;
        }
        else {
            return false;
        }
    },
    
    /**
     * APIMethod: deactivate
     * 关闭地图的右键菜单。
     * 
     * Returns:
     * {Boolean} 是否关闭成功。
     */
    deactivate: function(){
        if (Geo.View2D.Control.prototype.deactivate.apply(this, arguments)) {
            this.hide();
            this.map.viewPortDiv.oncontextmenu = OpenLayers.Function.True;
            return true;
        }
        else {
            return false;
        }
    },
    
    /**
     * Method: draw
     * 
     * Returns:
     * {DOMElement}
     */
    draw: function(){
        Geo.View2D.Control.prototype.draw.apply(this, arguments);
        var menu = this.div;
        menu.style.position = "absolute";
        menu.style.background = "white";
        menu.style.border = "1px solid #adbfe4";
        menu.style.zIndex = this.map.Z_INDEX_BASE['Control'] + this.map.controls.length;
        menu.innerHTML = this.contentHTML ? this.contentHTML : "";
        this.menuDiv = menu;
		this.menuDiv.onmousedown = OpenLayers.Function.bind(function(){
			//火狐事件对象event为arguments[0]。IE和chrome的事件对象则全局存在event。
        	var evt = arguments[0] || event;
			OpenLayers.Event.stop(evt);
        }, this);
        this.hide();
        this.map.viewPortDiv.appendChild(this.menuDiv);
        return this.div;
    },
    
    /**
     * Method: click
     */
    leftClick: function(evt){
    },
    
    /**
     * Method: showContextMenu
     * 点击右键在地图上显示菜单。
     */
    showContextMenu: function(evt){
        this.lastRightClickXY = evt.xy;
        this.lastRightClickLonLat = this.map.getLonLatFromPixel(evt.xy);
        var menu = this.menuDiv;
        menu.style.left = evt.xy.x + "px";
        menu.style.top = evt.xy.y + "px";
        this.show();
    },
    
    /**
     * Method: show
     * 显示右键菜单。
     */
    show: function(){
        if (this.menuDiv && this.menuDiv.style.display == "none") {
            this.menuDiv.style.display = "";
        }
    },
    
    /**
     * Method: hide
     * 隐藏右键菜单。
     */
    hide: function(){
        if (this.menuDiv && this.menuDiv.style.display != "none") {
            this.menuDiv.style.display = "none";
        }
    },
    
    /**
     * APIMethod: setContentHTML
     * 设置右键菜单的内容。
     *
     * Parameters:
     * contentHTML - {String} 右键菜单的HTML字符串。
     */
    setContentHTML: function(contentHTML){
        if (contentHTML != null) {
            this.contentHTML = contentHTML;
        }
        if ((this.menuDiv != null) && (this.contentHTML != null) &&
        (this.contentHTML != this.menuDiv.innerHTML)) {
            this.menuDiv.innerHTML = this.contentHTML;
        }
    },
	
    /**
     * APIMethod: addItem
     * 添加菜单选项。
     * 
     * Parameters:
     * menuItem - {<Geo.View2D.MenuItem>} 鼠标右键地图菜单选项。
     */
    addItem: function(menuItem){
        var itemDiv = document.createElement("div");
        itemDiv.style.cssText = "padding-bottom: 2px; line-height: 17px; margin: 0px 2px; padding-left: 6px; width:" + menuItem.width + "px; padding-right: 6px; color: #000; font-size: 12px; cursor: pointer; padding-top: 2px;";
		itemDiv.innerHTML = "<span>" + menuItem.text + "</span>";
		itemDiv.onclick = OpenLayers.Function.bind(function(){
			menuItem.callback();
			this.hide();
        }, this);
		itemDiv.onmouseover = function(){
			itemDiv.style.color = "#6688cc";
		}
		itemDiv.onmouseout = function(){
			itemDiv.style.color = "#000";
		}
        this.menuDiv.appendChild(itemDiv);
		this.setContentHTML(this.menuDiv.innerHTML);
    },
	
    /**
     * APIMethod: addSeparator
     * 添加菜单的分割线。
     */
	addSeparator: function(){
		var separatorDiv = document.createElement("div");
        separatorDiv.style.cssText = "border-bottom:#adbfe4 1px solid;margin:0px 6px;font-size:0px;padding:1px";
		this.menuDiv.appendChild(separatorDiv);
		this.setContentHTML(this.menuDiv.innerHTML);
	},
    
    CLASS_NAME: "Geo.View2D.Control.MapContextMenu"
});
//定义鼠标单击双击对象
Geo.View2D.Control.Click = Geo.Class(Geo.View2D.Control, {
    defaultHandlerOptions: {
        'single': true,
        'double': false,
        'delay':0
    },
    initialize: function(options) {
        this.handlerOptions = Geo.Util.extend(
            {}, this.defaultHandlerOptions
        );
        Geo.View2D.Control.prototype.initialize.apply(
            this, arguments
        ); 
        this.handler = new Geo.View2D.Handler.Click(
            this, {
                'click': this.onClick,
                'dblclick': this.onDblclick
            }, this.handlerOptions
        );
    }, 
    onClick: function(evt) {},
    onDblclick: function(evt) {}
});//定义鼠标拖拽对象
Geo.View2D.Control.MouseDrag = Geo.Class(Geo.View2D.Control, {                
    defaultHandlerOptions: {
    },
    initialize: function(options) {
        this.handlerOptions = Geo.Util.extend(
            {}, this.defaultHandlerOptions
        );
        Geo.View2D.Control.prototype.initialize.apply(
            this, arguments
        ); 
        this.handler = new Geo.View2D.Handler.Drag(
            this, {
            }, this.handlerOptions
        );
    }
});﻿/**
 * Class: Geo.View2D.Control.TimeSlider
 * 时间轴控件类，控件为可视控件类型。该控件可设置时间轴上的刻度总数目，根据刻度总数把时间轴整条分成各个小段。
 * > 时间轴控件可以结合要素渲染，展现某段时间内的矢量要素按时间点先后顺序的动画绘制效果，使用时间轴来控制动画的播放进度。
 * > 时间轴控件类的功能包括：
 * > 1、用户使用鼠标左键按住时间轴指针进行拖动，来控制进度；
 * > 2、用户使用鼠标左键点击时间轴上某一刻度来控制进度的跳转。
 * > 3、控件具有“播放”、“暂停”、“前进”，“后退”的功能。
 * > 4、点击“播放”时，时间轴指针每秒移动一个刻度距离，直到移动至最后一个刻度线为止。
 * > 5、点击“暂停”，时间轴指针将停止不动，如这时再点击“播放”，则指针继续移动。
 * > 6、点击“后退”按钮，指针回退一个刻度。点击“前进”按钮，指针前进一个刻度。
 *
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.TimeSlider = Geo.Class(Geo.View2D.Control, {
	
    /**
     * Property: mouseDragStart
     * {Number} 鼠标拖动起点标识。
     */
    mouseDragStart: null,
	
    /**
     * Property: tmpNewWidthPX
     * {Number} 该属性临时最新存储进度条长度。
     */
    tmpNewWidthPX: null,
	
    /**
     * Property: progressBarPX
     * {Number} 进度条长度。
     */
    progressBarPX: null,
	
    /**
     * APIProperty: markNum
     * {Number} 进度条分成多少个刻度。
     */
	markNum: 100,
	
    /**
     * APIProperty: currentMark
     * {Number} 当前进度条所指向的刻度数。
     */
	currentMark: 0,
	
    /**
     * Property: timerId
     * {Object} 定时器的ID。
     */
    timerId: null,
	
    /**
     * APIProperty: interval
     * {Integer} 播放间隔。单位：毫秒。默认为1000毫秒。
     */
    interval: 1000,
	
    /**
     * APIProperty: onSliderBarMove
     * {Function} 时间轴指针移动时，调用该函数，具体事情由用户实现。
     */
	onSliderBarMove: function(){},
	
    /**
     * APIProperty: markInfo
     * {Array(String)} 时间点数组。
     */
	markInfo: null,
	
	/**
     * Constructor: Geo.View2D.Control.TimeSlider
     * 创建时间轴对象实例。
     *
     * Parameters:
     * options - {Object} 对象构造参数。
     */
    initialize: function(options){
        OpenLayers.Control.prototype.initialize.apply(this, arguments);
	},
	
    /** 
     * Method: setMap
     * 该控件与地图对象关联。
     * 
     * Parameters:
     * map - {<Geo.View2D.Map>} 
     */
    setMap: function(map){
        Geo.View2D.Control.prototype.setMap.apply(this, arguments);
    },


	/**
    * Method: draw
    *
    * Parameters:
    * px - {<Geo.Pixel>} 
    */
    draw: function(px){
		var timeSliderDiv = document.getElementById("timeSliderDiv");
		timeSliderDiv.innerHTML = Geo.View2D.Control.TimeSlider.timeSliderDivHTML;
		this.timeSliderDiv = timeSliderDiv;
		
		var sliderMoveableInfoDIV = document.getElementById("sliderMoveableInfo");
		this.sliderMoveableInfoDIV = sliderMoveableInfoDIV;
		
		var remainingBar = document.getElementById("remainingBar");
		var progressBar = document.getElementById("progressBar");
		var sliderBar = document.getElementById("sliderFocusNode");
		this.remainingBar = remainingBar;
		this.progressBar = progressBar;
		this.sliderBar = sliderBar;
		//进度条指针事件对象。
        this.sliderEvents = new OpenLayers.Events(this, sliderBar, null, true, {
            includeXY: true
        });
        this.documentEvents = new OpenLayers.Events(this, document, null, true, {
            includeXY: true
        });
		//设置进度条事件
        this.sliderEvents.on({
            "mousedown": this.sliderBarDown,
            "mousemove": this.sliderBarDrag,
            "mouseup": this.sliderBarUp
        });
		
		//设置初始化进度条长度。
		this.setProgressBarWidth();
		
		//绑定播放，后退，前进按钮的事件。
		var playButton = document.getElementById("playButton");
		var prevButton = document.getElementById("prevButton");
		var nextButton = document.getElementById("nextButton");
		this.playButton = playButton;
		this.prevButton = prevButton;
		this.nextButton = nextButton;
		this.playButton.onclick = OpenLayers.Function.bind(function(){
			if(this.timerId == null){
				this.play();
			}else{
				this.pause();
			}
		}, this);
		this.prevButton.onclick = OpenLayers.Function.bind(function(){
			if (this.timerId == null) {
				this.previous();
			}
		}, this);
		this.nextButton.onclick = OpenLayers.Function.bind(function(){
			if (this.timerId == null) {
				this.next();
			}
		}, this);
		
		//在进度条下填充刻度线。
		this._setRuleMarksHTML();
		
		
		//鼠标在进度条上时，进度条变色。
		this.sliderBar.onmouseover = OpenLayers.Function.bind(function(){
			this.sliderBar.className = "sliderImage sliderImageHover";
		}, this);
		this.sliderBar.onmouseout = OpenLayers.Function.bind(function(){
			if(this.mouseDragStart == null){
				this.sliderBar.className = "sliderImage";
			}
		}, this);
		var sliderBarContainerTable = document.getElementById("sliderBarContainerTableID");
		this.sliderBarContainerTable = sliderBarContainerTable;
		this.sliderBarContainerTable.onmouseover = OpenLayers.Function.bind(function(){
			this.sliderBarContainerTable.className = "timeSliderTable sliderBarContainerTable sliderHover";
		}, this);
		this.sliderBarContainerTable.onmouseout = OpenLayers.Function.bind(function(){
			if (this.mouseDragStart == null) {
				this.sliderBarContainerTable.className = "timeSliderTable sliderBarContainerTable";
			}
		}, this);
		
		
		//鼠标点击进度条上时，进度改变至鼠标点击的位置。
		var sliderBarContainerTr = document.getElementById("sliderBarContainerTrID");
		this.sliderBarContainerTr = sliderBarContainerTr;
        this.sliderBarContainerTr.onclick = OpenLayers.Function.bind(this.onCilckSliderBarContainerTr, this);
        this.sliderBarContainerTr.onmousemove = OpenLayers.Function.bind(this.onMousemoveSliderBarContainerTr, this);
    },
    
    /**
     * Method: onCilckSliderBarContainerTr
     * 鼠标移动至进度条上时，显示该位置的时间点。
     */
    onMousemoveSliderBarContainerTr: function(){
        //火狐事件对象event为arguments[0]。IE和chrome的事件对象则全局存在event。
        var eventObj = arguments[0] || event;
        //火狐:target存在。IE:srcElement存在。chrome:target和srcElement都存在。
        var srcElement = eventObj.target || eventObj.srcElement;
        if (srcElement.id == "sliderFocusNode") {
            return;
        }
        //火狐:layerX存在。IE:offsetX存在。chrome:offsetX存在。
        var offsetX = (eventObj.offsetX != undefined) ? eventObj.offsetX : eventObj.layerX;
        var newWidthPX = offsetX;
        if (newWidthPX < 0) {
            newWidthPX = 0;
        }
        if (srcElement.className == "") {
            return;
        }
        if (srcElement.className == "sliderBarContainerPanelLeft") {
            newWidthPX = 0;
        }
        if (srcElement.className == "sliderBarContainerPanelRight") {
            newWidthPX = this.remainingBar.clientWidth;
        }
        //所占的格子数
        var currentMark = Math.floor((newWidthPX / this.remainingBar.clientWidth) * this.markNum);
        if (this.markInfo) {
            this.sliderBarContainerTr.title = this.markInfo[currentMark];
        }
	},
    
    /**
     * Method: onCilckSliderBarContainerTr
     * 鼠标点击进度条上时，进度改变至鼠标点击的位置。
     */
    onCilckSliderBarContainerTr: function(){
        //火狐事件对象event为arguments[0]。IE和chrome的事件对象则全局存在event。
        var eventObj = arguments[0] || event;
        //火狐:target存在。IE:srcElement存在。chrome:target和srcElement都存在。
        var srcElement = eventObj.target || eventObj.srcElement;
        if (srcElement.id == "sliderFocusNode") {
            return;
        }
        //火狐:layerX存在。IE:offsetX存在。chrome:offsetX存在。
        var offsetX = (eventObj.offsetX != undefined) ? eventObj.offsetX : eventObj.layerX;
        var newWidthPX = offsetX;
        if (newWidthPX < 0) {
            newWidthPX = 0;
        }
		if(srcElement.className == ""){
			return;
		}
        if (srcElement.className == "sliderBarContainerPanelLeft") {
            newWidthPX = 0;
        }
        if (srcElement.className == "sliderBarContainerPanelRight") {
            newWidthPX = this.remainingBar.clientWidth;
        }
        //所占的格子数
        this.currentMark = Math.floor((newWidthPX / this.remainingBar.clientWidth) * this.markNum);
        //长度的最终百分比值  = 所占的份数 * 每份的百分比 
        var percentValueWidth = this.currentMark / this.markNum * 100;
        this.progressBar.style.width = percentValueWidth + "%";
        //同步this.tmpNewWidthPX存储进度条长度，防止拖动时错位的问题。
        this.tmpNewWidthPX = this.progressBar.clientWidth;
        //防止点击至起点或终点时，拖动错位的问题。
        this.progressBarPX = null;
		this.onSliderBarMove();
		this.setSliderBarTitle();
    },
    
    /**
     * Method: sliderBarDown
     * 鼠标光标在进度条指针上按下时，触发该方法。
     *
     * Parameters:
     * evt - {<Geo.Event>} 事件对象。
     */
    sliderBarDown: function(evt){
        if (!OpenLayers.Event.isLeftClick(evt) && !OpenLayers.Event.isSingleTouch(evt)) {
            return;
        }
        this.map.events.on({
            "touchmove": this.passEventToSlider,
            "mousemove": this.passEventToSlider,
            "mouseup": this.passEventToSlider,
            scope: this
        });
        this.documentEvents.on({
            "touchmove": this.passEventToSlider,
            "mousemove": this.passEventToSlider,
            "mouseup": this.passEventToSlider,
            scope: this
        });
		//鼠标光标居中于进程条上的按钮的偏移像素值
        var middleDelta = 0;
		
		var offsetX = (evt.offsetX != undefined) ? evt.offsetX : evt.layerX;
        if (offsetX >= 0 && offsetX <= 18) {
            middleDelta = offsetX - this.sliderBar.clientWidth / 2;
        }
        //鼠标起始坐标X
        this.mouseDragStart = evt.clientX - middleDelta;
        OpenLayers.Event.stop(evt);
    },
	
    /**
     * Method: sliderBarDrag
     * 鼠标光标在进度条指针上按下并拖动时，触发该方法。
     *
     * Parameters:
     * evt - {<Geo.Event>} 事件对象。
     */
    sliderBarDrag: function(evt){
        if (this.mouseDragStart != null) {
            
            //鼠标实际偏移像素值//screenX
            var deltaX = evt.clientX - this.mouseDragStart;
			
            //----------------------------------------------------------------------
			if(this.tmpNewWidthPX != null){
				this.tmpNewWidthPX += deltaX;
			}else{
				this.tmpNewWidthPX = this.progressBar.clientWidth + deltaX;
			}
            
            if (this.tmpNewWidthPX >= 0 && this.tmpNewWidthPX <= this.remainingBar.clientWidth) {
                //this.tmpNewWidthPX += deltaX;
            }
            else 
                if (this.tmpNewWidthPX < 0) {
                    this.tmpNewWidthPX = 0;
                }
                else 
                    if (this.tmpNewWidthPX > this.remainingBar.clientWidth) {
                        this.tmpNewWidthPX = this.remainingBar.clientWidth;
                    }
			//----------------------------------------------------------------------
			//每格子
			var OneMarkNum = (1 / this.markNum);
			//所占的格子数
			this.currentMark = Math.floor((this.tmpNewWidthPX / this.remainingBar.clientWidth) * this.markNum);
			//长度的最终百分比值  = 所占的份数 * 每份的百分比 
			var percentValueWidth = this.currentMark / this.markNum * 100;
			
			if (this.tmpNewWidthPX > 0 && this.tmpNewWidthPX < this.remainingBar.clientWidth) {
				//精确的进程像素长度
				this.progressBarPX = this.tmpNewWidthPX;
				//有误差的进程百分比长度
				this.progressBar.style.width = percentValueWidth + "%";
				this.mouseDragStart = evt.clientX;
			}else if(this.tmpNewWidthPX == 0){
				if(this.progressBarPX != null){
					this.mouseDragStart = this.mouseDragStart - this.progressBarPX;
				}
				//精确的进程像素长度
				this.progressBarPX = 0;
				this.progressBar.style.width = "0%";
			}else if(this.tmpNewWidthPX == this.remainingBar.clientWidth){
				//alert(this.remainingBar.clientWidth);
				if (this.progressBarPX != null) {
					this.mouseDragStart = this.mouseDragStart - this.progressBarPX + this.remainingBar.clientWidth;
				}
				//精确的进程像素长度
				this.progressBarPX = this.remainingBar.clientWidth;
				this.progressBar.style.width = "100%";
			}
			this.setSliderBarTitle();
        }
    },
    
    /**
     * Method: sliderBarUp
     * 鼠标光标在进度条指针上按下或按下拖动后抬起时，触发该方法。
     *
     * Parameters:
     * evt - {<Geo.Event>} 事件对象。
     */
    sliderBarUp: function(evt){
        if (!OpenLayers.Event.isLeftClick(evt) && evt.type !== "touchend") {
            return;
        }
		
		var srcElement = evt.target || evt.srcElement;
		if(srcElement.id != "sliderFocusNode"){
			this.sliderBar.className = "sliderImage";
			this.sliderBarContainerTable.className = "timeSliderTable sliderBarContainerTable";
		}
		
        if (this.mouseDragStart) {
            this.map.events.un({
                "touchmove": this.passEventToSlider,
                "mouseup": this.passEventToSlider,
                "mousemove": this.passEventToSlider,
                scope: this
            });
            this.documentEvents.un({
                "touchmove": this.passEventToSlider,
                "mouseup": this.passEventToSlider,
                "mousemove": this.passEventToSlider,
                scope: this
            });
            this.mouseDragStart = null;
            OpenLayers.Event.stop(evt);
        }
		
		this.onSliderBarMove();
    },
	
    /**
     * Method: passEventToSlider
     * 传递事件至进度条指针。
     *
     * Parameters:
     * evt - {<Geo.Event>} 事件对象。
     */
    passEventToSlider: function(evt) {
        this.sliderEvents.handleBrowserEvent(evt);
    },
	
    /**
     * APIMethod: play
     * 播放。
     */
    play: function(){
		if (this.interval <= 0) {
			return;
		}
		this.timerId && clearInterval(this.timerId);
		//播放时，按钮设置为暂停图标
		this.playButton.children[0].className = "sliderButtonNodeIcon pauseButton sliderInline";
		this.prevButton.className = "sliderButtonNode sliderInline sliderButtonDisabled";
		this.nextButton.className = "sliderButtonNode sliderInline sliderButtonDisabled";
		
        var timerCallback = function(){
            if (this.currentMark >= this.markNum) {
				//暂停
                this.pause();
                return;
            }
			//前进一个刻度
			this.setProgressBarWidth(1);
        };
		this.timerId = window.setInterval(OpenLayers.Function.bind(timerCallback, this), this.interval);
    },
	
    /**
     * APIMethod: pause
     * 暂停。
     */
	pause: function(){
		clearInterval(this.timerId);
		this.timerId = null;
		//停止播放时，按钮设置为播放图标
		this.playButton.children[0].className = "sliderButtonNodeIcon playButton sliderInline";
		this.prevButton.className = "sliderButtonNode sliderInline";
		this.nextButton.className = "sliderButtonNode sliderInline";
	},
	
    /**
     * APIMethod: previous
     * 后退。
     */
	previous: function(){
		this.setProgressBarWidth(-1);
	},
	
    /**
     * APIMethod: next
     * 前进。
     */
	next: function(){
		this.setProgressBarWidth(1);
	},
	
    /**
     * APIMethod: setCurrentMark
     * 设置当前进度条需指向的时间点索引。
     * 
     * Parameters:
     * currentMark - {Number} 当前进度条需指向的时间点索引。
     */
	setCurrentMark: function(currentMark){
		this.currentMark = currentMark;
		this.setProgressBarWidth();
	},
	
    /**
     * Method: setProgressBarWidth
     * 根据偏移刻度值设置进度条长度。
     * 
     * Parameters:
     * delta - {Number} 偏移刻度值。
     */
	setProgressBarWidth: function(delta){
		if(!delta){
			delta = 0;
		}
		var cm = this.currentMark + delta;
		if (cm > this.markNum || cm < 0) {
			return;
		}
		this.currentMark += delta;
		var percentValueWidth = this.currentMark / this.markNum * 100;
		this.progressBar.style.width = percentValueWidth + "%";
		//同步this.tmpNewWidthPX存储进度条长度，防止拖动时错位的问题。
		this.tmpNewWidthPX = this.progressBar.clientWidth;
		this.onSliderBarMove();
		this.setSliderBarTitle();
	},
	
    /**
     * Method: _setRuleMarksHTML
     * 在进度条下填充刻度线。
     */
	_setRuleMarksHTML: function(){
        var html = '';
		this.textArr = new Array();
        for (var i = 0; i <= this.markNum; i += 1) {
            var percentValue = i / this.markNum * 100;
			var title = "";
			if (this.markInfo) {
				title = this.markInfo[i];
			}
            html += '<div class="ruleMark" style="left:' + percentValue + '%" title="' + title +'"></div>';
        }
		document.getElementById("ruleContainer").innerHTML = html;
	},
	
    /**
     * Method: setSliderBarTitle
     * 设置指针标题。
     */
	setSliderBarTitle: function(){
		if (!this.markInfo) {
			this.sliderMoveableInfoDIV.style.display = "none";
			return;
		}
		this.sliderMoveableInfoDIV.innerHTML = this.markInfo[this.currentMark];
		var num = this.sliderMoveableInfoDIV.innerHTML.length;
		//每个字的宽度。
		var wordWidth = 9;
		this.sliderMoveableInfoDIV.style.width = num * wordWidth + "px";
		this.sliderMoveableInfoDIV.style.left = -(num * wordWidth / 2 - 6) + "px";
		this.sliderMoveableInfoDIV.style.display = "block";
	},
	
    /**
     * APIMethod: setMarkInfo
     * 设置时间点数组。
     * 
     * Parameters:
     * markInfo - {Array(String)} 偏移刻度值。
     */
	setMarkInfo: function(markInfo){
		this.markInfo = markInfo;
	},
	
    /**
     * Method: _removeSliderEvents
     * 移除进度条指针事件监听。
     */
    _removeSliderEvents: function(){
        this.sliderEvents.un({
            "mousedown": this.sliderBarDown,
            "mousemove": this.sliderBarDrag,
            "mouseup": this.sliderBarUp
        });
        this.sliderEvents.destroy();
    },
	
    /**
     * APIMethod: destroy
     * 销毁该对象。
     */
    destroy: function(){
        this._removeSliderEvents();
        
        OpenLayers.Control.prototype.destroy.apply(this, arguments);
        
        delete this.mouseDragStart;
    },
	
    CLASS_NAME: "Geo.View2D.Control.TimeSlider"
});
Geo.View2D.Control.TimeSlider.timeSliderDivHTML = '' +
	'<table width="100%" class="timeSliderTable" style="margin-left:5px;">' +
		'<tbody>' +
			'<tr>' +
				'<td align="right">' +
					'<div id="buttonLeftPanel">' +
						'<span class="sliderButtonNode sliderInline" id="playButton">' +
							'<span class="sliderButtonNodeIcon playButton sliderInline"></span>' +
						'</span>' +
					'</div>' +
				'</td>' +
					'<!-- 刻度条容器面板-->' +
				'<td width="80%" align="center">' +
					'<table class="timeSliderTable sliderBarContainerTable" id="sliderBarContainerTableID" >' +
		        		'<tbody>' +
		        			'<tr id="sliderBarContainerTrID">' +
		        				'<!-- 刻度条容器左侧封闭-->' +
		        				'<td><div class="sliderBarContainerPanelLeft"></div></td>' +
		        				'<td width="100%"><div id="sliderBarContainerPanel">' +
										'<!-- 刻度条容器-->' +
										'<div id="sliderBarContainer">' +
											'<!-- 已播放的进程条 -->' +
											'<div id="progressBar" class="sliderBarC">' +
												'<!-- 隐藏的 -->' +
												'<div id="sliderMoveable">' +
												'<!-- 显示当前时间信息的DIV -->' +
												'<div id="sliderMoveableInfo"></div>' +
													'<!-- 指针 -->' +
													'<div class="sliderImage" id="sliderFocusNode">' +
													'</div>' +
												'</div>' +
											'</div>' +
											'<div id="remainingBar" class="sliderBarC">' +
											'</div>' +
										'</div>' +
									'</div>' +
								'</td>' +
		        				'<td><div class="sliderBarContainerPanelRight"></div></td>' +
							'</tr>' +
							'<tr>' +
								'<td></td>' +
								'<td width="100%">' +
									'<div id="ruleContainer">' +
										'<div class="ruleMark" style="left:0%"></div>' +
									'</div>' +
								'</td>' +
								'<td></td>' +
							'</tr>' +
						'</tbody>' +
					'</table>' +
				'</td>' +
				'<td width=30>' +
					'<span class="sliderButtonNode sliderInline" id="prevButton">' +
						'<span class="sliderButtonNodeIcon prevButton sliderInline"></span>' +
					'</span>' +
				'</td>' +
				'<td align="left">' +
					'<div id="buttonRightPanel">' +
						'<span class="sliderButtonNode sliderInline" id="nextButton">' +
							'<span class="sliderButtonNodeIcon nextButton sliderInline"></span>' +
						'</span>' +
					'</div>' +
				'</td>' +
			'</tr>' +
		'</tbody>' +
	'</table>';﻿/**
 * Class: Geo.View2D.Control.PrintMap
 * 打印控件类，控件为可视控件类型。
 *
 * Inherits from:
 *  - <Geo.View2D.Control>
 */
Geo.View2D.Control.PrintMap = Geo.Class(Geo.View2D.Control, {
	/**
     * APIProperty: titleName
     * {String} 打印预览页面title标签元素内显示的名称。
     */
    titleName: "地图打印",
	
    /**
     * APIProperty: headerName
     * {String} 打印预览页面显示的打印名称。
     */
    headerName: "地图",
	
	/**
     * APIProperty: containerWidth
     * {String} 打印地图容器的宽度，默认值为1024。
     */
	containerWidth: "1024",
	
	/**
     * APIProperty: containerHeight
     * {String} 打印地图容器的高度，默认值为768。
     */
	containerHeight: "768",
	
	/**
     * APIProperty: printImgSrc
     * {String} 打印按钮的背景图片地址。
     */
	printImgSrc: "",
	/**
     * Constructor: Geo.View2D.Control.PrintMap
     * 创建打印控件对象实例。
     *
     * Parameters:
     * options - {Object} 对象构造参数。
     */
    initialize: function(options){
        OpenLayers.Control.prototype.initialize.apply(this, arguments);
	},
	
    /** 
     * Method: setMap
     * 该控件与地图对象关联。
     * 
     * Parameters:
     * map - {<Geo.View2D.Map>} 
     */
    setMap: function(map){
        Geo.View2D.Control.prototype.setMap.apply(this, arguments);
    },
    
	/**
     * APIMethod: createPrintMap
     * 显示打印预览页面，打印地图操作。
     * 
     * Parameters:
     * id - {String} 地图容器的id值。 
     */
	createPrintMap: function(id){
		var size = map.getSize();
		if(this.containerWidth > size.w){
			alert("打印地图容器宽度超过了地图的宽度，请重新设置打印地图容器宽度。");
			return;
		}
		if(this.containerHeight > size.h){
			alert("打印地图容器高度超过了地图的高度，请重新设置打印地图容器高度。");
			return;
		}
		/*
		if(OpenLayers.BROWSER_NAME == 'msie'){
			var arVersion = navigator.appVersion.split("MSIE");
        	var version = parseFloat(arVersion[1]);
			if(parseInt(version) < 9){
				alert("控件不支持在IE9以下版本的浏览器中运行!");
				return;
			}
		}
		*/
		var printWindow = window.open("");
		var strInnerHTML = document.getElementById(id).innerHTML;
		var strHeader = "<!DOCTYPE html><html><head><META HTTP-EQUIV='pragma' CONTENT='no-cache'><META HTTP-EQUIV='Cache-Control' CONTENT='no-cache, must-revalidate'><META HTTP-EQUIV='expires' CONTENT='Wed, 26 Feb 1997 08:21:57 GMT'><meta http-equiv='Content-Type' content='text/html; charset=utf-8' /><meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0' /><meta name='apple-mobile-web-app-capable' content='yes' /><title>"+this.titleName+"</title>";
//		var strCSS = "<link href='../../css/demoComm.css' rel='stylesheet' /><link href='../../../css/print.css' rel='stylesheet' />";
		var height = parseInt(this.containerHeight)-10;
		var strCSS = '';
		var printButton = "";
		strCSS = strCSS + '<style type="text/css">';
		strCSS = strCSS + '.olImageLoadError{background-color: pink; opacity: 0!important; filter: alpha(opacity=0)!important;}';
		strCSS = strCSS + '.print-container {margin: auto;width:'+this.containerWidth+'px;height:'+this.containerHeight+'px;top: 50px;position: relative;}';
		strCSS = strCSS + '.geoD {width: 100%;height: 24px;line-height: 24px;border-bottom: 3px solid #B2B2B2;font-size: 14px;margin-bottom: 6px;}';
		strCSS = strCSS + '#'+ id + '{position: relative;height:'+ height +'px;margin-bottom: 15px;clear: both;}';
		strCSS = strCSS + '#geoft {content: ".";height: 77px;display: block;overflow: hidden;clear: both;}';
		strCSS = strCSS + '.printMap {margin-bottom: 20px;float: right;}';
		if(this.printImgSrc != undefined && this.printImgSrc != ""){
			strCSS = strCSS + '.printMap span {background-position: 0px 0px;cursor: pointer;margin-right: 0px;margin-top: 5px;display: inline-block;width: 69px;height: 29px;background-image: url('+this.printImgSrc+');}';
			printButton = "<span id='printMap' onclick = 'printDiv()'></span>";
		}else {
			printButton = "<input id='printMap' type='button' value='打印' onclick = 'printDiv()'></input>";
		}
		strCSS = strCSS + '</style>';
		var strScript = "<script type = 'text/javascript'>" + "\n" + "function printDiv(){var divObj = document.getElementById('printMap');divObj.style.display = 'none';window.print();divObj.style.display = 'block';}<\/script>";
		var strBody = "</head><body><div class='print-container'><div class='geoD'><h3>"+this.headerName+"</h3></div><div id='"+id+"' >" +strInnerHTML + "</div><div id='geoft'><div class='printMap'>"
		strBody = strBody + printButton;
		strBody = strBody + "</div></div></div></body></html>";
        var strHTML = strHeader + strCSS + strScript + strBody;
		printWindow.document.write(strHTML);
		printWindow.document.close();
	},
			
    /**
     * APIMethod: destroy
     * 销毁该对象。
     */
    destroy: function(){
        OpenLayers.Control.prototype.destroy.apply(this, arguments);
    },
	
    CLASS_NAME: "Geo.View2D.Control.PrintMap"
});/**
 * Class: Geo.View2D.Control.ShutterView
 * 卷帘控件。
 */
Geo.View2D.Control.ShutterView = Geo.Class(Geo.View2D.Control, {
				
    /**
     * APIProperty: shutterTransparentDIV
     * 透明层div id，用来屏蔽主地图，防止主地图事件触发。
     */ 
	shutterTransparentDIV: null,
	
    /**
     * APIProperty: shutterMapWrapDIV
     * 地图容器外层div id
     */ 
	shutterMapWrapDIV: null,
	
    /**
     * APIProperty: shutterMap
     * 副地图容器div id
     */ 
	shutterMapDIV: null,
				
    /**
     * APIProperty: layers
     * 副地图图层
     */    
	layers: null,
	
    /**
     * Property: shuttermap
     */ 
	shuttermap: null,
	
    /**
     * Property: isDoUp
     */ 
	isDoUp: false,
	
	/**
     * Property: dir
     */    
	dir: null,
	
	/**
	 * Constructor: Geo.View2D.Control.ShutterView
	 * Geo.View2D.Control.ShutterView构造函数
	 */
    initialize: function(options){
        Geo.View2D.Control.prototype.initialize.apply(this, [options]);
		this.layers = this.layers ? this.layers : [];
		
		this.shutterTransparentDIVEle = document.getElementById(this.shutterTransparentDIV);
		this.shutterMapWrapDIVEle = document.getElementById(this.shutterMapWrapDIV);
		this.shutterMapDIVEle = document.getElementById(this.shutterMapDIV);
    },
	
	/**
	 * Method: addEvent
	 * 绑定卷帘地图div的鼠标事件
	 */	
	addEvent: function(){
		this.shutterTransparentDIVEle.onmousemove = OpenLayers.Function.bind(this.doMove, this);
		this.shutterMapWrapDIVEle.onmousemove = OpenLayers.Function.bind(this.doMove, this);
		this.shutterTransparentDIVEle.onmousedown = OpenLayers.Function.bind(this.doDown, this);
		this.shutterMapWrapDIVEle.onmousedown = OpenLayers.Function.bind(this.doDown, this);
		this.shutterTransparentDIVEle.onmouseup = OpenLayers.Function.bind(this.doUp, this);
		this.shutterMapWrapDIVEle.onmouseup = OpenLayers.Function.bind(this.doUp, this);
	},
	
	/**
	 * Method: removeEvent
	 * 移除事件
	 */	
	removeEvent: function(){
		this.shutterTransparentDIVEle.onmousemove = function(){};
		this.shutterMapWrapDIVEle.onmousemove = function(){};
		this.shutterTransparentDIVEle.onmousedown = function(){};
		this.shutterMapWrapDIVEle.onmousedown = function(){};
		this.shutterTransparentDIVEle.onmouseup = function(){};
		this.shutterMapWrapDIVEle.onmouseup = function(){};
	},
	
    /**
     * APIMethod: done
     * 绘制完成的响应函数，用户可以使用自己定义的函数替代。
     * 
     * Parameters:
     * geometry - {<Geo.Geometry>} 绘制的几何对象。
     */
    done: function(geometry){
        
    },
	
	/**
	 * Method: resizeObject
	 * 重置条件
	 * 重置卷帘相关的数据的值
	 */		
	resizeObject : function(){
		 this.el = null; //pointer to the object
		 this.dir = "";      //type of current resize (n, s, e, w, ne, nw, se, sw)
		 this.grabx = null;     //Some useful values
		 this.graby = null;
		 this.width = null;
		 this.height = null;
		 this.left = null;
		 this.top = null;
	},
	
	/**
	 * Method: getDirection
     * 
     * Parameters:
     * el - {Object} 页面对象
     * 
     * Returns:
     * {String} 鼠标移动关键字段。
	 */
    getDirection: function(el){
        var xPos, yPos, offset, dir;
        dir = "";
		/*
        //判断是否开启全屏
        if ($("#header").css("display") != "none") {//未开启全屏
            xPos = window.event.clientX;
            yPos = window.event.clientY - 108; //The distance from the edge in pixels
        }
        else {
            xPos = window.event.clientX;
            yPos = window.event.clientY - 30; //The distance from the edge in pixels	
        }
        */
        xPos = window.event.clientX;
        yPos = window.event.clientY;
			
        if (yPos > 0 && xPos > 0 && yPos <= el.offsetHeight && xPos <= el.offsetWidth) {
            if ((yPos / xPos) < (el.offsetHeight / el.offsetWidth)) {
                if (yPos / (el.offsetWidth - xPos) < (el.offsetHeight / el.offsetWidth)) {
                    dir += "n";
                }
                if (yPos / (el.offsetWidth - xPos) >= (el.offsetHeight / el.offsetWidth)) {
                    dir += "e";
                }
            }
            else 
                if ((yPos / xPos) > (el.offsetHeight / el.offsetWidth)) {
                    if (yPos / (el.offsetWidth - xPos) < (el.offsetHeight / el.offsetWidth)) {
                        dir += "w";
                    }
                    if (yPos / (el.offsetWidth - xPos) > (el.offsetHeight / el.offsetWidth)) {
                        dir += "s";
                    }
                }
        }
        return dir;
    },
	
	/**
	 * Method: doDown
	 * 鼠标按下时触发
	 * 鼠标按下时获取卷帘地图相关数据，然后坐相应的处理
	 */
    doDown: function(){
        var el, elmap, xPos, yPos, str, xMax, yMax;
        el = document.getElementById(this.shutterMapWrapDIV);
        elmap = document.getElementById(this.shutterMapDIV);
        xMax = parseFloat(elmap.style.width);
        yMax = parseFloat(elmap.style.height);
        dir = this.getDirection(el);
        if (this.dir == "") 
            return;
        this.resizeObject();
        //theobject = this;
		this.isDoUp = false;
        this.el = el;
        this.dir = dir;
        //this.grabx = window.event.clientX;
        //this.graby = window.event.clientY;
		/*
        //判断是否开启全屏
        if ($("#header").css("display") != "none") {//未开启全屏
            this.grabx = 0;
            this.graby = 108;
        }
        else {
            this.grabx = 0;
            this.graby = 30;
        }
        */
		this.grabx = 0;
        this.graby = 0;
		
        this.width = el.offsetWidth;
        this.height = el.offsetHeight;
        this.left = el.offsetLeft;
        this.top = el.offsetTop;
        if (this.isDoUp === false) {
            if (dir.indexOf("e") != -1) {
                //alert(this.width )
                //alert(window.event.clientX);
                var width1 = Math.min(xMax, window.event.clientX - this.grabx) + "px";
                //$(this.el).css("width", width1);
				this.el.style.width = width1;
                //alert(this.el.style.width);
            }
            if (dir.indexOf("s") != -1) {
                var height1 = Math.min(yMax, window.event.clientY - this.graby) + "px";
                //$(this.el).css("height", height1);
				this.el.style.height = height1;
                
            }
            if (dir.indexOf("w") != -1) {
                var left1 = Math.min(this.left + window.event.clientX - this.grabx, this.left + this.width) + "px";
                var left2 = -Math.min(this.left + window.event.clientX - this.grabx, this.left + this.width) + "px";
                var width1 = Math.min(xMax, this.width - window.event.clientX + this.grabx) + "px";
                //$(this.el).css("left", left1);
				this.el.style.left = left1;
                //$(this.el).css("width", width1);
				this.el.style.width = width1;
                //$(elmap).css("left", left2);
				elmap.style.left = left2;
            }
            if (dir.indexOf("n") != -1) {
                var top1 = Math.min(this.top + window.event.clientY - this.graby, this.top + this.height) + "px";
                var top2 = -Math.min(this.top + window.event.clientY - this.graby, this.top + this.height) + "px";
                var height1 = Math.min(yMax, this.height - window.event.clientY + this.graby) + "px";
                //$(this.el).css("top", top1);
				this.el.style.top = top1;
                //$(this.el).css("height", height1);
				this.el.style.height = height1;
                //$(elmap).css("top", top2);
				elmap.style.top = top2;
            }
            this.width = parseFloat(this.el.style.width);
            this.height = parseFloat(this.el.style.height);
            this.left = parseFloat(this.el.style.left);
            this.top = parseFloat(this.el.style.top);
        }
        this.grabx = window.event.clientX;
        this.graby = window.event.clientY;
        window.event.returnValue = false;
        /*如果提供了事件对象，则这是一个非IE浏览器*/
        if (window.event && window.event.stopPropagation) {
            /*因此它支持W3C的stopPropagation()方法*/
            window.event.stopPropagation();
        }
        else {
            /*否则，我们需要使用IE的方式来取消事件冒泡*/
            window.event.cancelBubble = true;
        }
    },
	
	/**
	 * Method: doUp
	 * 替换页面所有的鼠标弹起事件
	 * 鼠标按下后弹起事件
	 */
    doUp: function(){
        //if (this != null && this.el != null) {
            var elmap = document.getElementById(this.shutterMapDIV);
            //this.el.style.width = $(this.map.div).width(); 
            //this.el.style.height = $(this.map.div).height();
            //$(this.el).css("width", $(this.map.div).width());
            //$(this.el).css("height", $(this.map.div).height());
			this.el.style.width = this.map.div.clientWidth + "px";
			this.el.style.height = this.map.div.clientHeight + "px";
            this.el.style.left = "0px";
            this.el.style.top = "0px";
            elmap.style.top = "0px";
            elmap.style.left = "0px";
			
			this.isDoUp = true;
        //}
        //$(this.map.div).css("cursor", "url(img/cur/openhand.cur),url(img/cur/openhand.cur), default;");
		this.map.div.style.cursor = "url(img/cur/openhand.cur),url(img/cur/openhand.cur), default;"
    },
	
	/**
	 * Method: doMove
	 * 鼠标按下后移动的替换方法
	 */
    doMove: function(){
        var el, elmap, xPos, yPos, str, xMax, yMax;
        el = document.getElementById(this.shutterMapWrapDIV);
        elmap = document.getElementById(this.shutterMapDIV);
        elDIV = document.getElementById(this.shutterTransparentDIV);
        //Mapel = this.map.div;
        xMax = parseFloat(elmap.style.width);
        yMax = parseFloat(elmap.style.height);
        //dir = this.getDirection(el);
        if (this.dir == null) {
            return;
        }
        if (this.isDoUp === true) {
            str = this.getDirection(el);
            if (str == "") 
                str = "default";
            else 
                str += "-resize";
            elmap.style.cursor = str;
            elDIV.style.cursor = str;
            this.map.div.style.cursor = str;
        }
        //var min = this.top-10;
        //var max = this.top+10;
        //if(!this.temp || this.temp<min||this.temp>max ){
        //	this.temp=this.top;
        //}
        //Dragging starts here
        if (this.isDoUp === false) {
            if (dir.indexOf("e") != -1) {
                var width1 = (Math.min(xMax, this.width + window.event.clientX - this.grabx) > 0 ? Math.min(xMax, this.width + window.event.clientX - this.grabx) : 0) + "px";
                //$(this.el).css("width", width1);
				this.el.style.width = width1;
            }
            if (dir.indexOf("s") != -1) {
                var height1 = (Math.min(yMax, this.height + window.event.clientY - this.graby) > 0 ? Math.min(yMax, this.height + window.event.clientY - this.graby) : 0) + "px";
                //$(this.el).css("height", height1);
				this.el.style.height = height1;
            }
            if (dir.indexOf("w") != -1) {
                var left1 = Math.min(this.left + window.event.clientX - this.grabx, this.left + this.width) + "px";
                var left2 = -Math.min(this.left + window.event.clientX - this.grabx, this.left + this.width) + "px";
                var width1 = (Math.min(xMax, this.width - window.event.clientX + this.grabx) > 0 ? Math.min(xMax, this.width - window.event.clientX + this.grabx) : 0) + "px";
                //$(this.el).css("left", left1);
				this.el.style.left = left1;
                //$(this.el).css("width", width1);
				this.el.style.width = width1;
                //$(elmap).css("left", left2);
				elmap.style.left = left2;
            }
            if (dir.indexOf("n") != -1) {
                var top1 = Math.min(this.top + window.event.clientY - this.graby, this.top + this.height) + "px";
                var top2 = -Math.min(this.top + window.event.clientY - this.graby, this.top + this.height) + "px";
                var height1 = (Math.min(yMax, this.height - window.event.clientY + this.graby) > 0 ? Math.min(yMax, this.height - window.event.clientY + this.graby) : 0) + "px";
                //$(this.el).css("top", top1);
				this.el.style.top = top1;
                //$(this.el).css("height", height1);
				this.el.style.height = height1;
                //$(elmap).css("top", top2);
				elmap.style.top = top2;
            }
            
            window.event.returnValue = false;
            /*如果提供了事件对象，则这是一个非IE浏览器*/
            if (window.event && window.event.stopPropagation) {
                /*因此它支持W3C的stopPropagation()方法*/
                window.event.stopPropagation();
            }
            else {
                /*否则，我们需要使用IE的方式来取消事件冒泡*/
                window.event.cancelBubble = true;
            }
        }
    },
    
    /** 
     * Method: setMap
     * Set the map property for the control and <previous> and <next> child
     *     controls.
     *
     * Parameters:
     * map - {<Geo.View2D.Map>} 
     */
    setMap: function(map) {
        this.map = map;
        this.layers;
    },
	
	/**
     * APIMethod: activate
     * 激活控件。
     *
     * Returns:
     * {Boolean} 是否激活成功。
     */
    activate: function() {
        var activated = false;
        if(this.map) {
            if(Geo.View2D.Control.prototype.activate.apply(this)) {
				this.shutterTransparentDIVEle.style.display = "block";
				this.shutterMapWrapDIVEle.style.display = "block";
				this.shutterMapDIVEle.style.display = "block";
				this.shutterMapDIVEle.style.width = this.map.div.clientWidth + "px";
				this.shutterMapDIVEle.style.height = this.map.div.clientHeight + "px";
				if(!this.shuttermap){
	                var options = {
	                    controls: [],
	                    maxExtent: new Geo.Bounds(-180, -90, 180, 90)
	                }
	                this.shuttermap = new Geo.View2D.Map(this.shutterMapDIV, options);
					this.shuttermap.addLayers(this.layers);
				}
                this.map.setRealCenter(this.map.getCenter(), this.map.getRealZoom());
                this.shuttermap.setRealCenter(this.map.getCenter(), this.map.getRealZoom());
				//绑定卷帘地图div的鼠标事件
				this.addEvent();
                activated = true;
            }
        }
        return activated;
    },
	
	/**
     * APIMethod: deactivate
     * 关闭控件。
     *
     * Returns:
     * {Boolean} 是否关闭成功。
     */
    deactivate: function() {
        var deactivated = false;
        if(this.map) {
            if(Geo.View2D.Control.prototype.deactivate.apply(this)) {
				this.shutterTransparentDIVEle.style.display = "none";
				this.shutterMapWrapDIVEle.style.display = "none";
				this.shutterMapDIVEle.style.display = "none";
				this.removeEvent();
				this.map.div.style.cursor = "default";
                deactivated = true;
            }
        }
        return deactivated;
    },
	
	CLASS_NAME: "Geo.View2D.Control.ShutterView"
});
/**
 * Class: Geo.View2D.MenuItem
 * 鼠标右键地图菜单选项类。
 */
Geo.View2D.MenuItem = Geo.Class({

    /**
     * APIProperty: text
     * {String} 菜单项显示的文本。
     */
    text: null,

    /**
     * APIProperty: callback
     * {Function} 回调函数。
     */
    callback: null,

    /**
     * APIProperty: width
     * {String} 菜单项长度。默认值为100px。
     */
	width: 100,
	
    /**
     * Constructor: Geo.View2D.MenuItem
     * 鼠标右键地图菜单选项的构造函数。
     * 
     * Parameters:
     * options - {Object} 构造参数选项。
     */
    initialize: function(options){
		OpenLayers.Util.extend(this, options);
    },
	
	
    /**
     * APIMethod: setText
     * 设置菜单项显示的文本。
     *
     * Parameters:
     * text - {String} 菜单项显示的文本。
     */
	setText: function(text){
		this.text = text;
	},
	
    CLASS_NAME: "Geo.View2D.MenuItem"
});
/**
 * Class: Geo.View2D.TemporalRenderer
 * 本类是一个能展现不同时间段内数据实时走向的动画渲染类，展现的应用场景包括，地震，台风等。
 */
Geo.View2D.TemporalRenderer = Geo.Class({
    
	/**
	 * APIProperty: classId
	 * {String} 要素分类ID。
	 */
	classId: "EVENTID",
	
	/**
	 * 队列对象。
	 */
	hash: {},
	
	//动画队列
    _queue:null,
	
	/**
	 * 是否停止行走
	 */
	isStop: null,
	
	/**
	 * Property: frequence
	 * 移动频率，默认值为1秒
	 */
	frequence: 1000,
	
	/**
	 * Property: trackStyle
	 * 线的样式。
	 */
	trackStyle: null,
	
	/**
	 * Property: sourceProjection
	 * 源投影
	 */
	sourceProjection:null,
	
	/**
	 * Property: destProjection
	 * 目标投影
	 */
	destProjection: null,
	
	/**
	 * Property: latestStyle
	 */
	latestStyle: null,
	
	/**
	 * Property: dateTimes
	 */
	dateTimes: [],
	
	/**
	 * Property: currentTime
	 */
	currentTime: null,
	
	/**
	 * Property: ispause
	 * 是否暂停
	 */
	ispause: null,
	
    /**
     * Constructor: Geo.View2D.TemporalRenderer
     * 构造函数。矢量要素动画类实例。
     *
     * Parameters:
     * options - {Object} 对象相关选项设置。
     */
    initialize: function(options) {
        this.id = OpenLayers.Util.createUniqueID("Geo.TemporalRenderer_");
		OpenLayers.Util.extend(this, options);
		this._queue = {};
    },
	
	/**
	 * APIMethod: setFeatures
	 * 设置要素。方法中的features参数值是通过地图服务查询接口获取的。
	 * 
	 * Parameters:
	 * features - {Array(<Geo.Feature.Vector>)}  
	 */
	setFeatures: function(features){
		if(Geo.Util.isArray(features)) {
			for(var i = 0; i < features.length; i++) {
				var classId = features[i].attributes[this.classId];
				if(!Geo.Util.isArray(this.hash[classId])) {
					this.hash[classId] = [];
				}
				//分类保存要素
				this.hash[classId].push(features[i].clone());
				//设置时间轴数据
				this.setDateTimes(features[i].attributes["Date_Time"]);
				this.setCurrentTime(this.dateTimes[0]);
				this.dateTimes = this.getUniqueArray(this.dateTimes);
			}
		}
		this.cacheFeatures(this.hash);
	},
	
	/**
	 * APIMethod: getDateTimes
	 * 获取时间戳数组。说明：先调用setFeatures方法设置要素数组，然后调用本方法获取dateTimes数组。
	 * 
	 * Returns:
	 * {Array(<Integer>)} 时间戳数组。
	 */
	getDateTimes: function() {
		return this.dateTimes;
	},
	
	/**
	 * Method: sortNumber
	 */
	sortNumber: function(a, b) {
		return a - b
	},
	
	/**
	 * Method: getUniqueArray
	 */
	getUniqueArray: function(data){
		data = data || []; 
		var a = {}; 
		len = data.length; 
		for (var i=0; i<len;i++){ 
		var v = data[i]; 
		if (typeof(a[v]) == 'undefined'){ 
		a[v] = 1; 
		} 
		}; 
		data.length=0; 
		for (var i in a){ 
		data[data.length] = i; 
		} 
		return data; 
	},
	
	/**
	 * Method: setDateTimes
	 */
	setDateTimes: function(dateTime) {
		this.dateTimes.push(dateTime);
		//按照升序排序
		this.dateTimes.sort(this.sortNumber);
	},
	
	/**
	 * Method: setDateTime
	 */
	setDateTime: function() {
		
	},
	
	/**
	 * Method: cacheFeatures
	 * 初始化缓存
	 */
	cacheFeatures: function(hash) {
		for(var fs in hash) {
			var features = hash[fs];
			this._queue[fs] = this._getQueueItem();
			this.recordFeatures(features,this._queue[fs]);
		};
	},
	
	/**
	 * APIMethod: setMap
	 * 与地图关联
	 */
	setMap: function(map) {
		if(map && !this.map){
			this.map = map;
			
			//添加结果图层
//			this.vectorLayer = new OpenLayers.Layer.Vector("GeoGlobeRendererVector", {
//			//	styleMap: this.styleMap,
//				isOnTop: true,
//				displayInLayerSwitcher: false,
//				//要素的显示级别设置为开启状态，默认为false
//				rendererOptions: {zIndexing: true}
//			});
			this.vectorLayer = new OpenLayers.Layer.Vector();
			map.addLayer(this.vectorLayer);
		}
	},
	
	/**
	 * APIMethod: locateTime
	 * 定位到某个时间点
	 */
    locateTime: function(dateTime) {
		//绘制各个要素组合
		var hash = this.hash;
		this.vectorLayer.removeAllFeatures();
		for(var fs in hash) {
			var item = this._queue[fs];
			var dateTimes = item.dateTimes;
			if(dateTime < dateTimes[0]) {
				continue;
			}
			for(var i = 0; i < dateTimes.length - 1; i++) {
				if(dateTime >= dateTimes[i] && dateTime < dateTimes[i + 1] ) {
					this.vectorLayer.addFeatures(item.record[dateTimes[i]]);
				}else if(dateTime >= dateTimes[dateTimes.length - 1]) {
					this.vectorLayer.addFeatures(item.record[dateTimes[dateTimes.length - 1]]);
				//	window.clearInterval(item.interval);
				}
			}
		};
	},
	
	/**
	 * Method: fallback
	 * 后退
	 */
	fallback: function(dateTime) {
		if(this.counter > 0) {
			this.currentTime = this.dateTimes[this.counter - 1];
			this.locateTime(this.currentTime);
		}
	},
	
	/**
	 * Method: goAlong
	 * 前进
	 */
	goAlong: function(currentTime) {
		if(this.counter < this.dateTimes.length - 1) {
			this.currentTime = this.dateTimes[this.counter + 1];
			this.locateTime(this.currentTime);
		}
	},
	
	/**
	 * Method: pause
	 * 暂停
	 */
	pause: function() {
		var hash = this.hash;
		for(var fs in hash) {
			var item = this._queue[fs];
        	window.clearInterval(item.interval);
		};
		window.clearInterval(this.interval);
	},
	
	/**
	 * Method:recordFeatures
	 *  初始化缓存数据
	 */
	recordFeatures: function(features,item) {
		//逐个绘制要素
		//将要素记录在备忘录中
		for(var i = 0; i < features.length - 1; i++) {
			if(i === 0) {
				//TODO
		//		features[i].geometry = features[i].geometry.transform(new Geo.Projection("EPSG:4326"),new Geo.Projection("EPSG:4326"));
				var style = OpenLayers.Util.extend({ pointRadius: 3}, OpenLayers.Feature.Vector.style["default"]);
				style.pointRadius = 4;
				features[i].style = style;
				//TODO
				item.record[features[i].attributes["Date_Time"]] = [features[i]];
				item.dateTimes.push(features[i].attributes["Date_Time"]);
				
			}else {
				var pointGeometryArray = [];
				var pointFeatures = [];
				for(var j = 0; j <= i; j++) {
					//TODO
		//			features[j].geometry = features[j].geometry.transform(new Geo.Projection("EPSG:4326"),new Geo.Projection("EPSG:4326"));
					pointGeometryArray.push(features[j].geometry.clone());
					var style = OpenLayers.Util.extend({ pointRadius: 2}, OpenLayers.Feature.Vector.style["default"]);
					style.pointRadius = 4;
					features[j].style = style;
					pointFeatures.push(features[j]);
				}
				var tempLine = new Geo.Feature.Vector(new Geo.Geometry.LineString(pointGeometryArray));
				//TODO
		//		features[i].geometry = features[i].geometry.transform(new Geo.Projection("EPSG:4326"),new Geo.Projection("EPSG:4326"));
				//TODO
				item.record[features[i].attributes["Date_Time"]] = pointFeatures.concat(tempLine);
				item.dateTimes.push(features[i].attributes["Date_Time"]);
			}
		}
	},
	
	/**
	 * Method: setCurrentTime
	 * 设置当前时间
	 */
	setCurrentTime: function(currentTime) {
		this.currentTime = currentTime;
	},
	
	/**
	 * Method: getCurrentTime
	 * 设置当前时间
	 */
	getCurrentTime: function() {
		return this.currentTime;
	},
	
	/**
	 * Method: drawFeatures
	 * 绘制数据
	 */
	drawFeatures: function(item) {
		var hash = this.hash;
		for (var fs in hash) {
			var item = this._queue[fs];
			this.currentTime = this.getCurrentTime();
			//绘制以时间为导向
			for(var i = 0; i < item.dateTimes.length - 1; i++) {
				if(this.currentTime >= item.dateTimes[i] && this.currentTime < item.dateTimes[i + 1] ) {
					this.vectorLayer.addFeatures(item.record[item.dateTimes[i]]);
				}else if(this.currentTime >= item.dateTimes[item.dateTimes.length - 1]) {
					this.vectorLayer.addFeatures(item.record[item.dateTimes[item.dateTimes.length - 1]]);
					window.clearInterval(item.interval);
				}
			}
		}
	},
	
	/**
	 * Method: _getQueueItem
	 */
	_getQueueItem: function() {
        return {
            counter: 0,
            isStop: false,
			record: {},
			dateTimes:[],
            interval: null,
            options: {}
        };
    },
	
	//TODO：测试属性
	counter: 0,
	
//	//TODO：此方法为测试方法，以后会去掉
//	startTimeZhou: function() {
//		var fn = Geo.Function.bind(function() {
//			this.currentTime = this.dateTimes[this.counter];
//			this.counter++;
//			if(this.dateTimes.length -1 < this.counter) {
//				window.clearInterval(this.interval);
//				this.counter = 0;
//			}
//		},this);
//		this.interval = window.setInterval(fn, this.frequence + 500);
//	},
	
	/**
	 * Method: stop
	 * 停止
	 */
	stop: function() {
		this.isStop = true;
		var hash = this.hash;
		for(var fs in hash) {
			var item = this._queue[fs];
        	window.clearInterval(item.interval);
		};
		window.clearInterval(this.interval);
		this.currentTime = this.dateTimes[0];
		this.counter = 0;
	},
	
	/**
	 * Method: start
	 * 开始
	 */
	start: function() {
		var hash = this.hash;
		var i = 0;
		//如果是停止状态就清除之前的元素，只有在执行停止操作后属性才为true
		if(this.isStop === true) {
			this.vectorLayer.removeAllFeatures();
		}
		this.isStop = false;
//		this.startTimeZhou();
	
		var fn1 = Geo.Function.bind(function(fs) {
			var fn = Geo.Function.bind(function() {
				this.drawFeatures();
			},this);
			this._queue.interval = window.setInterval(fn, this.frequence);
        },this);
		fn1();
	},
	
    CLASS_NAME: "Geo.View2D.TemporalRenderer"
});

/**
 * 用来给要素设置样式
 */
Geo.View2D.TemporalRenderer.HashStyle = Geo.Class({
	
	data: [],
	
 	/**
     * Constructor: Geo.View2D.TemporalRenderer.HashStyle
     *
     * Parameters:
     * options - {Object} 对象相关选项设置。
     */
    initialize: function(options) {
        this.id = OpenLayers.Util.createUniqueID("Geo.TemporalRenderer.HashStyle_");
    },
	
	put: function(key, value) {
        this.data[key] = value;
    },
			
	get: function(key) {
        return this.data[key];
    },
	
	remove: function(key) {
        this.data[key] = null;
    },
	
	isEmpty: function() {
        return this.data.length == 0;
    },
	
	size: function() {
        return this.data.length;
    },
	
	CLASS_NAME: "Geo.View2D.TemporalRenderer.HashStyle"
});/**
 * Class: Geo.View2D.Layer.DynamicMapService
 * rest服务的动态地图图层类。继承自Geo.View2D.Layer.Grid类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 * 本图层用于展示rest服务的动态地图服务提供的瓦片数据。
 * 本图层支持的服务类型：OGC_Geo_MapService_Rest、Arcgis_MapService_Rest。
 * 
 * Inherits from:
 *  - <Geo.View2D.Layer.Grid>
 */
Geo.View2D.Layer.DynamicMapService = Geo.Class(Geo.View2D.Layer.Grid, {

    /**
     * Constant: DEFAULT_PARAMS
     * {Object} 键值对对象。为参数设置默认值
     */
    DEFAULT_PARAMS: {
      format: "png"
    },
        
    /**
     * APIProperty: isBaseLayer
     * {Boolean} 是否为基础图层
     */
    isBaseLayer: true,
	
	/**
	 *  APIProperty: layers
	 * 确定哪些图层在导出图像上出现。可以通过四种方式指定图层显示。
	 * 
	 * 参数如下：
	 *	show: 仅导出列表中指定的图层。 
	 *	hide: 导出列表指定图层以外的所有图层。 
	 *	include: 除了以默认方式导出图层以外, 列表中指定的图层也会被导出。 
	 *	exclude:没有在这个列表中指定的,以默认方式导出的图层将会被导出。
	 *	示例: layers=show:2,4,7
     *
	 */
	layers:null,
	
	/**
	 * APIProperty: time
	 * {Object} 请求指定时间段内的瓦片。默认可不填
		取值举例：
		timeExtent： {
			startTime:new Date("6/1/2013"),
			endTime:new Date("6/1/2003")
		}
	 */
	timeExtent:null,
	
	/**
	 * APIProperty: layerDefs
	 * 允许你通过定义图层的表达式来过滤单个图层的要素。 
     *
	 *	语法: layerId1:layerDef1;layerId2:layerDef2
	 *	layerId1, layerId2 是地图服务资源返回的图层ID 
	 *	
	 *	示例: 0:POP2000 > 1000000;5:AREA > 100000
	 */
	layerDefs: null,
	
    /**
     * Constructor: Geo.View2D.Layer.DynamicMapService
     * 创建一个动态地图图层
     *
     * Parameters：
     * name - {String} 图层名称
     * url - {String} 动态地图服务地址
     * params - {object}
     * 		format - {String}瓦片格式
     * 		transparent - {Boolean} 透明度
     *      layers: {String} 确定哪些图层在导出图像上出现。
     * 		time - {String} 指定请问时间范围内的瓦片，比如：time:"2013-05-16,2013-05-16"
     * 		gdbVersion - {String} 地图的数据版本，在10.1版本后支持     
     * Example:
     * (code)
     * var arcims = new Geo.View2D.Layer.DynamicMapService("MyName",
     * "http://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Specialty/ESRI_StateCityHighway_USA/MapServer", 
     * {
     *    layers: "0,1,2"
     * }
     * );
     * (end)
     * 	
     */
    initialize: function(name, url, params, options) {
		var location = url.indexOf("/",url.length - 1);
		if(location != -1) {
			url = url + "export";
		}else {
			url = url + "/" + "export";
		}
        var newArguments = [];
        //uppercase params
        params = OpenLayers.Util.upperCaseObject(params);
        newArguments.push(name, url, params, options);
        OpenLayers.Layer.Grid.prototype.initialize.apply(this, newArguments);
        OpenLayers.Util.applyDefaults(
                       this.params, 
                       OpenLayers.Util.upperCaseObject(this.DEFAULT_PARAMS)
                       );
                       
        //layer is transparent        
        if (this.params.TRANSPARENT && 
            this.params.TRANSPARENT.toString().toLowerCase() == "true") {
            
            // unless explicitly set in options, make layer an overlay
            if ( (options == null) || (!options.isBaseLayer) ) {
                this.isBaseLayer = false;
            } 
            
            // jpegs can never be transparent, so intelligently switch the 
            //  format, depending on the browser's capabilities
            if (this.params.FORMAT == "jpg") {
                this.params.FORMAT = OpenLayers.Util.alphaHack() ? "gif"
                                                                 : "png";
            }
        }
		
		if(this.params.TIMEEXTENT) {
			if(this.params.TIMEEXTENT.startTime instanceof Date && this.params.TIMEEXTENT.endTime instanceof Date) {
				var startTime = Date.parse(this.params.TIMEEXTENT.startTime);
				var endTime = Date.parse(this.params.TIMEEXTENT.endTime);
				this.params.TIME = startTime + "," + endTime;
				delete this.params.TIMEEXTENT;
			}
		}
    },    

    
    /**
     * Method: destroy
     * Destroy this layer
     */
    destroy: function() {
        // for now, nothing special to do here. 
        OpenLayers.Layer.Grid.prototype.destroy.apply(this, arguments);  
    },   
    
    /**
     * Method: clone
     * Create a clone of this layer
     *
     * Returns:
     * {<Geo.View2D.Layer.DynamicMapService>} An exact clone of this layer
     */
    clone: function (obj) {
        
        if (obj == null) {
            obj = new Geo.View2D.Layer.DynamicMapService(this.name,
                                           this.url,
                                           this.params,
                                           this.getOptions());
        }

        //get all additions from superclasses
        obj = OpenLayers.Layer.Grid.prototype.clone.apply(this, [obj]);

        // copy/set any non-init, non-simple values here

        return obj;
    },
    
    /**
     * Method: getURL
     * Return an image url this layer.
     *
     * Parameters:
     * bounds - {<OpenLayers.Bounds>} A bounds representing the bbox for the
     *                                request.
     *
     * Returns:
     * {String} A string with the map image's url.
     */
    getURL: function (bounds) {
        bounds = this.adjustBounds(bounds);

        // ArcGIS Server only wants the numeric portion of the projection ID.
        var projWords = this.projection.getCode().split(":");
        var srid = projWords[projWords.length - 1];

        var imageSize = this.getImageSize(); 
        var newParams = {
            'BBOX': bounds.toBBOX(),
            'SIZE': imageSize.w + "," + imageSize.h,
            // We always want image, the other options were json, image with a whole lotta html around it, etc.
            'F': "image",
            'BBOXSR': srid,
            'IMAGESR': srid
        };

        // Now add the filter parameters.
        if (this.layerDefs) {
            var layerDefStrList = [];
            var layerID;
            for(layerID in this.layerDefs) {
                if (this.layerDefs.hasOwnProperty(layerID)) {
                    if (this.layerDefs[layerID]) {
                        layerDefStrList.push(layerID);
                        layerDefStrList.push(":");
                        layerDefStrList.push(this.layerDefs[layerID]);
                        layerDefStrList.push(";");
                    }
                }
            }
            if (layerDefStrList.length > 0) {
                newParams['LAYERDEFS'] = layerDefStrList.join("");
            }
        }
        var requestString = this.getFullRequestString(newParams);
        return requestString;
    },
    
    /**
     * Method: setLayerFilter
     * addTile creates a tile, initializes it, and adds it to the layer div. 
     *
     * Parameters:
     * id - {String} The id of the layer to which the filter applies.
     * queryDef - {String} A sql-ish query filter, for more detail see the ESRI
     *                     documentation at http://sampleserver1.arcgisonline.com/ArcGIS/SDK/REST/export.html
     */
    setLayerFilter: function ( id, queryDef ) {
        if (!this.layerDefs) {
            this.layerDefs = {};
        }
        if (queryDef) {
            this.layerDefs[id] = queryDef;
        } else {
            delete this.layerDefs[id];
        }
    },
    
    /**
     * Method: clearLayerFilter
     * Clears layer filters, either from a specific layer,
     * or all of them.
     *
     * Parameters:
     * id - {String} The id of the layer from which to remove any
     *               filter.  If unspecified/blank, all filters
     *               will be removed.
     */
    clearLayerFilter: function ( id ) {
        if (id) {
            delete this.layerDefs[id];
        } else {
            delete this.layerDefs;
        }
    },
    
    /**
     * APIMethod: mergeNewParams
     * 在调用父类的可变参数以前将可变参数与大写的新参数合并。一旦参数变化，瓦片将会使用新的参数重新加载。
     * 
     * Parameters:
     * newParams - {Object}键值对参数，参数是本类的成员属性
     */
    mergeNewParams:function(newParams) {
        var upperParams = OpenLayers.Util.upperCaseObject(newParams);
        var newArguments = [upperParams];
        return OpenLayers.Layer.Grid.prototype.mergeNewParams.apply(this, 
                                                             newArguments);
    },

    CLASS_NAME: "Geo.View2D.Layer.DynamicMapService"
});/**
 * Class: Geo.View2D.Layer.TileMapService
 *	 地图瓦片图层。地图瓦片图层请求的是地图瓦片服务，该服务请求的瓦片是服务端已经缓存好的瓦片，而不是实时渲染生成的。  
 *   本图层支持的服务类型包括：OGC_Geo_MapService_Rest、Arcgis_MapService_Rest。
 */
Geo.View2D.Layer.TileMapService = Geo.Class(Geo.View2D.Layer.XYZ, {  

    /**
     * APIProperty: url
     * {String} 地图瓦片服务地址。
     */
    url: null,
    
   /**
    * APIProperty: tileOrigin
    * {<Geo.LonLat>} 瓦片原点
    */
    tileOrigin: null, 
   
   /**
    * APIProperty: tileSize
    * {<Geo.Size>} 每个瓦片的大小，默认宽高是256像素
    */
    tileSize: new Geo.Size(256, 256),
    
   /**
    * APIProperty: useArcGISServer
    * {Boolean} 是否按照tile/z/y/x格式去请求瓦片。
    * 如果为true,请求格式为tile/z/y/x；如果为false,请求格式为tile/z/y/x.type；其中type为瓦片类型，其默认值为png
	*	
    */    
    useArcGISServer: true,

   /**
    * APIProperty: type
    * {String}请求瓦片的格式
    */
    type: 'png',
    
   /**
    * Constructor: Geo.View2D.Layer.TileMapService
    * 创建一个地图瓦片图层
    * 
    * Parameters: 
    * name - {String} 图层名
    * url - {String} 地图瓦片服务地址
    * options - {Object} 键值对对象。可以设置本类及其父类的属性。
    * 
    * (code)
    * 	//墨卡托投影下创建地图服务瓦片图层
	* 	var tileLayer = new Geo.View2D.Layer.TileMapService( "TileMapService",
    *     	"http://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer", {
    *       isBaseLayer: true,                    
    *       tileSize: new Geo.Size(256, 256),                        
    *       tileOrigin: new Geo.LonLat(-20037508.342787 , 20037508.342787),                        
    *       maxExtent: new Geo.Bounds(-20037507.067162,-19971868.880409,20037507.067162,19971868.880409)
    *  });
    * (end)
    * 	
    */ 
    initialize: function(name, url, options) { 
        Geo.View2D.Layer.XYZ.prototype.initialize.apply(this, arguments);

        if (this.resolutions) {        
            this.serverResolutions = this.resolutions;
       //     this.maxExtent = this.getMaxExtentForResolution(this.resolutions[0]);
        }

        // this block steps through translating the values from the server layer JSON 
        // capabilities object into values that we can use.  This is also a helpful
        // reference when configuring this layer directly.
        if (this.layerInfo) {
            // alias the object
            var info = this.layerInfo;
            
            // build our extents
            var startingTileExtent = new Geo.Bounds(
                info.fullExtent.xmin, 
                info.fullExtent.ymin, 
                info.fullExtent.xmax, 
                info.fullExtent.ymax  
            );

            // set our projection based on the given spatial reference.
            // esri uses slightly different IDs, so this may not be comprehensive
            this.projection = 'EPSG:' + info.spatialReference.wkid;
            this.sphericalMercator = (info.spatialReference.wkid == 102100);
            
            // convert esri units into openlayers units (basic feet or meters only)
            this.units = (info.units == "esriFeet") ? 'ft' : 'm';

            // optional extended section based on whether or not the server returned
            // specific tile information
            if (!!info.tileInfo) {            
                // either set the tiles based on rows/columns, or specific width/height
                this.tileSize = new Geo.Size(
                    info.tileInfo.width || info.tileInfo.cols, 
                    info.tileInfo.height || info.tileInfo.rows
                );
                
                // this must be set when manually configuring this layer
                this.tileOrigin = new Geo.LonLat(
                    info.tileInfo.origin.x, 
                    info.tileInfo.origin.y
                );

                var upperLeft = new Geo.Geometry.Point(
                    startingTileExtent.left, 
                    startingTileExtent.top
                );
                
                var bottomRight = new Geo.Geometry.Point(
                    startingTileExtent.right, 
                    startingTileExtent.bottom
                );            
                
                if (this.useScales) {
                    this.scales = [];
                } else {
                    this.resolutions = [];
                }
                
                this.lods = [];
                for(var key in info.tileInfo.lods) {
                    if (info.tileInfo.lods.hasOwnProperty(key)) {
                        var lod = info.tileInfo.lods[key];
                        if (this.useScales) {
                            this.scales.push(lod.scale);
                        } else {
                            this.resolutions.push(lod.resolution);
                        }
                    
                        var start = this.getContainingTileCoords(upperLeft, lod.resolution);
                        lod.startTileCol = start.x;
                        lod.startTileRow = start.y;
                    
                        var end = this.getContainingTileCoords(bottomRight, lod.resolution);
                        lod.endTileCol = end.x;
                        lod.endTileRow = end.y;    
                        this.lods.push(lod);
                    }
                }

                this.maxExtent = this.calculateMaxExtentWithLOD(this.lods[0]);
                this.serverResolutions = this.resolutions;
                if (this.overrideDPI && info.tileInfo.dpi) {
                    // see comment above for 'overrideDPI'
                    OpenLayers.DOTS_PER_INCH = info.tileInfo.dpi;
                }
            } 
       }
    }, 

   /** 
    * Method: getContainingTileCoords
    * Calculates the x/y pixel corresponding to the position of the tile
    *     that contains the given point and for the for the given resolution.
    * 
    * Parameters:
    * point - {<Geo.Geometry.Point>} 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<Geo.Pixel>} The x/y pixel corresponding to the position 
    * of the upper left tile for the given resolution.
    */
    getContainingTileCoords: function(point, res) {
        return new Geo.Pixel(
           Math.max(Math.floor((point.x - this.tileOrigin.lon) / (this.tileSize.w * res)),0),
           Math.max(Math.floor((this.tileOrigin.lat - point.y) / (this.tileSize.h * res)),0)
        );
    },
    
   /** 
    * Method: calculateMaxExtentWithLOD
    * Given a Level of Detail object from the server, this function
    *     calculates the actual max extent
    * 
    * Parameters: 
    * lod - {Object} a Level of Detail Object from the server capabilities object 
            representing a particular zoom level
    * 
    * Returns: 
    * {<Geo.Bounds>} The actual extent of the tiles for the given zoom level
    */
   calculateMaxExtentWithLOD: function(lod) {
        // the max extent we're provided with just overlaps some tiles
        // our real extent is the bounds of all the tiles we touch

        var numTileCols = (lod.endTileCol - lod.startTileCol) + 1;
        var numTileRows = (lod.endTileRow - lod.startTileRow) + 1;        

        var minX = this.tileOrigin.lon + (lod.startTileCol * this.tileSize.w * lod.resolution);
        var maxX = minX + (numTileCols * this.tileSize.w * lod.resolution);

        var maxY = this.tileOrigin.lat - (lod.startTileRow * this.tileSize.h * lod.resolution);
        var minY = maxY - (numTileRows * this.tileSize.h * lod.resolution);
        return new Geo.Bounds(minX, minY, maxX, maxY);
   },
    
   /** 
    * Method: calculateMaxExtentWithExtent
    * Given a 'suggested' max extent from the server, this function uses
    *     information about the actual tile sizes to determine the actual
    *     extent of the layer.
    * 
    * Parameters: 
    * extent - {<Geo.Bounds>} The 'suggested' extent for the layer
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<Geo.Bounds>} The actual extent of the tiles for the given zoom level
    */
   calculateMaxExtentWithExtent: function(extent, res) {
        var upperLeft = new Geo.Geometry.Point(extent.left, extent.top);
        var bottomRight = new Geo.Geometry.Point(extent.right, extent.bottom);
        var start = this.getContainingTileCoords(upperLeft, res);
        var end = this.getContainingTileCoords(bottomRight, res);
        var lod = {
            resolution: res,
            startTileCol: start.x,
            startTileRow: start.y,
            endTileCol: end.x,
            endTileRow: end.y
        };
        return this.calculateMaxExtentWithLOD(lod);
   },
    
    /** 
    * Method: getUpperLeftTileCoord
    * Calculates the x/y pixel corresponding to the position 
    *     of the upper left tile for the given resolution.
    * 
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<Geo.Pixel>} The x/y pixel corresponding to the position 
    * of the upper left tile for the given resolution.
    */
    getUpperLeftTileCoord: function(res) {
        var upperLeft = new Geo.Geometry.Point(
            this.maxExtent.left,
            this.maxExtent.top);
        return this.getContainingTileCoords(upperLeft, res);
    },

    /** 
    * Method: getLowerRightTileCoord
    * Calculates the x/y pixel corresponding to the position 
    *     of the lower right tile for the given resolution.
    *  
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<Geo.Pixel>} The x/y pixel corresponding to the position
    * of the lower right tile for the given resolution.
    */
    getLowerRightTileCoord: function(res) {
        var bottomRight = new Geo.Geometry.Point(
            this.maxExtent.right,
            this.maxExtent.bottom);
        return this.getContainingTileCoords(bottomRight, res);
    },
    
   /** 
    * Method: getMaxExtentForResolution
    * Since the max extent of a set of tiles can change from zoom level
    *     to zoom level, we need to be able to calculate that max extent 
    *     for a given resolution.
    * 在进行级别切换的时候瓦片的最大范围会发生变化，所以我们需要计算给定分辨率的最大范围。
    * Parameters: 
    * res - {Float} The resolution for which to compute the extent.
    * 
    * Returns: 
    * {<Geo.Bounds>} The extent for this resolution
    */ 
    getMaxExtentForResolution: function(res) {
        var start = this.getUpperLeftTileCoord(res);
        var end = this.getLowerRightTileCoord(res);

        var numTileCols = (end.x - start.x) + 1;
        var numTileRows = (end.y - start.y) + 1;

        var minX = this.tileOrigin.lon + (start.x * this.tileSize.w * res);
        var maxX = minX + (numTileCols * this.tileSize.w * res);
        
        var maxY = this.tileOrigin.lat - (start.y * this.tileSize.h * res);
        var minY = maxY - (numTileRows * this.tileSize.h * res);
        return new Geo.Bounds(minX, minY, maxX, maxY);
    },
    
   /** 
    * APIMethod: clone 
    * 克隆图层
    * 
    * Parameters: 
    * [obj] - {Object} 传入本对象的一个实例.
    *  
    * Returns: 
    * {<Geo.View2D.Layer.ArcGISCache>} 返回克隆对象 
    */ 
    clone: function (obj) { 
        if (obj == null) { 
            obj = new Geo.View2D.Layer.TileMapService(this.name, this.url, this.options);
        }
        return Geo.View2D.Layer.XYZ.prototype.clone.apply(this, [obj]);
    },

   /**
    * Method: getURL
    * Determine the URL for a tile given the tile bounds.  This is should support
    *     urls that access tiles through an ArcGIS Server MapServer or directly through
    *     the hex folder structure using HTTP.  Just be sure to set the useArcGISServer
    *     property appropriately!  This is basically the same as 
    *     'OpenLayers.Layer.TMS.getURL',  but with the addition of hex addressing,
    *     and tile rounding.
    *	
    * Parameters:
    * bounds - {<Geo.Bounds>}
    *
    * Returns:
    * {String} The URL for a tile based on given bounds.
    */
	getURL: function (bounds) {
		bounds = this.adjustBounds(bounds);
        var res = this.map.getResolution();
        var x = Math.round((bounds.left - this.tileOrigin.lon) /
            (res * this.tileSize.w));
        var y = Math.round((this.tileOrigin.lat - bounds.top) /
            (res * this.tileSize.h));
        var z = 
            this.map.getZoom() + this.zoomOffset;

        var limit = Math.pow(2, z);
        if (this.wrapDateLine)
        {
           x = ((x % limit) + limit) % limit;
        }

   //     return {'x': x, 'y': y, 'z': z};
   		var url = this.url;
		var location = url.indexOf("/",url.length - 1);
		if(location != -1) {
			url = url + 'tile/${z}/${y}/${x}';
		}else {
			url = url + '/tile/${z}/${y}/${x}';
		}
//		url = url + '/tile/${z}/${y}/${x}';
        // Write the values into our formatted url
        url = OpenLayers.String.format(url, {'x': x, 'y': y, 'z': z});

        return url;
    }, 

    /**
     * Method: zeroPad
     * Create a zero padded string optionally with a radix for casting numbers.
     *
     * Parameters:
     * num - {Number} The number to be zero padded.
     * len - {Number} The length of the string to be returned.
     * radix - {Number} An integer between 2 and 36 specifying the base to use
     *     for representing numeric values.
     */
    zeroPad: function(num, len, radix) {
        var str = num.toString(radix || 10);
        while (str.length < len) {
            str = "0" + str;
        }
        return str;
    },

    CLASS_NAME: 'Geo.View2D.Layer.TileMapService' 
}); /**
 * Class: Geo.View2D.Layer.GeoMarkers
 * 吉奥标记图层构造类，本类的实例用来在吉奥标记图层上显示地图上的吉奥标注。
 * 
 * Inherits from:
 *  - <Geo.View2D.Layer.Markers> 
 */
Geo.View2D.Layer.GeoMarkers = Geo.Class(Geo.View2D.Layer.Markers, {

    /** 
     * Method: drawMarker
     * Calculate the pixel location for the marker, create it, and 
     *    add it to the layer's div
     *
     * Parameters:
     * marker - {<OpenLayers.Marker>} 
     */
    drawMarker: function(marker) {
        var px = this.map.getLayerPxFromLonLat(marker.lonlat);
        if (px == null) {
            marker.display(false);
        } else {
            if (!marker.isDrawn()) {
                var markerImg = marker.draw(px);
                this.div.appendChild(markerImg);
            } else if(marker.icon) {
                marker.icon.moveTo(px);
            }
			// 新增标签div绘制
			if (!marker.isDrawnTag()) {
                var div = marker.drawTag(px);
				if(div){
					this.div.appendChild(div);
				}
            } else if(marker.tag) {
                marker.tag.moveTo(px);
            }
        }
    },
    
    CLASS_NAME: "Geo.View2D.Layer.GeoMarkers"
});
/**
 * Class: Geo.View2D.ChartContainer
 * 专题图图表容器类。
 */
Geo.View2D.ChartContainer = Geo.Class({

    /** 
     * Property: events  
     * {<OpenLayers.Events>} custom event manager 
     */
    events: null,
    
    /** Property: id
     * {String} the unique identifier assigned to this popup.
     */
    id: "",

    /** 
     * Property: lonlat 
     * {<OpenLayers.LonLat>} the position of this popup on the map
     */
    lonlat: null,

    /** 
     * Property: div 
     * {DOMElement} the div that contains this popup.
     */
    div: null,

    /** 
     * Property: contentSize 
     * {<OpenLayers.Size>} the width and height of the content.
     */
    contentSize: null,    

    /** 
     * Property: size 
     * {<OpenLayers.Size>} the width and height of the popup.
     */
    size: null,    

    /** 
     * Property: contentHTML 
     * {String} An HTML string for this popup to display.
     */
    contentHTML: null,
    
    /** 
     * Property: backgroundColor 
     * {String} the background color used by the popup.
     */
    backgroundColor: "",
    
    /** 
     * Property: opacity 
     * {float} the opacity of this popup (between 0.0 and 1.0)
     */
    opacity: "",

    /** 
     * Property: border 
     * {String} the border size of the popup.  (eg 2px)
     */
    border: "",
    
    /** 
     * Property: contentDiv 
     * {DOMElement} a reference to the element that holds the content of
     *              the div.
     */
    contentDiv: null,
    
    /** 
     * Property: groupDiv 
     * {DOMElement} First and only child of 'div'. The group Div contains the
     *     'contentDiv' and the 'closeDiv'.
     */
    groupDiv: null,

    /** 
     * Property: closeDiv
     * {DOMElement} the optional closer image
     */
    closeDiv: null,

    /** 
     * APIProperty: autoSize
     * {Boolean} 根据内容自动调整浮云的大小，默认为false。
     */
    autoSize: false,

    /**
     * APIProperty: minSize
     * {<Geo.Size>}允许窗口显示的最小尺寸。
     */
    minSize: null,

    /**
     * APIProperty: maxSize
     * {<Geo.Size>}允许窗口显示的最大尺寸。
     */
    maxSize: null,

    /** 
     * Property: displayClass
     * {String} The CSS class of the popup.
     */
    displayClass: "olPopup",

    /** 
     * Property: contentDisplayClass
     * {String} The CSS class of the popup content div.
     */
    contentDisplayClass: "olPopupContent",

    /** 
     * Property: padding 
     * {int or <OpenLayers.Bounds>} An extra opportunity to specify internal 
     *     padding of the content div inside the popup. This was originally
     *     confused with the css padding as specified in style.css's 
     *     'olPopupContent' class. We would like to get rid of this altogether,
     *     except that it does come in handy for the framed and anchoredbubble
     *     popups, who need to maintain yet another barrier between their 
     *     content and the outer border of the popup itself. 
     * 
     *     Note that in order to not break API, we must continue to support 
     *     this property being set as an integer. Really, though, we'd like to 
     *     have this specified as a Bounds object so that user can specify
     *     distinct left, top, right, bottom paddings. With the 3.0 release
     *     we can make this only a bounds.
     */
    padding: 0,

    /** 
     * Property: disableFirefoxOverflowHack
     * {Boolean} The hack for overflow in Firefox causes all elements 
     *     to be re-drawn, which causes Flash elements to be 
     *     re-initialized, which is troublesome.
     *     With this property the hack can be disabled.
     */
    disableFirefoxOverflowHack: false,

    /**
     * Method: fixPadding
     * To be removed in 3.0, this function merely helps us to deal with the 
     *     case where the user may have set an integer value for padding, 
     *     instead of an <OpenLayers.Bounds> object.
     */
    fixPadding: function() {
        if (typeof this.padding == "number") {
            this.padding = new OpenLayers.Bounds(
                this.padding, this.padding, this.padding, this.padding
            );
        }
    },

    /**
     * APIProperty: panMapIfOutOfView
     *  {Boolean} 当绘制和地图的上下左右移动时，整个弹出框在当前视口是可见的。默认为false。
     */
    panMapIfOutOfView: false,
    
    /**
     * APIProperty: keepInMap 
     * {Boolean} 将该容器保存在地图对象里，默认为false。
     */
    keepInMap: false,

    /**
     * APIProperty: closeOnMove
     * {Boolean} 当地图平移时，关闭该容器。默认为false。
     */
    closeOnMove: false,

    /**
     * APIProperty: offset
     * {<Geo.Pixel>} 像素对象，表示图表容器的偏移量。
     */
    offset: null,
    
    /** 
     * Property: map 
     * {<OpenLayers.Map>} this gets set in Map.js when the popup is added to the map
     */
    map: null,

    /** 
    * Constructor: Geo.View2D.ChartContainer
    * 创建一个专题图图表容器。
    * 
    * Parameters: 
    * id - {String}  该容器的唯一标识，如果没有设置将会自动生成一个。
    * lonlat - {<Geo.LonLat>}  容器显示的地理位置。
    * contentSize - {<Geo.Size>} 容器的尺寸。
    * contentHTML - {String}  容器内容。
    * closeBox - {Boolean}   是否显示关闭该容器。
    * closeBoxCallback - {Function}   点击关闭该容器时的回调方法。
    */
    initialize:function(id, lonlat, contentSize, contentHTML, closeBox, closeBoxCallback) {
        if (id == null) {
            id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        }

        this.id = id;
        this.lonlat = lonlat;

        this.contentSize = (contentSize != null) ? contentSize 
                                  : new OpenLayers.Size(
                                                   Geo.View2D.ChartContainer.WIDTH,
                                                   Geo.View2D.ChartContainer.HEIGHT);
        if (contentHTML != null) { 
             this.contentHTML = contentHTML;
        }
        this.backgroundColor = Geo.View2D.ChartContainer.COLOR;
        this.opacity = Geo.View2D.ChartContainer.OPACITY;
        this.border = Geo.View2D.ChartContainer.BORDER;

        this.div = OpenLayers.Util.createDiv(this.id, null, null, 
                                             null, null, null, "hidden");
        this.div.className = this.displayClass;
        
        var groupDivId = this.id + "_GroupDiv";
        this.groupDiv = OpenLayers.Util.createDiv(groupDivId, null, null, 
                                                    null, "relative", null,
                                                    "hidden");

        var id = this.div.id + "_contentDiv";
        this.contentDiv = OpenLayers.Util.createDiv(id, null, this.contentSize.clone(), 
                                                    null, "relative");
        this.contentDiv.className = this.contentDisplayClass;
        this.groupDiv.appendChild(this.contentDiv);
        this.div.appendChild(this.groupDiv);

        if (closeBox) {
            this.addCloseBox(closeBoxCallback);
        } 

        this.registerEvents();
    },

    /** 
     * Method: destroy
     * nullify references to prevent circular references and memory leaks
     */
    destroy: function() {

        this.id = null;
        this.lonlat = null;
        this.size = null;
        this.contentHTML = null;
        
        this.backgroundColor = null;
        this.opacity = null;
        this.border = null;
        
        if (this.closeOnMove && this.map) {
            this.map.events.unregister("movestart", this, this.hide);
        }

        this.events.destroy();
        this.events = null;
        
        if (this.closeDiv) {
            OpenLayers.Event.stopObservingElement(this.closeDiv); 
            this.groupDiv.removeChild(this.closeDiv);
        }
        this.closeDiv = null;
        
        this.div.removeChild(this.groupDiv);
        this.groupDiv = null;

        if (this.map != null) {
            this.map.removePopup(this);
        }
        this.map = null;
        this.div = null;
        
        this.autoSize = null;
        this.minSize = null;
        this.maxSize = null;
        this.padding = null;
        this.panMapIfOutOfView = null;
    },

    /** 
    * Method: draw
    * Constructs the elements that make up the popup.
    *
    * Parameters:
    * px - {<OpenLayers.Pixel>} the position the popup in pixels.
    * 
    * Returns:
    * {DOMElement} Reference to a div that contains the drawn popup
    */
    draw: function(px) {
        if (px == null) {
            if ((this.lonlat != null) && (this.map != null)) {
                px = this.map.getLayerPxFromLonLat(this.lonlat);
            }
        }

        // this assumes that this.map already exists, which is okay because 
        // this.draw is only called once the popup has been added to the map.
        if (this.closeOnMove) {
            this.map.events.register("movestart", this, this.hide);
        }
        
        //listen to movestart, moveend to disable overflow (FF bug)
        if (!this.disableFirefoxOverflowHack && OpenLayers.BROWSER_NAME == 'firefox') {
            this.map.events.register("movestart", this, function() {
                var style = document.defaultView.getComputedStyle(
                    this.contentDiv, null
                );
                var currentOverflow = style.getPropertyValue("overflow");
                if (currentOverflow != "hidden") {
                    this.contentDiv._oldOverflow = currentOverflow;
                    this.contentDiv.style.overflow = "hidden";
                }
            });
            this.map.events.register("moveend", this, function() {
                var oldOverflow = this.contentDiv._oldOverflow;
                if (oldOverflow) {
                    this.contentDiv.style.overflow = oldOverflow;
                    this.contentDiv._oldOverflow = null;
                }
            });
        }

        this.moveTo(px);
        if (!this.autoSize && !this.size) {
            this.setSize(this.contentSize);
        }
        this.setBackgroundColor();
        this.setOpacity();
        this.setBorder();
        this.setContentHTML();
        
        if (this.panMapIfOutOfView) {
            this.panIntoView();
        }    

        return this.div;
    },

    /** 
     * Method: updatePosition
     * if the popup has a lonlat and its map members set, 
     * then have it move itself to its proper position
     */
    updatePosition: function() {
        if ((this.lonlat) && (this.map)) {
            var px = this.map.getLayerPxFromLonLat(this.lonlat);
            if (px) {
                this.moveTo(px);           
            }    
        }
    },

    /**
     * Method: moveTo
     * 
     * Parameters:
     * px - {<OpenLayers.Pixel>} the top and left position of the popup div. 
     */
    moveTo: function(px) {
        if ((px != null) && (this.div != null)) {
			var px = px.offset(this.offset);
            this.div.style.left = px.x + "px";
            this.div.style.top = px.y + "px";
        }
    },

    /**
     * Method: visible
     *
     * Returns:      
     * {Boolean} Boolean indicating whether or not the popup is visible
     */
    visible: function() {
        return OpenLayers.Element.visible(this.div);
    },

    /**
     * Method: toggle
     * Toggles visibility of the popup.
     */
    toggle: function() {
        if (this.visible()) {
            this.hide();
        } else {
            this.show();
        }
    },

    /**
     * Method: show
     * Makes the popup visible.
     */
    show: function() {
        this.div.style.display = '';

        if (this.panMapIfOutOfView) {
            this.panIntoView();
        }    
    },

    /**
     * Method: hide
     * Makes the popup invisible.
     */
    hide: function() {
        this.div.style.display = 'none';
    },

    /**
     * Method: setSize
     * Used to adjust the size of the popup. 
     *
     * Parameters:
     * contentSize - {<OpenLayers.Size>} the new size for the popup's 
     *     contents div (in pixels).
     */
    setSize:function(contentSize) { 
        this.size = contentSize.clone(); 
        
        // if our contentDiv has a css 'padding' set on it by a stylesheet, we 
        //  must add that to the desired "size". 
        var contentDivPadding = this.getContentDivPadding();
        var wPadding = contentDivPadding.left + contentDivPadding.right;
        var hPadding = contentDivPadding.top + contentDivPadding.bottom;

        // take into account the popup's 'padding' property
        this.fixPadding();
        wPadding += this.padding.left + this.padding.right;
        hPadding += this.padding.top + this.padding.bottom;

        // make extra space for the close div
        if (this.closeDiv) {
            var closeDivWidth = parseInt(this.closeDiv.style.width);
            wPadding += closeDivWidth + contentDivPadding.right;
        }

        //increase size of the main popup div to take into account the 
        // users's desired padding and close div.        
        this.size.w += wPadding;
        this.size.h += hPadding;

        //now if our browser is IE, we need to actually make the contents 
        // div itself bigger to take its own padding into effect. this makes 
        // me want to shoot someone, but so it goes.
        if (OpenLayers.BROWSER_NAME == "msie") {
            this.contentSize.w += 
                contentDivPadding.left + contentDivPadding.right;
            this.contentSize.h += 
                contentDivPadding.bottom + contentDivPadding.top;
        }

        if (this.div != null) {
            this.div.style.width = this.size.w + "px";
            this.div.style.height = this.size.h + "px";
        }
        if (this.contentDiv != null){
            this.contentDiv.style.width = contentSize.w + "px";
            this.contentDiv.style.height = contentSize.h + "px";
        }
    },  

    /**
     * APIMethod: updateSize
     * 更新尺寸大小。
     */
    updateSize: function() {
        
        // determine actual render dimensions of the contents by putting its
        // contents into a fake contentDiv (for the CSS) and then measuring it
        var preparedHTML = "<div class='" + this.contentDisplayClass+ "'>" + 
            this.contentDiv.innerHTML + 
            "</div>";
 
        var containerElement = (this.map) ? this.map.layerContainerDiv
        								  : document.body;
        var realSize = OpenLayers.Util.getRenderedDimensions(
            preparedHTML, null,	{
                displayClass: this.displayClass,
                containerElement: containerElement
            }
        );

        // is the "real" size of the div is safe to display in our map?
        var safeSize = this.getSafeContentSize(realSize);

        var newSize = null;
        if (safeSize.equals(realSize)) {
            //real size of content is small enough to fit on the map, 
            // so we use real size.
            newSize = realSize;

        } else {

            //make a new OL.Size object with the clipped dimensions 
            // set or null if not clipped.
            var fixedSize = new OpenLayers.Size();
            fixedSize.w = (safeSize.w < realSize.w) ? safeSize.w : null;
            fixedSize.h = (safeSize.h < realSize.h) ? safeSize.h : null;
        
            if (fixedSize.w && fixedSize.h) {
                //content is too big in both directions, so we will use 
                // max popup size (safeSize), knowing well that it will 
                // overflow both ways.                
                newSize = safeSize;
            } else {
                //content is clipped in only one direction, so we need to 
                // run getRenderedDimensions() again with a fixed dimension
                var clippedSize = OpenLayers.Util.getRenderedDimensions(
                    preparedHTML, fixedSize, {
                        displayClass: this.contentDisplayClass,
                        containerElement: containerElement
                    }
                );
                
                //if the clipped size is still the same as the safeSize, 
                // that means that our content must be fixed in the 
                // offending direction. If overflow is 'auto', this means 
                // we are going to have a scrollbar for sure, so we must 
                // adjust for that.
                //
                var currentOverflow = OpenLayers.Element.getStyle(
                    this.contentDiv, "overflow"
                );
                if ( (currentOverflow != "hidden") && 
                     (clippedSize.equals(safeSize)) ) {
                    var scrollBar = OpenLayers.Util.getScrollbarWidth();
                    if (fixedSize.w) {
                        clippedSize.h += scrollBar;
                    } else {
                        clippedSize.w += scrollBar;
                    }
                }
                
                newSize = this.getSafeContentSize(clippedSize);
            }
        }                        
        this.setSize(newSize);     
    },    

    /**
     * Method: setBackgroundColor
     * Sets the background color of the popup.
     *
     * Parameters:
     * color - {String} the background color.  eg "#FFBBBB"
     */
    setBackgroundColor:function(color) { 
        if (color != undefined) {
            this.backgroundColor = color; 
        }
        
        if (this.div != null) {
            this.div.style.backgroundColor = this.backgroundColor;
        }
    },  
    
    /**
     * Method: setOpacity
     * Sets the opacity of the popup.
     * 
     * Parameters:
     * opacity - {float} A value between 0.0 (transparent) and 1.0 (solid).   
     */
    setOpacity:function(opacity) { 
        if (opacity != undefined) {
            this.opacity = opacity; 
        }
        
        if (this.div != null) {
            // for Mozilla and Safari
            this.div.style.opacity = this.opacity;

            // for IE
            //this.div.style.filter = 'alpha(opacity=' + this.opacity*100 + ')';
        }
    },  
    
    /**
     * Method: setBorder
     * Sets the border style of the popup.
     *
     * Parameters:
     * border - {String} The border style value. eg 2px 
     */
    setBorder:function(border) { 
        if (border != undefined) {
            this.border = border;
        }
        
        if (this.div != null) {
            this.div.style.border = this.border;
        }
    },      
    
    /**
     * Method: setContentHTML
     * Allows the user to set the HTML content of the popup.
     *
     * Parameters:
     * contentHTML - {String} HTML for the div.
     */
    setContentHTML:function(contentHTML) {

        if (contentHTML != null) {
            this.contentHTML = contentHTML;
        }
       
        if ((this.contentDiv != null) && 
            (this.contentHTML != null) &&
            (this.contentHTML != this.contentDiv.innerHTML)) {
       
            this.contentDiv.innerHTML = this.contentHTML;
       
            if (this.autoSize) {
                
                //if popup has images, listen for when they finish
                // loading and resize accordingly
                this.registerImageListeners();

                //auto size the popup to its current contents
                this.updateSize();
            }
        }    

    },
    
    /**
     * Method: registerImageListeners
     * Called when an image contained by the popup loaded. this function
     *     updates the popup size, then unregisters the image load listener.
     */   
    registerImageListeners: function() { 

        // As the images load, this function will call updateSize() to 
        // resize the popup to fit the content div (which presumably is now
        // bigger than when the image was not loaded).
        // 
        // If the 'panMapIfOutOfView' property is set, we will pan the newly
        // resized popup back into view.
        // 
        // Note that this function, when called, will have 'popup' and 
        // 'img' properties in the context.
        //
        var onImgLoad = function() {
            
            this.popup.updateSize();
     
            if ( this.popup.visible() && this.popup.panMapIfOutOfView ) {
                this.popup.panIntoView();
            }

            OpenLayers.Event.stopObserving(
                this.img, "load", this.img._onImageLoad
            );
    
        };

        //cycle through the images and if their size is 0x0, that means that 
        // they haven't been loaded yet, so we attach the listener, which 
        // will fire when the images finish loading and will resize the 
        // popup accordingly to its new size.
        var images = this.contentDiv.getElementsByTagName("img");
        for (var i = 0, len = images.length; i < len; i++) {
            var img = images[i];
            if (img.width == 0 || img.height == 0) {

                var context = {
                    'popup': this,
                    'img': img
                };

                //expando this function to the image itself before registering
                // it. This way we can easily and properly unregister it.
                img._onImgLoad = OpenLayers.Function.bind(onImgLoad, context);

                OpenLayers.Event.observe(img, 'load', img._onImgLoad);
            }    
        } 
    },

    /**
     * APIMethod: getSafeContentSize
     * 该容器的尺寸既不小于最小尺寸，也不大于最大尺寸，而是计算相对于视口的合适尺寸大小。
     * 
     * Parameters:
     * size - {<Geo.Size>} 所需区域的大小。
     * 
     * Returns:
     * {<Geo.Size>} 返回合适的尺寸。
     */
    getSafeContentSize: function(size) {

        var safeContentSize = size.clone();

        // if our contentDiv has a css 'padding' set on it by a stylesheet, we 
        //  must add that to the desired "size". 
        var contentDivPadding = this.getContentDivPadding();
        var wPadding = contentDivPadding.left + contentDivPadding.right;
        var hPadding = contentDivPadding.top + contentDivPadding.bottom;

        // take into account the popup's 'padding' property
        this.fixPadding();
        wPadding += this.padding.left + this.padding.right;
        hPadding += this.padding.top + this.padding.bottom;

        if (this.closeDiv) {
            var closeDivWidth = parseInt(this.closeDiv.style.width);
            wPadding += closeDivWidth + contentDivPadding.right;
        }

        // prevent the popup from being smaller than a specified minimal size
        if (this.minSize) {
            safeContentSize.w = Math.max(safeContentSize.w, 
                (this.minSize.w - wPadding));
            safeContentSize.h = Math.max(safeContentSize.h, 
                (this.minSize.h - hPadding));
        }

        // prevent the popup from being bigger than a specified maximum size
        if (this.maxSize) {
            safeContentSize.w = Math.min(safeContentSize.w, 
                (this.maxSize.w - wPadding));
            safeContentSize.h = Math.min(safeContentSize.h, 
                (this.maxSize.h - hPadding));
        }
        
        //make sure the desired size to set doesn't result in a popup that 
        // is bigger than the map's viewport.
        //
        if (this.map && this.map.size) {
            
            var extraX = 0, extraY = 0;
            if (this.keepInMap && !this.panMapIfOutOfView) {
                var px = this.map.getPixelFromLonLat(this.lonlat);
                switch (this.relativePosition) {
                    case "tr":
                        extraX = px.x;
                        extraY = this.map.size.h - px.y;
                        break;
                    case "tl":
                        extraX = this.map.size.w - px.x;
                        extraY = this.map.size.h - px.y;
                        break;
                    case "bl":
                        extraX = this.map.size.w - px.x;
                        extraY = px.y;
                        break;
                    case "br":
                        extraX = px.x;
                        extraY = px.y;
                        break;
                    default:    
                        extraX = px.x;
                        extraY = this.map.size.h - px.y;
                        break;
                }
            }    
          
            var maxY = this.map.size.h - 
                this.map.paddingForPopups.top - 
                this.map.paddingForPopups.bottom - 
                hPadding - extraY;
            
            var maxX = this.map.size.w - 
                this.map.paddingForPopups.left - 
                this.map.paddingForPopups.right - 
                wPadding - extraX;
            
            safeContentSize.w = Math.min(safeContentSize.w, maxX);
            safeContentSize.h = Math.min(safeContentSize.h, maxY);
        }
        
        return safeContentSize;
    },
    
    /**
     * Method: getContentDivPadding
     * Glorious, oh glorious hack in order to determine the css 'padding' of 
     *     the contentDiv. IE/Opera return null here unless we actually add the 
     *     popup's main 'div' element (which contains contentDiv) to the DOM. 
     *     So we make it invisible and then add it to the document temporarily. 
     *
     *     Once we've taken the padding readings we need, we then remove it 
     *     from the DOM (it will actually get added to the DOM in 
     *     Map.js's addPopup)
     *
     * Returns:
     * {<OpenLayers.Bounds>}
     */
    getContentDivPadding: function() {

        //use cached value if we have it
        var contentDivPadding = this._contentDivPadding;
        if (!contentDivPadding) {

        	if (this.div.parentNode == null) {
	        	//make the div invisible and add it to the page        
	            this.div.style.display = "none";
	            document.body.appendChild(this.div);
	    	}
	            
            //read the padding settings from css, put them in an OL.Bounds        
            contentDivPadding = new OpenLayers.Bounds(
                OpenLayers.Element.getStyle(this.contentDiv, "padding-left"),
                OpenLayers.Element.getStyle(this.contentDiv, "padding-bottom"),
                OpenLayers.Element.getStyle(this.contentDiv, "padding-right"),
                OpenLayers.Element.getStyle(this.contentDiv, "padding-top")
            );
    
            //cache the value
            this._contentDivPadding = contentDivPadding;

            if (this.div.parentNode == document.body) {
	            //remove the div from the page and make it visible again
	            document.body.removeChild(this.div);
	            this.div.style.display = "";
            }
        }
        return contentDivPadding;
    },

    /**
     * Method: addCloseBox
     * 
     * Parameters:
     * callback - {Function} The callback to be called when the close button
     *     is clicked.
     */
    addCloseBox: function(callback) {

        this.closeDiv = OpenLayers.Util.createDiv(
            this.id + "_close", null, new OpenLayers.Size(17, 17)
        );
        this.closeDiv.className = "olPopupCloseBox"; 
        
        // use the content div's css padding to determine if we should
        //  padd the close div
        var contentDivPadding = this.getContentDivPadding();
         
        this.closeDiv.style.right = contentDivPadding.right + "px";
        this.closeDiv.style.top = contentDivPadding.top + "px";
        this.groupDiv.appendChild(this.closeDiv);

        var closePopup = callback || function(e) {
            this.hide();
            OpenLayers.Event.stop(e);
        };
        OpenLayers.Event.observe(this.closeDiv, "touchend", 
                OpenLayers.Function.bindAsEventListener(closePopup, this));
        OpenLayers.Event.observe(this.closeDiv, "click", 
                OpenLayers.Function.bindAsEventListener(closePopup, this));
    },

    /**
     * Method: panIntoView
     * Pans the map such that the popup is totaly viewable (if necessary)
     */
    panIntoView: function() {
        
        var mapSize = this.map.getSize();
    
        //start with the top left corner of the popup, in px, 
        // relative to the viewport
        var origTL = this.map.getViewPortPxFromLayerPx( new OpenLayers.Pixel(
            parseInt(this.div.style.left),
            parseInt(this.div.style.top)
        ));
        var newTL = origTL.clone();
    
        //new left (compare to margins, using this.size to calculate right)
        if (origTL.x < this.map.paddingForPopups.left) {
            newTL.x = this.map.paddingForPopups.left;
        } else 
        if ( (origTL.x + this.size.w) > (mapSize.w - this.map.paddingForPopups.right)) {
            newTL.x = mapSize.w - this.map.paddingForPopups.right - this.size.w;
        }
        
        //new top (compare to margins, using this.size to calculate bottom)
        if (origTL.y < this.map.paddingForPopups.top) {
            newTL.y = this.map.paddingForPopups.top;
        } else 
        if ( (origTL.y + this.size.h) > (mapSize.h - this.map.paddingForPopups.bottom)) {
            newTL.y = mapSize.h - this.map.paddingForPopups.bottom - this.size.h;
        }
        
        var dx = origTL.x - newTL.x;
        var dy = origTL.y - newTL.y;
        
        this.map.pan(dx, dy);
    },

    /** 
     * Method: registerEvents
     * Registers events on the popup.
     *
     * Do this in a separate function so that subclasses can 
     *   choose to override it if they wish to deal differently
     *   with mouse events
     * 
     *   Note in the following handler functions that some special
     *    care is needed to deal correctly with mousing and popups. 
     *   
     *   Because the user might select the zoom-rectangle option and
     *    then drag it over a popup, we need a safe way to allow the
     *    mousemove and mouseup events to pass through the popup when
     *    they are initiated from outside. The same procedure is needed for
     *    touchmove and touchend events.
     * 
     *   Otherwise, we want to essentially kill the event propagation
     *    for all other events, though we have to do so carefully, 
     *    without disabling basic html functionality, like clicking on 
     *    hyperlinks or drag-selecting text.
     */
     registerEvents:function() {
        this.events = new OpenLayers.Events(this, this.div, null, true);

        function onTouchstart(evt) {
            OpenLayers.Event.stop(evt, true);
        }
        this.events.on({
            "mousedown": this.onmousedown,
            "mousemove": this.onmousemove,
            "mouseup": this.onmouseup,
            "click": this.onclick,
            "mouseout": this.onmouseout,
            "dblclick": this.ondblclick,
            "touchstart": onTouchstart,
            scope: this
        });
        
     },

    /** 
     * Method: onmousedown 
     * When mouse goes down within the popup, make a note of
     *   it locally, and then do not propagate the mousedown 
     *   (but do so safely so that user can select text inside)
     * 
     * Parameters:
     * evt - {Event} 
     */
    onmousedown: function (evt) {
        this.mousedown = true;
        OpenLayers.Event.stop(evt, true);
    },

    /** 
     * Method: onmousemove
     * If the drag was started within the popup, then 
     *   do not propagate the mousemove (but do so safely
     *   so that user can select text inside)
     * 
     * Parameters:
     * evt - {Event} 
     */
    onmousemove: function (evt) {
        if (this.mousedown) {
            OpenLayers.Event.stop(evt, true);
        }
    },

    /** 
     * Method: onmouseup
     * When mouse comes up within the popup, after going down 
     *   in it, reset the flag, and then (once again) do not 
     *   propagate the event, but do so safely so that user can 
     *   select text inside
     * 
     * Parameters:
     * evt - {Event} 
     */
    onmouseup: function (evt) {
        if (this.mousedown) {
            this.mousedown = false;
            OpenLayers.Event.stop(evt, true);
        }
    },

    /**
     * Method: onclick
     * Ignore clicks, but allowing default browser handling
     * 
     * Parameters:
     * evt - {Event} 
     */
    onclick: function (evt) {
        OpenLayers.Event.stop(evt, true);
    },

    /** 
     * Method: onmouseout
     * When mouse goes out of the popup set the flag to false so that
     *   if they let go and then drag back in, we won't be confused.
     * 
     * Parameters:
     * evt - {Event} 
     */
    onmouseout: function (evt) {
        this.mousedown = false;
    },
    
    /** 
     * Method: ondblclick
     * Ignore double-clicks, but allowing default browser handling
     * 
     * Parameters:
     * evt - {Event} 
     */
    ondblclick: function (evt) {
        OpenLayers.Event.stop(evt, true);
    },

    CLASS_NAME: "OpenLayers.Popup"
});

Geo.View2D.ChartContainer.WIDTH = 200;
Geo.View2D.ChartContainer.HEIGHT = 200;
Geo.View2D.ChartContainer.COLOR = "white";
Geo.View2D.ChartContainer.OPACITY = 1;
Geo.View2D.ChartContainer.BORDER = "0px";
/**
 * Class: Geo.View2D.Popup.GeoFrameCloud
 * 带有阴影的浮云框。
 * 
 * Inherits from:
 *  - <Geo.View2D.Popup.FramedCloud>
 */
Geo.View2D.Popup.GeoFrameCloud = Geo.Class(Geo.View2D.Popup.FramedCloud, {
	
	/**
	 * Property: shadowSrc
	 * {String} 阴影图片的地址
	 */
	shadowSrc: null,
	
	/**
	 * APIProperty: isShowShadow
	 * {Boolean} 是否显示阴影，默认为true。
	 */
	isShowShadow: true,
	
	/**
	 * APIProperty: shadowOffset
	 * {Geo.Pixel} 阴影偏移量。
	 */
	shadowOffset: null,
	
	/**
	 * APIProperty: minSize
	 * {<Geo.Size>} 最小宽度等于左下角阴影宽度+尾巴阴影宽度。
	 * 说明：如果使用带阴影的浮云框，最小宽度不得低于120。
	 */
	minSize: new Geo.Size(120, 10),
	
	/**
	 * APIProperty: borderStyle
	 * {Integer} 浮云边框样式。默认为圆角边框样式。
	 * > 浮云框边角为圆角，指向为斜向(Geo.View2D.Popup.GeoFrameCloud.CORNER)，
	 * > 浮云框边角为直角，指向为斜向(Geo.View2D.Popup.GeoFrameCloud.SHARP)，
	 * > 浮云框边角为直角，指向为垂直(Geo.View2D.Popup.GeoFrameCloud.VERTICALDIRECTION)。
	 */
	borderStyle: 1,

	/** 
	 * Constructor: Geo.View2D.Popup.GeoFrameCloud
	 * Geo.View2D.Popup.GeoFrameCloud构造函数。
	 * 
	 * Parameters:
	 * id - {String}  浮云框的唯一标识，如果没有设置将会自动生成一个。
     * lonlat - {<Geo.LonLat>} 地图上浮云显示的位置。
     * contentSize - {<Geo.Size>} 浮云的尺寸。
     * contentHTML - {String} 浮云内容，浮云内容为HTML要素的字符串。
     * anchor - {Object} 锚点。包含一个大小信息{<Geo.Size>}和偏移信息{<Geo.Pixel>}的对象。(一般为{<Geo.View2D.Icon>}类型）。
     * closeBox - {Boolean} 是否显示关闭浮云窗口的按钮。
     * closeBoxCallback - {Function} 关闭浮云触发该回调函数。
	 * shadowOptions - {Object}
	 * >   isShowShadow -  {Boolean} 是否显示阴影,默认为true。
	 * >   shadowOffset - {<Geo.Pixel>} 阴影偏移,默认无偏移。
	 * >   取值举例：shadowOffset的值为new Geo.Pixel(2,3)，表示浮云框阴影向右偏移2个像素，向下偏移3个像素。
	 * borderStyle - {Number} 浮云边框样式。
	 */
	initialize:function(id, lonlat, contentSize, contentHTML, anchor, closeBox, 
						closeBoxCallback, shadowOptions, borderStyle) {
		
		if(shadowOptions && typeof shadowOptions.isShowShadow === "boolean" ) {
			this.isShowShadow = shadowOptions.isShowShadow === false ?  shadowOptions.isShowShadow : true;
		}
		if(shadowOptions && shadowOptions.shadowOffset instanceof OpenLayers.Pixel) {
			this.shadowOffset = shadowOptions.shadowOffset;
		}
		if(typeof shadowOptions.clickShadow === "function") {
			this.clickShadow = shadowOptions.clickShadow;
		}	
		if(typeof shadowOptions.moveoverShadow === "function") {
			this.moveoverShadow = shadowOptions.moveoverShadow;
		}				
		
		this.fixedRelativePosition = true;
		//固定浮云框显示位置为右上角
		this.relativePosition = "tr";
		this.shadowSrc = OpenLayers.Util.getImagesLocation() + "shadow.png";
		
		this.borderStyle = borderStyle ? borderStyle : Geo.View2D.Popup.GeoFrameCloud.CORNER;
		//OpenLayers.Popup.FramedCloud.prototype.initialize.apply(this, arguments);
        switch (this.borderStyle) {
            case Geo.View2D.Popup.GeoFrameCloud.CORNER:
				this.imageSrc = OpenLayers.Util.getImageLocation('cloud-popup-relative.png');
                break;
            case Geo.View2D.Popup.GeoFrameCloud.SHARP:
				this.imageSrc = OpenLayers.Util.getImageLocation('cloud-popup-relative-2.png');
                break;
            case Geo.View2D.Popup.GeoFrameCloud.VERTICALDIRECTION:
				this.imageSrc = OpenLayers.Util.getImageLocation('cloud-popup-relative-3.png');
                break;
        }
		OpenLayers.Popup.Framed.prototype.initialize.apply(this, arguments);
        this.contentDiv.className = this.contentDisplayClass;
		
		//让阴影能够显示出来
		this.div.style.overflow = "visible";
	},
	
	/** 
	 *	Method: createShadow
	 */
	createShadow: function() {
		var imgId = this.id + '_shadomImg_' ;
		//创建一个图片
		
		if ((this.lonlat != null) && (this.map != null)) {
			px = this.map.getLayerPxFromLonLat(this.lonlat);
		}
		
		var divId = this.id + '_shadomDiv_' ;
		this.shadowDiv = OpenLayers.Util.createDiv(divId, 
			null, null, null, "absolute", null, "visible", null
		);
		this.shadowDiv.style.position="absolute";
	   
		this.shadowDiv.style.zIndex = 0;
		this.calculateShadowDivLocation(this.size, this.shadowDiv);
		this.map.layerContainerDiv.appendChild(this.shadowDiv);
		this.shadowevents = new OpenLayers.Events(this, this.shadowDiv, null, true);
		var isClick = false;	
		this.shadowevents.on({
			"click": this.clickShadow,
			//鼠标是否经过阴影区
			"mousemove":this.moveoverShadow,
			scope: this
		});		
		this.map.events.register("zoomend", this,this.calculateShadowLocation);
	},
	
	/**
	 * Method: calculateShadowDivLocation
	 * 计算阴影div的位置。
	 */
	calculateShadowDivLocation: function(size, div) {
		var divId = this.id + '_leftTop_shadowdiv_';
		var divLocation = new OpenLayers.Pixel(0,0);
	
		this.divSize = new OpenLayers.Size();
		this.divSize.h = size.h * 0.5 - 30; //30是尾巴的高度
		this.divSize.w = size.w;// - divSize.h;//浮云框的宽度等于左上角阴影的宽度
		//创建左上角DIV
		var leftTop_shadowdiv = OpenLayers.Util.createDiv(divId,
			divLocation, this.divSize, null, "absolute",null, "hidden", null
		);
		
		var imgId = this.id + '_leftTop_shadomImg_' ;
		
		//左上角阴影left = (0+this.divSize.w);top = 0 TODO:需要限制divSize.h最大高度为330
		var imgleftLocation = 320 - this.divSize.h - 24; //320是浮云框阴影左边斜线组成的正方形的宽度，24是偏移
		var imgLocation = new OpenLayers.Pixel(-(0 + imgleftLocation), 0);
		
		
		var imgSize = new OpenLayers.Size(1062,356);
		
		var image = OpenLayers.Util.createImage(imgId, 
			imgLocation, imgSize, this.shadowSrc,
			"absolute", null, null, null
		);
		leftTop_shadowdiv.appendChild(image);
		div.appendChild(leftTop_shadowdiv);
		
		this.setrightTopshadowdiv(this.divSize,imgSize,div);
		this.setleftBottomShadowDiv(this.divSize,imgSize,div);
		this.setleftBottom23shadowdiv(this.divSize,imgSize,div);
		this.setrightBottomshadowdiv(this.divSize,imgSize,div);
		
	},
	/**
	 * Method: calculateShadowDivLocation
	 * 计算右上角阴影的位置。
	 */						
	setrightTopshadowdiv:function(divSize,imgSize,div) {
		//创建右上角DIV
		var divId = this.id + '_rightTop_shadowdiv_';
		var divrightTopLocation = new OpenLayers.Pixel(divSize.w,0);
		var divrightTopSize = new OpenLayers.Size();
		divrightTopSize.h = divSize.h; //40是尾巴的高度
		divrightTopSize.w = divSize.h + 20+11;//20是多加的长度
		var rightTop_shadowdiv = OpenLayers.Util.createDiv(divId,
			divrightTopLocation, divrightTopSize, null, "absolute",  null, "hidden", null
		);
		//创建右上角img
		var imgrightTopLocation = new OpenLayers.Pixel(-(1062 - divSize.h - 20-24-25), 1);//上面的div宽度多加了20，这里减去20
		var imgId = this.id + '_rightTop_shadomImg_' ;
		var rightTopImage = OpenLayers.Util.createImage(imgId, 
			imgrightTopLocation, imgSize, this.shadowSrc, 
			"absolute", null, null, null
		);
		rightTop_shadowdiv.appendChild(rightTopImage);
		div.appendChild(rightTop_shadowdiv);
		
	},
	/**
	 * Method: calculateShadowLocation
	 * 计算整个阴影的位置。
	 */	
	calculateShadowLocation: function() {
		var divleftBottomSize = this.divleftBottomSize;
		var div = this.shadowDiv;
		var shadowoffsetY = (this.divSize.h + divleftBottomSize.h);
		var px = this.map.getLayerPxFromLonLat(this.lonlat);
		//阴影尾巴的位置
		if(this.shadowOffset instanceof OpenLayers.Pixel) {
		div.style.top= (px.y - shadowoffsetY - 10 + this.shadowOffset.y)  + "px";//
		div.style.left= (px.x - divleftBottomSize.w - 5 + this.shadowOffset.x)+ "px";//
		}else {
			div.style.top= (px.y - shadowoffsetY - 10)  + "px";//
			div.style.left= (px.x - divleftBottomSize.w - 5)+ "px";//
		}
		this.setShadowzIndex(div);
	},
	
	/**
	 * Method: recalculateShadowLocation
	 * 重新计算整个阴影的位置。
	 */		
	recalculateShadowLocation: function(divSize, divleftBottomSize, div) {
		var shadowoffsetY = (this.divSize.h + divleftBottomSize.h);
		var px = this.map.getLayerPxFromLonLat(this.lonlat);
		//阴影尾巴的位置
		if(this.shadowOffset instanceof OpenLayers.Pixel) {
			div.style.top= (px.y - shadowoffsetY - 10 + this.shadowOffset.y)  + "px";//
			div.style.left= (px.x - divleftBottomSize.w - 5 + this.shadowOffset.x)+ "px";//
		}else {
			div.style.top= (px.y - shadowoffsetY - 10)  + "px";//
			div.style.left= (px.x - divleftBottomSize.w - 5)+ "px";//
		}
		
		this.setShadowzIndex(div);
		
	},
	/**
	 * Method: setShadowzIndex
	 * 设置div阴影的的zindex。
	 */	
	setShadowzIndex: function(div) { //设置阴影级别
		div.style.zIndex = this.map.Z_INDEX_BASE['Popup'] +
				this.map.popups.length;
	},
	/**
	 * Method: setrightBottomshadowdiv
	 * 添加右下角div阴影。
	 */
	setrightBottomshadowdiv:function(divSize,imgSize,div) {
		//左下边第三个DIV
		var divId3 = this.id + '_rightBottom_shadowdiv_';
		var divrightBottomLocation = new OpenLayers.Pixel(divSize.w,divSize.h);
		var divrightBottomSize = new OpenLayers.Size();
		divrightBottomSize.h = 40; //27是临时定的值
		//TODO:需要判断divSize.w至少要大于等于(divleftBottom2Size.w + 30)
		divrightBottomSize.w = 45;
		
		var imgrightBottom_shadowdiv = OpenLayers.Util.createDiv(divId3,
			divrightBottomLocation, divrightBottomSize, null, "absolute",  null, "hidden", null
		);
		
		//img
		var imgrightBottomLocation = new OpenLayers.Pixel(-703, -290);
		var imgId3 = this.id + '_rightBottom_shadomImg_' ;
		var imgrightBottomImage = OpenLayers.Util.createImage(imgId3, 
			imgrightBottomLocation, imgSize, this.shadowSrc, 
			"absolute", null, null, null
		);
		imgrightBottom_shadowdiv.appendChild(imgrightBottomImage);
		div.appendChild(imgrightBottom_shadowdiv);
	},
	
	/**
	 * Method: setrightBottomshadowdiv
	 * 添加左下角右边的两个阴影。
	 */
	setleftBottom23shadowdiv:function(divSize,imgSize,div) {
		//左下边第二个DIV
		var divId = this.id + '_leftBottom2_shadowdiv_';
		var divleftBottom2Location = new OpenLayers.Pixel(35,divSize.h);
		var divleftBottom2Size = new OpenLayers.Size();
		divleftBottom2Size.h = 70; //40是尾巴的高度
		divleftBottom2Size.w = 70;
		var imgleftBottom2_shadowdiv = OpenLayers.Util.createDiv(divId,
			divleftBottom2Location, divleftBottom2Size, null, "absolute",  null, "hidden", null
		);
		
		//img
		var imgleftBottom2Location = new OpenLayers.Pixel(-440, -290);
		var imgId = this.id + '_leftBottom2_shadomImg_' ;
		var imgleftBottom2Image = OpenLayers.Util.createImage(imgId, 
			imgleftBottom2Location, imgSize, this.shadowSrc, 
			"absolute", null, null, null
		);
		imgleftBottom2_shadowdiv.appendChild(imgleftBottom2Image);
		div.appendChild(imgleftBottom2_shadowdiv);
		
		//左下边第三个DIV
		var divId3 = this.id + '_leftBottom3_shadowdiv_';
		var divleftBottom3Location = new OpenLayers.Pixel((35 + divleftBottom2Size.w),divSize.h);
		var divleftBottom3Size = new OpenLayers.Size();
		divleftBottom3Size.h = 35; //35是临时定的值
		//TODO:需要判断divSize.w至少要大于等于(divleftBottom2Size.w + 30)
		
		divleftBottom3Size.w = divSize.w - divleftBottom2Size.w - 35;//这个30是divleftBottomSize.w
		var imgleftBottom3_shadowdiv = OpenLayers.Util.createDiv(divId3,
			divleftBottom3Location, divleftBottom3Size, null, "absolute",  null, "hidden", null
		);
		
		//img
		var imgleftBottom3Location = new OpenLayers.Pixel(-60, -290);
		var imgId3 = this.id + '_leftBottom3_shadomImg_' ;
		var imgleftBottom3Image = OpenLayers.Util.createImage(imgId3, 
			imgleftBottom3Location, imgSize, this.shadowSrc, 
			"absolute", null, null, null
		);
		imgleftBottom3_shadowdiv.appendChild(imgleftBottom3Image);
		div.appendChild(imgleftBottom3_shadowdiv);
	},
	
	/**
	 * Method: setrightBottomshadowdiv
	 * 添加左下角阴影。
	 */
	setleftBottomShadowDiv:function(divSize,imgSize, div) {
		//创建左下角DIV
		var divId = this.id + '_leftBottom_shadowdiv_';
		var divleftBottomLocation = new OpenLayers.Pixel(0,divSize.h);
		this.divleftBottomSize = new OpenLayers.Size();
		this.divleftBottomSize.h = 70 - 30; //TODO:70是临时得出来的，没有经过计算
		this.divleftBottomSize.w = 35;//TODO:30是临时得出来的，没有经过计算
		var leftBottom_shadowdiv = OpenLayers.Util.createDiv(divId,
			divleftBottomLocation, this.divleftBottomSize, null, "absolute",  null, "hidden", null
		);
		//创建左下角img
		var imgleftBottomLocation = new OpenLayers.Pixel(-5, -290);//TODO:310是临时得出来的，没有经过计算
		var imgId = this.id + '_leftBottom_shadomImg_' ;
		var leftBottomImage = OpenLayers.Util.createImage(imgId, 
			imgleftBottomLocation, imgSize, this.shadowSrc, 
			"absolute", null, null, null
		);
		leftBottom_shadowdiv.appendChild(leftBottomImage);
		div.appendChild(leftBottom_shadowdiv);
		this.recalculateShadowLocation(divSize, this.divleftBottomSize, div);
	},
	
	/**
	 * Method: setrightBottomshadowdiv
	 * 设置浮云框阴影的大小和位置。
	 */
	setShadowSize: function() {
		var image = this.image;
		var size = this.size;
		//设置阴影框大小
		image.style.width= (size.w + 80) + "px";
		image.style.height= size.h / 2+ "px";
		image.style.left= 0 + "px";
		image.style.bottom= 40 + "px";
	},
	
    /** 
     * Method: draw
     * 
     * Parameters:
     * px - {<Geo.Pixel>}
     * 
     * Returns:
     * {DOMElement} 包含浮云框的div。
     */
    draw: function(px) {
        
        OpenLayers.Popup.Anchored.prototype.draw.apply(this, arguments);
        if(this.isShowShadow) {
			//创建阴影图
			this.createShadow();
		}

        return this.div;
    },
	
	/**
	 * Method: addCloseBox
	 * 
	 * Parameters:
	 * callback - {Function} 点击关闭按钮的时候执行该回调。
	 */
	addCloseBox: function(callback) {

		this.closeDiv = OpenLayers.Util.createDiv(
			this.id + "_close", null, new OpenLayers.Size(17, 17)
		);
		this.closeDiv.className = "olPopupCloseBox"; 
		
		// use the content div's css padding to determine if we should
		//  padd the close div
		var contentDivPadding = this.getContentDivPadding();
		 
		this.closeDiv.style.right = contentDivPadding.right + "px";
		this.closeDiv.style.top = contentDivPadding.top + "px";
		this.groupDiv.appendChild(this.closeDiv);
		
		var closePopup = callback || function(e) {
			this.hide();
			OpenLayers.Event.stop(e);
		};
		OpenLayers.Event.observe(this.closeDiv, "touchend", 
				OpenLayers.Function.bindAsEventListener(closePopup, this));
		OpenLayers.Event.observe(this.closeDiv, "click", 
				OpenLayers.Function.bindAsEventListener(closePopup, this));
	},
	
	/**
	 * Method: hide
	 * 设置浮云框隐藏。
	 */
	hide: function() {
	   if(this.shadowDiv) {
			this.shadowDiv.style.display = 'none';
		}
		OpenLayers.Popup.FramedCloud.prototype.hide.apply(this, arguments);
	},
	
	/**
	 * Method: show
	 * 设置浮云框可显。
	 */
	show: function() {
		if(this.shadowDiv) {
			this.shadowDiv.style.display = '';
		}
		OpenLayers.Popup.FramedCloud.prototype.show.apply(this, arguments);   
	},
	
	/**
	 * APIMethod: clickShadow
	 * 鼠标点击浮云框阴影时执行的函数，可由用户重写此函数，自定义操作内容。
	 * 
	 * Parameters:
	 * event - {Object} 事件对象。
	 */
	clickShadow:function(event) {	
	},	
	
	/**
	 * APIMethod: moveoverShadow
	 * 鼠标移入浮云框阴影时执行的函数，可由用户重写此函数，自定义操作内容。
	 * 
	 * Parameters:
	 * event - {Object} 事件对象。
	 */
	moveoverShadow: function(event) {
	},	
	
	/** 
	 * APIMethod: destroy
	 * 销毁浮云框对象。
	 */
	destroy: function() {
		if(this.shadowDiv && this.map) {
			this.shadowevents.unregister({
				"click": this.clickShadow,
				//鼠标是否经过阴影区
				"mousemove":this.moveoverShadow,
				scope: this
			});	
			//移除浮云框阴影
			this.map.events.unregister("zoomend", this,this.calculateShadowLocation);
			this.map.layerContainerDiv.removeChild(this.shadowDiv);
			this.shadowDiv = null;	
		}
		OpenLayers.Popup.FramedCloud.prototype.destroy.apply(this, arguments);
	},	
	
    /**
     * Method: updateBlocks
     * Internal method, called on initialize and when the popup's relative
     *     position has changed. This function takes care of re-positioning
     *     the popup's blocks in their appropropriate places.
     */
    updateBlocks: function() {
        if (!this.blocks) {
            this.createBlocks();
        }
        
        if (this.size && this.relativePosition) {
            var position = this.positionBlocks[this.relativePosition];
            for (var i = 0; i < position.blocks.length; i++) {
    
                var positionBlock = position.blocks[i];
                var block = this.blocks[i];
    
                // adjust sizes
                var l = positionBlock.anchor.left;
                var b = positionBlock.anchor.bottom;
                var r = positionBlock.anchor.right;
                var t = positionBlock.anchor.top;
    
                //note that we use the isNaN() test here because if the 
                // size object is initialized with a "auto" parameter, the 
                // size constructor calls parseFloat() on the string, 
                // which will turn it into NaN
                //
                var w = (isNaN(positionBlock.size.w)) ? this.size.w - (r + l) 
                                                      : positionBlock.size.w;
    
                var h = (isNaN(positionBlock.size.h)) ? this.size.h - (b + t) 
                                                      : positionBlock.size.h;
    
                block.div.style.width = (w < 0 ? 0 : w) + 'px';
                block.div.style.height = (h < 0 ? 0 : h) + 'px';
    
                block.div.style.left = (l != null) ? l + 'px' : '';
                block.div.style.bottom = (b != null) ? b + 'px' : '';
                block.div.style.right = (r != null) ? r + 'px' : '';            
                block.div.style.top = (t != null) ? t + 'px' : '';
    
                block.image.style.left = positionBlock.position.x + 'px';
                block.image.style.top = positionBlock.position.y + 'px';
            }
			
			switch (this.borderStyle) {
	            case Geo.View2D.Popup.GeoFrameCloud.CORNER:
					this.contentDiv.style.left = this.padding.left + "px";
					this.contentDiv.style.top = this.padding.top + "px";
	                break;
	            case Geo.View2D.Popup.GeoFrameCloud.SHARP:
					this.contentDiv.style.left = 0 + "px";
					this.contentDiv.style.top = 0 + "px";
	                break;
	            case Geo.View2D.Popup.GeoFrameCloud.VERTICALDIRECTION:
					this.contentDiv.style.left = 0 + "px";
					this.contentDiv.style.top = 0 + "px";
	                break;
	        }
        }
    },
	
	CLASS_NAME: "Geo.View2D.Popup.GeoFrameCloud"
});

/**
 * Constant: CORNER
 * {Integer} 浮云边框为圆角的标识。
 */
Geo.View2D.Popup.GeoFrameCloud.CORNER = 1;


/**
 * Constant: SHARP
 * {Integer} 浮云边框为直角的标识。
 */
Geo.View2D.Popup.GeoFrameCloud.SHARP = 2;

/**
 * Constant: VERTICALDIRECTION
 * {Integer} 浮云边框为垂直指向要素的标识。
 */
Geo.View2D.Popup.GeoFrameCloud.VERTICALDIRECTION = 3;
/**
 * Class: Geo.View3D.Map
 * 三维地图对象。
 */
Geo.View3D.Map = Geo.Class({

    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,
    
    /**
     * APIProperty: div
     * {DOMElement} 三维地图所在的div容器。
     */
    div: null,
    
    /**
     * APIProperty: activexObj
     * {DOMElement} 三维地图的ActiveX对象引用。
     */
    activexObj: null,
    
    /**
     * APIProperty: layers
     * {Array} 地图中所有图层。
     */
    layers: null, 
   
    /**
     * APIProperty: overLayers
     * {Array} 所有的覆盖图层。
     */
    overLayers: null,
    
    /**
     * APIProperty: controls
     * {Array} 地图中所有控件。
     */
    controls: null,
	
	/**
     * APIProperty: popups
     * {Array(<Geo.View3D.Popup>)} 添加到地图上的弹出框。
     */
    popups: null,
    
	/**
	 * Property: handlers
	 * {Object} 地图中所有鼠标事件监听器。
	 */
    handlers:null,
	
	/**
     * APIProperty: BaseLayerGroup
     * {Geo.View3D.BaseLayerGroup} 基础图层组。
     */
	baseLayerGroup: null,
    
	_auxStatus: null,
	
    /**
     * APIProperty: zoomRatio
     * {Number} 调用地图缩放方法zoomIn和zoomOut方法时的缩放比率值，默认值为0.05。
     */
    zoomRatio: 0.05,
    
    /**
     * APIProperty: EVENT_TYPES
     * {Array} 支持的事件类型。
     */
    EVENT_TYPES: ["unloadLayerGroup", "loadlayergroup"],
    
    /**
     * APIProperty: pyramid
     * {<Geo.Pyramid>} 地图的金字塔方案对象，在三维地图中只能为360度金字塔方案。
     */
    pyramid: null,
        
    events: null,
	
	// 图层移动方式的枚举变量
	_enumMoveLayerType: {
		"MOVE_TO_TOP": 0, //移动图层到顶层显示
		"MOVE_TO_BOTTOM": 1, //移动图层到底层显示
		"MOVE_UP": 2, //向上移动一层
		"MOVE_DOWN": 3 //向下移动一层
	},
	
	//三维球元素类型枚举
	_enumScreenElementType: {
		LATLONGGRID: 0,//经纬网格
		COMPASS: 1,//罗盘
		ATMOSPHERE: 2,//大气圈
		COODINFO: 3,//坐标信息
		CROSSHAIR: 5 //十字丝
	},
	
	/**
     * APIProperty: projection
     * {String} 地图投影,默认 "EPSG:4326".
     */
    projection: "EPSG:4326",    
        
    /**
     * APIProperty: units
     * {String} 地图单位，默认为'degrees'. 
     */
    units: 'degrees',	
	
    /**
     * APIProperty: layerGroupLoaded
     * {Boolean} 实例化一个地图对象时，是否默认加载图层组。
     */
	layerGroupLoaded: false,
	
    /**
     * APIProperty: layerGroupType
     * {String} 表示实例化一个地图对象时，默认加载图层组的类型，一般设置为"vec"或"img"。
     * "vec"表示矢量图层组，"img"表示影像图层组。若不设置，默认会显示矢量图层组。
     */
	layerGroupType: null,
	
    /** 
     * Constructor: Geo.View3D.Map
     * Geo.View3D.Map构造方法。
     *
     * Parameters:
     * div - {DOMElement|String} DIV元素。
     * options - {Object} 选项。
     * (code)
     * var map = new Geo.View3D.Map("simpleMap");
     * (end)
     *
     */
    initialize: function(div, options){
    
        if (typeof(div) == "string") {
            this.div = document.getElementById(div);
        }
        else {
            this.div = div;
        }
        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME);
		OpenLayers.Util.extend(this, options);
        //初始化插件
        var initResult = Geo.View3D.Map.getActivex(this.id + "_Activex");
        this.activexObj = initResult.obj;
        var version = initResult.version;
        
        //检查三维插件是否安装
//        if (!this.activexObj || initResult.version < Geo.View3D.Map.ACTIVEX_DEFAULT_VERSION) {
//            this.div.innerHTML = Geo.View3D.Map.activexErrorInfo;
//            return;
//        }        
        
        this.div.appendChild(this.activexObj);
		
		//this.setFocus(true);
		/*
		this.activexObj.onfocus = function(){
			this.parentNode.onfocus = "true";
		}
		*/
        this.setScenario("no server", 2);
        
        this.events = new OpenLayers.Events(this, 
                                            this.div, 
                                            this.EVENT_TYPES, 
                                            this.fallThrough, 
                                            {includeXY: true});
        //金字塔对象                                    
		this.pyramid = new Geo.Pyramid();                                            
        this.layers = [];
        this.overLayers = [];
        this.handlers = [];
		this.popups = [];
		
		//辅助图层状态信息初始化
    	this._auxStatus = {
	        latLongGrid: false,
	        compass:true,
	        coodInfo:true,
	        atmosphere:true,
	        crossHair:true
	    };
//        
//		this._initGeoRaster();
//        
//        //绑定量算事件
//        var measureHandler = OpenLayers.Function.bind(function(eventObj){
//            this._measureHandler(eventObj);
//        }, this);
//        this.activexObj.attachEvent("GGMeasureEvent", measureHandler);
//
		//绑定鼠标事件
        var mouseEventHandler = OpenLayers.Function.bind(function(eventObj){
			
            this._mouseEventHandler(eventObj);
        }, this);
     //   this.activexObj.attachEvent("OnMouseEvent", mouseEventHandler);
		if (this.activexObj.attachEvent){
			this.activexObj.attachEvent("OnMouseEvent",mouseEventHandler);        
		}else if (this.activexObj.addEventListener){
			this.activexObj.addEventListener("MouseEvent",mouseEventHandler,false);      
		}		
		
		//绑定视图范围改变事件
        var _viewExtentChanged = OpenLayers.Function.bind(function(eventObj){
            this.viewExtentChanged(eventObj);
        }, this);
     //   this.activexObj.attachEvent("OnViewExtentChanged", _viewExtentChanged);
		if (this.activexObj.attachEvent){
			this.activexObj.attachEvent("OnViewExtentChanged",_viewExtentChanged);        
		}else if (this.activexObj.addEventListener){
			this.activexObj.addEventListener("ViewExtentChanged",_viewExtentChanged,false);      
		}		
		
		//绑定键盘事件
//        var keyEventHandler = OpenLayers.Function.bind(function(eventObj){KeyCode,keyState
        var keyEventHandler = OpenLayers.Function.bind(function(keyCode,keyState){
        	var eventObj = {};
        	eventObj.keyCode = keyCode;
        	eventObj.keyState = keyState;
            this._keyEventHandler(eventObj);
        }, this);
    //    this.activexObj.attachEvent("OnKeyEvent", keyEventHandler);
		if (this.activexObj.attachEvent){
			this.activexObj.attachEvent("OnKeyEvent",keyEventHandler);        
		}else if (this.activexObj.addEventListener){
			this.activexObj.addEventListener("KeyEvent",keyEventHandler,false);      
		}
//		
//		//修正页面后退，刷新三维插件对不销毁问题
//		this.unloadDestroy = OpenLayers.Function.bind(this.destroy, this);
//        OpenLayers.Event.observe(window, 'unload', this.unloadDestroy);
// 
 		//如果未在构造地图对象时指定加载控件，则加载默认控件（键盘控制控件）
        if (this.controls == null) {
			
			//如果不存在Control也不加载控件
            if (Geo.View3D.Control != null) { 
                this.controls = [new Geo.View3D.Control.KeyboardDefaults()];
            }
            else {
                this.controls = [];
            }
        }
        for(var i=0, len=this.controls.length; i<len; i++) {
            this.addControlToMap(this.controls[i]);
        }
//		
//		//坐标信息显示设置为红色字体
//        var options = {
//            fontColor: 0x00ff0000
//        };
//		this.setCoodInfo(options);
		
		if (this.layerGroupLoaded == true) {
			//获取天地图基础图层组
			var layerGroup = Geo.View3D.BaseLayerGroup.getTDTGroup(this.layerGroupType);
			if(layerGroup){
				this.loadLayerGroup(layerGroup);
			}
		}
    },

    /**
     * APIMethod: zoomTo
     * 缩放到指定的级别。
     * 
     * Parameters:
     * zoom - {Integer}
     */    
    zoomTo: function(zoom){
       if (zoom != null && zoom >= 0) {
            this.setCenter(null, zoom);
        }
    },
    
    /**
     * APIMethod: zoomIn
     * 放大地图级别。
     */    
    zoomIn: function(){
        this.zoom(this.zoomRatio);
    },
    
    /**
     * APIMethod: zoomOut
     * 缩小地图级别。
     */
    zoomOut: function(){
        this.zoom(-this.zoomRatio);
    },
    
    /**
     * APIMethod: zoom
     * 按指定比率缩放地图。
     */
    zoom: function(ratio){
        ratio = ratio ? ratio : 0.05;
        var camera = this.activexObj.Camera;
        camera.Zoom(ratio);
    },
	
	/**
     * APIMethod: pan
     * 允许用户根据屏幕的像素值来进行平移。
     * 
     * Parameters:
     * dx - {Integer}
     * dy - {Integer}
     */
    pan: function(dx, dy) {
		if ( (dx == null) || (dy == null) ) {
            var msg = OpenLayers.i18n("pixelAddError");
            OpenLayers.Console.error(msg);
            return null;
        }
        var globe = this.activexObj;
		if (globe) {
			globe.SceneBox.PanByScreen(dx, dy);
        }
	},
	
    /**
     * APIMethod: panTo
     * 根据坐标信息参数，将地图平移相应的距离。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 
     */
    panTo: function(lonlat){
        if(!lonlat){
            return;
        }
        // center will not change, don't do nothing
        var center = map.getCenter();
        if (lonlat.equals(center)) {
            return;
        }
		//经纬度各偏移1度
        var globe = this.activexObj;
        var lat = parseFloat(lonlat.lat - center.lat);
        var lon = parseFloat(lonlat.lon - center.lon);
        if (globe) {
			globe.SceneBox.Pan(lat, lon);
        } 
    },   
    
    /**
     * APIMethod: setCenter
     * 设置三维地图中心点和地图级别(没有飞行过程)。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 中心点。
     * level - {Integer} 地图级别。
     * isFly - {Boolean} 是否开启飞行动画效果。
     */
    setCenter: function(lonlat, level, isFly){
    	if(level === undefined){
	        level = this.getZoom();
	    }
	
	    isFly = isFly || false;
	    this._gotoPosition({
	        lon: lonlat.lon,
	        lat: lonlat.lat,
	        level: level
	    }, isFly);
    },
    
    /**
     * APIMethod: flyTo
     * 飞到三维地图中心点和海拨高度。
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>} 中心点。
     * alt - {Integer} 海拨高度(单位为米) 。
     */
    flyTo: function(lonlat, alt){
        this._gotoPosition({
            lon: lonlat.lon,
            lat: lonlat.lat,
            alt: alt
        }, true);
    },

	/**
     * APIMethod: zoomToExtent
     * 缩放到指定地图范围。
     * 
     * Parameters:
     * bounds - {<Geo.Bounds>} 范围。
     * isFlyTo - {Boolean} 是否飞行过去。
     */
    zoomToExtent: function(bounds, isFlyTo) {
    	var center = bounds.getCenterLonLat();
	    var viewSize = this.getSize();
	    var idealResolution = Math.max( bounds.getWidth()  / viewSize.w,
	                                    bounds.getHeight() / viewSize.h );
		var p360 = this.pyramid;	                                    
	    var zoom = p360.getLevelForResolution(idealResolution);
	    if(zoom > Geo.View3D.Map.ZOOMTOEXTENT_MINILEVEL){
	        zoom = Geo.View3D.Map.ZOOMTOEXTENT_MINILEVEL;
	    }
	    this.setCenter(center,zoom,isFlyTo);
    },
        
    //定位到指定位置,可以指定是否飞行方式
    _gotoPosition: function(position, isFlyTo){
        var globe = this.activexObj;
        if(!globe){
            return;
        }
        
        var lon = position.lon;
        var lat = position.lat;
        var level = position.level;
        
        //如果未指定海拨高度,则用默认高度
        var alt = (typeof(position.alt) == "undefined") ? Geo.View3D.Map.DEFAULT_ALT : position.alt;
        
        //如果有指定级别则优先以级别换算高度
        alt = (typeof(level) != "undefined") ? Geo.View3D.Map.getZfromLevel(level) : alt;
        
		// 如果当前高度大于等于目标高度（alt）并且小于目标高度前一级别换算的高度，则不改变定位的高度。
        if (this.getAltitude() >= alt && level != 0 && this.getAltitude() < Geo.View3D.Map.getZfromLevel(level - 1)) {
			alt = this.getAltitude();
        }
		// 如果当前高度大于等于目标高度（alt）并且目标级别为0，则不改变定位的高度。
        if (this.getAltitude() >= alt && level == 0) {
			alt = this.getAltitude();
        }
		
        if (isFlyTo) {
	   		globe.SceneBox.ParabolaFlyTo(lon, lat, alt);
        }
        else {
			globe.SceneBox.PutCameraPosition(lon, lat, alt);
        }
    },
    
    /**
     * APIMethod: addLayer
     * 添加单个图层对象到地图中。
     * 
     * Parameters:
     * layer - {<Geo.View3D.Layer>} 图层对象。
     */
    addLayer: function(layer){
        var layers = this.layers;
        if(!layer){
            return false;
        }
        for(var i=0, len=layers.length; i<len; i++) {
            if (this.layers[i] == layer) {
                var msg = OpenLayers.i18n('layerAlreadyAdded', 
                                                      {'layerName':layer.name});
                OpenLayers.Console.warn(msg);
                return false;
            }
        }
        this.layers.push(layer);
        layer.setMap(this);
    },
    
    /**
     * APIMethod: addLayers
     * 添加多个图层到地图中。
     * 
     * Parameters:
     * layers - {Array(<Geo.View3D.Layer>)}图层对象数组。
     */
    addLayers: function(layers){
        if (!(Geo.Util.isArray(layers))) {
            layers = [layers];
        }
        for (var i = 0; i < layers.length; i++) {
            this.addLayer(layers[i]);
        }
    },

    /**
	 * APIMethod: addOverLayer
	 * 将指定图层作为覆盖层添加。与addLayer方法不同的是，该图层的引用除了保存到地图对象的layers数组中，还将保存到overLayers数组。
	 * 覆盖层在基础图层组切换时，叠加顺序不受基础图层加载、卸载的影响，始终保持在所有基础图层的上方。
	 *
	 * Parameters: 
	 * layer - {Geo.View3D.Layer} 三维视图图层对象。
	 */		
    addOverLayer: function(layer){
        this.addLayer(layer);
        this.overLayers.push(layer);
    },
        
    /**
     * APIMethod: removeLayer
     * 从地图中移除图层。
     * 
     * Parameters:
     * layer - {<Geo.View3D.Layer>} 图层对象。
     */
    removeLayer: function(layer){
        OpenLayers.Util.removeItem(this.overLayers, layer);
        OpenLayers.Util.removeItem(this.layers, layer);
        layer.removeMap();
        layer.map = null;
    },

    /**
     * APIMethod: getNumLayers
     * 获取当前地图中的图层个数。
     * 
     * Returns:
     * {Number} 图层个数。
     */
    getNumLayers:function(){
        return this.layers.length;
    },
    
    /**
     * APIMethod: getLayerByIndex
     * 获取指定图层在地图所有图层中的位置。
     * 
     * Parameters:
     * layer - {<Geo.View3D.Layer>} 图层对象。
     * 
     * Returns:
     * {Number} 图层所在位置。
     */
    getLayerIndex: function (layer) {
        return OpenLayers.Util.indexOf(this.layers, layer);
    },
    
    /**
     * APIMethod: getLayer
     * 根据指定图层ID获取指定图层对象的引用。
     * 
     * Parameters:
     * id - {String} 编号。
     * 
     * Returns:
     * {<Geo.View3D.Layer>} 图层对象。
     */
    getLayer: function(id) {
        var foundLayer = null;
        
        //在数据图层中查询
        for (var i=0, len=this.layers.length; i<len; i++) {
            var layer = this.layers[i];
            if (layer.id == id) {
                foundLayer = layer;
                break;
            }
        }
        return foundLayer;
    },
    
    /**
     * APIMethod: raiseLayer
     * 移动指定图层，正数为下移，负数为上移。
     * 
     * Parameters:
     * layer - {Object} 图层对象。
     * delta - {}
     * 
     */
    raiseLayer: function (layer, delta) {
		//要移动图层的当前位置
		var currentIndex = this.getLayerIndex(layer);
		//delta表示移动几位
	    var tempDelta = Math.abs(delta);
		if(delta > 0) {
			for (var i = currentIndex, len=this.layers.length; i<len; i++) {
				//若起大于0
				if(tempDelta == 0 || len <= i+1) {
					break;
				}
				if(!this.layers[i+1].displayInLayerSwitcher) {
					delta ++;
				}else {
					tempDelta--;
				}
        		
        	}
		}else if(delta < 0) {
			for (var i = currentIndex, len=this.layers.length;i >= 0; i--) {
        		if(tempDelta == 0 || i - 1 < 0) {
					break;
				}
				if(!this.layers[i-1].displayInLayerSwitcher) {
					delta = delta - 1;
				}else {
					tempDelta--;
				}
        	}
		}
        var idx = this.getLayerIndex(layer) + delta;
        this.setLayerIndex(layer, idx);
    },

	
    /**
	 * APIMethod: resetTopLayer
	 * 将置顶图层重新排列。
	 */	
    resetTopLayer: function(){
        var layersNum = this.layers.length;
		var topIndex = layersNum - 1;
        for (var i = layersNum - 1; i >= 0; i--) {
            var layer = this.layers[i];
            if (layer.isOnTop) {
                this.setLayerIndex(layer, topIndex--);
            }
        }
    },
	
	/**
	 * APIMethod: resetOverLayer
	 * 将覆盖图层重新排列。
	 */	
	resetOverLayer:function(){
		var layersNum = this.layers.length;
		var topIndex = layersNum - 1;
        for (var i = layersNum - 1; i >= 0; i--) {
            var layer = this.layers[i];
            
            //如果不是覆盖图层则视为底图图层将之移到最底层
            if (OpenLayers.Util.indexOf(this.overLayers,layer) != -1) {
                this.setLayerIndex(layer, topIndex--);
            }
        }
	},
    
    /**
     * APIMethod: setLayerIndex
     * 改变图层所在位置。
     * 
     * Parameters:
     * layer - {Object} 图层对象。
     * idx - {Integer}
     * 
     */
    setLayerIndex: function (layer, idx) {
        var base = this.getLayerIndex(layer);
		/***/
		// 该图层前一个索引图层
		var aLayer = null;
		// 该图层后一个索引图层
		var bLayer = null;
		if(base == 0){
			var bLayer = this.layers[base + 1];
		}else if(base == this.layers.length - 1){
			var aLayer = this.layers[base - 1];
		}else{
			var aLayer = this.layers[base - 1];
			var bLayer = this.layers[base + 1];
		}
        var alayerData = null;
        var blayerData = null;
        
        if (aLayer && aLayer._layerData) {
            alayerData = aLayer._layerData;
            //针对前一个索引图层为WMS图层中会有多个指定子图层
            if (!(Geo.Util.isArray(aLayer._layerData))) {
                alayerData = [aLayer._layerData];
            }
        }
        if (bLayer && bLayer._layerData) {
            blayerData = bLayer._layerData;
            //针对后一个索引图层为WMS图层中会有多个指定子图层
            if (!(Geo.Util.isArray(bLayer._layerData))) {
                blayerData = [bLayer._layerData];
            }
        }
        
		/***/
        if (idx < 0) {
            idx = 0;
        } else if (idx > this.layers.length) {
            idx = this.layers.length;
        }
        if (base != idx) {
            this.layers.splice(base, 1);
            this.layers.splice(idx, 0, layer);
            
            //根据偏移量，移动插件中的图层
            var delta = base - idx;
			var layerData = layer._layerData;
			/***/
			//针对前一个索引图层为WMS图层中会有多个指定子图层，则偏移量多加上（图层个数-1（默认个数））
			if (alayerData && delta > 0) {
				delta += alayerData.length -1;
			}
			//针对后一个索引图层为WMS图层中会有多个指定子图层，则偏移量多减去（图层个数-1（默认个数））
			if (blayerData && delta < 0) {
				delta -= blayerData.length -1;
			}
			/***/
			if (layerData) {
				//针对WMS图层中会有多个指定子图层
				if (!(Geo.Util.isArray(layerData))) {
					layerData = [layerData];
				}
				for (var i = 0; i < Math.abs(delta); i++) {
					for (var m = 0; m < layerData.length; m++) {
						if (delta < 0) {
							this._moveLayerUp(layerData[m]);
						}
						if (delta > 0) {
							// 如果是需要置顶的图层（绘制图层）中如果包含标注图层则下移（置顶）
							if (layer.isOnTop && layer._markerLayer) {
								this._moveLayerDown(layer._markerLayer);
							}
							this._moveLayerDown(layerData[layerData.length - m - 1]);
						}
					}
				}
			}
        }
    },

    //图层组相关------------------------------------------------------------
    /**
     * APIMethod: loadLayerGroup
     * 加载图层组到地图中。
     * 
     * Parameters:
     * layerGroup - {Geo.View3D.BaseLayerGroup} 图层组对象。
     * 
     */
    loadLayerGroup: function(layerGroup){
		
        if (this.baseLayerGroup == layerGroup) {
            msg = "不能重复加载图层组到地图中！";
            OpenLayers.Console.warn(msg);
            return false;
        }
        this.unloadLayerGroup();

        layerGroup.setMap(this);
        this.baseLayerGroup = layerGroup;
        
        this.resetOverLayer();
        this.resetTopLayer();
        
        this.events.triggerEvent("loadlayergroup", {
            layerGroup: layerGroup,
			map : this
        });
    },
	
    /**
     * APIMethod: unloadLayerGroup
     * 卸载图层组。
     */
    unloadLayerGroup: function(){
		var layerGroup = this.baseLayerGroup;
        if (!layerGroup) {
			return false;
		}
        var layers = layerGroup.layers;
        for (var i = 0; i < layers.length; i++) {
            var layer = layers[i];
            this.removeLayer(layer);
        }
        layerGroup.map = null;
        this.baseLayerGroup = null;
        this.events.triggerEvent("unloadLayerGroup", {
            layerGroup: layerGroup,
			map : this
        });
    },
    
    /**
     * APIMethod: addControl
     * 添加单个控件到地图中。
     * 
     * Parameters:
     * control - {Object} 控件对象。
     * 
     */
    addControl: function(control){
        this.controls.push(control);
        this.addControlToMap(control);
    },
    
    /**
     * APIMethod: addControls
     * 添加多个控件到地图中。
     * 
     * Parameters:
     * controls - {Object} 控件组。
     * 
     */
    addControls: function (controls) {
        for (var i=0, len=controls.length; i<len; i++) {
            var ctrl = controls[i];
            this.addControl(ctrl);
        }
    },
	
    //添加控件到地图中
    addControlToMap: function(control,px){
        control.setMap(this);
        control.draw(px);
        if(control.autoActivate) {
            control.activate();
        }
    },
    
    /**
     * APIMethod: getControl
     * 根据给定ID获取控件对象的引用。
     * 
	 * Parameters:
     * id - {String} 控件唯一标识。
     * 
     * Returns:
     * {<Geo.View3D.Control>} 控件对象。
     */
    getControl: function(id){
        var returnControl = null;
        for (var i = 0, len = this.controls.length; i < len; i++) {
            var control = this.controls[i];
            if (control.id == id) {
                returnControl = control;
                break;
            }
        }
        return returnControl;
    },
    
	/**
     * APIMethod: removeControl
     * 删除地图中的控件。移除的控件来自于地图对象的控件列表。
     * 
     * Parameters:
     * control - {<Geo.View3D.Control>} 移除的控件。
     */
    removeControl: function(control){
        if ((control) && (control == this.getControl(control.id))) {
            OpenLayers.Util.removeItem(this.controls, control);
			control.deactivate();
        }
    },
    
    /** 
     * APIMethod: addPopup
     * 添加浮云框。
     * 
     * Parameters:
     * popup - {<Geo.View3D.Popup>}
     * exclusive - {Boolean} 是否关闭其他的浮云框。
     */
    addPopup: function(popup, exclusive) {

        if (exclusive) {
            //remove all other popups from screen
            for (var i = this.popups.length - 1; i >= 0; --i) {
                this.removePopup(this.popups[i]);
            }
        }

        popup.map = this;
        this.popups.push(popup);
        popup.draw();
    },

    /** 
    * APIMethod: removePopup
    * 移除浮云框。
    * 
    * Parameters:
    * popup - {<Geo.View3D.Popup>}
    */
    removePopup: function(popup) {
		//如果参数为空，清除全部
		if(!popup){
			popup = this.popups;
		}
		if (!(Geo.Util.isArray(popup))) {
            popup = [popup];
        }
		for(var i = popup.length - 1; i >= 0; i--){
	        if (popup[i].map) {
	            popup[i]._clear();
	        }
	        popup[i].map = null;
			OpenLayers.Util.removeItem(this.popups, popup[i]);
		}
    },  
   
   /**
    * APIMethod: getAuxStatus
    * 获取指定辅助图层状态,如果为"all"则返回所有辅助图层的状态。
    * 
    * Parameters:
    * type - {Object}
    */
    getAuxStatus: function(type){
        return type == "all" ? this._auxStatus : this._auxStatus[type];
    },
	
    /**
     * APIMethod: showLatLongGrid
     * 设置是否显示经纬网格。
     * 
     * Parameters:
     * isShow - {Boolean}
     */
    showLatLongGrid: function(isShow){
        var globe = this.activexObj;
        if (globe) {
            //auxTools = globe.GetAuxTools();
            //auxTools.ShowLatLongGrid(isShow);
			globe.ScreenBox.ChangeScreenElementVisible(this._enumScreenElementType.LATLONGGRID,isShow);
            this._auxStatus["latLongGrid"] = isShow;
        }
        
    },
	
    /**
     * APIMethod: showCompass
     * 设置是否显示罗盘。
     * 
     * Parameters:
     * isShow - {Boolean}
     */
    showCompass: function(isShow){
        var globe = this.activexObj;
        if (globe) {
            //参数1表示罗盘
			globe.ScreenBox.ChangeScreenElementVisible(this._enumScreenElementType.COMPASS,isShow);
            this._auxStatus["compass"] = isShow;
        }
        
    },
    
    /**
     * APIMethod: showCoodInfo
     * 设置是否显示坐标信息。
     * 
     * Parameters:
     * isShow - {Boolean}
     */
    showCoodInfo: function(isShow){
        var globe = this.activexObj;
        if (globe) {
            //参数3表示坐标信息
			globe.ScreenBox.ChangeScreenElementVisible(this._enumScreenElementType.COODINFO,isShow);
            this._auxStatus["coodInfo"] = isShow;
        }
        
    },

    /**
     * APIMethod: setCoodInfo
     * 设置坐标信息相关选项，可以改变坐标信息的屏幕位置、文本对齐方式、字体颜色、字体名称、是否加粗、字号。
     * 
     * Parameters:
     * options - {<Object>} 参数对象，支持以下属性：
     *  - screenPosition 屏幕位置，可以为以下值：
     *      0：屏幕左下（默认）
     *      2：屏幕中下
     *      4：屏幕右下
     *      6：屏幕中央
     *      8：屏幕右上
     *      10：屏幕中上
     *      12：屏幕左上
     *  - textAlignment 文本对齐方式，可以为以下值：
     *      0：左对齐（默认）
     *      1：居中对齐
     *      2：右对齐
     *  - fontColor 字体颜色(默认0x000000ff)。
     *  - fontName 字体名称（默认"宋体"）。
     *  - fontBold 字体是否加粗。
     *  - fontSize 字号（默认14）。
     *  
     *  示例：
     *  (code)
     *  map.setCoodInfo({
     *     screenPosition: 2,
     *     fontSize: 18
     *  });
     *  (end)
     */    
    setCoodInfo:function(options){
        var defaultOption = {
            screenPosition: 0,
            textAlignment: 0, 
            fontColor: 0x000000ff, 
            fontName: "宋体", 
            fontBold: true, 
            fontSize: 14
        };
        
        OpenLayers.Util.applyDefaults(options,defaultOption);
        options.fontColor = Geo.Util.ToArgb(options.fontColor,255);
        var globe = this.activexObj;
		var coodInfo = globe.ScreenBox.QueryScreenElement(this._enumScreenElementType.COODINFO);
		coodInfo.ScreenPosition = options.screenPosition;
		coodInfo.TextAlignment = options.textAlignment;
		coodInfo.FontColor = options.fontColor;
		coodInfo.FontName = options.fontName;
		coodInfo.FontBold = options.fontBold;
		coodInfo.FontSize = options.fontSize;
	//	globe.ConfigBox.SaveConfigItem(8, options.screenPosition);
//        globe.GetAuxTools().SetPositionInfoParam(
//            options.screenPosition,
//            options.textAlignment,
//            options.fontColor,
//            options.fontName,
//            options.fontBold,
//            options.fontSize
//        )
    },
    

    /**
     * APIMethod: showAtmosphere
     * 设置是否显示大气圈。
     * 
     * Parameters:
     * isShow - {Boolean}
     */
    showAtmosphere: function(isShow){
        var globe = this.activexObj;
        if (globe) {
			 //参数2表示大气圈
			globe.ScreenBox.ChangeScreenElementVisible(this._enumScreenElementType.ATMOSPHERE,isShow);
            this._auxStatus["atmosphere"] = isShow;
        }
    },
    
    /**
     * APIMethod: showCrossHair
     * 设置是否显示十字丝。
     * 
     * Parameters:
     * isShow - {Boolean}
     */
    showCrossHair: function(isShow){
        var globe = this.activexObj;
        if (globe) {
			//参数5表示十字丝
			globe.ScreenBox.ChangeScreenElementVisible(this._enumScreenElementType.CROSSHAIR,isShow);
            this._auxStatus["crossHair"] = isShow;
        }
        
    },
	
    /**
     * APIMethod: setCompassPosition
     * 设置罗盘在屏幕上显示的位置。
     * 
     * Parameters:
     * positoin - {String} 罗盘的屏幕位置，目前只支持"left"或"right"，表示设置罗盘显示在屏幕右上或屏幕左上。
     * 
     */
    setCompassPosition: function(positoin){
        var globe = this.activexObj;
        if (globe) {
			switch(positoin){
				case "left" :
				   //第二个参数12表示罗盘在地图右上角；第一个参数7表示设置罗盘位置
					globe.ConfigBox.SaveConfigItem(7, 12);
					break;
				case "right" :
					globe.ConfigBox.SaveConfigItem(7, 8);
					break;
				default:
					return;
			}
        }
    },

    
    /**
     * APIMethod: setExaggeration
     * 设置地形夸张系数。
     * 
     * Parameters:
     * num - {Number} 为夸张的系数。
     */
    setExaggeration:function(num){
        num = (num < 0) ? 0 : num;
        num = (num > 5) ? 5 : num;
        
        var globe = this.activexObj;
        if (globe) {
            //globe.GetLayerBox().TerrainExaggeration(num);
			globe.Camera.TerrainExaggeration = num;
        }
    },    
    
    /**
     * APIMethod: resetNorth
     * 重新设置三维视图的指北方向。
     */
	resetNorth: function(){
		var globe = this.activexObj;
		if(globe){
//			globe.Camera.SetNorth();
			globe.Camera.Rotate(0, 0, 0.01 - globe.Camera.Heading); 
		}
	},

    /**
     * APIMethod: cameraRotation
     * 场景旋转。参数分别代表XYZ三个轴的偏移量。
     * 
     * Parameters:
     * dYaw - {Object}
     * dPitch - {Object}
     * dRoll - {Object}
     */
    cameraRotation: function(dYaw, dPitch, dRoll){
        var globe = this.activexObj;
        if (globe) {
            //参数分别代表XYZ三个轴的偏移量   
            globe.SceneBox.Rotate(dYaw, dPitch, dRoll);
        }
    },
    /**
     * APIMethod: getZoom
     * 获取当前海拨高度转换后的地图级别。
     * 
     * Returns:
     * {Integer} 地图级别。
     */
    getZoom: function(){
		var alt = this.getAltitude();
        return Geo.View3D.Map.getZoomfromAlt(Math.round(alt));
    },
    /**
    * APIMethod: getGeography
    * 获取当前中心点三维地理坐标。
    * 
    * Returns:
    * {Array} 三维地理坐标。
    */
    getGeography:function(){
    	return eval(this.activexObj.SceneBox.CameraLookAtScript);
    },
     /**
     * APIMethod: lonlatToScreen
     * 经纬度转屏幕像素。
     * 
     * Parameters:
     * lon - {Number} 经度。
     * lat - {Number} 纬度。
     * z - {Number} 
     * Returns:
     * {Pixel} 屏幕坐标。
     */
    lonlatToScreen: function(lon,lat,z){
    	var box = this.activexObj.AnalysisBox;
		//第三个参数为1的时候表示精确的坐标转换，里面有地形参与计算 
		var screenScript = eval(box.GeographyToScreenScript(lon, lat,z, 1));
		return new Geo.Pixel(parseFloat(screenScript[0]),parseFloat(screenScript[1]));
    },
     /**
     * APIMethod: lonlatToScreen
     * 屏幕像素转经纬度。
     * 
     * Parameters:
     * pX - {Number} 屏幕X坐标。
     * pX - {Number} 屏幕Y坐标。
     * Returns:
     * {LonLat} 经纬度。
     */
    screenToLonlat: function(pX,pY){
    	var box = this.activexObj.AnalysisBox;
		//第三个参数为1的时候表示精确的坐标转换，里面有地形参与计算 
		var geographyScript = eval(box.ScreenToGeographyScript(pX, pY,1));
		return new Geo.LonLat(parseFloat(geographyScript[0]),parseFloat(geographyScript[1]));
    },
    
    /**
     * APIMethod: getViewPortPxFromLonLat
     * 经纬度转屏幕像素.
     * 
     * Parameters:
     * lonlat - {<Geo.LonLat>}
     * 
     * Returns:
     * {<Geo.Pixel>} 屏幕坐标.
     */
    getViewPortPxFromLonLat: function (lonlat) {
        var box = this.activexObj.AnalysisBox;
        var geography = this.getGeography();
        var z = parseFloat(geography[2]);
		//第三个参数为1的时候表示精确的坐标转换，里面有地形参与计算 
		var screenScript = eval(box.GeographyToScreenScript(lonlat.lon, lonlat.lat,z, 1));
		return new Geo.Pixel(parseFloat(screenScript[0]),parseFloat(screenScript[1]));
    },
    
    /**
     * Method: getLonLatFromViewPortPx
     * 屏幕像素转经纬度.
     * 
     * Parameters:
     * viewPortPx - {<Geo.Pixel>}
     * 
     * Returns:
     * {<Geo.LonLat>} 经纬度.
     */
    getLonLatFromViewPortPx: function (viewPortPx) {
    	var box = this.activexObj.AnalysisBox;
		//第三个参数为1的时候表示精确的坐标转换，里面有地形参与计算 
		var geographyScript = eval(box.ScreenToGeographyScript(pX, pY,1));
		return new Geo.LonLat(parseFloat(geographyScript[0]),parseFloat(geographyScript[1]));
    },
    
    /**
     * APIMethod: getCenter
     * 获取当前中心点地理坐标。
     */
    getCenter: function(){
        var cameraLookAtScript = eval(this.activexObj.SceneBox.CameraLookAtScript);
    	return new Geo.LonLat(parseFloat(cameraLookAtScript[0]),parseFloat(cameraLookAtScript[1]));
    },   
    
    /**
     * APIMethod: getAltitude
     * 获取当前中心点海拨高度，单位为米。
     */    
    getAltitude: function(){
		return this.activexObj.SceneBox.MaxCameraAltitude;
    }, 
    
    /**
     * APIMethod: setTasService
     * 设置地形分析服务。
     * 
     * Parameters:
     * url - {String} 地形分析服务地址。
     */
    setTasService: function(url){
        var globe = this.activexObj;
        if (globe) {
            globe.SetTerrainAnalysisService(url);
        }
    },
	
	/**
	 * APIMethod: getExtent
	 * 获取三维视图下的视口范围。
	 * 
     * Returns:
     * {Geo.Bounds} 视口范围
	 */
	getExtent:function() {
		var center = this.getCenter();
    	var pixelSize = this.getSize();
    	var res = this.getResolution();
    	var lonlatSize = new Geo.Size(pixelSize.w * res, pixelSize.h * res);
    	return new Geo.Bounds(center.lon - lonlatSize.w/2, center.lat - lonlatSize.h/2,
                        center.lon + lonlatSize.w/2, center.lat + lonlatSize.h/2);

	},
	
	/**
     * APIMethod: getResolution
     * 获取当前地图的分辨率。
     * 
     * Returns:
     * {Float} 分辨率
     */
	getResolution : function(){
	    var currentZoom = this.getZoom();
	    var p360 = this.pyramid;
	    return p360.getResolutionForLevel(currentZoom);
	},
	
	/**
     * APIMethod: getResolutionForZoom
     * 根据地图级别获取分辨率。
     * 
     * Parameter:
     * zoom - {Float}
     * 
     * Returns:
     * {Float} 分辨率
     */
	getResolutionForZoom : function(zoom){
    	var p360 = this.pyramid;
    	return p360.getResolutionForLevel(zoom);
	},
	
	/**
     * APIMethod: getZoomForResolution
     * 根据地图分辨率获取地图级别。
     * 
     * Parameter:
     * resolution - {Float}
     * 
     * Returns:
     * {Integer} 地图级别
     */
	getZoomForResolution : function(resolution){
    	var p360 = this.pyramid;
    	return p360.getLevelForResolution(resolution);
	},
	
	/**
     * APIMethod: getSize
     * 获取三维控件尺寸大小。
     * 
     * Returns:
     * {<Geo.Size>} 控件尺寸
     */
	getSize : function(){
		var globe = this.activexObj;
	    if(globe){
	        return new Geo.Size(parseInt(globe.offsetWidth),
	                              parseInt(globe.offsetHeight));
	    }
	},
	
	/**
      * APIMethod: getScale
      * 获取当前地图的比例尺。
      * 
      * Returns:
      * {Float} 比例尺 
      */
    getScale: function () {
        var scale = null;
        var res = this.getResolution();
        var units = this.units;
        scale = OpenLayers.Util.getScaleFromResolution(res, units);
        return scale;
    },
	
//    /**
//     * APIMethod: setFocus
//     * 设置球体容器的焦点。参数flag为true表示焦点在三维球体上时，则容器获得焦点。
//     * 
//     * Parameter:
//     * flag - {Boolean}
//     */	 
//	setFocus: function(flag){
//		if(flag){
//			this.activexObj.onfocus = function(){
//				this.parentNode.onfocus = "true";
//			}
//		}else{
//			this.activexObj.onfocus = "true";
//		}
//	},
	
	/**
     * Method: destroy
     * 销毁地图对象。
     */
    destroy:function() {
        for(var i=(this.layers.length-1); i>=0; i--){
            this.removeLayer(this.layers[i]);
        }
		if(this.activexObj){
			this.div.removeChild(this.activexObj);
		}
		this.activexObj = null;
    },	
    
    /**
     * Method: setScenario
     * 连接服务（应有加新服务和老服务之分，目前未处理）。
     *
     * Parameters:
     * scenario - {String} 方案地址。
     */
    setScenario: function(scenario){
		/*
        if (scenario) {
            this.activexObj.ConnectServer(scenario, 1);
        }
        */
        if (scenario) {
	        if(arguments.length < 2) {
	        		this.activexObj.ConnectServer(scenario, 1);
	        	}else{
	        		this.activexObj.ConnectServer(arguments[0], arguments[1]);
	        }
        }		
    },
	
	//初始化光栅对象
	_initGeoRaster: function(){
		this._geoRaster = this.activexObj.CreateGeoRasterObj();
		//设置为1绘制的几何对象贴地		
		this._geoRaster.GeoRasterType = 1;
	},
	
	/**
     * APIMethod: viewExtentChanged
     * 当地图的视图范围改变时，运行该函数，函数可以覆写，使用方式：
     * 
     * (code)
     *  var map = new Geo.View3D.Map("simpleMap");
     *  map.viewExtentChanged = function(e){
     *  //Todo
     *  }
     * (end)
     */
	viewExtentChanged: function() {
			
	},
        
	//鼠标事件监听
    _mouseEventHandler: function(e){
//		if (e.MouseButton === 0 && e.MouseState === 3) {
//            return true;
//        }
		//e.Cancel=true;
//        for (var i = 0; i < this.handlers.length; i++) {
//            var handler = this.handlers[i];
//            if (handler instanceof Geo.View3D.Handler.KeybordDefaults) {
//                continue;
//            }
//            if (handler.active) {
//                handler.listener(e);
//            }
//        }
		//记录鼠标键按下位置，用以区分点击与拖拽行为
	    if(Geo.View3D.Event.MouseEvent.isMouseDown(e)){
	        Geo.View3D.Event.MouseEvent._mouseDownPos = {
	            x:e.ScreenX,
	            y:e.ScreenY
	        };
	    };
	
	    for (var i = 0; i < this.handlers.length; i++) {
	        var handler = this.handlers[i];
	        if (handler instanceof Geo.View3D.Handler.KeybordDefaults) {
	            continue;
	        }
	        if (handler.active) {
	            handler.listener(e);
	        }
	    };
	
	    //鼠标键抬起后清除位置记录
	    if(Geo.View3D.Event.MouseEvent.isMouseUp(e)){
	        Geo.View3D.Event.MouseEvent._mouseDownPos = null;
	    };
    },
	
	//键盘事件监听
    _keyEventHandler: function(e){
        for (var i = 0; i < this.handlers.length; i++) {
            var handler = this.handlers[i];
            if (handler instanceof Geo.View3D.Handler.KeybordDefaults || handler instanceof Geo.View3D.Handler.Keyboard) {
                if (handler.active) {
                    handler.listener(e);
                }
            }
        }
    },
    
    //量算事件监听
    _measureHandler: function(e){
        
    },
    
    //添加GLOBE瓦片服务
    _addGlobeTileService: function(url,version,type){
        var globe = this.activexObj;
		//创建吉奥瓦片图层，第二个参数是版本,第三个参数是数据源类型，6表示数据源来自于吉奥瓦片
		var geoGlobeTileLayer = globe.DataSourceBox.CreateDataLayer(url, version, type);
		//吉奥瓦片图层对象
		globe.LayerBox.UserGroupLayer.AddLayer(geoGlobeTileLayer);
		return geoGlobeTileLayer;
    },
    
    //删除GLOBE瓦片服务
    _removeLayerData: function(layer){
        var globe = this.activexObj;
        if (globe && layer) {
			globe.LayerBox.UserGroupLayer.RemoveLayer(layer);
        }
    },
    
     //获取点的坐标值
    _getPointGeometryArr:function (strPoints){
        var start = strPoints.indexOf("(") + 1;
		var end = strPoints.indexOf(")");
		var points = strPoints.slice(start,end).split(" ");
        return points;
    },
	
	//数字唯一标示计数器
	_i: 0,
	
	//生成数字唯一表示其
	_createUniqueID: function() {
		var i = this._i;
		i++;
		if(i == 1.7976931348623157E+308) {
			i = 0;
		}
		this._i = i;
		return i;
	},
	
    //在指定图层上绘制给定几何对象
    //featureid, rastLayer, strPoints, type, style
    _drawGeometry: function(options){
        var globe = this.activexObj;
        if (globe) {
            var drawBox = options.drawBox;
            var wkt = options.strPoints;
			var _style = OpenLayers.Util.extend({},Geo.Feature.Vector.style['default']);
			var style = OpenLayers.Util.extend(_style,options.style);
			options.feature.style = style;
            switch (options.type) {
                case 0:
					//如果要素样式中有外部图片的地址，则以标注方式创建点要素
					if(style.externalGraphic){
						var dynamicLayer = options.dynamicLayer;
						var fontColor = style.fontColor ? this._convertColorValue(style.fontColor) : 0x00ff0000;
						var fontSize = style.fontSize ? style.fontSize : 12;
						var fontFamily = style.fontFamily ? style.fontFamily : "宋体"
						var label = style.label?style.label : "";
						var lonlat = options.strPoints.split(" ");
//						var fid = this._createUniqueID();
//						options.feature.fid = fid;
						var id = options.feature.id;
						//var markpoint = globe.DrawBox.AddPOIDrawObject(fid, options.strPoints, "", label, style.externalGraphic, 12, 12, "12");
						var markpoint = globe.DrawBox.AddPOIDrawObject(id, options.strPoints, "", label, style.externalGraphic, fontColor, fontSize, fontFamily);
						dynamicLayer.AddPOI(markpoint);
						globe.DrawBox.RemoveObject(markpoint);
					} else {
						//创建三维geometry
						var geometry = globe.DrawBox.CreateGeometryObject(wkt, "", 1, 1);
						//geometry的唯一标示，删除要素需要使用这个唯一标示来进行删除
						geometry.Key = options.featureid;
						//0表示贴地,注意，如果设成成贴地必须要有矢量或影像图层作为底图才能显示贴地的要素
			            geometry.ZType = 0;
						geometry.PutViewRange(0, 36000000);
						//样式
						var rgb = style.fillColor.replace("#","");
						var argb = Geo.Util.ToArgb(rgb,parseInt(style.strokeOpacity * 255));
						//第一个参数是线的宽度，第二个参数是ARGB值
			            var style = globe.DrawBox.CreatePointSymbolObject(style.pointRadius, argb);
						drawBox.AddOrReplaceGeometry(geometry, style);	
//						var geometry = drawBox.CreateGeometryObject(wkt,null,1,1);
//						var pointSybol = drawBox.CreatePointSymbolObject(10, -65536);
//						geometry.ZType= 0;
//						geometry.Key = OpenLayers.Util.createUniqueID("point" + "_");
//						options.feature.geometry._3dGeometry = geometry;
//						var points = this._getPointGeometryArr(options.strPoints);
//						drawBox.AddDrawObject(geometry,pointSybol);				
					}
                    break;
                case 1:
					//第三个参数1表示point ,2表示lineString,3表示Ring,4表示Model，5表示 Box
					var geometry = globe.DrawBox.CreateGeometryObject(wkt, "", 2, 1);
		            geometry.Key = options.featureid;
		            geometry.ZType = 0;//0表示贴地， 1 表示贴近海平面， 2表示相对于地标，3表示绝对坐标(相对于海平面)
		            geometry.PutViewRange(0, 36000000);
					var rgb = style.strokeColor.replace("#","");
					var argb = Geo.Util.ToArgb(rgb,parseInt(style.strokeOpacity * 255));
					//第一个参数是线的宽度，第二个参数是ARGB值
		            var style = globe.DrawBox.CreateLineSymbolObject(style.strokeWidth, argb);
		            drawBox.AddOrReplaceGeometry(geometry, style);
	                break;
                case 2:
					var geometry = globe.DrawBox.CreateGeometryObject(wkt, "", 3, 1);
		            geometry.Key =  options.featureid;
		            geometry.ZType = 0; //0表示贴地， 1 表示贴近海平面， 2表示相对于地标(相对地面)，3表示绝对坐标(相对于海平面)
		            geometry.PutViewRange(0, 36000000);
					var rgb = style.strokeColor.replace("#","");
					//rgb和透明度转ARGB
					var argb = Geo.Util.ToArgb(rgb,parseInt(style.strokeOpacity * 255));
					//第一个参数是线的宽度，第二个参数是ARGB值
					var sym2 = globe.DrawBox.CreateLineSymbolObject(style.strokeWidth, argb);
					//面的填充色
					var fillrgb = style.fillColor.replace("#","");
					var fillargb = Geo.Util.ToArgb(fillrgb,parseInt(style.fillOpacity * 255));
            		var style = globe.DrawBox.CreateFillSymbolObject(fillargb, sym2);
		            drawBox.AddOrReplaceGeometry(geometry, style);
                    break;
                default:
                    return;            
			}
			
        };
    },
    
    _delGeometryByName: function(geometry,drawBox){
		//根据key删除要素
		drawBox.DeleteGeometry(geometry);
    },
	
	_delBookMark: function(geometry,drawBox){
		drawBox.RemovePOI(geometry);            
	},
            
    //删除矢量图层对象
    _removeVectorLayerData: function(ILayerWrapper){
        var globe = this.activexObj;
        if(globe){
    		globe.GetSceneGroup().RemoveLayer(ILayerWrapper);
        }
    },
    
    //上移图层
	/*
	 * // 图层移动方式的枚举变量
	_enumMoveLayerType: {
		MOVE_TO_TOP:0, //移动图层到顶层显示
		MOVE_TO_BOTTOM:1, //移动图层到底层显示
		MOVE_UP:2, //向上移动一层
		MOVE_DOWN:3 //向下移动一层
	},
	 */
    _moveLayerUp:function(layerData){
        var globe = this.activexObj;
        if (globe) {
            globe.LayerBox.UserGroupLayer.MoveLayer(layerData, this._enumMoveLayerType["MOVE_UP"]);
        }
    },
    
    //下移图层
    _moveLayerDown:function(layerData){
        var globe = this.activexObj;
        if (globe) {
            globe.LayerBox.UserGroupLayer.MoveLayer(layerData, this._enumMoveLayerType["MOVE_DOWN"]);
        }
    },
    
    //跳转到指定图层
    _gotoLayer: function(layerData){
        var globe = this.activexObj;
        if (layerData && globe) {
			var bounds = this._createLayerOperate(this._enumLayerOperateType["layerBounds"], layerData, {});
			this.zoomToExtent(bounds,true);
        };
    },

    //设置图层透明度
    //layer为要调整透明度的图层对象（之所以用图层对象而不用图层名称，是为了在需要时能调整无名图层的透明度）
    //三维插件透明度的值的范围是0-255
    _setLayerOpacity: function(layerData, opacity){
        var globe = this.activexObj;
        if (globe) {
			this._createLayerOperate(this._enumLayerOperateType["opacity"], layerData, {opacity : opacity});
        }
    },
	
	_setLayerVisibility: function(layerData,display) {
		 var globe = this.activexObj;
        if (globe) {
			this._createLayerOperate(this._enumLayerOperateType["visible"], layerData, {visible : display});
        }
	},

	//添加WMTS服务
    _addWMTSService: function(url, layerName){
    
        var globe = this.activexObj;
        if (globe) {
            var wmsObj = globe.GetLayerBox();
            if(null == url || undefined == url){
                url = "";
			}
            var layerBox = wmsObj.GetWmtsInfo(url);//传入服务地址
            var ILayerWrapperArr = [];
            var i = layerBox.GetCount(); //得到图层的个数
            for (var j = 0; j < i; j++) {
                var layerinfo = layerBox.GetResByIndex(j);//得到里面的一个图层
                // 根据图层名称和传进参数的图层名称相同则加载至场景中
                if (!layerName || layerinfo.Name == layerName) {
                    var layerdata = wmsObj.AddOneWmtsLayer(layerinfo, "");//添加一个图层到场景中
                    globe.GetCameraWrapper().GoToLayer(layerdata);//定位到图层
                    ILayerWrapperArr.push(layerdata);
                }
            }
            return ILayerWrapperArr;
        }
    },
    
	//添加WMS服务
    _addWMSService: function(url, layerName){
		var layerArr = layerName.split(",");
        if (!layerName) {
            return;
        };
        var globe = this.activexObj;
        if (globe) {
            var wmsObj = globe.GetOGCBox();//得到IWmsConMng对象
            if(null == url || undefined == url){
                url = "";
			}
            //设置wms服务地址并返回图层信息
            var layerBox = wmsObj.GetWmsLayersInfo(url);
            
            //遍历每一个图层信息  wmsObj.AddWmsInfoData();
			var ILayerWrapperArr = [];
            for (var j = 0,len = layerBox.GetWmsInfoCount(); j < len; j++) {
                var layerinfo = layerBox.GetWmsInfoByIndex(j);
                for(var m = 0;m < layerArr.length; m++) {
					if (layerinfo.Name == layerArr[m]) {
	                    var ILayerWrapper = wmsObj.ConSelecedLayers(false, 200, 1, 20, true, 255, "image/png", layerinfo);
	                    ILayerWrapper.Name = layerinfo.Name;
	                    globe.GetLayerBox().AddLayerData(ILayerWrapper);
						ILayerWrapperArr.push(ILayerWrapper);
                	};
				}
                
            };
			return ILayerWrapperArr;
        };
    },
    
	//添加WCS服务
    _addWCSService: function(url){
        var globe = this.activexObj;
		var ILayerWrapper = null;
        if (globe) {
			if(null == url || undefined == url){
                url = "";
			}
            var ILayerBox = globe.GetOGCBox().ConnectWCS(url);
			ILayerWrapper= ILayerBox.GetLayerByIndex(0);
        };
        return ILayerWrapper;
    },
	
	//添加矢量图层
	_addVectorLayer:function(){
		var activexObj =  this.activexObj;
		//创建矢量图层对象 GeometryLayer = 0; DynamicLayer = 1; ElementLayer = 2
		var geometryLayer = activexObj.ObjectFactory.CreateObject(0);
		//将矢量图层添加到地图
		activexObj.LayerBox.UserGroupLayer.AddLayer(geometryLayer);
		return geometryLayer;
	},
	
	_addDynamicLayer: function() {
		//创建矢量图层对象
		var activexObj = this.activexObj;
		var dynamicLayer = activexObj.ObjectFactory.CreateObject(1);
		//将矢量图层添加到地图
		activexObj.LayerBox.UserGroupLayer.AddLayer(dynamicLayer);
		return dynamicLayer;
	},
	
	//添加自定义图层
	_addCustomLayer: function(strJson){
		//创建自定义图层
		var activexObj = this.activexObj;
		var customLayer = activexObj.DataSourceBox.CreateLayerFromJson(strJson);
		//将自定义图层加到地图
		activexObj.LayerBox.UserGroupLayer.AddLayer(customLayer);
		return customLayer;
	},
	
	//转换颜色字符串为十进制
	_convertColorValue: function(webcolor){
		return new Number("0x00" + webcolor.replace("#",""));
	},
	
	//图层操作枚举
	_enumLayerOperateType: {
		"visible" : 1,
	//	"type" : 3,
		"opacity" : 2,
		"object" : 4,
		"layerBounds" : 3,//获取图层范围
		"wmsLayerinfo" : 6,
		"wmtsLayerinfo" : 7
		
	},
	
	/*
	 * 对图层相关属性进行操作
	 * 
	 */
	_createLayerOperate: function(number,layer,options) {
		var layerOperate = this.activexObj.LayerBox.CreateLayerOperate(layer);
		switch(number) {
			case this._enumLayerOperateType["visible"]:
			//	layerOperate.LayerProperty(number) = options.visible;
				layerOperate.ChangeLayerProperty(number, options.visible);
				break;
			case this._enumLayerOperateType["opacity"]:
//				layerOperate.LayerProperty(number) = parseInt(options.opacity * 255);
				layerOperate.ChangeLayerProperty(number, parseInt(options.opacity * 255));
			break;
			case this._enumLayerOperateType["layerBounds"]:
				var bbox = layerOperate.LayerProperty(number);
				bbox = eval(bbox);
				var bounds = new Geo.Bounds(bbox[2],bbox[1],bbox[3],bbox[0]);
				return bounds;
			break;
		}
		
	},	
	
    /**
     * Method: unloadDestroy
     * 窗口关闭时销毁地图对象的方法
     */	 
	unloadDestroy: function(){
	},
	
	/**
     * APIMethod: isSuspend
     * 设置是否开启球体刷新线程。
     * 
     * Parameters:
     * isSuspend - {Boolean} true开启，false关闭。
     */
	isSuspend: function(isSuspend){
		this.activexObj.Suspend = isSuspend;
	},
	
	/**
     * APIMethod: setFocusAlways
     * 设置是否开启抢占焦点。
     * 
     * Parameters:
     * isOpen - {Boolean}，true开启，false关闭。
     */
	setFocusAlways: function(isOpen){
		this.activexObj.ConfigBox.SaveConfigItem(26,isOpen);
	},

    CLASS_NAME: "Geo.View3D.Map"

});

//缺省海拨高度(米)
Geo.View3D.Map.DEFAULT_ALT = 2500000;

Geo.View3D.Map.getActivex = function(id){
    var version = "";
    var activexObj = null;
    try {
        //初始化插件
        activexObj = document.createElement("object");
        activexObj.classid = "CLSID:535CEBE1-7D19-4203-AA3B-B1B40167BF86";
        activexObj.width = "100%";
        activexObj.height = "100%"; 
        if(id){
            activexObj.id = id;
        }
        version = activexObj.Version;
    } 
    catch (e) {
    }
    return {
        obj:activexObj,
        version:version
    };
};

Geo.View3D.Map.getActivexVersion = function(){
	if(Geo.View3D.Map.activexVersion){
		return Geo.View3D.Map.activexVersion;
	}
	
    var GeoControlVersion;
    try{
        GeoControlVersion = new ActiveXObject("GeoSpace3D.ControlVersion.1");
		Geo.View3D.Map.activexVersion = GeoControlVersion.Version;
    }catch(e){
        return null;
    }
    return Geo.View3D.Map.activexVersion;
};

Geo.View3D.Map.ACTIVEX_DEFAULT_VERSION = "1.3.1.55185";

//图层级别换算成高度
Geo.View3D.Map.zoomMaping = [];
Geo.View3D.Map.zoomMaping[0] = 23000000;
Geo.View3D.Map.zoomMaping[1] = 15000000;
Geo.View3D.Map.zoomMaping[2] = 10000000;
Geo.View3D.Map.zoomMaping[3] = 9000000;
Geo.View3D.Map.zoomMaping[4] = 5916173;
Geo.View3D.Map.zoomMaping[5] = 2958087;
Geo.View3D.Map.zoomMaping[6] = 1479044;
Geo.View3D.Map.zoomMaping[7] = 739522;
Geo.View3D.Map.zoomMaping[8] = 369761;
Geo.View3D.Map.zoomMaping[9] = 184881;
Geo.View3D.Map.zoomMaping[10] = 92441;
Geo.View3D.Map.zoomMaping[11] = 46221;
Geo.View3D.Map.zoomMaping[12] = 23111;
Geo.View3D.Map.zoomMaping[13] = 11556;
Geo.View3D.Map.zoomMaping[14] = 5778;
Geo.View3D.Map.zoomMaping[15] = 2889;
Geo.View3D.Map.zoomMaping[16] = 1445;
Geo.View3D.Map.zoomMaping[17] = 723;
Geo.View3D.Map.zoomMaping[18] = 362;
Geo.View3D.Map.zoomMaping[19] = 181;
Geo.View3D.Map.zoomMaping[20] = 1;

/**
 * APIMethod: getZoomfromAlt
 * 根据高度返回金字塔级别。
 * 
 * Parameters:
 * alt - {Number} 海拔高度
 * Returns:
 * {Number} 金字塔级别 
 */
Geo.View3D.Map.getZoomfromAlt = function(alt){
    for (var i = 0; i < Geo.View3D.Map.zoomMaping.length; i++) {
    	// 如果当前高度大于等于级别为0的高度，则返回0。
    	if (alt >= Geo.View3D.Map.zoomMaping[0]) {
       		return i;
    	}
    	// 如果当前高度大于等于当前级别的高度并且小于前一级别换算的高度，则返回当前级别。
    	if (alt >= Geo.View3D.Map.zoomMaping[i] && i != 0 && alt < Geo.View3D.Map.zoomMaping[i - 1]) {
        	return i;
    	}
    	// 如果当前高度小于等于级别为20的高度，则返回20。
    	if (alt < Geo.View3D.Map.zoomMaping[Geo.View3D.Map.zoomMaping.length - 1]) {
        	return Geo.View3D.Map.zoomMaping.length - 1;
    	}
	}
};

/**
 * APIMethod: getAltfromZoom
 * 根据金字塔级别返回对应的三维海拔高度。
 * 
 * Parameters:
 * zoom - {Number} 金字塔级别
 * Returns:
 * {Number} 海拔高度
 */
Geo.View3D.Map.getAltfromZoom = function(zoom){
    var z = Geo.View3D.Map.zoomMaping[zoom];
    return z ? z : 0;
};

//根据金字塔级别返回对应的三维海拔高度
Geo.View3D.Map.getZfromLevel = Geo.View3D.Map.getAltfromZoom;

/**
 * APIProperty: activexErrorInfo
 * {String} 缺省三维插件错误提示信息。
 */	    
// Geo.View3D.Map.activexErrorInfo = "对不起，您电脑上未安装三维视图所需插件或插件版本不适合本系统，请重新安装适当版本后重新刷新本页面。";
Geo.View3D.Map.activexErrorInfo = "";

//为修复三维定位在某些地点，因海拨高度而撞地，限定到一定级别
Geo.View3D.Map.ZOOMTOEXTENT_MINILEVEL = 17;

//三维地图如果使用代理服务，图层http请求数据，请求标头需要referer。一般设置为window.location.href
Geo.View3D.Map.HTTP_REFERER = "";
/**
 * Class: Geo.View3D.Layer
 * 三维视图下的图层基类。本类不直接使用,需要由子类继承。
 */
Geo.View3D.Layer = Geo.Class({
	
    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,

    /** 
     * APIProperty: name
     * {String} 图层名称。
     */
    name: null,
	
    /**
     * APIProperty: opacity
     * {Float} 图层的透明度，值在0.0与1.0之间。
     */
    opacity: 1.0,
	
    /**
     * APIProperty: map
     * {Geo.View3D.Map} 图层所在的地图对象。
     */
    map: null,
	
    /** 
     * APIProperty: displayInLayerSwitcher
     * {Boolean} 图层名称是否在图层列表中显示,默认值为true。
     */
    displayInLayerSwitcher: true,
	
	/**
	 * APIProperty: isOnTop
	 * {Boolean} 图层是否在图层列表中置顶，默认值为false。
	 */
	isOnTop: false,
	
	/**
     * APIProperty: events
     * {<Geo.Events>} 事件对象。
     */
    events: null,	

    /**
     * APIProperty: visibility
     * {Boolean} 图层是否在地图中可见，默认值为true。
     */
    visibility: true,

    /**
     * Constant: EVENT_TYPES
     * {Array(String)} 图层对象所支持的事件类型。
     * 
     * 本对象支持以下事件类型：
     * visibilitychanged - 可视状态改变事件。
     */
    EVENT_TYPES: ["visibilitychanged"],
	
	/**
	 * Constructor: Geo.View3D.Layer
	 * Geo.View3D.Layer构造函数。
	 *
	 * Parameters:
	 * name - {String} 图层名称。
	 * options - {Object} 选项。
	 */	 
    initialize: function(name, options) {
		
		this.addOptions(options);
		
        this.name = name;
        
        if (this.id == null) {
            this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
			
			this.events = new OpenLayers.Events(this, this.div, 
                                                this.EVENT_TYPES);
            if(this.eventListeners instanceof Object) {
                this.events.on(this.eventListeners);
            }
        }
    },

	/**
	 * Method: setMap
	 * 将图层关联到地图对象，如果该图层已经关联到地图对象了则不做任何操作。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>)} 地图对象。
	 */	
    setMap: function(map) {
        if (this.map != null) {
            return;
        }
        this.map = map;
		var activexObj = this.map.activexObj;
		//通过DataSourceBox可以获得图层对象
		this.dataSourceBox = activexObj.DataSourceBox;
		//通过LayerBox可以将图层添加到地图，也可以实现图层的显示隐藏删除等操作
		this.layerBox = activexObj.LayerBox;
    },

	/**
	 * APIMethod: removeMap
	 * 解除图层与地图对象的关联。
	 */	    
    removeMap: function() {
        //此方法由子类覆盖
    },

	/**
	 * APIMethod: getVisibility
	 * 获取图层可视状态。
	 * 
     * Returns:
     * {Boolean} 图层可视状态。
	 */	
    getVisibility: function() {
        return this.visibility;
    },

    /**
     * APIMethod: setVisibility
     * 设置图层是否可视。
     * 
	 * Parameters:
	 * visibility - {Boolean} 是否可见。
     */
    setVisibility: function(visibility) {
        if (visibility != this.visibility) {
            this.visibility = visibility;
            this.display(visibility);
        }
    },

    /**
     * Method: display
     * 显示或隐藏图层，此方法由子类覆盖。
     * 
	 * Parameters:
	 * display - {Boolean} 是否可见 。
     */
    display: function(display) {
        //此方法由子类覆盖
    },
	
    /**
     * APIMethod: setOpacity
     * 仅对透明度的值进行判断，如果与当前透明度相同则返回。
     * 
	 * Parameters:
	 * opacity - {Float} 
     */
    setOpacity: function(opacity) {
        if (opacity === this.opacity) {
            return;
        }
    },
	
    /**
     * APIMethod: getOptions
     * 获取图层构造参数。
     * 
     * Returns:
     * {Object} 图层构造参数。
     */
    getOptions: function() {
        var options = {};
        for(var o in this.options) {
            options[o] = this[o];
        }
        return options;
    },
	
    /**
     * APIMethod: addOptions
     * 添加图层构造参数。
     */
    addOptions: function (newOptions) {

        if (this.options == null) {
            this.options = {};
        }

        // update our copy for clone
        OpenLayers.Util.extend(this.options, newOptions);

        // add new options to this
        OpenLayers.Util.extend(this, newOptions);

    },
	
    /**
     * APIMethod: destroy
     * 销毁图层。
     */
	destroy: function(){
        this.map = null;
        this.name = null;
        this.dataSourceBox = null;
		this.layerBox = null;
        this.options = null;

        if (this.events) {
            if(this.eventListeners) {
                this.events.un(this.eventListeners);
            }
            this.events.destroy();
        }
        this.eventListeners = null;
        this.events = null;
	},
	
    CLASS_NAME: "Geo.View3D.Layer"
});
﻿/**
 * Class: Geo.View3D.BaseLayerGroup
 * 三维视图的底图图层组对象，可以将多个图层对象组合在一起，进行统一的加载和卸载操作。该图层组中的图层
 * 将做为地图中的底图置于所有图层的最下方。
 */
Geo.View3D.BaseLayerGroup = Geo.Class({

    /**
     * APIProperty: id
     * ｛String｝唯一标识符。
     */
    id: null,
    
    /**
     * APIProperty: layers
     * {Array} 图层集合。
     */
    layers: null,
    
    /**
     * APIProperty: map
     * 图层所在地图对象的引用。
     */
    map: null,
    
    /**
     * Constructor: Geo.View3D.BaseLayerGroup
     * Geo.View3D.LayerGroup构造函数。
     * 
     * Parameters:
     * options - {Object} 相关选项设置
     * 
     * 示例代码：
     * 
     * (code)
     * var vectorGroup = new Geo.View3D.BaseLayerGroup({
     *      layers: [
     *          new Geo.View3D.Layer.GlobeTile("全球1:100万矢量底图", "http://tile0.tianditu.com/services/A0512_EMap"), 
     *          new Geo.View3D.Layer.GlobeTile("全球1:100万矢量注记", "http://tile0.tianditu.com/services/AB0512_Anno")
     *      ]
     *  });
     * (end)
     */
    initialize: function(options){
        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        OpenLayers.Util.extend(this, options);
        if (!this.layers) 
            this.layers = [];
    },
    
    /**
     * APIMethod: setMap
     * 将图层组关联到地图
     *
     * Parameters:
     * map - {OpenLayers.Map} 设置地图对象
     */
    setMap: function(map){
        if (map && !this.map) {
            this.map = map;
            this.map.addLayers(this.layers);
        }
    },
    
    CLASS_NAME: "Geo.View3D.BaseLayerGroup"

});

Geo.View3D.BaseLayerGroup.getTianDiTuGroup = function(type){
    
    var typeMapping = {
        "img":[
            new Geo.View3D.Layer.GlobeTile("全球影像底图(2-10)", "http://tile0.tianditu.com/services/sbsm0210"),
            new Geo.View3D.Layer.GlobeTile("全球影像注记(2-10)", "http://tile0.tianditu.com/services/A0104_ImgAnnoE"),
            new Geo.View3D.Layer.GlobeTile("全国影像(14)", "http://tile0.tianditu.com/services/eastdawnall"),
            new Geo.View3D.Layer.GlobeTile("全球影像(15-18)", "http://tile0.tianditu.com/services/sbsm1518"),
            new Geo.View3D.Layer.GlobeTile("全国影像(13)", "http://tile0.tianditu.com/services/e13"),
            new Geo.View3D.Layer.GlobeTile("全国影像(12)", "http://tile0.tianditu.com/services/e12"),
            new Geo.View3D.Layer.GlobeTile("全国影像(11)", "http://tile0.tianditu.com/services/e11"),
            new Geo.View3D.Layer.GlobeTile("全国影像注记(11-14)", "http://tile0.tianditu.com/services/B0530_eImgAnno"),
            new Geo.View3D.Layer.GlobeTile("全国影像注记(15-18)", "http://tile0.tianditu.com/services/siweiAnno68")
        ],
        "dlg":[
            new Geo.View3D.Layer.GlobeTile("全国矢量(2-10)", "http://tile0.tianditu.com/services/A0512_EMap"),
            new Geo.View3D.Layer.GlobeTile("全国矢量注记(2-10)", "http://tile0.tianditu.com/services/AB0512_Anno"),
            new Geo.View3D.Layer.GlobeTile("全国矢量(11-12)", "http://tile0.tianditu.com/services/B0627_EMap1112"),
            new Geo.View3D.Layer.GlobeTile("全国矢量(13-18)", "http://tile0.tianditu.com/services/siwei0608")
        ]
    };
    
    var layers = typeMapping[type];
    if(layers){
        return new Geo.View3D.BaseLayerGroup({layers: layers});
    }
    return null;
};

Geo.View3D.BaseLayerGroup.getTDTGroup = function(type){
    if(type == null || type == undefined || type == ""){
		type = "vec";
	}
    /*
     * 服务相关信息定义
     */
    var serviceInfo = {
        "vec": [{
			url: "http://t0.tianditu.com/vec_c/wmts",
            name: "1-18级WMTS矢量底图",//名称
            projection: "EPSG:4326",//当前图层使用的投影
			opacity: 1,//图层透明度
            style: "default",//样式标识
            layer: "vec",//图层标识
            format: "tiles",//数据格式
            matrixSet: "c",//矩阵集名称
			topLevel: 1,//图层顶层级别
			bottomLevel: 18,//图层底层级别
            tileFullExtent: Geo.Bounds.fromString("-180.0,-90.0,180.0,90.0")//图层范围
		},{
			url: "http://t0.tianditu.com/cva_c/wmts",
            name: "1-18级WMTS矢量中文注记",//名称
            projection: "EPSG:4326",//当前图层使用的投影
			opacity: 1,//图层透明度
            style: "default",//样式标识
            layer: "cva",//图层标识
            format: "tiles",//数据格式
            matrixSet: "c",//矩阵集名称
			topLevel: 1,//图层顶层级别
			bottomLevel: 18,//图层底层级别
            tileFullExtent: Geo.Bounds.fromString("-180.0,-90.0,180.0,90.0")//图层范围
		}],
        "img": [{
			url: "http://t0.tianditu.com/img_c/wmts",
            name: "1-18级WMTS影像底图",//名称
            projection: "EPSG:4326",//当前图层使用的投影
            opacity: 1,//图层透明度
            style: "default",//样式标识
            layer: "img",//图层标识
            format: "tiles",//数据格式
            matrixSet: "c",//矩阵集名称
			topLevel: 1,//图层顶层级别
			bottomLevel: 18,//图层底层级别
            tileFullExtent: Geo.Bounds.fromString("-180.0,-90.0,180.0,90.0")//图层范围
        }, {
			url: "http://t0.tianditu.com/cia_c/wmts",
            name: "1-18级WMTS影像注记底图",//名称
            projection: "EPSG:4326",//当前图层使用的投影
            opacity: 1,//图层透明度
            style: "default",//样式标识
            layer: "cia",//图层标识
            format: "tiles",//数据格式
            matrixSet: "c",//矩阵集名称
			topLevel: 1,//图层顶层级别
			bottomLevel: 18,//图层底层级别
            tileFullExtent: Geo.Bounds.fromString("-180.0,-90.0,180.0,90.0")//图层范围
        }]
    };
    
	var layers = [];
	if(serviceInfo[type]){
	    for (var i = 0; i < serviceInfo[type].length; i++) {
	    	layers.push(new Geo.View3D.Layer.WMTS(serviceInfo[type][i]));
	    }
	}
    if(layers && layers.length > 0){
        return new Geo.View3D.BaseLayerGroup({layers: layers});
    }
    return null;
};﻿//此类已被废弃，推荐使用Geo.View3D.BaseLayerGroup代替
Geo.View3D.LayerGroup = Geo.View3D.BaseLayerGroup;﻿/**
 * Class: Geo.View3D.Layer.ArcgisRest
 * 三维视图下的ArcGis REST服务图层对象。在三维视图下，添加ArcGis REST服务，请使用本类。
 * 
 * Inherits from:
 *  - <Geo.View3D.Layer>
 */
Geo.View3D.Layer.ArcgisRest = Geo.Class(Geo.View3D.Layer,{
    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,
	
	/**
     * APIProperty: url
     * {String} 服务地址。
     */
    url: null,
    
    _layerData: null,
    
	/**
     * Constructor: Geo.View3D.Layer.ArcgisRest
     * 构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 选项。
  	 * 例如：
  	 * (code)
	 * 	  var layer = new Geo.View3D.Layer.ArcgisRest("arcgisRest", 
	 * 	  "http://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/export",
	 *     {
	 *      	format:"png",//请求的图片格式，默认：jpeg,必填
	 *      	transparent: "TRUE"//请求的瓦片背景区域是否透明,默认：TRUE	
	 *     },
	 *     {	
	 *      	//支持级别，分辨率，比例的用法，任一选择
	 *      	topLevel:0,//顶层级别，默认：0
	 *      	bottomLevel:20,//底层级别，默认：20
	 *       	opacity : 1,//图层透明度设置，可以设置：0-1，默认：1
	 *      	projection: "EPSG:4326",//当前图层使用的投影,默认EPSG:4326
	 *       	width:"256",//图片宽度，默认：256
	 *       	height:"256",//图片高度，默认：256
	 *       	//图层范围,默认为全球范围：-180,-90,180,90,必填
	 *       	maxExtent:Geo.Bounds.fromString("73.446960,6.318641,135.085830,53.557926")	
	 *		    //支持分辨率
	 *		    //maxResolution :0.000005364418029785156,//最大分辨率
	 *  		//minResolution :0.703125//最小分辨率
	 *   		//支持比例尺
	 *   		//minScale : 2.958293554545656E8,
	 *   		//maxScale : 2256.998866688275
	 *     });。
	 * (end)           
     */	      
    initialize: function(name, url, params, options) {
       //与二维一致的新的三维图层加载方式
    	params = params || {};
    	params.pyramid = params.pyramid ? params.pyramid : new Geo.Pyramid();
//    	if(typeof params.projection == "string") {
//            this.projection = new Geo.Projection(params.projection);
//        }
//        if(this.projection && this.projection.getUnits()) {
//            this.units = this.projection.getUnits();
//        }
		if(options.maxResolution){
			params.bottomLevel = params.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			params.topLevel = params.pyramid.getLevelForResolution(options.minResolution);
		}
		
		if(options.maxScale){
			params.bottomLevel = params.pyramid.getLevelForScale(options.maxScale);
		}
		if(options.minScale){
			params.topLevel = params.pyramid.getLevelForScale(options.minScale);
		}
    	var args = [name, url, options];
    	this.params = params;
        Geo.View3D.Layer.GlobeTile.prototype.initialize.apply(this, args);
    },

	/**
	 * APIMethod: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
    setMap: function(map) {
		this._createLayerFromJson(map);
	},

	//自定义图层方式
    _createLayerFromJson : function(map){
    	var DEFAULT_PARAMS = 
		{ 
	      request: "GetTile",
	      styles: "",
	      format: "png"
	     };
	    /**所有的服务的公共参数**/ 
	    //默认为影像：ImageDataType，矢量：VectorDataType，模型数据：ModelDataType， Lod模型数据：LodModelDataType，POI数据：POIDataType
	    var dataType= this.params.dataType ? this.params.dataType : "ImageDataType";    
	    //设置图层透明度，默认:100，可以设置:0-100
	    var renderTransparency = this.params.opacity >= 0 ? this.params.opacity * 100 : 100;
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.params.topLevel ? this.params.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.params.bottomLevel ? this.params.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.maxExtent ? this.options.maxExtent.left : -180;
	    var yMin = this.options.maxExtent ? this.options.maxExtent.bottom : -90;
	    var xMax = this.options.maxExtent ? this.options.maxExtent.right : 180;
	    var yMax = this.options.maxExtent ? this.options.maxExtent.top : 90;
	    //服务地址
	    var url = this.url;
	    //请求的图片格式
	    var format = this.params.format ? this.params.format : DEFAULT_PARAMS.format;
	    //请求的瓦片背景区域是否透明,默认为TURE
	    var transparent = this.params.transparent ? this.params.transparent : "TRUE";
	    //请求的图片宽度
	    var width = this.params.width ? this.params.width : 256;
	    //请求的图片高度
	    var height = this.params.height ? this.params.height : 256;
	    //获取投影
	    var projection = this.options.projection ? this.options.projection : "EPSG:4326";
	    //获取空间参数
	    var arr = projection.split(":");
	    var spatialReference = DEFAULT_PARAMS.spatialReference;
	    if(arr.length == 2){
	    	spatialReference = arr[1];
	    } else {
	    	spatialReference = arr[0];
	    }
	    //拼图层请求串
	    var layerJson = '{'+
		'"Referer":"' + Geo.View3D.Map.HTTP_REFERER + '",'+
		'"DataType":"'+dataType+'",'+
		'"DataSourceType":"Customer",'+
		'"StartLevel":'+dataSetStartLevel+','+
		'"EndLevel":'+dataSetEndLevel+','+
		'"XMin":'+xMin+','+
		'"YMin":'+yMin+','+
		'"XMax":'+xMax+','+
		'"YMax":'+yMax+','+
		'"SpatialReference":"'+spatialReference+'",' +
		'"RenderTransparency":'+renderTransparency+',' +
		'"ServerUrl":"'+ url +
		'?dpi=96&transparent='+transparent+'&format='+format+'&bbox=${TileXMin}%2C${TileYMin}%2C${TileXMax}%2C${TileYMax}' +
		'&size='+width+'%2C'+height+'&f=image';
		layerJson +='"}';
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    var layer = this.dataSourceBox.CreateLayerFromJson(layerJson);
	    this.layerBox.UserGroupLayer.AddLayer(layer);
	    this._layerData = layer;
    },
	
	/**
	 * APIMethod: removeMap
	 * 取消三维视图对象与图层关联。
	 *
	 */	    
    removeMap: function() {
        var map = this.map;
        if(map){
            map._removeLayerData(this._layerData);
			this._layerData = null;
        }
		this.map = null;
    },


	/**
	 * APIMethod: setVisibility
	 * 设置图层是否可见。
	 *
	 * Parameters:
	 * visibility - {Boolean} 是否可见
	 */	
    setVisibility: function(visibility) {
        if (visibility != this.visibility) {
            this.visibility = visibility;
            this.display(visibility);
        }
    },

	/**
	 * APIMethod: display
	 *
	 * Parameters:
	 * display - {Boolean} 
	 */	
    display: function(display) {
        if(display != this._layerData.LayerData.Visible){
            this._layerData.LayerData.Visible = display;
        }
    },

	/**
	 * APIMethod: setOpacity
	 * 设置图层不透明度，数值在0-1.0之间。
	 *
	 * Parameters:
	 * opacity - {Float} 透明度。
	 */	
    setOpacity: function(opacity) {
        Geo.View3D.Layer.prototype.setOpacity.apply(opacity);
        var map = this.map;
        if(map){
            map._setLayerOpacity(this._layerData,opacity);
            this.opacity = opacity;
        }
    },

	/**
	 * APIMethod: gotoCenter
	 * 定位到图层中心点。
	 * 图层定位的方法是通过图层的范围大小，计算一个相机高度，来实现定位的。 
	 * 在实际应用过程中，存在通过范围定位的高度换算成金字塔层级会高于/低于当前瓦片显示的金字塔范围。 
	 * 有可能存在定位准了，但是相机高度不对，有时候需要往下缩小或者往上放大才能看到图层的现象。 
	 */	    
    gotoCenter:function(){
        var map = this.map;
        if(map){
            map._gotoLayer(this._layerData);
        }
    },
	 	
    CLASS_NAME: "Geo.View3D.Layer.ArcgisRest"
});/**
 * Class: Geo.View3D.Layer.GlobeTile
 * 三维视图下的吉奥瓦片服务图层对象。在三维视图下，添加瓦片服务，请使用本类。
 * 
 * Inherits from:
 *  - <Geo.View3D.Layer>
 */
Geo.View3D.Layer.GlobeTile = Geo.Class(Geo.View3D.Layer,{
    
    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,
			
	/**
     * APIProperty: url
     * {String} 服务地址。
     */
    url: null,
	
	//吉奥瓦片图层类型
	_LAYER_TYPE_GLOBETILE:6,
	
    //私有图层对象
    _layerData: null,
    
	//判断用户使用的什么版本的api，由构造参数个数判断
	_oldLoad: null,
	/**
	 * Constructor: Geo.View3D.Layer.GlobeTile
	 * 构造函数。
	 *
	 * Parameters:
	 * name - {String} 服务名称。
	 * url - {String} 服务地址。
	 * options - {Object} 相关参数选项。
	 * 例如：
	 * (code)
	 * 	  var globeTile = new Geo.View3D.Layer.GlobeTile("globeTile", "http://192.168.40.69:9010/dlgtile0319/services/tile",
     *       	{
     *       		topLevel:1,//顶层级别，默认:0
	 *				bottomLevel:20,//底层级别，默认:20
	 *				maxExtent:Geo.Bounds.fromString("45,0,180,90"),//图层范围,默认范围:-180,-90,180,90，必填
     *       		opacity : 1,//图层透明度设置，可以设置：0-1，默认：1
     *       		projection: "EPSG:4326",//当前图层使用的投影,默认EPSG:4326
     *       		version:"5.0",//请求的服务版本，默认：2.0.0
	 *				//支持分辨率
	 *				//maxResolution :0.000005364418029785156,//最大分辨率
     *       		//minResolution :0.703125//最小分辨率
     *       		//支持比例尺
     *       		//minScale : 2.958293554545656E8,
     *       		//maxScale : 2256.998866688275      
     *       	});
     * (end)
	 */		      
    initialize: function(name, url, options) {
        //判断用户使用api版本
    	if(arguments.length < 3){
    		this._oldLoad = true;
    		Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        	this.url = url;
        	return;
    	}
    	//与二维一致的新的三维图层加载方式
    	options = options || {};
        options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		if(options.maxResolution){
			options.bottomLevel = options.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			options.topLevel = options.pyramid.getLevelForResolution(options.minResolution);
		}
		if(options.maxScale){
			options.bottomLevel = options.pyramid.getLevelForScale(options.maxScale);
		}
		if(options.minScale){
			options.topLevel = options.pyramid.getLevelForScale(options.minScale);
		}
		if(typeof options.projection == "string") {
        	this.projection = new Geo.Projection(options.projection);
        }
        if(this.projection && this.projection.getUnits()) {
            this.units = this.projection.getUnits();
        }
        Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        this.url = url;
    },

	/**
	 * Method: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
	setMap: function(map){
    	if(this._oldLoad){
    		this._oldSetMap(map);
    		return;
    	}
    	this._createLayerFromJson(map);
		this.display(this.visibility);
    },
    
    //老版本,参数内部构造
    _oldSetMap: function(map) {
        Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		this._layerData = map._addGlobeTileService(this.url,"",this._LAYER_TYPE_GLOBETILE);
    },
    
     //自定义图层方式
    _createLayerFromJson : function(map){
    	var DEFAULT_PARAMS = 
		{ 
	      version: "2.0.0",
	      request: "GetTile",
	      styles: "",
	      format: "image/png",
	      spatialReference : "4326"
	     };
	    /**所有的服务的公共参数**/ 
	    //默认为影像：ImageDataType，矢量：VectorDataType，模型数据：ModelDataType， Lod模型数据：LodModelDataType，POI数据：POIDataType
	    var dataType= this.options.dataType ? this.options.dataType : "ImageDataType";    
	    //设置图层透明度，默认:100，可以设置:0-100
	    var renderTransparency = this.options.opacity >= 0 ? this.options.opacity * 100 : 100;
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.options.topLevel ? this.options.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.options.bottomLevel ? this.options.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.maxExtent ? this.options.maxExtent.left : -180;
	    var yMin = this.options.maxExtent ? this.options.maxExtent.bottom : -90;
	    var xMax = this.options.maxExtent ? this.options.maxExtent.right : 180;
	    var yMax = this.options.maxExtent ? this.options.maxExtent.top : 90;
	    //服务地址
	    var url = this.url;
	    //请求的服务版本号，version版本为2.1的暂时不支持
	    var version = this.options.version ? this.options.version : DEFAULT_PARAMS.version;
	    //获取投影
	    var projection = this.options.projection ? this.options.projection : "EPSG:4326";
	    //获取空间参数
	    var arr = projection.split(":");
	    var spatialReference = DEFAULT_PARAMS.spatialReference;
	    if(arr.length == 2){
	    	spatialReference = arr[1];
	    } else {
	    	spatialReference = arr[0];
	    }
	    //拼图层请求串
	    var layerJson = '{'+
		'"Referer":"' + Geo.View3D.Map.HTTP_REFERER + '",'+
		'"DataType":"'+dataType+'",'+
		'"DataSourceType":"GeoTile",'+
		'"StartLevel":'+dataSetStartLevel+','+
		'"EndLevel":'+dataSetEndLevel+','+
		'"XMin":'+xMin+','+
		'"YMin":'+yMin+','+
		'"XMax":'+xMax+','+
		'"YMax":'+yMax+','+
		'"SpatialReference":"'+spatialReference+'",' +
		'"RenderTransparency":'+renderTransparency+',' +
		'"ServerUrl":"'+ url+'",' +
		'"Version":"'+ version;
		layerJson +='"}';
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    var layer = this.dataSourceBox.CreateLayerFromJson(layerJson);
	    this.layerBox.UserGroupLayer.AddLayer(layer);
	    this._layerData = layer;	
    },

	/**
	 * Method: removeMap
	 * 取消三维视图对象与图层关联。
	 *
	 */	    
    removeMap: function() {
        var map = this.map;
        if(map){
            map._removeLayerData(this._layerData);
        }
		this.map = null;
    },


	/**
	 * Method: setVisibility
	 * 设置图层是否可见。
	 *
	 * Parameters:
	 * visibility - {Boolean} 是否可见。
	 */	
    setVisibility: function(visibility) {
        if (visibility != this.visibility) {
        	this.visibility = visibility;
            this.display(visibility);
        }
    },

	/**
	 * Method: display
	 *
	 * Parameters:
	 * display - {Boolean} 
	 */	
    display: function(display) {
		if(!this._layerData){
			return;
		}
        if(display != this._layerData.Visible){
			var map = this.map;
			map._setLayerVisibility(this._layerData,display);
        }
    },

	/**
	 * Method: setOpacity
	 * 设置图层不透明度，数值在0-1.0之间。
	 *
	 * Parameters:
	 * opacity - {Float} 透明度。
	 */	
    setOpacity: function(opacity) {
        Geo.View3D.Layer.prototype.setOpacity.apply(opacity);
        var map = this.map;
        if(map){
            if (this._layerData) {
                map._setLayerOpacity(this._layerData,opacity);
            }
            this.opacity = opacity;
        }
    },

	/**
	 * Method: gotoCenter
	 * 定位到图层中心点。
	 * 图层定位的方法是通过图层的范围大小，计算一个相机高度，来实现定位的。 
	 * 在实际应用过程中，存在通过范围定位的高度换算成金字塔层级会高于/低于当前瓦片显示的金字塔范围。 
	 * 有可能存在定位准了，但是相机高度不对，有时候需要往下缩小或者往上放大才能看到图层的现象。 
	 */	    
    gotoCenter:function(){
        var map = this.map;
        if(map){
            if (this._layerData) {
                map._gotoLayer(this._layerData);
            }
        }
    },
	 	
    CLASS_NAME: "Geo.View3D.Layer.GlobeTile"
});/**
 * Class: Geo.View3D.Layer.Shape
 * 本地SHAPE文件图层对象。
 *
 * Inherits from:
 *  - <Geo.View3D.Layer>
 */
Geo.View3D.Layer.Shape = Geo.Class(Geo.View3D.Layer, {
	
	_LAYER_TYPE_Shape : 3,	
	
    /**
     * Constructor: Geo.View3D.Layer.Shape
     * 构造函数。
     *
     * Parameters:
     * name - {String} 图层名称。
     * url - {String} 文件地址。
     * options - {Object} 选项。
     */
    initialize: function(name, url, options){
        Geo.View3D.Layer.prototype.initialize.apply(this, [name, options]);
        this.url = url;
    },
	
	/**
	 * Method: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {Geo.View3D.Map} 三维视图对象。
	 */	
    setMap: function(map){
        Geo.View3D.Layer.prototype.setMap.apply(this, [map]);
        this._layerData = this._addShpDate(this.url);
    },
    
    //添加本地数据
    _addShpDate: function(path){
		var shapeLayer = this.dataSourceBox.CreateDataLayer(
                            this.url, null,
                          0);
		this.layerBox.UserGroupLayer.AddLayer(shapeLayer);
		this._layerData = shapeLayer;
    },
    
    CLASS_NAME: "Geo.View3D.Layer.Shape"
});
/**
 * Class: Geo.View3D.Layer.Terrain
 * 三维地形图层对象。
 *
 * Inherits from:
 *  - <Geo.View3D.Layer.GlobeTile>
 */
Geo.View3D.Layer.Terrain = Geo.Class(Geo.View3D.Layer.GlobeTile, {
	/**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,
    
	/**
     * APIProperty: url
     * {String} 服务地址。
     */
    url: null,
	
	//私有图层对象
    _layerData: null,
    
	//判断用户使用的什么版本的api，由构造参数个数判断
	_oldLoad: null,
	
	/**
	 * Constructor: Geo.View3D.Layer.Terrain
	 * 构造函数。
	 *
	 * Parameters:
	 * name - {String} 服务名称。
	 * url - {String} 服务地址。
	 * options - {Object} 相关参数选项。
	 * 例如：
	 * (code)
	 * 	  var globeTile = new Geo.View3D.Layer.Terrain("Terrain", 
	 * 			"http://192.168.40.69:9010/dlgtile0319/services/tile",
     *       	{
     *       		topLevel:1,//顶层级别，默认:0
	 *				bottomLevel:20,//底层级别，默认:20
	 *				maxExtent:Geo.Bounds(45,0,180,90),//图层范围,默认范围:-180,-90,180,90，必填
	 *              demDataType:"int16" // 地形数据类型，必填
     *       	});
     * (end)
	 */		      
    initialize: function(name, url, options) {
        //判断用户使用api版本
    	if(arguments.length < 3){
    		this._oldLoad = true;
    		Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        	this.url = url;
        	return;
    	}
    	//与二维一致的新的三维图层加载方式
    	options = options || {};
        options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		if(options.maxResolution){
			options.bottomLevel = options.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			options.topLevel = options.pyramid.getLevelForResolution(options.minResolution);
		}
		if(options.maxScale){
			options.bottomLevel = options.pyramid.getLevelForScale(options.maxScale);
		}
		if(options.minScale){
			options.topLevel = options.pyramid.getLevelForScale(options.minScale);
		}
		if(typeof options.projection == "string") {
        	this.projection = new Geo.Projection(options.projection);
        }
        if(this.projection && this.projection.getUnits()) {
            this.units = this.projection.getUnits();
        }
        Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        this.url = url;
    },	
			
	/**
	 * Method: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
    setMap: function(map) {
		if(this._oldLoad){
    		this._oldSetMap(map);
    		return;
    	}
    	this._createLayerFromJson(map);
		this.display(this.visibility);
    },
	
	/**
	 * Method: _oldSetMap
	 * 老版本，将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
    _oldSetMap: function(map) {
        Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		var TerrainDataset=this.dataSourceBox.CreateTerrainDataset(this.url);
	   	this.dataSourceBox.AddTerrainDataset(TerrainDataset);
		this._layerData = TerrainDataset;
    },	
	
	/**
	 * Method: _createLayerFromJson
	 * 自定义图层方式
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
    _createLayerFromJson : function(map){
    	var DEFAULT_PARAMS = 
		{ 
	      version: "2.0.0",
	      request: "GetTile",
	      styles: "",
	      format: "image/png",
	      spatialReference : "4326"
	     };
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.options.topLevel ? this.options.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.options.bottomLevel ? this.options.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.maxExtent ? this.options.maxExtent.left : -180;
	    var yMin = this.options.maxExtent ? this.options.maxExtent.bottom : -90;
	    var xMax = this.options.maxExtent ? this.options.maxExtent.right : 180;
	    var yMax = this.options.maxExtent ? this.options.maxExtent.top : 90;
		var demDataType = this.options.demDataType ? this.options.demDataType : "int16";
	    //服务地址
	    var url = this.url;
	    //拼图层请求串
	    var layerJson = '{'+
		'"Referer":"' + Geo.View3D.Map.HTTP_REFERER + '",'+
		'"StartLevel":'+dataSetStartLevel+','+
		'"EndLevel":'+dataSetEndLevel+','+
		'"DEMDataType":"'+demDataType+'",'+
		'"XMin":'+xMin+','+
		'"YMin":'+yMin+','+
		'"XMax":'+xMax+','+
		'"YMax":'+yMax+','+
		'"ServerUrl":"'+ url;
		layerJson +='"}';
	//	alert(demDataType);
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    var layer = this.dataSourceBox.CreateTerrainDatasetFromJson(layerJson);
	    this.dataSourceBox.AddTerrainDataset(layer);
	    this._layerData = layer;	
    },	
    
    /**
	 * Method: removeMap
	 * 取消三维视图对象与图层关联。
	 *
	 */
    removeMap: function() {
		if (!this._layerData){
			return;
		}else{
			this._removeMap();
		}
    },
	
    /**
	 * Method: _removeMap
	 * 取消三维视图对象与图层关联。
	 *
	 */
    _removeMap: function() {
		if(this._oldLoad){
			//老版本的删除方法
	    	var map = this.map;
	    	if(map){
	    		var globe = map.activexObj;
	    		var camera = globe.Camera;
	    		var terrainAccessor	= camera.TerrainAccessor;
	    		terrainAccessor.remove(this._layerData);
	    	}
	    	this.map = null;
    	}else{
    		//新版本的删除方法
    		this.dataSourceBox.RemoveTerrainDataset(this._layerData);
    	}    	
    },
    
    /**
	 * Method: setVisibility
	 * 设置图层是否可见。
	 *
	 * Parameters:
	 * visibility - {Boolean} 是否可见。
	 */	
    setVisibility: function(visibility) {
        this.visibility = visibility;
        this.display(visibility);   	 
    },    
	
    /**
	 * Method: display
	 * 显示或者隐藏图层
	 * 
	 * Parameters:
	 * display - {Boolean} 
	 */	
    display: function(display) {
		if (!this._layerData){
			return;
		}else{
			this._display(display);
		}
    },
	
    /**
	 * Method: _display
	 * 显示或者隐藏图层
	 * 
	 * Parameters:
	 * display - {Boolean} 
	 */	
    _display: function(display) {
		this.map.activexObj.ConfigBox.SaveConfigItem(19, display);
		return;
    },	
	
    CLASS_NAME: "Geo.View3D.Layer.Terrain"
});
/**
 * Class: Geo.View3D.Layer.Vector
 * 三维视图下的矢量图层类。本类主要用于在三维地图上对矢量要素(点,线,面)进行操作。
 * 
 * Inherits from:
 *  - <Geo.View3D.Layer>
 */
Geo.View3D.Layer.Vector = Geo.Class(Geo.View3D.Layer,{
    
	//三维插件用的矢量图层。
  	_geometryLayer:null,
	
	//三维插件用的标注图层。
	_dynamicLayer: null,
    
    
    /** 
     * APIProperty: features
     * {Array(<Geo.Feature.Vector>)} 图层上所有要素。
     */	
    features: null,
    
    /** 
     * APIProperty: selectedFeatures
     * {Array(<Geo.Feature.Vector>)}  被选择的要素。
     */	
	selectedFeatures: null,

    /** 
     * APIProperty: style
     * {Object} 图层缺省样式。
     */
    style: null,
	
    /**
     * Property: styleMap
     * {<Geo.StyleMap>}
     */
    styleMap: null,

    /**
     * APIProperty: EVENT_TYPES
     * {Array(String)} 对象所支持的事件类型，使用以下方式可以为特定事件注册一个事件监听器。
     * (code)
     * layer.events.register(type, obj, listener);
     * (end)
     *
     */
    EVENT_TYPES: ["beforefeatureadded", "beforefeaturesadded",
                  "featureadded", "featuresadded", "beforefeatureremoved",
                  "beforefeaturesremoved", "featureremoved", "featuresremoved",
                  "beforefeatureselected", "featureselected", "featureunselected", 
                  "beforefeaturemodified", "featuremodified", "afterfeaturemodified",
                  "vertexmodified", "sketchstarted", "sketchmodified",
                  "sketchcomplete", "refresh"],
	
	/**
     * Constructor: Geo.View3D.Layer.Vector
     * 构造Geo.View3D.Layer.Vector对象实例。
     *
     * Parameters:
     * name - {String}  图层名称。
     * options - {Object} 选项。
     *
     */  			  
    initialize: function(name, options) {
		
        this.EVENT_TYPES =
            Geo.View3D.Layer.Vector.prototype.EVENT_TYPES.concat(
            Geo.View3D.Layer.prototype.EVENT_TYPES
        );
				
        this.features = [];
		this.selectedFeatures = [];
        Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
    },
 	
	/**
	 * Method: setMap
	 * 将图层对象关联到地图。
	 *
	 * Parameters:
	 * map - {Geo.View3D.Map} 三维地图对象。
	 */	
    setMap: function(map) {
        Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		this._geometryLayer = map._addVectorLayer();
		this._dynamicLayer = map._addDynamicLayer();
		this._layerData = this._geometryLayer;
    },

	/**
	 * APIMethod: addFeatures
	 * 向图层中添加要素。说明：三维中添加的要素的颜色设置只能设置为#开头的样式。
	 *
	 * Parameters:
	 * features - {Array(<Geo.Feature.Vector>)} 要素数组。
	 */	    
    addFeatures: function(features) {
        if (!(Geo.Util.isArray(features))) {
            features = [features];
        }
        
        for (var i=0, len=features.length; i<len; i++) {
            var feature = features[i];
            
            if (!feature.style && this.style) {
                feature.style = OpenLayers.Util.extend({}, this.style);
            }
            this.features.push(feature);
            this.drawFeature(feature);
        }
        
    },
	
	/**
	 * APIMethod: drawFeature
	 * 画要素图层。
	 * 
	 * Parameters:
	 * features - {Object} 要素。
	 */
	drawFeature: function(feature) {
		var map = this.map;
        if (map) {
			map._drawGeometry({
				vectorLayerObj: this,
				featureid: feature.id,
				feature:feature,
				dynamicLayer: this._dynamicLayer,
				drawBox:this._geometryLayer,
				strPoints: this._getGeometryStr(feature.geometry),
				type: this._getGeometryType(feature.geometry),
				style: feature.style
			});
			feature.layer = this;
		}
	},

    /**
     * APIMethod: removeFeatures
     * 移除图层中的要素。
     * 
     * Parameters:
     * features - {Array(<Geo.Feature.Vector>)} 要素数组。
     */    
    removeFeatures: function(features) {
        if(!features) {
            return;
        }
        if (!(Geo.Util.isArray(features))) {
            features = [features];
        }
        
        for (var i = features.length - 1; i >= 0; i--) {
            var feature = features[i];
            var map = this.map;
            if (map) {
				//如果是点要素，并且样式指定为图片渲染，则删除标注
				if(feature.style && feature.geometry.CLASS_NAME == "OpenLayers.Geometry.Point" 
							&& feature.style.externalGraphic){
					map._delBookMark(feature.id,this._dynamicLayer);
				} else {
					map._delGeometryByName(feature.id,this._geometryLayer);
				}
            }
            this.features = OpenLayers.Util.removeItem(this.features, feature);
        }
    },

    /**
     * APIMethod: destroyFeatures
     * 删除并且销毁图层上的要素。
     *
     * Parameters:
     * features - {Array(<Geo.Feature.Vector>)} 要销毁的要素数组，此项可选，如果无此项则销毁图层上所有要素。
     * options - {Object}
     */
    destroyFeatures: function(features, options) {
        var all = (features == undefined); // evaluates to true if
                                           // features is null
        if(all) {
            features = this.features;
        }
        if(features) {
            this.removeFeatures(features, options);
            for(var i=features.length-1; i>=0; i--) {
                features[i].destroy();
            }
        }
    },

    /**
     * Method: removeMap
     * 移除3D视图。
     *
     * Parameters:
	 * map - {Geo.View3D.Map} 三维视图对象。
     */
    removeMap: function(map) {
		var map = this.map;
        if(map){
			this.destroyFeatures(this.features);
			this._geometryLayer = null;
			this._dynamicLayer = null;
        }
		this.map = null;
    },


    /**
     * Method: setVisibility
     * 设置图层是否可见。
     * 
     * Parameters:
     * visibility - {Boolean} 图层是否可见
     */  
    setVisibility: function(visibility) {
        if (visibility != this.visibility) {
            this.visibility = visibility;
            this.display(visibility);
        }
    },

    /**
     * Method: display
     * 
     * Parameters:
     * display - {Boolean} 
     */  
    display: function(display) {
		var map = this.map;
        if(map){
			map._setLayerVisibility(this._layerData, display);
			map._setLayerVisibility(this._dynamicLayer, display);
        }
    },

    //得到几何对象的类型。
    _getGeometryType: function(geometry){
        var maping = {
            "OpenLayers.Geometry.Point": 0,
            "OpenLayers.Geometry.LineString": 1,
            "OpenLayers.Geometry.Polygon": 2
        }
        
        return maping[geometry.CLASS_NAME];
    },
	
    /**
     * APIMethod: getFeatureBy
     * 通过给定的属性和值来查找要素。
     *
     * Parameters:
     * property - {String} 要素对象属性。
     * value - {String} 指定属性的值。
     *
     * Returns:
     * {<Geo.Feature.Vector>} 返回符合给定值的要素，如果无符合则返回null。
     */
    getFeatureBy: function(property, value) {
        var feature = null;
        for(var i=0, len=this.features.length; i<len; ++i) {
            if(this.features[i][property] == value) {
                feature = this.features[i];
                break;
            }
        }
        return feature;
    },

    /**
     * APIMethod: getFeatureById
     * 查找并返回指定id的要素。
     *
     * Parameters:
     * featureId - {String} 要素对象的id属性值。
     *
     * Returns:
     * {<Geo.Feature.Vector>} 
     */
    getFeatureById: function(featureId) {
        return this.getFeatureBy('id', featureId);
    },

     //获取几何对象相应字符串
    _getGeometryStr:function (geometry){
        //替换所有指定字符串
        String.prototype.replaceAll = function(s1, s2){
            return this.replace(new RegExp(s1, "gm"), s2);
        }
        
        var str = geometry.toString();
        var start = str.indexOf("(") + 1;
        var end = str.indexOf(")");
//		if(geometry instanceof OpenLayers.Geometry.Point) {
//			return "POINT("+str.slice(start,end)+" 100000"+")";
//		}
		if(geometry instanceof OpenLayers.Geometry.LineString){
           var lineArr = str.slice(start,end).split(",");
		   for(var i = 0; i < lineArr.length; i++) {
	   	      lineArr[i] = (lineArr[i] + " 100000");
		   }
		   var line = lineArr.join(",");
		   return "LINESTRING("+line+")";
        }
        if(geometry instanceof OpenLayers.Geometry.Polygon){
			 var polygonArr = str.slice(start+1,end).split(",");
		   for(var i = 0; i < polygonArr.length; i++) {
	   	      polygonArr[i] = (polygonArr[i] + " 100000");
		   }
		   var line = polygonArr.join(",");
		   return "Ring("+line+")";
        }
        return str;
    },
	
    /** 
     * APIMethod: getDataExtent
     * 计算图层上所有要素的最大范围。
     * 
     * Returns:
     * {<Geo.Bounds>} 所有要素的范围。
     */
    getDataExtent: function () {
        var maxExtent = null;
        var features = this.features;
        if(features && (features.length > 0)) {
            maxExtent = new Geo.Bounds();
            var geometry = null;
            for(var i=0, len=features.length; i<len; i++) {
                geometry = features[i].geometry;
                if (geometry) {
                    maxExtent.extend(geometry.getBounds());
                }
            }
        }
        return maxExtent;
    },
	
    CLASS_NAME: "Geo.View3D.Layer.Vector"
});/**
 * Class: Geo.View3D.Layer.WMS
 * 三维视图中的WMS服务图层对象。
 * 
 * Inherits from:
 *  - <Geo.View3D.Layer.GlobeTile>
 */
Geo.View3D.Layer.WMS = Geo.Class(Geo.View3D.Layer.GlobeTile,{
    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,
			
	/**
     * APIProperty: url
     * {String} 服务地址。
     */
    url: null,    

	_LAYER_TYPE_OGCWMS : 2,		
	/**
     * APIProperty: params
     * {String} WMS服务请求参数。
     */    
    params: null,
	
    //私有图层对象
    _layerData: null,

    //判断用户使用的什么版本的api，由构造参数个数判断
	_oldLoad: null,
			
	//默认参数
	DEFAULT_PARAMS :
	{
	  service: "WMS",
      version: "1.1.1",
      request: "GetMap",
      styles: "",
      format: "image/jpeg",
      spatialReference: "4326"
     },			
	/**
	 * Constructor: Geo.View3D.Layer.WMS
	 * 构造函数。
	 *
	 * Parameters:
	 * name - {String} 服务名称。
	 * url - {String} 服务地址。
	 * params - {Object} 服务请求参数。
	 * options - {Object} 选项。
     * 例如：
     * (code)
	 * 	  var wmsLayer = new Geo.View3D.Layer.WMS("wms", "http://192.168.40.69:9010/wms0319/wms",
	 *          {
	 *           	version:"1.1.1"//请求的服务版本，默认为：1.1.1
	 *           	layers: "China400w",//请求的图层名称，必填
	 *           	format:"image/jpeg",//请求的图片格式，默认：image/jpeg
	 *           	transparent: "false",//请求的瓦片背景区域是否透明,默认：true		
	 *           },
	 *           {	
	 *           	//级别(级别、分辨率、比例尺的参数设置，任选其一设置即可)
	 *           	topLevel:0,//顶层级别，默认：0
	 *           	bottomLevel:20,//底层级别，默认：20
	 *           	opacity : 1,//图层透明度设置，可以设置：0-1，默认：1
	 *           	projection: "EPSG:4326",//当前图层使用的投影,默认EPSG:4326
	 *           	tileSize: new Geo.Size(256,256),//瓦片宽度，瓦片高度，默认：256，256
	 *           	//图层范围,默认为全球范围：-180,-90,180,90,必填
	 *           	maxExtent:Geo.Bounds.fromString("73.446960,6.318641,135.085830,53.557926"),	
	 *				//分辨率
	 *				//maxResolution :0.000005364418029785156,//最大分辨率
     *       		//minResolution :0.703125//最小分辨率
     *       		//比例尺
     *       		//minScale : 2.958293554545656E8,
     *       		//maxScale : 2256.998866688275
	 *           });。
	 *  (end)         
	 */	    
    initialize: function(name, url, params, options) {
        this.url = url;
     	//判断用户使用api版本
    	if(arguments.length < 4){
    		this._oldLoad = true;
    		Geo.View3D.Layer.GlobeTile.prototype.initialize.apply(this,[name, url, options]);
			if(params && !params.version){
				params.version = "1.3.0";
			}
	        this.params = params;
	        return;
    	}
    	//与二维一致的新的三维图层加载方式
    	params = params || {};
    	params.pyramid = params.pyramid ? params.pyramid : new Geo.Pyramid();
		if(options.maxResolution){
			options.bottomLevel = params.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			options.topLevel = params.pyramid.getLevelForResolution(options.minResolution);
		}
		
		if(params.maxScale){
			options.bottomLevel = params.pyramid.getLevelForScale(options.maxScale);
		}
		if(params.minScale){
			options.topLevel = params.pyramid.getLevelForScale(options.minScale);
		}
		params.format = params.format ? this.DEFAULT_PARAMS.format : "image/jpeg";
    	var args = [name, url, options];
    	this.params = params;
        Geo.View3D.Layer.GlobeTile.prototype.initialize.apply(this, args);
		//layer is transparent        
        if (this.params.transparent && 
            this.params.transparent.toString().toLowerCase() == "true") {
            // jpegs can never be transparent, so intelligently switch the 
            //  format, depending on the browser's capabilities
            if (this.params.format == "image/jpeg") {
                this.params.format = OpenLayers.Util.alphaHack() ? "image/gif"
                                                                 : "image/png";
            }
        }
    },

    /**
     * Method: setMap
     * 将图层关联到指定三维视图对象。
     *
     * Parameters:
     * map - {Geo.View3D.Map} 三维视图对象。
     */
    setMap: function(map){
    	if(this._oldLoad){
    		this._oldSetMap(map);
    		return;
    	}
    	this._createLayerFromJson(map);
		this.display(this.visibility);
    },
    
	//老版本,参数内部构造
    _oldSetMap: function(map) {
        Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		var wmsLayer = this.dataSourceBox.CreateDataLayer(this.url, this.params.version, this._LAYER_TYPE_OGCWMS);
		this.layerBox.UserGroupLayer.AddLayer(wmsLayer);
        this._layerData = wmsLayer;
    },
    
	//自定义图层方式
    _createLayerFromJson : function(map){
	    //服务数据类型，有两种类型，影像数据：ImageDataType，矢量数据：VectorDataType，默认：ImageDataType
	    var dataType= this.options.dataType ? this.options.dataType : "ImageDataType";
	    //设置图层透明度，默认:100，可以设置:0-100
	    var renderTransparency = this.options.opacity >= 0 ? this.options.opacity * 100 : 100;
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.options.topLevel ? this.options.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.options.bottomLevel ? this.options.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.maxExtent ? this.options.maxExtent.left : -180;
	    var yMin = this.options.maxExtent ? this.options.maxExtent.bottom : -90;
	    var xMax = this.options.maxExtent ? this.options.maxExtent.right : 180;
	    var yMax = this.options.maxExtent ? this.options.maxExtent.top : 90;
	    //服务地址
	    var url = this.url;
	    //请求的服务版本号
	    var version = this.params.version ? this.params.version : this.DEFAULT_PARAMS.version;
	    /**私有参数**/
	    //请求的图层名称
	    var layers = encodeURIComponent(this.params.layers ? this.params.layers : "");
	    //请求的图片格式
	    var format = encodeURIComponent(this.params.format ? this.params.format : this.DEFAULT_PARAMS.format);
	    //请求的瓦片背景区域是否透明,默认为TURE
	    var transparent = this.params.transparent ? this.params.transparent : "TRUE";
	    //请求的图层样式
	    var styles = this.options.styles ? this.options.styles : this.DEFAULT_PARAMS.styles;
	    //获取瓦片大小
	    var tileSize =  this.options.tileSize ? this.options.tileSize : new Geo.Size(256,256);
	    //请求的图片宽度
	    var width = tileSize.w ? tileSize.w : 256;
	    //请求的图片高度
	    var height = tileSize.h ? tileSize.h : 256;
	    //获取投影
	    var projection = this.options.projection ? this.options.projection : "EPSG:4326";
	    //获取空间参数
	    var arr = projection.split(":");
	    var spatialReference = this.params.spatialReference ? this.params.spatialReference : this.DEFAULT_PARAMS.spatialReference;
	    if(arr.length == 2){
	    	spatialReference = arr[1];
	    } else {
	    	spatialReference = arr[0];
	    }
	    //拼图层请求串
	    var layerJson = '{'+
		'"Referer":"' + Geo.View3D.Map.HTTP_REFERER + '",'+
		'"DataType":"'+dataType+'",'+
		'"DataSourceType":"Customer",'+
		'"StartLevel":'+dataSetStartLevel+','+
		'"EndLevel":'+dataSetEndLevel+','+
		'"XMin":'+xMin+','+
		'"YMin":'+yMin+','+
		'"XMax":'+xMax+','+
		'"YMax":'+yMax+','+
		'"SpatialReference":"'+spatialReference+'",' +
		'"RenderTransparency":'+renderTransparency+',' +
		'"ServerUrl":"'+url+''+
		'?SERVICE='+this.DEFAULT_PARAMS.service+'&transparent='+transparent+'&Request=GetMap&VERSION='+version+'' +
		'&LAYERS='+layers+'&STYLES='+styles+'&FORMAT='+format+''+
		'&WIDTH='+width+'&HEIGHT='+height;
		//如果请求的服务版本为1.3，请求的投影设置为CRS,否则其它情况时，设置请求投影为SRS
		var srs = projection;
	    var crs = "";
		if(parseFloat(version) >= 1.3){
			layerJson += '&CRS='+srs+'';
			crs = srs;
		}else{
			layerJson += '&SRS='+srs+'';
		}
		//如果CRS不为空，并且开始字答串为EPSG，并且请求服务版本为1.3时，BBOX的请求串为ymin,xmin,ymax,xmax;否则都为xmin,ymin,xmax,ymax.
		if(crs != "" && parseFloat(version) == 1.3){
			layerJson += '&BBox=${TileYMin},${TileXMin},${TileYMax},${TileXMax}';
		}else{
			layerJson += '&BBox=${TileXMin},${TileYMin},${TileXMax},${TileYMax}';
		}
		layerJson +='"}';
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    //根据拼好的请求字符串调用三维接口进行服务请求
	    var layer = this.dataSourceBox.CreateLayerFromJson(layerJson);
	    this.layerBox.UserGroupLayer.AddLayer(layer);
	    this._layerData = layer;
    },
    
	/**
	 * Method: display
	 *
	 * Parameters:
	 * display - {Boolean} 
	 */	
    display: function(display) {
    	var map = this.map;
		if(this._layerData && display != this._layerData.Visible){
			map._setLayerVisibility(this._layerData, display);
    	}
    },
	
	/**
	 * Method: setOpacity
	 * 设置图层不透明度，数值在0-1.0之间。
	 *
	 * Parameters:
	 * opacity - {Float} 透明度。
	 */	
    setOpacity: function(opacity) {
        Geo.View3D.Layer.prototype.setOpacity.apply(opacity);
        var map = this.map;
        if(map){
			map._setLayerOpacity(this._layerData,opacity);
	    	this.opacity = opacity;
        }
    },
	
	/**
	 * Method: gotoCenter
	 * 定位到图层中心点。
	 *
	 */	    
    gotoCenter:function(){
        var map = this.map;
        if(map){
            map._gotoLayer(this._layerData);
        }
    },
	
	/**
	 * Method: removeMap
	 * 取消三维视图对象与图层关联。
	 *
	 */	    
    removeMap: function() {
        var map = this.map;
        if(map){
			map._removeLayerData(this._layerData);
        }
		this.map = null;
    },
	 	
    CLASS_NAME: "Geo.View3D.Layer.WMS"
});/**
 * Class: Geo.View3D.Layer.WMTS
 * 三维视图OGC-WMTS服务图层对象。
 *
 * Inherits from:
 *  - <Geo.View3D.Layer.GlobeTile>
 */
Geo.View3D.Layer.WMTS = Geo.Class(Geo.View3D.Layer.GlobeTile, {

    /**
     * APIProperty: layerName
     * {String} 图层名称。
     */
    layerName: null,
	
    //图层类型
	_LAYER_TYPE_OGCWMTS : 4,
    
	//判断用户使用的什么版本的api，由构造参数个数判断
	_oldLoad: null,
	
    /**
     * Constructor: Geo.View3D.Layer.WMTS
     * 构造函数。
     *
     * Parameters:
     * options - {Object} 设置图层属性。
     * 
     * 示例：
     * (code)
	 * 	  var wmtsLayer = new Geo.View3D.Layer.WMTS(
	 *          {
	 *           	name:"1-18级WMTS影像底图",//图层名称，必填
	 *           	url:"http://t0.tianditu.com/img_c/wmts",//服务URL地址，必填
	 *           	matrixSet:"c",//瓦片矩阵集，必填
	 *           	style:"default",//请求的样式，默认：""，必填
	 *           	layer: "img",//请求的图层名称，必填
	 *           	attribution:"1-18级WMTS影像底图",//图层信息
	 *           	format:"tiles",//请求的图片格式，默认：image/jpeg，必填
	 *           	//支持级别，分辨率，比例的用法，任一选择
	 *           	topLevel:0,//顶层级别，默认：0
	 *           	bottomLevel:20,//底层级别，默认：20
	 *           	tileFullExtent:Geo.Bounds.fromString("-180.0,-90.0,180.0,90.0"),//图层范围,缺省范围：-180,-90,180,90
	 *           	projection: "EPSG:4326",//当前图层使用的投影,默认EPSG:4326
	 *           	opacity : 1,//图层透明度设置，可以设置：0-1，默认：1
	 *           	version:"1.1.1"//服务版号，本默认为1.0.0
	 *				//支持分辨率
	 *				//maxResolution :0.000005364418029785156,//最大分辨率
     *       		//minResolution :0.703125//最小分辨率
     *       		//支持比例尺
     *       		//minScale : 2.958293554545656E8,
     *       		//maxScale : 2256.998866688275
	 *           });。
	 * (end)           
     */
    initialize: function(name, url, options){
        //判断用户使用api版本
    	if(typeof(arguments[0]) == "string"){
    		//老的三维图层加载方式传参为Name、URL
    		this._oldLoad = true;
    		Geo.View3D.Layer.GlobeTile.prototype.initialize.apply(this, [name, url, options]);
	        this.url = url;
	        options = options || {};
	        this.layerName = options.layer;
	        return;
    	}
    	
    	//与二维一致的新的三维图层加载方式
        var required = {
            url: true,
            layer: true,
            style: true,
            matrixSet: true
        };
        options = arguments[0] || {};
		/*
        for (var prop in required) {
            if (!(prop in options)) {
                throw new Error("Missing property '" + prop + "' in layer configuration.");
            }
        }
        */
        options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		if(options.maxResolution){
			options.bottomLevel = options.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			options.topLevel = options.pyramid.getLevelForResolution(options.minResolution);
		}
		
		if(options.maxScale){
			options.bottomLevel = options.pyramid.getLevelForScale(options.maxScale);
		}
		if(options.minScale){
			options.topLevel = options.pyramid.getLevelForScale(options.minScale);
		}
    	var args = [options.name, options.url, options];
        Geo.View3D.Layer.GlobeTile.prototype.initialize.apply(this, args);
    },
    
     /**
     * Method: setMap
     * 将图层关联到指定三维视图对象。
     *
     * Parameters:
     * map - {Geo.View3D.Map} 三维视图对象。
     */
    setMap: function(map){
    	if(this._oldLoad){
    		this._oldSetMap(map);
    		return;
    	}
    	this._createLayerFromJson(map);
		this.display(this.visibility);
    },
    
    //老版本,参数内部构造
    _oldSetMap: function(map){
        Geo.View3D.Layer.prototype.setMap.apply(this, [map]);
	 	var wmtsLayer = this.dataSourceBox.CreateDataLayer(this.url, "", this._LAYER_TYPE_OGCWMTS);
		//吉奥瓦片图层对象
		this.layerBox.UserGroupLayer.AddLayer(wmtsLayer);
		this._layerData = wmtsLayer;
    },
    
    //自定义图层方式
    _createLayerFromJson : function(map){
    	//默认参数值
    	var DEFAULT_PARAMS =
		{ 
		  service: "WMTS",
	      version: "1.0.0",
	      request: "GetTile",
	      styles: "",
	      format: "image/png",
	      spatialReference: "4326",
	      hasTemporal:"false"
	     };
	    //服务数据类型，有两种类型，影像数据：ImageDataType，矢量数据：VectorDataType，默认：ImageDataType
	    var dataType= this.options.dataType ? this.options.dataType : "ImageDataType";
	    //设置图层透明度，默认:100，可以设置:0-100
	    var renderTransparency = this.options.opacity >= 0 ? this.options.opacity * 100 : 100;
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.options.topLevel ? this.options.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.options.bottomLevel ? this.options.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.tileFullExtent ? this.options.tileFullExtent.left : -180;
	    var yMin = this.options.tileFullExtent ? this.options.tileFullExtent.bottom : -90;
	    var xMax = this.options.tileFullExtent ? this.options.tileFullExtent.right : 180;
	    var yMax = this.options.tileFullExtent ? this.options.tileFullExtent.top : 90;
	    //服务地址
	    var url = this.url;
	    //请求的服务版本号
	    var version = this.options.version ? this.options.version : DEFAULT_PARAMS.version;
	    //请求的图层名称
	    var layer = this.options.layer ? this.options.layer : "";
	    //请求的图片格式
	    var format = this.options.format ? this.options.format : DEFAULT_PARAMS.format;
	    //请求的图层样式
	    var style = this.options.style ? this.options.style : "";
	    //瓦片矩阵集
	    var matrixSet = this.options.matrixSet ? this.options.matrixSet:"";
	    //获取投影
	    var projection = this.options.projection ? this.options.projection : "EPSG:4326";
	    //获取空间参数
	    var arr = projection.split(":");
	    var spatialReference = DEFAULT_PARAMS.spatialReference;
	    if(arr.length == 2){
	    	spatialReference = arr[1];
	    } else {
	    	spatialReference = arr[0];
	    }
	    //是否加载多时相服务
	    var hasTemporal = this.options.hasTemporal ? this.options.hasTemporal : DEFAULT_PARAMS.hasTemporal;
	    //拼图层请求串
	    var layerJson = '{'+
		'"Referer":"' + Geo.View3D.Map.HTTP_REFERER + '",'+
		'"DataType":"'+dataType+'",'+
		'"DataSourceType":"WMTS",'+
		'"StartLevel":'+dataSetStartLevel+','+
		'"EndLevel":'+dataSetEndLevel+','+
		'"XMin":'+xMin+','+
		'"YMin":'+yMin+','+
		'"XMax":'+xMax+','+
		'"YMax":'+yMax+','+
		'"SpatialReference":"'+spatialReference+'",' +
		'"RenderTransparency":'+renderTransparency+',' +
		'"HasTemporal":"'+ hasTemporal +'",'+
		'"ServerUrl":"'+ url+'",'+
		'"Version":"'+ version+'",'+
		'"Layers":"' + layer + '",' +
		'"Styles":"' + style + '",' +
		'"ImageFormat":"' + format + '",' +
		'"TileMatrixSet":"' + matrixSet;
		layerJson +='"}';
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    var layer = this.dataSourceBox.CreateLayerFromJson(layerJson);
	    this.layerBox.UserGroupLayer.AddLayer(layer);
	    //是否启用多时相功能
	    this.layerBox.EnableTemporal=hasTemporal;
	    this._layerData = layer;
    },
    
     /**
     * Method: changeTemporal
     * 通过时间轴显示多时相数据。
     *
     * Parameters:
     * @param {String} varTime。
     */
	changeTemporal : function(varTime) {
		this.layerBox.ChangeTemporal(varTime);
	},
    
    /**
     * Method: removeMap
     * 取消三维视图对象与图层关联。
     *
     */
    removeMap: function(){
        var map = this.map;
        if (map) {
        	map._removeLayerData(this._layerData);
        }
        this.map = null;
    },
    
    /**
     * Method: display
     *
     * Parameters:
     * display - {Boolean}
     */
    display: function(display){
    	var map = this.map;
		if(!this._layerData){
			return;
		}
        if (display != this._layerData.Visible) {
			map._setLayerVisibility(this._layerData, display);
        }
    },
    
    /**
     * Method: gotoCenter
     * 定位到图层中心点。
     *
     */
    gotoCenter: function(){
        var map = this.map;
        if (map) {
			if(this._layerData){
				map._gotoLayer(this._layerData);
			}
        }
    },
    
    /**
     * Method: setOpacity
     * 设置图层不透明度，数值在0-1.0之间。
     *
     * Parameters:
     * opacity - {Float} 透明度。
     */
    setOpacity: function(opacity){
        Geo.View3D.Layer.prototype.setOpacity.apply(opacity);
        var map = this.map;
        if (map) {
            if (this._layerData) {
                map._setLayerOpacity(this._layerData, opacity);
                this.opacity = opacity;
            }
        }
    },
	
     /**
     * Method: showHistory
     * 显示多时相时间轴。
     *
     * Parameters:
     * visible - {Boolean} 是否显示时间轴，true为显示，false为不显示。
     * locationX - {Number} 时间轴在球体上的显示的横坐标位置。
     * locationY - {Number} 时间轴在球体上的显示的纵坐标位置。
     */
	showHistory: function(visible,locationX,locationY){
		 var map = this.map;
         if (map) {
		 	var varHis = map.activexObj.SceneBox.TemporalRuler;
			if(locationX)varHis.LocationX = locationX;
            if(locationY)varHis.LocationY = locationY;
		 	varHis.Visible = visible;
		 }
    },
	
    CLASS_NAME: "Geo.View3D.Layer.WMTS"
});
/**
 * Class: Geo.View3D.Layer.WTFS
 * 三维视图下的吉奥三维地名服务图层对象
 *
 * Inherits from:
 *  - <Geo.View3D.Layer.GlobeTile>
 */
Geo.View3D.Layer.WTFS = Geo.Class(Geo.View3D.Layer.GlobeTile, {
	/**
     * APIProperty: id
     * {String} 唯一标识符。
     */
    id: null,
    
	/**
     * APIProperty: url
     * {String} 服务地址。
     */
    url: null,
	
	//吉奥瓦片图层类型
	_LAYER_TYPE_GLOBETILE:6,
    
	//私有图层对象
    _layerData: null,
    
	//判断用户使用的什么版本的api，由构造参数个数判断
	_oldLoad: null,
	
	/**
	 * Constructor: Geo.View3D.Layer.WTFS
	 * 构造函数。
	 *
	 * Parameters:
	 * name - {String} 服务名称。
	 * url - {String} 服务地址。
	 * options - {Object} 相关参数选项。
	 * 例如：
	 * (code)
	 * 	  var wtfsLayer = new Geo.View3D.Layer.WTFS("wtfs", "http://192.168.40.69:9010/wtfs0319/wtfs",
	 *          {
	 *           	maxExtent:Geo.Bounds.fromString("-180,-90,180,90"),//图层范围,默认范围：-180,-90,180,90,必填
	 *           	opacity : 1,//图层透明度设置，可以设置：0-1，默认：1
	 *           	projection: "EPSG:4326",//当前图层使用的投影,默认EPSG:4326
	 *           	version:"1.1.1"//服务版号，本默认为1.1.1
	 *           	//支持级别，分辨率，比例的用法，任一选择
	 *           	topLevel:0,//顶层级别，默认：0
	 *				bottomLevel:20//底层级别，默认：20
	 *				//支持分辨率
	 *				//maxResolution :0.000005364418029785156,//最大分辨率
     *       		//minResolution :0.703125//最小分辨率
     *       		//支持比例尺
     *       		//minScale : 2.958293554545656E8,
     *       		//maxScale : 2256.998866688275
	 *           });。
	 *  (end)
	 */		      
    initialize: function(name, url, options) {
    	//判断用户使用api版本
    	if(arguments.length < 3){
    		this._oldLoad = true;
    		Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        	this.url = url;
        	return;
    	}
    	//与二维一致的新的三维图层加载方式
    	options = options || {};
        options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		if(options.maxResolution){
			options.bottomLevel = options.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			options.topLevel = options.pyramid.getLevelForResolution(options.minResolution);
		}
		if(options.maxScale){
			options.bottomLevel = options.pyramid.getLevelForScale(options.maxScale);
		}
		if(options.minScale){
			options.topLevel = options.pyramid.getLevelForScale(options.minScale);
		}
		if(typeof options.projection == "string") {
        	this.projection = new Geo.Projection(options.projection);
        }
        if(this.projection && this.projection.getUnits()) {
            this.units = this.projection.getUnits();
        }
        Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        this.url = url;
    },

	/**
	 * Method: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
	setMap: function(map){
    	if(this._oldLoad){
    		this._oldSetMap(map);
    		return;
    	}
    	this._createLayerFromJson(map);
		this.display(this.visibility);
    },
    
    //老版本,参数内部构造
    _oldSetMap: function(map) {
       Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		this._layerData = map._addGlobeTileService(this.url,"",this._LAYER_TYPE_GLOBETILE);
    },
    
     //自定义图层方式
    _createLayerFromJson : function(map){
    	var DEFAULT_PARAMS = 
		{ 
	      version: "1.1.1",
	      request: "GetTile",
	      styles: "",
	      format: "image/png",
	      spatialReference : "4326"
	     };
	    /**所有的服务的公共参数**/ 
	    //设置图层透明度，默认:100，可以设置:0-100
	    var renderTransparency = this.options.opacity >= 0 ? this.options.opacity * 100 : 100;
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.options.topLevel ? this.options.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.options.bottomLevel ? this.options.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.maxExtent ? this.options.maxExtent.left : -180;
	    var yMin = this.options.maxExtent ? this.options.maxExtent.bottom : -90;
	    var xMax = this.options.maxExtent ? this.options.maxExtent.right : 180;
	    var yMax = this.options.maxExtent ? this.options.maxExtent.top : 90;
	    //服务地址
	    var url = this.url;
	    //请求的服务版本号，version版本为2.1的暂时不支持
	    var version = this.options.version ? this.options.version : DEFAULT_PARAMS.version;
	    //获取投影
	    var projection = this.options.projection ? this.options.projection : "EPSG:4326";
	    //获取空间参数
	    var arr = projection.split(":");
	    var spatialReference = DEFAULT_PARAMS.spatialReference;
	    if(arr.length == 2){
	    	spatialReference = arr[1];
	    } else {
	    	spatialReference = arr[0];
	    }
	    //拼图层请求串
	    var layerJson = '{'+
		'"Referer":"' + Geo.View3D.Map.HTTP_REFERER + '",'+
		'"DataType":"POIDataType",'+
		'"DataSourceType":"GeoTile",'+
		'"StartLevel":'+dataSetStartLevel+','+
		'"EndLevel":'+dataSetEndLevel+','+
		'"XMin":'+xMin+','+
		'"YMin":'+yMin+','+
		'"XMax":'+xMax+','+
		'"YMax":'+yMax+','+
		'"SpatialReference":"'+spatialReference+'",' +
		'"RenderTransparency":'+renderTransparency+',' +
		'"ServerUrl":"'+ url+'",' +
		'"Version":"'+ version;
		layerJson +='"}';
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    var layer = this.dataSourceBox.CreateLayerFromJson(layerJson);
	    this.layerBox.UserGroupLayer.AddLayer(layer);
	    this._layerData = layer;	
    },
    
    CLASS_NAME: "Geo.View3D.Layer.WTFS"
});
/**
 * Class: Geo.View3D.Layer.Solid
 * 立方体图层对象。
 *
 * Inherits from:
 *  - <Geo.View3D.Layer>
 */
Geo.View3D.Layer.Solid = Geo.Class(Geo.View3D.Layer, {

    /**
     * APIProperty: geometry
     * {Object} 当前绘制的几何对象。
     */
    geometry: null,
    
    /**
     * APIProperty: height
     * {String} 当前绘制的几何对象的高度。
     */
    height: null,
    
    /**
     * APIProperty: faceColor
     * {Object}当前绘制的几何对象的颜色属性。
     */
    faceColor: null,
    
    _localDataBox: null,
    
    _layerData: null,
    
    /**
     * Constructor: Geo.View3D.Layer.Solid
     * Geo.View3D.Layer.Solid的构造函数。
     *
     * Parameters:
     * name - {String} 图层名称。
     * geometry - {Geo.Geometry} 绘制的集合对象。
     * height - {String} 海拔高度。
     * options - {Object} 选项。
     *
     * 示例:
     * (code)
     *
     *   solidLayer = new Geo.View3D.Layer.Solid("solid", polygon, 30000);
     *  
     *   //设置正方体中心点
     *     1.WKT字符串 2.暂时不用 3.//第三个参数1表示point ,2表示lineString,3表示Ring,4表示Model，5表示 Box
            a2 = GlobeCtrl.DrawBox.CreateGeometryObject("POINT(110 35 100)", "", 1, 1);
            //设置符号
            var b = GlobeCtrl.DrawBox.CreateSymbolObject(1);
            b.Color = -13660459;
            //设置正方体棱长
            b.Box = GlobeCtrl.DrawBox.CreateGeometryObject("", "", 5, 1);
            b.Size=200;
            GlobeCtrl.DrawBox.AddDrawObject(a2, b);
     *
     *  (end)
     */
    initialize: function(name, geometry, height, options){
//        this.faceColor = {
//            top: 0x7fffffff,
//            bottom: 0x7fffffff,
//            round: 0x7fffffff
//        };
		this.faceColor = {
            Color: -13660459,
            Size: 200
        };
        
        this.geometry = geometry;
        this.height = height;
        Geo.View3D.Layer.prototype.initialize.apply(this, [name, options]);
    },
	
	_getSolidSymbol: function() {
		//设置符号
        this._localDataBox = this._drawBox.CreateSymbolObject(1);
        this._localDataBox.Color = this.faceColor.Color;
        //设置正方体棱长
        this._localDataBox.Box = this._drawBox.CreateGeometryObject("", "", 5, 1);
        this._localDataBox.Size = this.faceColor.Size;
		return this._localDataBox;
	},
	
    /**
     * Method: setMap
     * 将图层关联到指定三维视图对象。
     *
     * Parameters:
     * map - {Geo.View3D.Map} 三维视图对象。
     *
     * 示例:
     * (code)
     *  var map = new Geo.View3D.Map("simpleMap");
     *  solidLayer = new Geo.View3D.Layer.Solid("solid", polygon, 30000);
     *  solidLayer.setMap(map);
     *  (end)
     */
    setMap: function(map){
        Geo.View3D.Layer.prototype.setMap.apply(this, [map]);
		this._drawBox = this.map.activexObj.DrawBox;
        this._layerData = this._createBoxLayer(this.geometry, this.height);
    },
    
    /**
     * Method: removeMap
     * 取消三维视图对象与图层关联。
     *
     * 示例:
     * (code)
     *  var map = new Geo.View3D.Map("simpleMap");
     *  solidLayer = new Geo.View3D.Layer.Solid("solid", polygon, 30000);
     *  solidLayer.setMap(map);
     *  solidLayer.removeMap();
     *  (end)
     */
    removeMap: function(){
        var map = this.map;
        if (map) {
            this._clearBoxLayer();
        }
        this.map = null;
    },
    
    /**
     * APIMethod: setHeight
     * 设置盒子高度。
     *
     * Parameters:
     * height - {Number} 海拔高度。
     *
     * 示例:
     * (code)
     *  solidLayer = new Geo.View3D.Layer.Solid("solid", polygon, 30000);
     *  solidLayer.setHeight(3000);
     *  (end)
     */
    setHeight: function(height){
		if (this._localDataBox && height) {
	        this._localDataBox.Box.Width = height;
	    }
//        if (this._localDataBox) {
//            this._localDataBox.setPolyGonHeight(this._layerData.Name, height);
//        }
    },
    
    /**
     * APIMethod: setFaceColor
     * 设置盒子颜色。
     *
     * Parameters:
     * colorParams - {Object} 颜色参数。
     * 
     * 示例:
     * (code)
     *  solidLayer = new Geo.View3D.Layer.Solid("solid", polygon, 30000);
     *  solidLayer.setFaceColor({
     *  top: 0x7f1760bf,
     *  bottom: 0x7f1760bf,
     *  round: 0x7f1760bf
     *  });
     *  (end)
     */
    setFaceColor: function(colorParams){
        this.faceColor = OpenLayers.Util.extend(this.faceColor, colorParams);
//        if (this._localDataBox) {
//            var boxLayerId = this._layerData.Name;
//            this._localDataBox.SetBoxFaceColor(boxLayerId, this.faceColor.top, this.faceColor.bottom, this.faceColor.round);
//        }
		//目前只支持设置立方体的一种颜色，不支持立方体的上面，下面和周边颜色的设置
		
		if(this.faceColor.top) {
			this._localDataBox.Color = Geo.Util.ToArgb(this.faceColor.top,255);
		}else if(this.faceColor.bottom) {
			this._localDataBox.Color = Geo.Util.ToArgb(this.faceColor.bottom,255);
		}else if(this.faceColor.round) {
			this._localDataBox.Color = Geo.Util.ToArgb(this.faceColor.round,255);
		}
    },
    
    
    // 画盒子图层
    _createBoxLayer: function(polygonGeometry, height){
		var centerPoint = polygonGeometry.getBounds().getCenterLonLat();
		var pointGeometry  = new Geo.Geometry.Point(centerPoint.lon, centerPoint.lat);
		var str = pointGeometry.toString();
        var start = str.indexOf("(") + 1;
        var end = str.indexOf(")");
		var point = str.slice(start,end);
		var pointWkt = "POINT(" + point + " " + height + ")";
    	this._layerData = this._drawBox.CreateGeometryObject(pointWkt, "", 1, 1);
		var symbol = this._getSolidSymbol();
		this._drawBox.AddDrawObject(this._layerData, symbol);
		this.map.activexObj.SceneBox.ParabolaFlyTo(centerPoint.lon, centerPoint.lat, 1000);
		return this._layerData;
//        var Globe = this.map.activexObj;
//        
//        // 画盒子用接口
//        if (!this._localDataBox) {
//            this._localDataBox = Globe.CreateAddLocalDataObj();
//        }
//        
//        var pointstr = this._getPointsThreeDegreeSpaceSplitStr(polygonGeometry, 0);
//        
//        
//        var boxLayerId = this.id + "_boxLayer";
//        
//        var layerdata = this._localDataBox.AddPolyGon(boxLayerId, pointstr);
//        layerdata.Name = boxLayerId;
//        this._localDataBox.setPolyGonHeight(boxLayerId, height);
//        this._localDataBox.SetBoxFaceColor(boxLayerId, this.faceColor.top, this.faceColor.bottom, this.faceColor.round);
        
    },
    
    // 删除盒子图层
    _clearBoxLayer: function(){
		this._drawBox.RemoveObject(this._layerData);
		this._layerData = null;
//        var Globe = this.map.activexObj;
//        var layer = Globe.GetSceneGroup().GetLayerByName(this.id + "_boxLayer");
//        if (layer != null) {
//            Globe.GetSceneGroup().RemoveLayer(layer);
//        }
    },
    
    //将二维点数组，加上指高度形成三维点数组转换成空格分隔的字符串
    _getPointsThreeDegreeSpaceSplitStr: function(polygonGeometry, height){
        var linearRing = polygonGeometry.components[0];
        var allPoints = linearRing.components;
        
        var points = [];
        for (var i = 0; i < allPoints.length; i++) {
            points.push(allPoints[i].x);
            points.push(allPoints[i].y);
            points.push(height);
        }
        return points.join(" ");
    },
    
    CLASS_NAME: "Geo.View3D.Layer.Solid"
});
/**
 * Class: Geo.View3D.Layer.WCS
 * 三维视图OGC-WCS服务图层对象。
 * 
 * Inherits from:
 *  - <Geo.View3D.Layer.GlobeTile>
 */
Geo.View3D.Layer.WCS = Geo.Class(Geo.View3D.Layer.GlobeTile, {

    setMap: function(map){
        Geo.View3D.Layer.prototype.setMap.apply(this, [map]);
        this._layerData = map._addWCSService(this.url);
		this.display(this.visibility);
    },
    
    CLASS_NAME: "Geo.View3D.Layer.WCS"
});
/**
 * Class: Geo.View3D.Layer.Grid
 * 三维下的自定义图层。
 * 
 * Inherits from:
 *  - <Geo.View3D.Layer>
 */
Geo.View3D.Layer.Grid = Geo.Class(Geo.View3D.Layer,{
	/**
	 * APIProperty: id
	 * {String} 唯一标识符。
	 */
	id:null,
	/**
	 * APIProperty: topLevel
	 * {Number} 顶层级别 默认为0。
	 */
	topLevel:0,
	/**
	 * APIProperty: buttomLevel
	 * {Number} 底层级别 默认为0。
	 */
	buttomLevel:0,
	/**
	 *  APIProperty: maxExtent
	 * {Object} 图层范围，缺省范围是-180,-90,180,90。
	 */
	maxExtent:null,
	/**
	 * APIProperty: dataType
	 * {String} 默认值为"ImageDataType"。
	 */
	dataType:"ImageDataType",
	/**
	 * APIProperty: url
	 * {String} 用户自定义服务，必须填写。
	 */
	url:null,
	/**
	* APIProperty: pyramid
	* {String} 默认为360°金字塔信息，一个xml字符串。
	*/
	pyramid:null,
	/**
	* APIProperty: spatialReference
	* {String} 默认为"4326"，字符串。
	*/
	spatialReference:"4326",
	/**
	 * APIProperty: dataSourceType
	 * {String} 当此值为"Customer"时，最好填写范围和层级，字符串。
	 */
	dataSourceType:"Customer",
	/**
	 * APIProperty: height
	 * {Number} 距离地面高度
	 */
	height:300,
	//私有图层对象
	_layerData:null,
	/**
	 * Constructor: Geo.View3D.Layer.Grid
	 * 构造函数。
	 * 
	 * Parameters:
	 * name - {String} 服务名称。
	 * url - {String} 服务地址。
	 * options - {Object} 相关参数选项。
	 */
	initialize:function(name, url, options){
		Geo.View3D.Layer.prototype.initialize.apply(this,[name,options]);
		this.url = url;
		var options = options || {};
		this.topLevel = options.topLevel?options.topLevel:this.topLevel;
		this.buttomLevel = options.buttomLevel?options.buttomLevel:this.buttomLevel;
		this.maxExtent = options.maxExtent?options.maxExtent:new Geo.Bounds(-180,-90,180,90);
		this.dataType = options.dataType?options.dataType:this.dataType;
		this.pyramid = options.pyramid?options.pyramid:"";
		this.spatialReference = options.spatialReference?options.spatialReference:this.spatialReference;
		this.dataSourceType = options.dataSourceType?options.dataSourceType:this.dataSourceType;
		this.height = options.height?options.height:this.height;
	},
	/**
	 * Method: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */
	setMap:function(map){
		Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		var layerJson = '{'+
		'"Referer":"' + Geo.View3D.Map.HTTP_REFERER + '",'+
		'"DataType":"'+this.dataType+'",'+
		'"DataSourceType":"'+this.dataSourceType+'",'+
		'"StartLevel":'+this.topLevel+','+
		'"EndLevel":'+this.buttomLevel+','+
		'"XMin":'+this.maxExtent.left+','+
		'"YMin":'+this.maxExtent.bottom+','+
		'"XMax":'+this.maxExtent.right+','+
		'"YMax":'+this.maxExtent.top+','+
		'"SpatialReference":"'+this.spatialReference+'",'+
		'"ServerUrl":"'+this.url + '"}';
        this._layerData = this.map.activexObj.DataSourceBox.CreateLayerFromJson(layerJson);
		this.map.activexObj.LayerBox.UserGroupLayer.AddLayer(this._layerData);
		this.display(this.visibility);
	},
	/**
	 * Method: removeMap
	 * 取消三维视图对象与图层关联。
	 */
	removeMap:function(){
		var map =  this.map;
		if(map){
			map._removeLayerData(this._layerData);
			this._layerData = null;
		}
		this.map = null;
	},
	/**
	 * Method: setVisibility
	 * 设置图层是否可见。
	 *
	 * Parameters:
	 * visibility - {Boolean} 是否可见。
	 */	
    setVisibility: function(visibility) {
        if (visibility != this.visibility) {
        	this.visibility = visibility;
            this.display(visibility);
        }
    },
	/**
	 * Method: display
	 *
	 * Parameters:
	 * display - {Boolean} 
	 */	
    display: function(display) {
		if(!this._layerData){
			return;
		}
        if(display != this._layerData.Visible){
			var map = this.map;
			map._setLayerVisibility(this._layerData,display);
        }
    },
	/**
	 * Method: setOpacity
	 * 设置透明度。
	 * 
	 * Parameters:
	 * opacity - {Number} 透明度。
	 */
	setOpacity:function(opacity){
		Geo.View3D.Layer.prototype.setOpacity.apply(opacity);
		var map = this.map;
		if(map){
			map._setLayerOpacity(this._layerData,opacity);
			this.opacity = opacity;
		}
	},
	/**
	 * Method: gotoCenter
	 * 定位到图层中心点。
	 */
	gotoCenter:function(){
		var map = this.map;
		if(map){
			map._gotoLayer(this._layerData);
		}
	},
	
	CLASS_NAME:"Geo.View3D.Layer.Grid"
});/**
 * Class: Geo.View3D.Layer.Model
 * 三维视图模型图层对象
 *
 * Inherits from:
 *  - <Geo.View3D.Layer.Grid>
 */
Geo.View3D.Layer.Model = Geo.Class(Geo.View3D.Layer.Grid, {
	//判断用户使用的什么版本的api，由构造参数个数判断
	_oldLoad: null,
	
	/**
     * APIProperty: enumLayerPropertyName
     * <Object>} 图层属性对象。
     */
	enumLayerPropertyName :
	{
		layerName : 0,
		layerVisible : 1,
		layerTransparency : 2,
		layerFullEnvelope : 3,
		wmslayerInfo : 4,
		wmtslayerInfo : 5,
		EnableSelection : 6,
		lodDistanceFactor : 7,
	    stereoModelColor : 8,
	    modelHeightOffset : 9
	},
	
	/**
	 * Constructor: Geo.View3D.Layer.Model
	 * 构造函数。
	 * 
	 * Parameters:
	 * name - {String} 服务名称。
	 * url - {String} 服务地址。
	 * options - {Object} 相关参数选项。
	 * 例如：
	 * (code)
	 * 	  var modelLayer = new Geo.View3D.Layer.Model("model", "http://192.168.42.56:9010/model/services/tile",
     *    {
     *       topLevel:1,//顶层级别，默认:0
	 *		 bottomLevel:20,//底层级别，默认:20
	 *       //图层范围,默认范围:-180,-90,180,90，必填
	 *		 maxExtent:Geo.Bounds.fromString("117.1966552734375,34.1839599609375,117.2845458984375,34.2828369140625"),
     *       layerType : "model",  //可选，图层类型值为model，设置此参数值表示让三维插件用新方式创建模型图层
     *       opacity : 1,//图层透明度设置,// 可以设置：0-1，默认：1
     *       projection: "EPSG:4326",//当前图层使用的投影,默认EPSG:4326
     *       version:"5.0",//请求的服务版本，默认：1.1.1
	 *		 //支持分辨率
	 *		 //maxResolution :0.000005364418029785156,//最大分辨率
     *       //minResolution :0.703125//最小分辨率
     *       //支持比例尺
     *       //minScale : 2.958293554545656E8,
     *       //maxScale : 2256.998866688275      
     *    });
	 * (end) 
	 */
	initialize:function(name, url, options){
		options = options || {};
		//通过读取用户创建模型时传入的layerType参数，判断接口的创建方式
		// oldFlag为true代表老方式创建，false代表新方式创建
		var oldFlag = typeof(options.layerType) == "undefined" ? true : false;
    	if(oldFlag){
    		this._oldLoad = true;
    		Geo.View3D.Layer.GlobeTile.prototype.initialize.apply(this,[name,url, options]);
        	this.url = url;
        	return;
    	}
    	//与二维一致的新的三维图层加载方式
        options.pyramid = options.pyramid ? options.pyramid : new Geo.Pyramid();
		if(options.maxResolution){
			options.bottomLevel = options.pyramid.getLevelForResolution(options.maxResolution);
		}
		if(options.minResolution){
			options.topLevel = options.pyramid.getLevelForResolution(options.minResolution);
		}
		if(options.maxScale){
			options.bottomLevel = options.pyramid.getLevelForScale(options.maxScale);
		}
		if(options.minScale){
			options.topLevel = options.pyramid.getLevelForScale(options.minScale);
		}
		if(typeof options.projection == "string") {
        	this.projection = new Geo.Projection(options.projection);
        }
        if(this.projection && this.projection.getUnits()) {
            this.units = this.projection.getUnits();
        }
        Geo.View3D.Layer.prototype.initialize.apply(this,[name, options]);
        this.url = url;
	},
	
	/**
	 * Method: setMap
	 * 将图层关联到指定三维视图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维视图对象。
	 */	
	setMap: function(map){
    	if(this._oldLoad){
    		this._oldSetMap(map);
    		return;
    	}
    	this._createLayerFromJson(map);
		this.display(this.visibility);
    },
    
    //老版本,参数内部构造
    _oldSetMap: function(map) {
        Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
		this._layerData = map._addGlobeTileService(this.url,"",this._LAYER_TYPE_GLOBETILE);
    },
    
     //自定义图层方式
    _createLayerFromJson : function(map){
    	var DEFAULT_PARAMS = 
		{ 
	      version: "5.0",
	      request: "GetTile",
	      styles: "",
	      format: "image/png",
	      spatialReference : "4326"
	     };
	    /**所有的服务的公共参数**/ 
	    //默认为影像：ImageDataType，矢量：VectorDataType，模型数据：ModelDataType， Lod模型数据：LodModelDataType，POI数据：POIDataType
	    var dataType= "LodModelDataType";    
	    //设置图层透明度，默认:100，可以设置:0-100
	    var renderTransparency = this.options.opacity >= 0 ? this.options.opacity * 100 : 100;
	    //顶层级别，默认:0
	    var dataSetStartLevel = this.options.topLevel ? this.options.topLevel : 0;
	    //底层级别，默认:20
	    var dataSetEndLevel = this.options.bottomLevel ? this.options.bottomLevel : 20;
	    //图层地理范围，默认:-180,-90,180,90
	    var xMin = this.options.maxExtent ? this.options.maxExtent.left : -180;
	    var yMin = this.options.maxExtent ? this.options.maxExtent.bottom : -90;
	    var xMax = this.options.maxExtent ? this.options.maxExtent.right : 180;
	    var yMax = this.options.maxExtent ? this.options.maxExtent.top : 90;
	    //服务地址
	    var url = this.url;
	    //请求的服务版本号，version版本为2.1的暂时不支持
	    var version = this.options.version ? this.options.version : DEFAULT_PARAMS.version;
	    //获取投影
	    var projection = this.options.projection ? this.options.projection : "EPSG:4326";
	    //获取空间参数
	    var arr = projection.split(":");
	    var spatialReference = DEFAULT_PARAMS.spatialReference;
	    if(arr.length == 2){
	    	spatialReference = arr[1];
	    } else {
	    	spatialReference = arr[0];
	    }
	    //拼图层请求串
//	    var layerJson = '{'+
//		'"DataType":"'+dataType+'",'+
//		'"DataSourceType":"GeoTile",'+
//		'"StartLevel":'+dataSetStartLevel+','+
//		'"EndLevel":'+dataSetEndLevel+','+
//		'"XMin":'+xMin+','+
//		'"YMin":'+yMin+','+
//		'"XMax":'+xMax+','+
//		'"YMax":'+yMax+','+
//		'"SpatialReference":"'+spatialReference+'",' +
//		'"RenderTransparency":'+renderTransparency+',' +
//		'"ServerUrl":"'+ url+'",' +
//		'"Version":"'+ version;
//		layerJson +='"}';

		var layerJson = '{'+
			'"Referer":"' + Geo.View3D.Map.HTTP_REFERER + '",'+
			'"Layer" : "ModelLayer",'+
			'"LayerDataType" : "Model",'+
			'"LayerName" : "JIYUDOUBLE",'+
			'"DataSet" : "CommonTileDataSet",'+
			'"SpatialReference" : "'+spatialReference+'",'+
			'"Render" : "LODModelRender",'+
			'"TileSource" : "TMSTileSource",'+
			'"Priority" : 1,'+
			'"UriRules" : "GeoTileUriRules",'+
			'"RenderTransparency" : '+renderTransparency+','+
			'"DataSetStartLevel" : '+dataSetStartLevel+','+
			'"DataSetEndLevel" : '+dataSetEndLevel+','+
			'"Pyramid" : "",'+
			'"XMin" : '+xMin+','+
			'"YMin" : '+yMin+','+
			'"XMax" : '+xMax+','+
			'"YMax" : '+yMax+','+
			'"Uris" : [{'+
				'"ServerUrl" : "'+url+'",'+
				'"StartLevel" : '+dataSetStartLevel+','+
				'"EndLevel" : '+dataSetEndLevel+','+
				'"Version" : "'+version+'",'+
				'"TimeStamp" : "",'+
				'"XMin" : '+xMin+','+
				'"YMin" : '+yMin+','+
				'"XMax" : '+xMax+','+
				'"YMax" : '+yMax+','+
				'"Layers" : null,'+
				'"Styles" : null,'+
				'"ImageFormat" : null,'+
				'"TileMatrixSet" : null,'+
				'"CRS" : null,'+
				'"RelativeLevel" : false,'+
				'"Pyramid" : null,'+
				'"HasTemporal" : false'+
			'}]'+
		'}';
	    Geo.View3D.Layer.prototype.setMap.apply(this,[map]);
	    var layer = this.dataSourceBox.CreateLayerFromJson(layerJson);
	    this.layerBox.UserGroupLayer.AddLayer(layer);
	    this._layerData = layer;	
    },
	
	/**
	 * APIMethod: modelHeightOffset
	 * 设置模型抬高高度。
	 *
	 * Parameters:
	 * height - {Number} 高度 。
	 */	
	modelHeightOffset:function(height){
		var layerOp = map.activexObj.LayerBox.CreateLayerOperate(this._layerData);
		layerOp.ChangeLayerProperty(this.enumLayerPropertyName.modelHeightOffset, height);
	},
	
	/**
	 * APIMethod: lodDistanceFactor
	 * 设置模型数据的显示范围。
	 *
	 * Parameters:
	 * factor - {Number} 范围值。 0,较小 1,普通 2,较大
	 */
	lodDistanceFactor : function(factor){
		var layerOp = map.activexObj.LayerBox.CreateLayerOperate(this._layerData);
		switch (factor) {
			case 0:
				layerOp.ChangeLayerProperty(this.enumLayerPropertyName.lodDistanceFactor, 0.6);
				break;
			case 1:
				layerOp.ChangeLayerProperty(this.enumLayerPropertyName.lodDistanceFactor, 1);
				break;
			case 2:
				layerOp.ChangeLayerProperty(this.enumLayerPropertyName.lodDistanceFactor, 1.5);
				break;
			default:
				return;			
		}
	},
    
    CLASS_NAME: "Geo.View3D.Layer.Model"
});
/**
 * Namespace: Geo.View3D.Event.KeyEvent
 * 三维键盘事件对象。
 */
Geo.View3D.Event.KeyEvent = {

    /**
     * Constant: KEY_SPACE
     * {Number} 空格键代码。
     */
    KEY_SPACE: 32,
    
    /** 
     * Constant: KEY_LEFT
     * {Number} 左方向键代码。
     */
    KEY_LEFT: 37,
    
    /** 
     * Constant: KEY_UP
     * {Number} 上方向键代码。
     */
    KEY_UP: 38,
    
    /** 
     * Constant: KEY_RIGHT
     * {Number} 右方向键代码。
     */
    KEY_RIGHT: 39,
    
    /** 
     * Constant: KEY_DOWN
     * {Number} 下方向键代码。
     */
    KEY_DOWN: 40,
    
    /** 
     * Constant: KEY_PLUS
     * {Number} 加号键代码。
     */
    KEY_PLUS: 187,
    
    /** 
     * Constant: KEY_MINUS
     * {Number} 减号键代码。
     */
    KEY_MINUS: 189,
    
     /** 
     * Constant: KEY_MINUS
     * {Number} 小键盘加号键代码。
     */
    KEY_NUM_PLUS: 107,
    /** 
     * Constant: KEY_MINUS
     * {Number} 小键盘减号键代码。
     */
    KEY_NUM_MINUS: 109,
    
     /**
     * APIMethod: isKeyDown
     * 判断是否键盘按键按下。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isKeyDown: function(e){
        if (e.EventType === 6) {
            return true;
        }
     },
			
	/**
     * APIMethod: isKeyUp
     * 判断是否键盘按键弹起。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isKeyUp: function(e){
        if (e.EventType === 7) {
            return true;
        }
    },
    
    /**
     * APIMethod: isKeyboardDown
     * 判断是否键盘按键按下。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isKeyboardDown: function(e){
        if (e.keyState === 0) {
            return true;
        }
     },
			
	/**
     * APIMethod: isKeyboardUp
     * 判断是否键盘按键弹起。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isKeyboardUp: function(e){
        if (e.keyState === 1) {
            return true;
        }
    },
    
    CLASS_NAME: "Geo.View3D.Event.KeyEvent"
};
/**
 * Namespace: Geo.View3D.Event.MouseEvent
 * 三维鼠标事件对象。本事件对象用于判断三维视图下鼠标是否触发了鼠标动作，包括鼠标左键点击，鼠标移动，鼠标
 * 右键点击等动作，以及鼠标所在的像素位置，经纬度和海拔高度信息。
 */
Geo.View3D.Event.MouseEvent = {

    /**
     * APIMethod: isMousemove
     * 判断是否鼠标移动。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMousemove: function(e){
		//if (e.MouseButton === -1 && e.MouseState === 1) 
        if (e.MouseButton === 0 && e.MouseState === 3) {
            return true;
        }
    },
    
    /**
     * APIMethod: isMouseDown
     * 判断是否鼠标左键按下。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseDown: function(e){
        //if (e.MouseButton === 0 && e.MouseState === 0) {
		if (e.MouseButton === 1 && e.MouseState === 0) {
            return true;
        }
	},
    
    /**
     * APIMethod: isLeftClick
     * 判断是否鼠标点击。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isLeftClick: function(e){
//        if (e.MouseButton === 0 && e.MouseState === 0) {
//		if (e.MouseButton === 1 && e.MouseState === 1) {
//            return true;
//        }
    	if (e.MouseButton !== 1 || e.MouseState !== 1) {
            return false;
        };
        if(Geo.View3D.Event.MouseEvent._mouseDownPos){
            var xOffset = Math.abs(Geo.View3D.Event.MouseEvent._mouseDownPos.x - e.ScreenX);
            var yOffset = Math.abs(Geo.View3D.Event.MouseEvent._mouseDownPos.y - e.ScreenY);
            var pixelTolerance = Geo.View3D.Event.MouseEvent.pixelTolerance;

            if(xOffset > pixelTolerance || yOffset > pixelTolerance){
                return false;
            };
        };
        return true;
	},
    
    /**
     * APIMethod: isMouseUp
     * 判断是否鼠标左键弹起。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseUp: function(e){
        //if (e.MouseButton === 0 && e.MouseState === 2) {
		if (e.MouseButton === 1 && e.MouseState === 1) {
            return true;
        }
	},
    
	/**
     * APIMethod: isMouseDownMove
     * 判断是否鼠标左键按住移动。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseDownMove: function(e){
        //if (e.MouseButton === 0 && e.MouseState === 0) {
		if (e.MouseButton === 1 && e.MouseState === 3) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMouseLeftDoubleClick
     * 判断是否鼠标左键双击。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseLeftDoubleClick: function(e){
		if (e.MouseButton === 1 && e.MouseState === 4) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMouseRightDown
     * 判断是否鼠标右键按下。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseRightDown: function(e){
		if (e.MouseButton === 2 && e.MouseState === 0) {
            return true;
        }
	},
	
    /**
     * APIMethod: isRightClick
     * 判断是否鼠标右键点击。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isRightClick: function(e){
        //if (e.MouseButton === 2 && e.MouseState === 2) {
        if (e.MouseButton === 2 && e.MouseState === 1) {
            return true;
        }
	},
    
	/**
     * APIMethod: isMouseRightUp
     * 判断是否鼠标右键弹起。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseRightUp: function(e){
        //if (e.MouseButton === 0 && e.MouseState === 2) {
		if (e.MouseButton === 2 && e.MouseState === 1) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMouseRightDownMove
     * 判断是否鼠标右键按住移动。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseRightDownMove: function(e){
		if (e.MouseButton === 2 && e.MouseState === 3) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMouseRightDoubleClick
     * 判断是否鼠标右键双击。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseRightDoubleClick: function(e){
		if (e.MouseButton === 2 && e.MouseState === 4) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMouseWheel
     * 判断是否鼠标滚轮。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseWheel: function(e){
		if (e.MouseButton === 0 && e.MouseState === 5) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMouseOut
     * 判断是否鼠标离开三维球体区域。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseOut: function(e){
        if (e.MouseButton === 0 && e.MouseState === 6) {
            return true;
        }
    },
    
    /**
     * APIMethod: isMouseOver
     * 判断是否鼠标进入三维球体区域。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseOver: function(e){
        if (e.MouseButton === 0 && e.MouseState === 7) {
            return true;
        }
    },
	
    /**
     * APIMethod: isMouseRightUp
     * 判断是否鼠标右键弹起。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMouseRightUp: function(e){
        //if (e.MouseButton === 0 && e.MouseState === 2) {
		if (e.MouseButton === 2 && e.MouseState === 1) {
            return true;
        }
	},
	
    /**
     * APIMethod: getMouseScreen
     * 获取屏幕坐标。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    getMouseScreen: function(e){
        return {
            x: e.ScreenX,
            y: e.ScreenY
        };
    },
    
    /**
     * APIMethod: getMouseLocation
     * 获取地理位置包括经纬度、海拨高度。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    getMouseLocation: function(e){
        return {
            lon: e.X,//e.Longitude,
            lat: e.Y,//e.Latitude,
            alt: e.Altitude
        };
    },
	
	/**
     * APIMethod: isMoveStart
     * 判断是否鼠标移动开始。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMoveStart: function(e){
		if (e.MouseButton === 1 && e.MouseState === 0) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMove
     * 判断是否鼠标移动中。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMove: function(e){
		if (e.MouseButton === 1 && e.MouseState === 3) {
            return true;
        }
	},
	
	/**
     * APIMethod: isMoveEnd
     * 判断是否鼠标移动结束。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isMoveEnd: function(e){
		if (e.MouseButton === 1 && e.MouseState === 1) {
            return true;
        }
	},
	
	/**
     * APIMethod: isZoomEnd
     * 判断是否鼠标缩放地图。
     *
     * Paramters:
     * e - {Object} 事件对象。
     */
    isZoomEnd: function(e){
		if (e.MouseButton === 0 && e.MouseState === 5) {
            return true;
        }
	},
//    /**
//     * APIMethod: isKeyDown
//     * 判断是否键盘按键按下。
//     *
//     * Paramters:
//     * e - {Object} 事件对象。
//     */
//    isKeyDown: function(e){
//        if (e.EventType === 6) {
//            return true;
//        }
//     },
//			
//	/**
//     * APIMethod: isKeyUp
//     * 判断是否键盘按键弹起。
//     *
//     * Paramters:
//     * e - {Object} 事件对象。
//     */
//    isKeyUp: function(e){
//        if (e.EventType === 7) {
//            return true;
//        }
//    },
					
    /**
     * Constant: KEY_SPACE
     * {int} 空格键代码。
     */
    KEY_SPACE: 32,
    
    /** 
     * Constant: KEY_LEFT
     * {int} 左方向键代码。
     */
    KEY_LEFT: 37,
    
    /** 
     * Constant: KEY_UP
     * {int} 上方向键代码。
     */
    KEY_UP: 38,
    
    /** 
     * Constant: KEY_RIGHT
     * {int} 右方向键代码。
     */
    KEY_RIGHT: 39,
    
    /** 
     * Constant: KEY_DOWN
     * {int} 下方向键代码。
     */
    KEY_DOWN: 40,
    
    /** 
     * Constant: KEY_PLUS
     * {int} 加号键代码。
     */
    KEY_PLUS: 187,
    
    /** 
     * Constant: KEY_MINUS
     * {int} 减号键代码。
     */
    KEY_MINUS: 189,
    
    CLASS_NAME: "Geo.View3D.Event.MouseEvent"
};
/**
 * Class: Geo.View3D.Handler
 * 三维视图事件监听对象。
 */
Geo.View3D.Handler = Geo.Class({

    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */  
    id: null,

    /**
     * APIProperty: active
     * {String} 是否激活。
     */      
    active: false,

    /**
     * APIProperty: control
     * {String} 所属控件。
     */      
    control: null,

    /**
     * APIProperty: map
     * {<Geo.View3D.Map>} 所属地图对象。
     */    
    map: null,

	 
	/**
	 * Constructor: Geo.View3D.Handler
	 * Geo.View3D.Handler构造函数。
	 *
	 * Parameters:
	 * control - {<Geo.View3D.Control>} 监听器所属的控件。
	 * options - {Object} 选项。
	 */	    
    initialize: function(control, callbacks, options){
        
        OpenLayers.Util.extend(this, options);
        this.control = control;
		this.callbacks = callbacks;
		
		var map = this.map || control.map;
        if (map) {
            this.setMap(map); 
        }
		
		this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
    },
 	
	/**
	 * Method: setMap
	 * 将监听器关联到三维地图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维地图对象。
	 */	    
    setMap: function (map) {
        if(map){
            this.map = map;
            this.map.handlers.push(this);
        }
    },
 	
   /**
    * Method: callback
    * 触发控件指定的回调方法。
    *
    * Parameters:
    * name - {String}
    * args - {Array(*)}
    */
    callback: function (name, args) {
        if (name && this.callbacks[name]) {
            this.callbacks[name].apply(this.control, args);
        }
    },

	/**
	 * Method: listener
	 * 监听鼠标事件。
	 *
	 * Parameters:
	 * e - {Object} 三维对象鼠标事件对象。
	 */	     
    listener:function(e){
        
    },

	/**
	 * APIMethod: activate
	 * 激活事件监听器，如果当前监听器已处于激活状态，则返回false。
	 *
	 * Return:
	 * {Boolean} 监听器是否被激活。
	 */	    
    activate: function() {
        if(this.active) {
            return false;
        }
        this.active = true;
        return true;
    },

	/**
	 * APIMethod: deactivate
	 * 关闭事件监听器，如果当前监听器已处于关闭状态，则返回false。
	 *
	 * Return:
	 * {Boolean} 监听器是否被关闭。
	 */    
    deactivate: function() {
        if(!this.active) {
            return false;
        }
        this.active = false;
        return true;
    },

    /**
     * APIMethod: destroy
     * 监听器销毁。
     */
    destroy: function () {
        this.deactivate();
		if(this.map){
			OpenLayers.Util.removeItem(this.map.handlers,this);
		}
        this.control = this.map = null;        
    },
	
    CLASS_NAME: "Geo.View3D.Handler"
});/**
 * Class: Geo.View3D.Handler.Box
 * 三维拉框动作监听类。
 * 
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Box = Geo.Class(Geo.View3D.Handler,{
	
	/**
     * Property: bbox
     * {String} 表示用户拉框的范围。例如： "5,42,10,45"。
     */
	bbox: null,
	
	/**
	 * Constructor: Geo.View3D.Handler.Box
	 * Geo.View3D.Handler.Box构造函数。
	 * 
	 * Parameters:
	 * control - {Geo.View3D.Control}关联的控件。
	 * callbacks - {Object} 回调方法。
	 * options - {Object} 参数选项。
	 */  
    initialize: function(control, callbacks, options) {
        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
		
    },
	
	/**
     * APIMethod: listener
     * 监听鼠标拉框动作。
     *
     * Parameters:
     * mouseEvent - {Object} 三维地图的鼠标事件对象。
     */
    listener: function(mouseEvent) {
		//鼠标按下时执行
		if(mouseEvent.MouseState == 0 || Geo.View3D.Event.MouseEvent.isRightClick(mouseEvent)){
			this.bbox = mouseEvent.Longitude + "," + mouseEvent.Latitude;
			return;
		}
		//鼠标弹起时执行
		if (mouseEvent.MouseState == 2){
			this.bbox = this.bbox + "," + mouseEvent.Longitude + "," + mouseEvent.Latitude;
		}
		var arr = this.bbox.split(",");
		//排序为左下右上
		var bbox = arr[0] + "," + arr[3] + "," + arr[2] + "," + arr[1];
		this.callback("emitMouseHandler", [bbox]);
		
    },
	
	 /**
     * APIMethod: activate
     * 打开绘制点监听器。
     */
    activate: function() {
        if(!Geo.View3D.Handler.prototype.activate.apply(this, arguments)) {
            return false;
        }
		//CurrentOpState的值为2时表示拉框
		this.map.activexObj.CurrentOpState = 2;
        return true;
    },
	
	/**
     * APIMethod: deactivate
     * 关闭监听。
     */
    deactivate: function() {
        if(!Geo.View3D.Handler.prototype.deactivate.apply(this, arguments)) {
            return false;
        }
		//恢复CurrentOpState的默认值
		this.map.activexObj.CurrentOpState = 0;
        return true;
    },
	
    CLASS_NAME: "Geo.View3D.Handler.Box"
});/**
 * Class: Geo.View3D.Handler.KeybordDefaults
 * 三维视图的键盘事件监听器。本类负责监听键盘的空格键，上下左右键以及加号减号键。
 *
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.KeybordDefaults = Geo.Class(Geo.View3D.Handler, {

    /**
     * APIMethod: listener
     * 键盘事件监听器。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    listener: function(e){
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_SPACE) {
				this.onKeySpace(e);
			} 
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_LEFT) {
				this.onKeyLeft(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_UP) {
				this.onKeyUp(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_RIGHT) {
				this.onKeyRight(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_DOWN) {
				this.onKeyDown(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_PLUS) {
				this.onKeyPlus(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_MINUS) {
				this.onKeyMinus(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_NUM_PLUS) {
				this.onKeyPlus(e);
			}
			if (e.keyCode == Geo.View3D.Event.KeyEvent.KEY_NUM_MINUS) {
				this.onKeyMinus(e);
			}
    },
    
    /**
     * APIMethod: onKeySpace
     * 空格键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeySpace: function(e){
    },
    
    /**
     * APIMethod: onKeyLeft
     * 向左方向键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeyLeft: function(e){
    },
    
    /**
     * APIMethod: onKeyUp
     * 向上方向键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeyUp: function(e){
    },
    
    /**
     * APIMethod: onKeyRight
     * 向右方向键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeyRight: function(e){
    },
    
    /**
     * APIMethod: onKeyDown
     * 向下方向键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeyDown: function(e){
    },
    
    /**
     * APIMethod: onKeyPlus
     * 加号键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeyPlus: function(e){
    },
    
    /**
     * APIMethod: onKeyMinus
     * 减号键被按下时的事件响应方法。
     *
     * Parameters:
     * e - {Object} 三维地图的键盘事件对象。
     */
    onKeyMinus: function(e){
    },
    
    CLASS_NAME: "Geo.View3D.Handler.KeybordDefaults"
});
/**
 * Class: Geo.View3D.Handler.Mouse
 * 三维视图的鼠标事件监听器。本类负责监听鼠标的左键右键和鼠标经过动作。
 *
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Mouse = Geo.Class(Geo.View3D.Handler, {

	/**
	 * Constructor: Geo.View3D.Handler.Mouse
	 * Geo.View3D.Handler.Mouse构造函数。
	 * 
	 * Parameters:
	 * control - {Geo.View3D.Control}关联的控件。
	 * callbacks - {Object} 回调方法。
	 * options - {Object} 参数选项。
	 */  
    initialize: function(control, callbacks, options) {
        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
    },
	
    /**
     * APIMethod: listener
     * 鼠标事件监听器。
     *
     * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
     */
    listener: function(e){
		if (Geo.View3D.Event.MouseEvent.isLeftClick(e)) {
            this.callback("click", [e]);
        }
        if (Geo.View3D.Event.MouseEvent.isMousemove(e)) {
            this.callback("mouseMove", [e]);
        }
        if (Geo.View3D.Event.MouseEvent.isMouseOut(e)) {
            this.callback("mouseOut", [e]);
        }
        if (Geo.View3D.Event.MouseEvent.isMouseOver(e)) {
            this.callback("mouseOver", [e]);
        }
        if (Geo.View3D.Event.MouseEvent.isRightClick(e)) {
            this.callback("rightClick", [e]);
        }
        if (Geo.View3D.Event.MouseEvent.isMouseLeftDoubleClick(e)) {
            this.callback("dblclick", [e]);
        }
        if(Geo.View3D.Event.MouseEvent.isMouseUp(e)) {
        	this.callback("mouseUp", [e]);
        }
        if(Geo.View3D.Event.MouseEvent.isMouseDown(e)) {
        	this.callback("mouseDown", [e]);
        }
        if(Geo.View3D.Event.MouseEvent.isMouseWheel(e)) {
        	this.callback("mouseWheel", [e]);
        }
        if(Geo.View3D.Event.MouseEvent.isMouseRightUp(e)) {
        	this.callback("mouseRightUp", [e]);
        }
        if(Geo.View3D.Event.MouseEvent.isMoveStart(e)) {
        	this.callback("movestart", [e]);
        }
		if(Geo.View3D.Event.MouseEvent.isMove(e)) {
        	this.callback("move", [e]);
        }
		if(Geo.View3D.Event.MouseEvent.isMoveEnd(e)) {
        	this.callback("moveend", [e]);
        }
		if(Geo.View3D.Event.MouseEvent.isZoomEnd(e)) {
        	this.callback("zoomend", [e]);
        }
		
    },
    
    CLASS_NAME: "Geo.View3D.Handler.Mouse"
});
/**
 * Class: Geo.View3D.Handler.ModelChoose
 * 三维视图的模型选择事件监听器。
 *
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.ModelChoose = Geo.Class(Geo.View3D.Handler, {

    /**
     * Constructor: Geo.View3D.Control.ModelChoose
     * Geo.View3D.Control.ModelChoose构造函数。
     */
    initialize: function(control, callbacks, options){
        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
    },
    
    /**
     * APIMethod: listener
     * 模型点击监听动作。
     *
     * Parameters:
     * mouseEvent - {Object} 三维地图的鼠标事件对象。
     */
    listener: function(mouseEvent){
        var isSelected = false;
        if (this.map && this.map.activexObj) {
            if (mouseEvent.MouseButton == 1 && mouseEvent.MouseState == 1) {
            	var x = mouseEvent.ScreenX;
	        	var y = mouseEvent.ScreenY;
            	var selectObj = this.map.activexObj.SelectionBox.QueryIDByScreenPoint(x, y);
		 		if(undefined != selectObj && null != selectObj){
		 			var selectLayer = this.map.activexObj.SelectionBox.GetLayerByID(selectObj.split(',')[0]);
		 			if(selectLayer == this.control.layer._layerData){
			 			var fid = selectObj.split(',')[1];
		                /**
		                var pBSTR;
		                isSelected = this.map.activexObj.SceneGroup.PerformSelection(modelLayer._layerData, x, y, pBSTR);
		                */
		                this.map.activexObj.SelectionBox.SelectByScreenPoint(x, y);
					    isSelected = true;
		                this.callback("chooseModel", [mouseEvent, isSelected, fid]);
		 			}
                }
            }
        }
    },
    
    /**
     * Method: enableSelection
     * 模型是否可被选择。
     * 
     * Parameters:
     * flag - {Boolean} 是否可被选择，true或false。
     */
    enableSelection: function(flag){
    	var modelLayer = this.control.layer;
    	if(null != modelLayer && undefined != modelLayer){
			var layerOP = this.map.activexObj.LayerBox.CreateLayerOperate(modelLayer._layerData);
           	layerOP.ChangeLayerProperty(6, flag);
           	layerOP.ChangeLayerProperty(13, flag);
            this.map.activexObj.SelectionBox.EnableSelection = flag;
		}
    },
    
    /**
     * APIMethod: activate
     * 打开模型点击监听器。
     */
    activate: function(){
    	this.enableSelection(true);
        if (!Geo.View3D.Handler.prototype.activate.apply(this, arguments)) {
            return false;
        }
        return true;
    },
    
    /**
     * APIMethod: deactivate
     * 关闭监听动作。
     */
    deactivate: function(){
    	this.enableSelection(false);
        if (!Geo.View3D.Handler.prototype.deactivate.apply(this, arguments)) {
            return false;
        }
        return true;
    },
    
    CLASS_NAME: "Geo.View3D.Handler.ModelChoose"
});/**
 * Class: Geo.View3D.Handler.Point
 * 三维视图点几何对象绘制操作事件监听器。该对象激活后，将在三维视图上监听绘制点的操作，
 * 完成后返回用户绘制的几何对象。该对象关闭后，将移除绘制图层。
 * 
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Point = Geo.Class(Geo.View3D.Handler,{
	
	    
    /**
     * APIProperty: point
     * {<Geo.Feature.Vector>} 当前绘制的点要素。
     */
    point: null,

    /**
     * APIProperty: layer
     * {<Geo.View3D.Layer.Vector>} 用于显示绘制要素的临时三维矢量图层。
     */
    layer: null,

    /**
     * APIProperty: persist
     * {Boolean} 是否立即销毁临时图层绘制的要素。
     */
    persist: false,


    /**
     * APIProperty: layerOptions
     * {Object} 临时绘制矢量要素图层对象构造选项。
     */
    layerOptions: null,

    /** 
     * Constructor: Geo.View3D.Handler.Point
     * Geo.View3D.Handler.Point构造函数。
     * 
     * Parameters:
     * control - {<Geo.View3D.Control>} 三维控件对象。
     * options - {Object} 参数对象。
     */
    initialize: function(control, options) {
        if(!(options && options.layerOptions && options.layerOptions.styleMap)) {
            this.style = OpenLayers.Util.extend(Geo.Feature.Vector.style['default'], {});
        }

        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
    },
    
	/**
	 * APIMethod: listener
	 * 鼠标事件监听器。
	 * 
     * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */	           
    listener:function(e){
		if (Geo.View3D.Event.KeyEvent.isKeyDown(e) || Geo.View3D.Event.KeyEvent.isKeyUp(e)) {
            return;
        }
        if (Geo.View3D.Event.MouseEvent.isMousemove(e)) {
            return;
        }
		
		var lon = e.X;//e.Longitude;
        var lat = e.Y;//e.Latitude;
				
        if (Geo.View3D.Event.MouseEvent.isMouseDown(e)) {
	        this.createFeature(new Geo.LonLat(lon,lat));
		}
		if (Geo.View3D.Event.MouseEvent.isMouseUp(e)) {
			if(this.persist){
				this.layer.destroyFeatures();
			}

			this.callback("done", [this.point.geometry.clone()]);
		}
		
    },
	
    /**
     * APIMethod: activate
     * 打开绘制点监听器。
     */
    activate: function() {
        if(!Geo.View3D.Handler.prototype.activate.apply(this, arguments)) {
            return false;
        }
        var options = OpenLayers.Util.extend({
            displayInLayerSwitcher: false,
			isOnTop: true
        }, this.layerOptions);
        this.layer = new Geo.View3D.Layer.Vector(this.CLASS_NAME, options);
        this.map.addLayer(this.layer);
		
		//this._setGeoRaster();
		
        return true;
    },	
				
    /**
     * APIMethod: createFeature
     * 向临时矢量图层添加绘制要素。
     *
     * Parameters:
     * lonlat - {Object} 经纬度信息。
     */
    createFeature: function(lonlat) {
        this.point = new Geo.Feature.Vector(
            new Geo.Geometry.Point(lonlat.lon, lonlat.lat)
        );
        this.point.geometry.clearBounds();
        this.layer.addFeatures([this.point], {silent: true});
    },

    /**
     * APIMethod: deactivate
     * 关闭绘制点监听器。
     */
    deactivate: function() {
        if(!Geo.View3D.Handler.prototype.deactivate.apply(this, arguments)) {
            return false;
        }
        this.destroyFeature();
        if (this.layer.map != null) {
            this.layer.destroy(false);
        }
        this.layer = null;
		
		//this.map.activexObj.SetPickedState(false);
		
        return true;
    },
    
    /**
     * APIMethod: destroyFeature
     * 销毁临时绘制矢量要素。
     */
    destroyFeature: function() {
        if(this.layer) {
            this.layer.destroyFeatures();
        }
        this.point = null;
    },

	/**
     * 设置GeoRaster。
     */
    _setGeoRaster:function(){
        var GeoRaster = this.map._geoRaster;
        GeoRaster.GeoRasterType = 1;
        
        //设置精确拾取 开,漫游状态要还原为FALSE
    	this.map.activexObj.SetPickedState(true);  
    },
	
    CLASS_NAME: "Geo.View3D.Handler.Point"
});/**
 * Class: Geo.View3D.Handler.Path
 * 三维视图线几何对象绘制操作事件监听器。该对象激活后，将在三维视图上监听绘制线的操作，
 * 完成后返回用户绘制的几何对象。该对象关闭后，将移除绘制图层。
 * 
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Path = Geo.Class(Geo.View3D.Handler,{

    /**
     * APIProperty: point
     * {<Geo.Feature.Vector>}当前绘制的点要素。
     */
    point: null,	
	
    /**
     * APIProperty: line
     * {<Geo.Feature.Vector>}当前绘制的线要素。
     */
    line: null,	    

    /**
     * APIProperty: layer
     * {<Geo.View3D.Layer.Vector>} 用于显示绘制要素的临时三维矢量图层。
     */
    layer: null,

    /**
     * APIProperty: persist
     * {Boolean} 是否立即销毁临时图层绘制的要素。
     */
    persist: false,


    /**
     * APIProperty: layerOptions
     * {Object} 临时绘制矢量要素图层对象构造选项。
     */
    layerOptions: null,
	
	//标记线是否点击右键绘制完成
	_isDone: false,

    /** 
     * Constructor: Geo.View3D.Handler.Path
     * Geo.View3D.Handler.Path构造函数。
     * 
     * Parameters:
     * control - {<Geo.View3D.Control>} 三维控件对象。
     * options - {Object} 参数对象。
     */
    initialize: function(control, options) {
        if(!(options && options.layerOptions && options.layerOptions.styleMap)) {
            this.style = OpenLayers.Util.extend(Geo.Feature.Vector.style['default'], {});
        }

        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
    },
    
	/**
	 * APIMethod: listener
	 * 鼠标事件监听器。
	 * 
     * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */	           
    listener:function(e){
		if (Geo.View3D.Event.KeyEvent.isKeyDown(e) || Geo.View3D.Event.KeyEvent.isKeyUp(e)) {
            return;
        }
        if (Geo.View3D.Event.MouseEvent.isMousemove(e)) {
            return;
        }
        if (Geo.View3D.Event.MouseEvent.isLeftClick(e)) {
			//alert(e.MouseButton +"   "+ e.MouseState);
			//结束当前线绘制后，再次点击清除前次绘制
			if(this._isDone){
				//this.layer.removeFeatures(this.line);
				this.line = null;
				this._isDone = false;
			}
			var GeoRaster = this.map._geoRaster;
	        var lon = e.X;//e.Longitude;
	        var lat = e.Y;//e.Latitude;
			this.addPoint(new Geo.LonLat(lon,lat));
			this.callback("point", [this.point.geometry, this.line.geometry]);
		}
//		if(Geo.View3D.Event.MouseEvent.isRightClick(e)){
//			//alert(e.MouseButton +"   "+ e.MouseState);
//			this._isDone = true;
//            if(this.persist){
//				this.layer.destroyFeatures();
//			}
//            if (this.line) {
//                this.callback("done", [this.line.geometry.clone()]);
//                //var GeoRaster = this.map._geoRaster;
//                //this.map.activexObj.SetPickedState(false);
//            }
//		}
		if(Geo.View3D.Event.MouseEvent.isMouseLeftDoubleClick(e)){
			this.handleDouble();
		}
    },
	
    /**
     * APIMethod: activate
     * 打开绘制线监听器。
     */
    activate: function() {
        if(!Geo.View3D.Handler.prototype.activate.apply(this, arguments)) {
            return false;
        }
        var options = OpenLayers.Util.extend({
            displayInLayerSwitcher: false,
			isOnTop: true
        }, this.layerOptions);
        this.layer = new Geo.View3D.Layer.Vector(this.CLASS_NAME, options);
        this.map.addLayer(this.layer);
		
		//this._setGeoRaster();
		
        return true;
    },	
	
	/**
	 * APIMethod: addPoint
	 * 添加点的方法。
	 * 
     * Parameters:
     * lonlat - {Object} 经纬度信息。
	 */	 
	addPoint:function(lonlat){
		this.point = new Geo.Feature.Vector(
            new Geo.Geometry.Point(lonlat.lon, lonlat.lat)
        );
        this.point.geometry.clearBounds();
		
		var lineGeometry;
		if(!this.line){
			lineGeometry = new Geo.Geometry.LineString([this.point.geometry]);
		} else {
			var points = this.line.geometry.components;
			points.push(this.point.geometry);
			lineGeometry = new Geo.Geometry.LineString(points);
		}
		this.layer.removeFeatures(this.line);
		this.line = new Geo.Feature.Vector(lineGeometry);
		this.layer.addFeatures([this.line], {silent: true});
	},
				
    /**
     * APIMethod: createFeature
     * 向临时矢量图层添加绘制要素。
     *
     * Parameters:
     * lonlat - {Object} 经纬度信息。
     */
    createFeature: function(lonlat) {
        this.point = new Geo.Feature.Vector(
            new Geo.Geometry.Point(lonlat.lon, lonlat.lat)
        );
        //this.callback("create", [this.point.geometry, this.point]);
        this.point.geometry.clearBounds();
        this.layer.addFeatures([this.point], {silent: true});
    },

    /**
     * APIMethod: deactivate
     * 关闭绘制线监听器。
     */
    deactivate: function() {
        if(!Geo.View3D.Handler.prototype.deactivate.apply(this, arguments)) {
            return false;
        }
        this.destroyFeature();
        if (this.layer.map != null) {
            this.layer.destroy(false);
        }
        this.layer = null;
		
		//this.map.activexObj.SetPickedState(false);
		
        return true;
    },
    
    /**
     * APIMethod: destroyFeature
     * 销毁临时绘制矢量要素。
     */
    destroyFeature: function() {
        if(this.layer) {
            this.layer.destroyFeatures();
        }
        this.point = null;
		this.line = null;
    },
	
    /**
     * 设置GeoRaster。
     */
    _setGeoRaster:function(){
        var GeoRaster = this.map._geoRaster;
        GeoRaster.GeoRasterType = 1;
        
        //设置精确拾取 开,漫游状态要还原为FALSE
    	this.map.activexObj.SetPickedState(true);  
    },
	
	/**
     * Method: handleDouble
     * 处理双击
     */
	handleDouble: function() {
        if (this.timerId) {
            window.clearTimeout(this.timerId);
            this.timerId = null;
        }
        this.timerId = window.setTimeout(
            OpenLayers.Function.bind(function() {
                this.timerId = null;
				this.finishGeometry();
            }, this), 300);
    },
	
	/**
     * Method: finishGeometry
     * 完成要素绘制
     */
	finishGeometry:function(){
		this._isDone = true;
        if(this.persist){
			this.layer.destroyFeatures();
		}
        if (this.line) {
            this.callback("done", [this.line.geometry.clone()]);
        }
	},
	
    CLASS_NAME: "Geo.View3D.Handler.Path"
});/**
 * Class: Geo.View3D.Handler.Polygon
 * 三维视图面几何对象绘制操作事件监听器。该对象激活后，将在三维视图上监听绘制面的操作，
 * 完成后返回用户绘制的几何对象。该对象关闭后，将移除绘制图层。
 * 
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Polygon = Geo.Class(Geo.View3D.Handler,{

	_points: [],

    /**
     * APIProperty: point
     * {<Geo.Feature.Vector>}当前绘制的点要素。
     */
    point: null,	
	
    /**
     * APIProperty: polygon
     * {<Geo.Feature.Vector>}当前绘制的线要素。
     */
    polygon: null,	    

    /**
     * APIProperty: layer
     * {<Geo.View3D.Layer.Vector>} 用于显示绘制要素的临时三维矢量图层。
     */
    layer: null,

    /**
     * APIProperty: persist
     * {Boolean} 是否立即销毁临时图层绘制的要素。
     */
    persist: false,
	
    /**
     * APIProperty: checkSelfCross
     * {Boolean} 是否允许多边形自相交。
     */
	checkSelfCross: true,

	//标记线是否点击右键绘制完成
	_isDone: false,

    /**
     * APIProperty: layerOptions
     * {Object} 临时绘制矢量要素图层对象构造选项。
     */
    layerOptions: null,
    
    /** 
     * Constructor: Geo.View3D.Handler.Polygon
     * Geo.View3D.Handler.Polygon构造函数。
     * 
     * Parameters:
     * control - {<Geo.View3D.Control>} 三维控件对象。
     * options - {Object} 参数对象。
     */
    initialize: function(control, options) {
        if(!(options && options.layerOptions && options.layerOptions.styleMap)) {
            this.style = OpenLayers.Util.extend(Geo.Feature.Vector.style['default'], {});
        }

        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
    },
    
	/**
	 * APIMethod: listener
	 * 鼠标事件监听器。
	 * 
     * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */	           
    listener:function(e){
		if (Geo.View3D.Event.KeyEvent.isKeyDown(e) || Geo.View3D.Event.KeyEvent.isKeyUp(e)) {
            return;
        }
        if (Geo.View3D.Event.MouseEvent.isMousemove(e)) {
            return;
        }
        if (Geo.View3D.Event.MouseEvent.isLeftClick(e)) {
			//alert(e.MouseButton +" L  "+ e.MouseState);
			//结束当前线绘制后，再次点击清除前次绘制
			if(this._isDone){
//				this.layer.removeFeatures(this.polygon);
				this.polygon = null;
				this._isDone = false;
			}
			
	        var lon = e.X;//e.Longitude;
	        var lat = e.Y;//e.Latitude;
			
			//临时保存点击的点供自相交检查
			this._points.push(new Geo.Geometry.Point(lon, lat));
			var linearRingGeometry = new Geo.Geometry.LinearRing(this._points);
			var polygonGeometry = new Geo.Geometry.Polygon([linearRingGeometry]);
		
            //做自相交检查，如果要求做相交检查而且自相交则不添加点
//            if(this.checkSelfCross && this._checkSelfCross(polygonGeometry)){
//                return;
//            }

			this.addPoint(new Geo.LonLat(lon,lat));
			this.callback("point", [this.point.geometry, this.polygon.geometry]);
		}
//		if(Geo.View3D.Event.MouseEvent.isRightClick(e)){
//			//alert(e.MouseButton +" R  "+ e.MouseState);
//			this._isDone = true;
//			this._points = [];
//            if(this.persist){
//				this.layer.destroyFeatures();
//			}
//            if (this.polygon) {
//                this.callback("done", [this.polygon.geometry.clone()]);
//                //this.map.activexObj.SetPickedState(false);
//            }
//		}
		//处理鼠标左键双击
		if(Geo.View3D.Event.MouseEvent.isMouseLeftDoubleClick(e)){
			this.handleDouble();
		}
    },
	
    /**
     * APIMethod: activate
     * 打开绘制面监听器。
     */
    activate: function() {
        if(!Geo.View3D.Handler.prototype.activate.apply(this, arguments)) {
            return false;
        }
        var options = OpenLayers.Util.extend({
            displayInLayerSwitcher: false,
			isOnTop: true
        }, this.layerOptions);
        this.layer = new Geo.View3D.Layer.Vector(this.CLASS_NAME, options);
        this.map.addLayer(this.layer);
		
		//this._setGeoRaster();
		
        return true;
    },	
	
	/**
	 * APIMethod: addPoint
	 * 添加点的方法。
	 * 
     * Parameters:
     * lonlat - {Object} 经纬度信息。
	 */	   
	addPoint:function(lonlat){
		this.point = new Geo.Feature.Vector(
            new Geo.Geometry.Point(lonlat.lon, lonlat.lat)
        );
        this.point.geometry.clearBounds();
		
		var polygonGeometry;
		var linearRingGeometry;
		if(!this.polygon){
			linearRingGeometry = new Geo.Geometry.LinearRing([this.point.geometry]);
		} else {
			var points = this.polygon.geometry.components[0].components;
			points.push(this.point.geometry);
			linearRingGeometry = new Geo.Geometry.LinearRing(points);
		}
		polygonGeometry = new Geo.Geometry.Polygon([linearRingGeometry]);
		this.layer.removeFeatures(this.polygon);
		this.polygon = new Geo.Feature.Vector(polygonGeometry);
		this.layer.addFeatures([this.polygon], {silent: true});
	},
				
    /**
     * APIMethod: createFeature
     * 向临时矢量图层添加绘制要素。
     *
     * Parameters:
     * lonlat - {Object} 经纬度信息。
     */
    createFeature: function(lonlat) {
        this.point = new Geo.Feature.Vector(
            new Geo.Geometry.Point(lonlat.lon, lonlat.lat)
        );
        //this.callback("create", [this.point.geometry, this.point]);
        this.point.geometry.clearBounds();
        this.layer.addFeatures([this.point], {silent: true});
    },

    /**
     * APIMethod: deactivate
     * 关闭绘制面监听器。
     */
    deactivate: function() {
        if(!Geo.View3D.Handler.prototype.deactivate.apply(this, arguments)) {
            return false;
        }
        this.destroyFeature();
        if (this.layer.map != null) {
            this.layer.destroy(false);
        }
        this.layer = null;
		
		//this.map.activexObj.SetPickedState(false);
		
        return true;
    },
    
    /**
     * APIMethod: destroyFeature
     * 销毁临时绘制矢量要素。
     */
    destroyFeature: function() {
        if(this.layer) {
            this.layer.destroyFeatures();
        }
        this.point = null;
        this.polygon = null;
    },
    
	//设置GeoRaster
    _setGeoRaster:function(){
        var GeoRaster = this.map._geoRaster;
        GeoRaster.GeoRasterType = 1;
        
        //设置精确拾取 开,漫游状态要还原为FALSE
    	this.map.activexObj.SetPickedState(true);  
    },
    
    //检查传入的点串有没有自交叉
    _checkSelfCross:function(allPoints){
        var checkPoints = this._getPointsSpaceSplitStr(allPoints);
        var Globe = this.map.activexObj;
        return Globe.SetTerrainAnalysisParam(checkPoints, 0, -1);
    },
	
    //将点数组转换成空格分隔的字符串
    _getPointsSpaceSplitStr:function(polygonGeometry){
		var linearRing = polygonGeometry.components[0];
		var allPoints = linearRing.components;
		
        var points = [];
        for(var i=0; i<allPoints.length; i++){
            points.push(allPoints[i].x);
            points.push(allPoints[i].y);
        }
        return points.join(" ");
    },	
	
	/**
     * Method: handleDouble
     * 双击处理
     */
	handleDouble: function() {
        if (this.timerId) {
            window.clearTimeout(this.timerId);
            this.timerId = null;
        }
        this.timerId = window.setTimeout(
            OpenLayers.Function.bind(function() {
                this.timerId = null;
				this.finishGeometry();
            }, this), 300);
    },
	
	/**
     * Method: finishGeometry
     * 完成要素绘制
     */
	finishGeometry:function(){
		this._isDone = true;
		this._points = [];
        if(this.persist){
			this.layer.destroyFeatures();
		}
        if (this.polygon) {
            this.callback("done", [this.polygon.geometry.clone()]);
            //this.map.activexObj.SetPickedState(false);
        }
	},
	
    CLASS_NAME: "Geo.View3D.Handler.Polygon"
});/**
 * Class: Geo.View3D.Handler.Feature
 * 三维视图要素选择对象操作事件监听器。该对象激活后，将在三维视图上监听要素选择的操作。
 * 
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Feature = Geo.Class(Geo.View3D.Handler,{

    //保存鼠标最后移入的要素id
    _feature: null,
	
    //是否启用图层选择功能
    _isEnableLayerSelect: false,

    /** 
     * Constructor: Geo.View3D.Handler.Feature
     * Geo.View3D.Handler.Feature构造函数。
     * 
     * Parameters:
     * control - {<Geo.View3D.Control>} 三维控件对象。
     * options - {Object} 参数对象。
     */
    initialize: function(control, options) {
        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
        this.control = control;
    },
    
	/**
	 * APIMethod: listener
	 * 鼠标事件监听器。
	 * 
     * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */	
    listener:function(e){
        var control = this.control;
        var globe = control.map.activexObj;
        var vectorLayer = control.layer;
        this._enableLayerSelect();
        var featureId = this._getFeatureIdFromScreen(e.ScreenX, e.ScreenY);
        var feature = control._getFeatureFromId(featureId);
        if (control.hover && Geo.View3D.Event.MouseEvent.isMousemove(e)) {
            if(featureId && this._feature !== featureId){
                control.select(feature);
                this._feature = featureId;
            }
            if(!featureId && this._feature){
                control.unselect(feature);
                this._feature = null;
            }
        }
        //监听鼠标左键点击下
        if (Geo.View3D.Event.MouseEvent.isLeftClick(e)) {
        	 if(featureId){
                control.select(feature);
                this._feature = featureId;
            }
        }
        //监听鼠标移动下，取消选择要素
		if(control.moveMapPopupClose == true && Geo.View3D.Event.MouseEvent.isMouseDownMove(e)){
        	if(!featureId && this._feature){
                control.unselect(feature);
                this._feature = null;
            }
        }
        //监听鼠标左击，取消选择要素
        if(control.moveMapPopupClose == false &&  Geo.View3D.Event.MouseEvent.isLeftClick(e)){
        	if(!featureId && this._feature){
                control.unselect(feature);
                this._feature = null;
            }
        }
    },

    //打开底层矢量图层选择功能
    _enableLayerSelect: function(){
        if(this._isEnableLayerSelect){
            return;
        }
        var control = this.control;
        var globe = control.map.activexObj;
        var vectorLayer = control.layer;
        //打开SelectionBox的选择功能，打开图层的选择功能
        globe.SelectionBox.EnableSelection = true;
        //针对标注
        var layerOp = globe.LayerBox.CreateLayerOperate(vectorLayer._dynamicLayer);
        layerOp.ChangeLayerProperty(6, true);
        //针对线面
        var layerOp2 = globe.LayerBox.CreateLayerOperate(vectorLayer._layerData);
        layerOp2.ChangeLayerProperty(6, true);
        this._isEnableLayerSelect = true;
    },

    //根据屏幕坐标查询对应要素id
    _getFeatureIdFromScreen: function(screenX,screenY){
        var control = this.control;
        var featureId = false;
        var globe = control.map.activexObj;
        globe.SelectionBox.SelectByScreenPoint(screenX, screenY);

        if(globe.SelectionBox.Count == 0){
            return featureId;
        }
        var box = globe.SelectionBox.QuerySelectedObject(0);
		if(box){
	        if( null == box.POIID || undefined == box.POIID){
	            featureId = box.Key;
	        } else {
	            featureId = box.POIGUID;
	        }			
		}
        return featureId;
    },

    CLASS_NAME: "Geo.View3D.Handler.Feature"
});/**
 * Class: Geo.View3D.Handler.Keyboard
 * 三维视图的键盘事件监听器。本类负责监听键盘的按下和抬起事件。
 *
 * Inherits from:
 *  - <Geo.View3D.Handler>
 */
Geo.View3D.Handler.Keyboard = Geo.Class(Geo.View3D.Handler, {

	/**
	 * Constructor: Geo.View3D.Handler.Keyboard
	 * Geo.View3D.Handler.Keyboard构造函数。
	 * 
	 * Parameters:
	 * control - {Geo.View3D.Control}关联的控件。
	 * callbacks - {Object} 回调方法。
	 * options - {Object} 参数选项。
	 */  
    initialize: function(control, callbacks, options) {
        Geo.View3D.Handler.prototype.initialize.apply(this, arguments);
    },
	
    /**
     * APIMethod: listener
     * 鼠标事件监听器。
     *
     * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
     */
    listener: function(e){
		if (Geo.View3D.Event.KeyEvent.isKeyboardDown(e)) {
            this.callback("keyboardDown", [e]);
        }
        if (Geo.View3D.Event.KeyEvent.isKeyboardUp(e)) {
            this.callback("keyboardUp", [e]);
        }
    },
    
    CLASS_NAME: "Geo.View3D.Handler.Keyboard"
});
/**
 * Class: Geo.View3D.Control
 * 三维视图控件基类。本类不直接使用,需要由子类继承。
 */
Geo.View3D.Control = Geo.Class({
	
    /**
     * APIProperty: id
     * {String} 唯一标识符。
     */      
    id: null,

    /**
     * APIProperty: autoActivate
     * {Boolean} 控件加入地图后是否自动激活。
     */      
    autoActivate: false,

    /**
     * APIProperty: active
     * {Boolean} 控件当前激活状态。
     */    
    active: false,

    /**
     * APIProperty: handler
     * {Object} 三维视图事件监听对象。
     */      
    handler: null,
	
    /**
     * APIProperty: eventListeners
     * {Object} 三维视图事件监听器。
     */      
    eventListeners: null,
	
    /**
     * APIProperty: events
     * {Object} 三维视图事件。
     */      
    events: null,
	
    /**
     * APIProperty: EVENT_TYPES
     * {Array} 控件基类所支持的事件类型。
     */     
    EVENT_TYPES: ["activate", "deactivate"],

    /**
     * APIProperty: map
     * {<Geo.View3D.Map>} 控件所属地图对象。
     */
    map: null,

	/**
	 * Constructor: Geo.View3D.Control
	 * Geo.View3D.Control构造函数。
	 *
	 * Parameters:
	 * options - {Object} 相关参数选项。
	 */    
    initialize: function(options){
        OpenLayers.Util.extend(this, options);
        
        this.events = new OpenLayers.Events(this, null, this.EVENT_TYPES);
        if(this.eventListeners instanceof Object) {
            this.events.on(this.eventListeners);
        }
        if (this.id == null) {
            this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        }
    },

	/**
	 * APIMethod: setMap
	 * 将控件关联到地图对象。
	 *
	 * Parameters:
	 * map - {<Geo.View3D.Map>} 三维地图对象。
	 */	    
    setMap: function(map) {
        this.map = map;
        if (this.handler) {
            this.handler.setMap(map);
        }
    },
    
    //控件绘制，由子类实现
    draw: function(px){
        
    },

	/**
	 * APIMethod: listener
	 * 鼠标事件监听器。
	 *
	 * Parameters:
	 * e - {Object} 三维地图鼠标事件对象。
	 */	     
    listener:function(e){
        
    },

	/**
	 * APIMethod: activate
	 * 激活控件。如果当前控件已经处于激活状态则返回false，否则激活该控件的事件监听器handler，并且触发该控件的"activate"事件，返回true。
	 */	     
    activate: function () {
        if (this.active) {
            return false;
        }
        if (this.handler) {
            this.handler.activate();
        }
        this.active = true;
        this.events.triggerEvent("activate");
        return true;
    },

	/**
	 * APIMethod: deactivate
	 * 关闭控件。如果当前控件已经处于关闭状态则返回false，否则关闭该控件的事件监听器handler，并且触发该控件的"deactivate"事件，返回true。
	 */	    
    deactivate: function () {
        if (this.active) {
            if (this.handler) {
                this.handler.deactivate();
            }
            this.active = false;
            this.events.triggerEvent("deactivate");
            return true;
        }
        return false;
    },
    
	/**
	 * APIMethod: destroy
	 * 销毁控件。
	 */	  
    destroy: function () {
        if(this.events) {
            if(this.eventListeners) {
                this.events.un(this.eventListeners);
            }
            this.events.destroy();
            this.events = null;
        }
        this.eventListeners = null;

        // eliminate circular references
        if (this.handler) {
            this.handler.destroy();
            this.handler = null;
        }
        if(this.handlers) {
            for(var key in this.handlers) {
                if(this.handlers.hasOwnProperty(key) &&
                   typeof this.handlers[key].destroy == "function") {
                    this.handlers[key].destroy();
                }
            }
            this.handlers = null;
        }
        if (this.map) {
            this.map.removeControl(this);
            this.map = null;
        }
    },
	  
    CLASS_NAME: "Geo.View3D.Control"
});/**
 * Class: Geo.View3D.Control.KeyboardDefaults
 * 三维视图键盘控制控件类。使用本控件可以实现用键盘进行三维视图的平移以及缩小放大功能。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.KeyboardDefaults = Geo.Class(Geo.View3D.Control, {

    /**
     * APIProperty: autoActivate
     * 设置控件为加入地图中自动激活。
     */
    autoActivate: true,
    
    /**
     * APIProperty: delta
     * 按下方向键时平移增量。
     */
    delta: 0,
    
    /**
     * Constructor: Geo.View3D.Control.KeyboardDefaults
     * Geo.View3D.Control.KeyboardDefaults构造函数。
     */
    initialize: function(options){
        Geo.View3D.Control.prototype.initialize.apply(this, arguments);
        this.handler = new Geo.View3D.Handler.KeybordDefaults(this, null, {
            onKeySpace: OpenLayers.Function.bind(this.resetNorth, this),
            onKeyLeft: OpenLayers.Function.bind(this.panLeft, this),
            onKeyUp: OpenLayers.Function.bind(this.panUp, this),
            onKeyRight: OpenLayers.Function.bind(this.panRight, this),
            onKeyDown: OpenLayers.Function.bind(this.panDown, this),
            onKeyPlus: OpenLayers.Function.bind(this.zoomIn, this),
            onKeyMinus: OpenLayers.Function.bind(this.zoomOut, this)
        });
    },
    
    /**
     * APIMethod: resetNorth
     * 重新设置指北方向。
     */
    resetNorth: function(){
        if (this.map) {
            this.map.resetNorth();
        }
    },
    
    /**
     * APIMethod: panLeft
     * 三维视图向左平移。
     */
    panLeft: function(){
        this.pan("left");
    },
    
    /**
     * APIMethod: panUp
     * 三维视图向上平移。
     */
    panUp: function(){
        this.pan("up");
    },
    
    /**
     * APIMethod: panRight
     * 三维视图向右平移。
     */
    panRight: function(){
        this.pan("right");
    },
    
    /**
     * APIMethod: panDown
     * 三维视图向下平移。
     */
    panDown: function(){
        this.pan("down");
    },
    
    /**
     * APIMethod: pan
     * 三维视图平移。
     *
     * Paramters:
     * type - {String} 方向类型，其值可为："left"、"up"、"right"、"down"。
     */
    pan: function(type){
        var globe = this.map.activexObj;
        var delta = this.delta;//15;//globe.GetCamera().ViewRange;
        var camera = globe.Camera;
        switch (type) {
            case "left":
                camera.Pan(-delta, 0);
                break;
            case "up":
                camera.Pan(0, delta);
                break;
            case "right":
                camera.Pan(delta, 0);
                break;
            case "down":
                camera.Pan(0, -delta);
                break;
        }
    },
    
    /**
     * APIMethod: zoomIn
     * 地图放大。
     */
    zoomIn: function(){
        var map = this.map;
        if (map) {
            map.zoomIn();
        }
    },
    
    /**
     * APIMethod: zoomOut
     * 地图缩小。
     */
    zoomOut: function(){
        var map = this.map;
        if (map) {
            map.zoomOut();
        }
    },
	
    CLASS_NAME: "Geo.View3D.Control.KeyboardDefaults"
});
/**
 * Class: Geo.View3D.Control.Measure
 * 量算类。
 * (code)
 * 使用方法：
 * 1.构造一个实例与地图关联，将自己的事件分派器与地图量算响应方法相关联。
 * 2.添加针对不同的量算类型添加绘制不同类型几何体的HANDLER。
 * 3.捕获到绘点线面的动作后调用响应方法。
 * (end)
 * Inherits from:
 *  - <Geo.View3D.Control>
 *
 */
Geo.View3D.Control.Measure = Geo.Class(Geo.View3D.Control, {

    /**
     * 量算服务地址。
     */
    serviceUrl: null,
    
    /**
     * 图层等级
     */
    layerLevel: null,
    
    /**
     * 图层名称
     */
    layerName: null,
    
    /**
     * 失败回调函数
     */
    failFn: null,
    
    /**
     * 地形分析服务对象。
     */
    _terrainAnalysisService: null,
    
    /**
     * 监听器类型由量算子类设置。
     */
    handlerType: null,
    
    /**
     * 监听器构造参数。
     */
    handlerOptions: null,
    
    /**
     * 点。
     */
    _points: null,
    
    /**
     * 临时保存量算结果。
     */
    _result: null,
    
    /**
     * {Object} The functions that are sent to the handler for callback
     */
    callbacks: null,
    
    /**
     * 构造函数。生成一个Geo.View3D.Control.Measure的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.serviceUrl = serviceUrl;
        this._terrainAnalysisService = new Geo.Service.TAS(this.id + "_service", serviceUrl);
        this.callbacks = OpenLayers.Util.extend({
            done: this._onComplete,
            point: this._onAddPoint
        }, this.callbacks);
        this.handlerOptions = this.handlerOptions || {};
        if (this.handlerType) {
            this.handler = new this.handlerType(this, this.callbacks, this.handlerOptions);
        }
        
    },
    
    /**
     * 量算完成。
     */
    _isComplete: false,
    
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     */
    onAddPoint: function(){
    },
    
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     */
    onComplete: function(result){
    },
    
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     */
    _onComplete: function(geometry){
    },
    
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     */
    _onAddPoint: function(){
    },
    
    /**
     * 量算监听器
     */
    _measureHandler: function(mouseEvent){
    },
    
    /**
     * 设置量算服务地址
     */
    setMeasureService: function(url){
        if (url && this._terrainAnalysisService) {
            this._terrainAnalysisService.url = url;
        }
    },
    
    /**
     * 获取量算结果
     */
    _getMeasureResult: function(type, options, successFn){
        var defaultOptions = {
            pointCount: this._terrainAnalysisService._countCoord(options.coordinates),
            layerLevel: this.layerLevel,
            layerName: this.layerName,
            subjoin: 0
        };
        options = OpenLayers.Util.applyDefaults(options, defaultOptions);
        
        var serivce = this._terrainAnalysisService;
        if (serivce) {
            serivce[type](options, successFn, this.failFn);
        }
    },
    
    /**
     * 激活量算控件
     */
    activate: function(){
        if (Geo.View3D.Control.prototype.activate.apply(this, arguments)) {
            this.map._measureHandler = OpenLayers.Function.bind(this._measureHandler, this);
            this.setMeasureService(this.serviceUrl);
        }
        return true;
    },
    
    /**
     * 将二维点数组，加上指高度形成三维点数组转换成空格分隔的字符串
     */
    _getPointsThreeDegreeSpaceSplitStr: function(polygonGeometry, height){
        var linearRing = polygonGeometry.components[0];
        var allPoints = linearRing.components;
        
        var points = [];
        for (var i = 0; i < allPoints.length; i++) {
            points.push(allPoints[i].x);
            points.push(allPoints[i].y);
            points.push(height);
        }
        return points.join(" ");
    },
    
    /**
     * 将点数组转换成空格分隔的字符串
     */
    _getPointsSpaceSplitStr: function(polygonGeometry){
        var linearRing = polygonGeometry.components[0];
        var allPoints = linearRing.components;
        
        var points = [];
        for (var i = 0; i < allPoints.length; i++) {
            points.push(allPoints[i].x);
            points.push(allPoints[i].y);
        }
        return points.join(" ");
    },
    
    /**
     * 设置量算分析服务参数
     */
    _setMeasureParams: function(type, pointsString, boxHeight){
        var Globe = this.map.activexObj;
        if (type !== undefined) {
            Globe.SetTerrainAnalysisParam(pointsString, boxHeight, type);
        }
    },
    
    /**
     * 删除盒子图层
     */
    _clearBoxLayer: function(){
        var Globe = this.map.activexObj;
        var layer = Globe.GetSceneGroup().GetLayerByName(this.id + "_boxLayer");
        if (layer != null) {
            Globe.GetSceneGroup().RemoveLayer(layer);
        }
    },
    
    /**
     * 画盒子图层
     */
    _createBoxLayer: function(mousePoints){
    
        var Globe = this.map.activexObj;
        
        // 画盒子用接口
        var LocalDataBox = Globe.CreateAddLocalDataObj();
        
        var pointstr = this._getPointsThreeDegreeSpaceSplitStr(mousePoints, 0);
        
        
        var boxLayerId = this.id + "_boxLayer";
        var layerdata = LocalDataBox.AddPolyGon(boxLayerId, pointstr);
        
        layerdata.name = boxLayerId;
        LocalDataBox.setPolyGonHeight(boxLayerId, this.height);
        LocalDataBox.SetBoxFaceColor(boxLayerId, 0x7fffffff, 0x7fffffff, 0x7fffffff)
        
    },
    
    CLASS_NAME: "Geo.View3D.Control.Measure"
});
/**
 * Class: Geo.View3D.Control.DrawPath
 * 几何线绘制控件类。使用本控件可以在三维地图上画线。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.DrawPath = Geo.Class(Geo.View3D.Control, {

    /**
     * APIProperty: type
     * 控件类型。 
     */  
    type: Geo.View2D.Control.TYPE_TOOL,
    
    /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: null,
    
	/**
	 * Constructor: Geo.View3D.Control.DrawPath
	 * Geo.View3D.Control.DrawPath构造函数。
	 */    
    initialize: function(options){
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.callbacks = OpenLayers.Util.extend(
            {
                "done": this.done
            },
            this.callbacks
        );
        this.handlerOptions = this.handlerOptions || {};        
        this.handler = new Geo.View3D.Handler.Path(this, this.callbacks, this.handlerOptions);
    },

    /**
     * APIMethod: done
     * 几何对象绘制完成回调函数，用户可以使用自己的方法来覆盖它。
     * 
     * Paramters:
     * geometry - 绘制的几何对象。
     */   	
    done: function(geometry){
        
    }
    
});
/**
 * Class: Geo.View3D.Control.DrawPoint
 * 几何点绘制控件类。使用本控件可以在三维地图上画点。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.DrawPoint = Geo.Class(Geo.View3D.Control, {

    /**
     * APIProperty: type
     * 控件类型。
     */
    type: Geo.View2D.Control.TYPE_TOOL,
    
    /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: null,
       
 	/**
	 * Constructor: Geo.View3D.Control.DrawPoint
	 * Geo.View3D.Control.DrawPoint构造函数。
	 */     
    initialize: function(options){
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.callbacks = OpenLayers.Util.extend(
            {
                "done": this.done
            },
            this.callbacks
        );
        this.handlerOptions = this.handlerOptions || {};
        this.handler = new Geo.View3D.Handler.Point(this, this.callbacks, this.handlerOptions);
    },
	
    /**
     * APIMethod: done
     * 几何对象绘制完成回调函数，用户可以使用自己的方法来覆盖它。
     * 
     * Paramters:
     * geometry - 绘制的几何对象。
     */   	
    done: function(geometry){
        
    }
    
});
/**
 * Class: Geo.View3D.Control.DrawPolygon
 * 几何多边形绘制控件类。使用本控件可以在三维地图上画面。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.DrawPolygon = Geo.Class(Geo.View3D.Control, {

    /**
     * APIProperty: type
     * 控件类型。 
     */
    type: Geo.View2D.Control.TYPE_TOOL,
    
    /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: null,
     
 	/**
	 * Constructor: Geo.View3D.Control.DrawPolygon
	 * Geo.View3D.Control.DrawPolygon构造函数。
	 */   
    initialize: function(options){
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.callbacks = OpenLayers.Util.extend(
            {
                "done": this.done
            },
            this.callbacks
        );
        this.handlerOptions = this.handlerOptions || {};
        this.handler = new Geo.View3D.Handler.Polygon(this, this.callbacks, this.handlerOptions);
    },
	
    /**
     * APIMethod: done
     * 几何对象绘制完成回调函数，用户可以使用自己的方法来覆盖它。
     * Paramters:
     * geometry - 绘制的几何对象。
     */       
    done: function(geometry){
        
    }
    
});
/**
 * Class: Geo.View3D.Control.DrawFeature
 * 要素绘制控件可以在三维矢量图层上通过鼠标绘制点、线、面要素。
 *
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.DrawFeature = Geo.Class(Geo.View3D.Control, {
    
    /**
     * APIProperty: layer
     * {<Geo.View3D.Layer.Vector>} 矢量图层对象。
     */
    layer: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */
    callbacks: null,
    
    /**
     * APIProperty: EVENT_TYPES
     * 触发的事件类型。
     */
    EVENT_TYPES: ["featureadded"],

	/**
     * APIMethod: featureAdded
     * 当在地图上绘画一个要素的时候会触发本方法。
     */
    featureAdded: function() {},

    /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,
    
    /**
     * Constructor: Geo.View3D.Control.DrawFeature
     * Geo.View3D.Control.DrawFeature构造函数。
     * 
     * Parameters:
     * layer - {<Geo.View3D.Layer.Vector>} 
     * handler - {<Geo.View3D.Handler>} 
     * options - {Object} 
     */
    initialize: function(layer, handler, options) {
        
        // concatenate events specific to vector with those from the base
        this.EVENT_TYPES =
            Geo.View3D.Control.DrawFeature.prototype.EVENT_TYPES.concat(
            Geo.View3D.Control.prototype.EVENT_TYPES
        );
        
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.callbacks = OpenLayers.Util.extend(
            {
                done: this.drawFeature
            },
            this.callbacks
        );
        this.layer = layer;
        this.handlerOptions = this.handlerOptions || {};

        var sketchStyle = this.layer.styleMap && this.layer.styleMap.styles.temporary;
        if(sketchStyle) {
            this.handlerOptions.layerOptions = OpenLayers.Util.applyDefaults(
                this.handlerOptions.layerOptions,
                {styleMap: new Geo.StyleMap({"default": sketchStyle})}
            );
        }
        this.handler = new handler(this, this.callbacks, this.handlerOptions);
    },

	/**
     * APIMethod: drawFeature
     * 在三维视图上绘制要素图层。
	 * 
	 * Paramters:
	 * geometry - {Object} 绘制的几何对象。
     */
    drawFeature: function(geometry) {
        var feature = new Geo.Feature.Vector(geometry);
        this.layer.addFeatures([feature]);
        this.featureAdded(feature);
        this.events.triggerEvent("featureadded",{feature : feature});
    },
	
    CLASS_NAME: "Geo.View3D.Control.DrawFeature"
});/**
 * Class: Geo.View3D.Control.SelectFeature
 * 三维视图下要素选择控件，该控件实现在指定的的图层上通过鼠标单击和悬浮选择矢量要素。
 *
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.SelectFeature = Geo.Class(Geo.View3D.Control, {

    clickout: true,

    multiple: false,

    EVENT_TYPES: ["beforefeaturehighlighted", "featurehighlighted", "featureunhighlighted"],
	
   /**
    * APIProperty: hover
    * {boolean} 在鼠标悬浮在要素上时，选中要素；移出要素时，取消选中。若设置为true，鼠标点击将不起作用。默认为false。
    */
    hover: false,	
	
	/**
	 * APIProperty: moveMapPopupClose
     * {boolean} 默认在鼠标拖动地图时，弹出的浮云框不会自动关闭。若设置为true，鼠标拖动地图时，浮云框会自动关闭。默认为false。
	 */
	moveMapPopupClose:false,

    /**
     * APIProperty: layer
     * {<Geo.View3D.Layer.Vector>} 要素选择控件所对应的矢量图层
     */
    layer: null,
	
    /**
     * APIProperty: scope
     * {Object} onBeforeSelect, onSelect, onUnselect等回调方法的上下文，即this的指向。如果为null值，则指向要素选择控件本身。
     * 
     */
    scope: null,

    /**
     * APIProperty: onBeforeSelect
     * {Function} 要素被选中之前可以调用该方法，完成用户指定的任务。要求用户定义具体方法，该方法接收当前选中要素作为参数。
     */
    onBeforeSelect: function() {},

    /**
     * APIProperty: onSelect
     * {Function} 要素被选中后可以调用该方法，完成用户指定的任务。要求用户定义具体方法，该方法接收当前选中要素作为参数。
     */
    onSelect: function() {},

    /**
     * APIProperty: onUnselect
     * {Function} 要素取消选择后可以调用该方法，完成用户指定的任务。要求用户定义具体方法，该方法接收当前选中要素作为参数。
     */
    onUnselect: function() {},	

    /**
     * Constructor: Geo.View3D.Control.SelectFeature
     * Geo.View3D.Control.SelectFeature构造函数
     *
     * Parameters:
     * layer - {<Geo.View3D.Layer.Vector>} 要素选择控件所对应的矢量图层
     * options - {Object} 构造参数
     */
    initialize: function(layer, options) {
        this.EVENT_TYPES =
            Geo.View3D.Control.SelectFeature.prototype.EVENT_TYPES.concat(
            Geo.View3D.Control.prototype.EVENT_TYPES
        );
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.handler = new Geo.View3D.Handler.Feature(this);
        this.layer = layer;
    },

    highlight: function(feature) {
        var layer = feature.layer;
    },


    unhighlight: function(feature) {
        var layer = feature.layer;
    },

    onSelect: function(feature){

    },
	
    /**
     * APIMethod: destroy
     * 销毁方法
     */
    destroy: function() {
    },	
	
    /**
     * APIMethod: setMap
     * 将控件关联到地图
     *
     * Parameters:
     * map - {<OpenLayers.Map>}
     */
    setMap: function(map) {
        Geo.View3D.Control.prototype.setMap.apply(this, arguments);
    },	

    /**
     * APIMethod: select
     * 选择要素，将指定要素添加到矢量图层的selectedFeatures数组中，重新以被选中样式绘制要素，
     * 并且调用onSelect方法。
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>}
     */
    select: function(feature) {
        //var feature = this._getFeatureFromId(featureId);
		if(null == feature || undefined == feature) return;
		var cont = this.onBeforeSelect.call(this.scope, feature);
        var layer = feature.layer;
        if(cont !== false) {
            cont = layer.events.triggerEvent("beforefeatureselected", {
                feature: feature
            });
            if(cont !== false) {
                if(this.multiple){
                    layer.selectedFeatures.push(feature);
                } else {
                    layer.selectedFeatures = [feature];
                }
                this.highlight(feature);
                layer.events.triggerEvent("featureselected", {feature: feature});
                this.onSelect.call(this.scope, feature);
            }
        }
    },

    _getFeatureFromId: function(featureId){
        var features = this.layer.features;
        for(var i=0; i<features.length; i++){
            var f = features[i];
            if(f.id === featureId){
                return f;
            };
        }
    },

    /**
     * APIMethod: unselect
     * 取消选择要素
     *
     * Parameters:
     * feature - {<Geo.Feature.Vector>}
     */
    unselect: function(feature) {
        //var feature = this._getFeatureFromId(featureId);
        if(null == feature || undefined == feature) return;
        var layer = feature.layer;
        this.unhighlight(feature);
        OpenLayers.Util.removeItem(layer.selectedFeatures, feature);
        this.onUnselect.call(this.scope, feature);
    },
	
    /**
     * APIMethod: unselectAll
     * 取消所有被选择要素
     *
     */
    unselectAll: function() {
        var layer = this.layer, feature;
        for(var i=layer.selectedFeatures.length-1; i>=0; --i) {
            feature = layer.selectedFeatures[i];
        }
    },	

    /**
     * APIProperty: CLASS_NAME
     * {String} 类名标识 - "Geo.View3D.Control.SelectFeature"
     * 
     */
    CLASS_NAME: "Geo.View3D.Control.SelectFeature"
});/**
 * Class: Geo.View3D.Control.Attribution
 * 图层属性信息控件。
 *
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.Attribution = 
  Geo.Class(Geo.View3D.Control, {
    
    /**
     * APIProperty: seperator
     * {String} 分隔符，用于分隔单个图层信息。不可以为HTML，可以加入转义符，例如："layer1\nlayer2"。
     */
    separator: ",",
	
	/**
	 * APIProperty: style
	 * {Object} 控件信息显示的样式。
	 * Symbolizer properties:
	 * startX - {Number} 以视图左上角为原点（0,0），文字框的左上点距离三维视图左边框的像素点。
	 * startY - {Number} 文字框的左上点距离三维视图上边框的像素点。
	 * endX - {Number} 文字框的右下点距离三维视图左边框的像素点。
	 * endY - {Number} 文字框的右下点距离三维视图上边框的像素点。
	 * fontSize - {Number} 字体大小。
	 * fontFamily - {String} 字体系列。
	 * opacity - {Number} 透明度。
	 * colorR - {Number} 颜色：红色的值。
	 * colorG - {Number} 颜色：绿色的值。
	 * colorB - {Number} 颜色：蓝色的值。
	 */
	style: {
		startX: 10,
		startY: 10,
		endX: 300,
		endY: 300,
		fontSize: 20,
		fontFamily: "雅黑",
		opacity: 255,
		colorR: 255,
		colorG: 255,
		colorB: 0
	},
    
    /**
     * Constructor: Geo.View3D.Control.Attribution 
     * 构造函数。
     * 
     * Parameters:
     * options - {Object} 选项参数。
     */
    initialize: function(options) {
        Geo.View3D.Control.prototype.initialize.apply(this, arguments);
    },

	/**
     * Method: updateAttribution
     * 控件销毁，私有。
     */
    destroy: function() {
		this.deactivate();
		this.removeTextElement();
        Geo.View3D.Control.prototype.destroy.apply(this, arguments);
    },    
     
	/**
     * Method: updateAttribution
     * 关联地图，私有。
     */
    setMap: function(map) {
        Geo.View3D.Control.prototype.setMap.apply(this, arguments);
    },

	/**
     * Method: updateAttribution
     * 控件绘制，私有。
     */
    draw: function(px){
        Geo.View3D.Control.prototype.draw.apply(this, arguments);
        this.map.events.on({
            'loadlayergroup': this.updateAttribution,
            scope: this
        });
        this.updateAttribution();
    },
	
    /**
     * Method: removeTextElement
     * 删除图层信息。
     */
    removeTextElement: function(){
        var globe = null;
        if (this.map) {
            globe = this.map.activexObj
            if (globe) {
                //globe.ScreenBox.ClearTextElement();
                globe.ScreenBox.RemoveTextElement(this.id);
            }
        }
    },
	
    /**
     * Method: updateAttribution
     * 更新图层信息。
     */
    updateAttribution: function() {
        if(this.map && this.map.activexObj){
            var globe = this.map.activexObj;
            var attributions = [];
            if (this.map.layers) {
                for(var i=0, len=this.map.layers.length; i<len; i++) {
                    var layer = this.map.layers[i];
                    if (layer.attribution && layer.getVisibility()) {
                        // add attribution only if attribution text is unique
                        if (OpenLayers.Util.indexOf(
                                        attributions, layer.attribution) === -1) {
                            attributions.push( layer.attribution );
                        }
                    }
                } 
				
                var outstr = attributions.join(this.separator);
                //globe.AddText(1, outstr, this.style.startX, this.style.startY, this.style.endX, this.style.endY, this.style.fontSize, this.style.fontFamily, this.style.opacity, this.style.colorR, this.style.colorG, this.style.colorB);
				globe.ScreenBox.AppendTextElement(this.id, 
				outstr, 
				this.style.fontFamily, 
				this.style.fontSize, 
				this.style.colorR+","+this.style.colorG+","+this.style.colorB, 
				this.style.startX, 
				this.style.startY, 
				this.style.endX, //width
				this.style.endY);//height
			}
        }
    },
	
    CLASS_NAME: "Geo.View3D.Control.Attribution"
});
/**
 * Class: Geo.View3D.Control.Box
 * 三维视图鼠标拉框类。本控件能够实现在三维视图下，用户使用鼠标进行拉框，来获得所拉框的bbox范围。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.Box = Geo.Class(Geo.View3D.Control,{
	
	 /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: null,
	
    /**
     * Constructor: Geo.View3D.Control.PullBoxControl
     * Geo.View3D.Control.PullBoxControl构造函数。
     */
    initialize: function(options){
		Geo.View3D.Control.prototype.initialize.apply(this, [options]);
		this.callbacks = OpenLayers.Util.extend(
            {
                "emitMouseHandler": this.emitMouseHandler
            },
            this.callbacks
        );
		this.handlerOptions = this.handlerOptions || {};
    	this.handler = new Geo.View3D.Handler.Box( this,
                            this.callbacks, this.handlerOptions);
    },	
	
	/**
	 * APIMethod: emitMouseHandler
	 * 拉框后的回调方法，由用户覆盖。
	 * 
	 * Parameters:
     * bbox - {String} bounds的字符串表示方式,值的顺序为左下右上。
	 */
	emitMouseHandler: function(bbox) {

	},
	
	CLASS_NAME: "Geo.View3D.Control.Box"
});/**
 * Class: Geo.View3D.Control.ModelChoose
 * 三维视图模型选择控件类。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.ModelChoose = Geo.Class(Geo.View3D.Control, {
	
	 /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,
	
	 /**
     * APIProperty: layer
     * {<Geo.View3D.Layer.Model>} 模型图层。
     */
    layer: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: {},
	
    /**
     * Constructor: Geo.View3D.Control.ModelChoose
     * Geo.View3D.Control.ModelChoose构造函数。
     */
    initialize: function(layer, options) {
		Geo.View3D.Control.prototype.initialize.apply(this, [options]);
		this.layer = layer;
		this.callbacks = OpenLayers.Util.extend(
            {
                "chooseModel": this.chooseModel
            },
            this.callbacks
        );
		this.handlerOptions = this.handlerOptions || {};
    	this.handler = new Geo.View3D.Handler.ModelChoose(this,
                            this.callbacks, this.handlerOptions);
    },	
	
	chooseModel: function(mouseEvent, isSelected, fid) {
		
	},
	
	CLASS_NAME: "Geo.View3D.Control.ModelChoose"
});/**
 * Class: Geo.View3D.Control.Mouse
 * 三维视图鼠标动作类。使用本控件可以实现通过鼠标左键，右键以及鼠标移动动作来捕捉到三维地图的鼠标事件对象。
 * 说明：本类与鼠标拉框动作功能是分开的。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.Mouse = Geo.Class(Geo.View3D.Control,{
	
	 /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: null,
	
    /**
     * Constructor: Geo.View3D.Control.Mouse
     * Geo.View3D.Control.Mouse构造函数。
     */
    initialize: function(options){
		Geo.View3D.Control.prototype.initialize.apply(this, [options]);
		this.callbacks = OpenLayers.Util.extend(
            {
                "click": this.onClick,
				"rightClick": this.onRightClick,
				"mouseMove": this.onMouseMove,
				"dblclick": this.onDblclick,
				"mouseUp": this.onMouseUp,
				"mouseRightUp":this.onMouseRightUp,
				"mouseDown": this.onMouseDown,
				"mouseWheel": this.onMouseWheel,
				"mouseOut": this.onMouseOut,
				"mouseOver": this.onMouseOver,
				"movestart": this.onMoveStart,
				"move": this.onMove,
				"moveend": this.onMoveEnd,
				"zoomend": this.onZoomEnd
            },
            this.callbacks
        );
		this.handlerOptions = this.handlerOptions || {};
    	this.handler = new Geo.View3D.Handler.Mouse( this,
                            this.callbacks, this.handlerOptions);
    },
	
   	/**
	 * APIMethod: onDblclick
	 * 鼠标左键双击动作，由用户覆盖
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象
	 */
	onDblclick: function(e) {

	},
	
	/**
	 * APIMethod: onClick
	 * 鼠标左键点击动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onClick: function(e) {

	},
	
	/**
	 * APIMethod: onRightClick
	 * 鼠标右键点击动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onRightClick: function(e) {
	
	},
	
	/**
	 * APIMethod: onMouseMove
	 * 鼠标移动动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseMove: function(e) {

	},
	
	/**
	 * APIMethod: onMouseUp
	 * 鼠标左键抬起动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseUp: function(e) {
		
	},
	
	/**
	 * APIMethod: onMouseDown
	 * 鼠标按下动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseDown: function(e) {
	
	},
	/**
	 * APIMethod: onMouseWheel
	 * 鼠标滚轮动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseWheel: function(e) {
		
	},
	
	/**
	 * APIMethod: onMouseOut
	 * 当鼠标移出元素时，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseOut: function(e) {
		
	},
	
	/**
	 * APIMethod: onMouseOver
	 * 当鼠标移动到元素上时，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseOver: function(e) {
		
	},
	
	/**
	 * APIMethod: onMouseRightUp
	 * 鼠标右键抬起动作，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMouseRightUp: function() {
	
	},
	
	/**
	 * APIMethod: onMoveStart
	 * 鼠标移动开始，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMoveStart: function() {
	
	},
	
	/**
	 * APIMethod: onMove
	 * 鼠标移动中，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMove: function() {
	
	},
	
	/**
	 * APIMethod: onMoveEnd
	 * 鼠标移动结束，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onMoveEnd: function() {
	
	},
	
	/**
	 * APIMethod: onZoomEnd
	 * 鼠标缩放地图，由用户覆盖。
	 * 
	 * Parameters:
     * e - {Object} 三维地图的鼠标事件对象。
	 */
	onZoomEnd: function() {
	
	},
	
	CLASS_NAME: "Geo.View3D.Control.Mouse"
});/**
* Class: Geo.View3D.Control.Analysis
* 测量与分析。
*
* Inherits from:
*  - <Geo.View3D.Control.Analysis>
*/
Geo.View3D.Control.Analysis = Geo.Class(Geo.View3D.Control, {
    //定义数组对象
    keyEventHandlers: [],
    trackerIds: [],
    elementsKeys: [],
    analysisResult: [],
    //分析结果对象
    m_surfaceArea_result: null, //面积 result
    m_aspectAnalysis_Result: null, //坡向分析 result
    m_slopeAnalysis_Result: null, //坡度分析 result
    m_cutFillAnalysis_result: null, //填挖方分析 result
    m_nosSourceFlood_Result: null, //洪水淹没 result
    m_sectionPlane_Result: null, //剖面分析 result
    m_oObserverPoints_Result: null, //单点可视 result
    m_lineOfSight_Result: null, //两点通视 result
    m_mulitiPointLineOfSight_Result: null, //多点通视 result
    m_viewshedAnalysis_Result: null, //相机可视域分析

    m_surfaceArea3D_result: null, //空间面积分析 result
    m_movePoint: null,


    m_pTracker: null,

    //三维Tracker操作类型枚举
    enumTrackerType:
	{
	    eTrackerEmpty: 0,
	    eTrackerPolyline: 1,
	    eTrackerPolygon: 2,
	    eTrackerCircleSurface: 3,
	    eTrackerCircleLine: 4,
	    eTrackerVerticalLine: 5,
	    eTrackerPolyline3D: 6,
	    eScreenEnvelopeTracker: 7,
	    eScreenPolylineTracker: 8,
	    eTrackerPolygon3D: 9
	},
    //量算类型
    enumAnalysisType: {
        measureLength: 0,
        surfaceArea: 1,
        elevationAnalysis: 2,
        aspectAnalysis: 3,
        slopeAnalysis: 4,
        cutFillAnalysis: 5,
        noSourceFloodAnalysis: 6,
        spatialLength: 7,
        spatialArea: 8,
        opserverPoints: 9,
        lineOfSight: 10,
        multiPointLineOfSight: 11,
        viewshedAnalysis: 12
    },
    /**
    * APIProperty: 填挖方目标高度
    * {Number} 
    */
    cutFillAnalysisHeight: 100,
    /**
    * APIProperty: 淹没高度
    * {Number} 
    */
    floodAnalysisHeight: 100,
    /**
    * APIProperty: autoActivate
    * {Boolean} 控件加入地图后是否自动激活。
    */
    autoActivate: true,


    /**
    * APIProperty: 相机可视域分析 水平视角
    * {double} 
    */
    viewshedAnalysisVerticalFOVAngle: 45.0,

    /**
    * APIProperty: 相机可视域分析 竖直视角
    * {double} 
    */
    viewshedAnalysisHorizontalFOVAngle: 45.0,

    /**
    * APIProperty: 相机可视域分析 可视距离
    * {double} 
    */
    viewshedAnalysisViewDistance: 100,

    /**
    * APIProperty: 相机可视域分析 方向角
    * {double} 
    */
    viewshedAnalysisHeadingAngle: 0,

    /**
    * APIProperty: 相机可视域分析 俯仰角
    * {double} 
    */
    viewshedAnalysisTiltAngle: -15,

    /**
    * APIProperty: 相机可视域分析 结果表现形式，0表示用线方式显示，其他值表示用填充方式显示
    * {double} 
    */
    viewshedAnalysisResultPresentatio: 1,

    /**
    * Constructor: Geo.View3D.Control.Analysis
    * 构造函数。生成一个Geo.View3D.Control.Analysis的实例。
    */
    initialize: function(options) {
        Geo.View3D.Control.prototype.initialize.apply(this, arguments);
    },

	 /**
     * APIMethod: measureLengthAnalysis
     * 量算距离。
     * 
     */  
    measureLengthAnalysis: function() {
        var id = OpenLayers.Util.createUniqueID();
        var globe = this.map.activexObj;
        if (globe) {
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerPolyline);
            this.lengthHandler = OpenLayers.Function.bind(function(eventObj) {
                this._lengthHandler(eventObj);
            }, this);

            //     globe.attachEvent("OnGeometryTracked", this.lengthHandler);
            if (globe.attachEvent) {
                globe.attachEvent("OnGeometryTracked", this.lengthHandler);
            } else if (globe.addEventListener) {
                globe.addEventListener("GeometryTracked", this.lengthHandler, false);
            }
            this.keyEventHandlers.push(this.lengthHandler);
            this.trackerIds.push(id);
        }
    },

    _lengthHandler: function(vObjGeo) {
        var globe = this.map.activexObj;
        var result = globe.AnalysisBox.SectionPlane(vObjGeo, 1000);
        // alert(result.InterpolationTotalLength);
        this.onComplete(this.enumAnalysisType.measureLength, result.InterpolationTotalLength);
        //   globe.detachEvent("OnGeometryTracked", this.lengthHandler);
        if (globe.detachEvent) {
            globe.detachEvent("OnGeometryTracked", this.lengthHandler);
        } else if (globe.removeEventListener) {
            globe.removeEventListener("GeometryTracked", this.lengthHandler, false);
        }
    },

	 /**
     * APIMethod: onComplete
     * 完成量算和分析的回调函数。
     * 
     * Parameters:
     * type - {String} 操作类型。
     * result - {Object} 返回结果。
     * 
     */
    onComplete: function(type, result) {
    },
	
     /**
     * APIMethod: measureLengthAnalysis
     * 量算面积。
     * 
     */
    surfaceAreaAnalysis: function() {
        var id = OpenLayers.Util.createUniqueID();
        var globe = this.map.activexObj;
        if (globe) {
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerPolygon);
            this.surfaceAreaHandler = OpenLayers.Function.bind(function(eventObj) {
                this._surfaceAreaHandler(eventObj);
            }, this);
            this.surfaceAreaFinishedHandler = OpenLayers.Function.bind(function(eventObj) {
                this._surfaceAreaFinishedHandler(eventObj);
            }, this);
            //		globe.attachEvent("OnTrackerFinished", this.surfaceAreaHandler);
            if (globe.attachEvent) {
                globe.attachEvent("OnTrackerFinished", this.surfaceAreaHandler);
            } else if (globe.addEventListener) {
                globe.addEventListener("TrackerFinished", this.surfaceAreaHandler, false);
            }
            //			globe.attachEvent("OnGeometryTracked", this.surfaceAreaHandler);
            //         globe.attachEvent("OnAnalysisFinished", this.surfaceAreaFinishedHandler);
            if (globe.attachEvent) {
                globe.attachEvent("OnAnalysisFinished", this.surfaceAreaFinishedHandler);
            } else if (globe.addEventListener) {
                globe.addEventListener("AnalysisFinished", this.surfaceAreaFinishedHandler, false);
            }

            this.trackerIds.push(id);
            this.keyEventHandlers.push(this.surfaceAreaHandler);
            this.keyEventHandlers.push(this.surfaceAreaFinishedHandler);
        }
    },
    _surfaceAreaHandler: function(vObjGeo, type) {
        var globe = this.map.activexObj;
        //	globe.detachEvent("OnTrackerFinished", this.surfaceAreaHandler);
        if (globe.detachEvent) {
            globe.detachEvent("OnTrackerFinished", this.surfaceAreaHandler);
        } else if (globe.removeEventListener) {
            globe.removeEventListener("TrackerFinished", this.surfaceAreaHandler, false);
        }
        var globe = this.map.activexObj;
        this.m_surfaceArea_result = globe.AnalysisBox.AreaAsynchronous(vObjGeo.Result, 10);
        globe.ScreenBox.AppendElement(this.m_surfaceArea_result.ProgressElement);
        this.m_surfaceArea_result.DoAnalysis();
        this.elementsKeys.push(this.m_surfaceArea_result.ProgressElement.Key);
    },
    _surfaceAreaFinishedHandler: function(vObjGeo) {
        var globe = this.map.activexObj;
        //	globe.detachEvent("OnAnalysisFinished", this.surfaceAreaFinishedHandler);
        if (globe.detachEvent) {
            globe.detachEvent("OnAnalysisFinished", this.surfaceAreaFinishedHandler);
        } else if (globe.removeEventListener) {
            globe.removeEventListener("AnalysisFinished", this.surfaceAreaFinishedHandler, false);
        }
        //alert(this.m_surfaceArea_result.Area);
        this.onComplete(this.enumAnalysisType.surfaceArea, this.m_surfaceArea_result.Area);
    },
	
     /**
     * APIMethod: measureHeightAnalysis
     * 高度量算。
     * 
     */
    measureHeightAnalysis: function() {
        var id = OpenLayers.Util.createUniqueID();
        var globe = this.map.activexObj;
        if (globe) {
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerVerticalLine);
            this.trackerIds.push(id);
        }
    },

	 /**
     * APIMethod: queryElevationAnalysis
     * 高程信息查询。
     * 
     */
    queryElevationAnalysis: function() {
        var globe = this.map.activexObj;
        if (globe) {
            this.queryElevationHandler = OpenLayers.Function.bind(function(eventObj) {
                this._queryElevationHandler(eventObj);
            }, this);
            //	globe.attachEvent("OnMouseEvent", this.queryElevationHandler);
            if (globe.attachEvent) {
                globe.attachEvent("OnMouseEvent", this.queryElevationHandler);
            } else if (globe.addEventListener) {
                globe.addEventListener("MouseEvent", this.queryElevationHandler, false);
            }
            this.keyEventHandlers.push(this.queryElevationHandler);
        }
    },
	
	 /**
     * APIMethod: removeElevationAnalysis
     * 删除高程信息查询监听。
     * 
     */
    removeElevationAnalysis: function() {
        var globe = this.map.activexObj;
        if (globe) {
            if (this.queryElevationHandler) {
                //	globe.detachEvent("OnMouseEvent", this.queryElevationHandler);
                if (globe.detachEvent) {
                    globe.detachEvent("OnMouseEvent", this.queryElevationHandler);
                } else if (globe.removeEventListener) {
                    globe.removeEventListener("MouseEvent", this.queryElevationHandler, false);
                }
            }
        }
    },
    _queryElevationHandler: function(e) {
        //监听鼠标单击事件
        if (e.MouseButton === 1 && e.MouseState === 0) {
            var finalResult = {
                longitude: null,
                latitude: null,
                altitude: null,
                slope: null,
                aspect: null
            };
            finalResult.longitude = e.X.toFixed(2);
            finalResult.latitude = e.Y.toFixed(2);
            finalResult.altitude = e.Altitude.toFixed(2);
            //调用回调函数
            this.onComplete(this.enumAnalysisType.elevationAnalysis, finalResult);
        }
    },

	/**
     * APIMethod: aspectAnalysis
     * 坡向分析。
     * 
     */
    aspectAnalysis: function() {
        var globe = this.map.activexObj;
        if (globe) {
            var id = OpenLayers.Util.createUniqueID();
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerPolygon);
            this.aspectTrackedHandler = OpenLayers.Function.bind(function(eventObj) {
                this._aspectTrackedHandler(eventObj);
            }, this);
            this.aspectFinishedHandler = OpenLayers.Function.bind(function(eventObj) {
                this._aspectFinishedHandler(eventObj);
            }, this);
            //		globe.attachEvent("OnGeometryTracked", this.aspectTrackedHandler);
            if (globe.attachEvent) {
                globe.attachEvent("OnGeometryTracked", this.aspectTrackedHandler);
            } else if (globe.addEventListener) {
                globe.addEventListener("GeometryTracked", this.aspectTrackedHandler, false);
            }
            //		globe.attachEvent("OnAnalysisFinished", this.aspectFinishedHandler);
            if (globe.attachEvent) {
                globe.attachEvent("OnAnalysisFinished", this.aspectFinishedHandler);
            } else if (globe.addEventListener) {
                globe.addEventListener("AnalysisFinished", this.aspectFinishedHandler, false);
            }
            this.trackerIds.push(id);
            this.keyEventHandlers.push(this.aspectTrackedHandler);
            this.keyEventHandlers.push(this.aspectFinishedHandler);
        }
    },
    _aspectTrackedHandler: function(vObjGeo) {
        var globe = this.map.activexObj;
        //	globe.detachEvent("OnGeometryTracked", this.aspectTrackedHandler);
        if (globe.detachEvent) {
            globe.detachEvent("OnGeometryTracked", this.aspectTrackedHandler);
        } else if (globe.removeEventListener) {
            globe.removeEventListener("GeometryTracked", this.aspectTrackedHandler, false);
        }
        this.m_aspectAnalysis_Result = globe.AnalysisBox.RangeAspect(vObjGeo, 10);
        globe.ScreenBox.AppendElement(this.m_aspectAnalysis_Result.ProgressDisplayElement);
        this.elementsKeys.push(this.m_aspectAnalysis_Result.ProgressDisplayElement.Key);
        //开始分析
        this.m_aspectAnalysis_Result.DoAnalysis(null);
    },
    _aspectFinishedHandler: function(varResultObject, resultType) {
        var globe = this.map.activexObj;
        //	globe.detachEvent("OnAnalysisFinished", this.aspectFinishedHandler);
        if (globe.detachEvent) {
            globe.detachEvent("OnAnalysisFinished", this.aspectFinishedHandler);
        } else if (globe.removeEventListener) {
            globe.removeEventListener("AnalysisFinished", this.aspectFinishedHandler, false);
        }
        globe.ScreenBox.RemoveElement(this.m_aspectAnalysis_Result.ProgressDisplayElement);
        globe.ScreenBox.AppendElement(this.m_aspectAnalysis_Result.ResultDisplayElement);
        this.elementsKeys.push(this.m_aspectAnalysis_Result.ResultDisplayElement.Key);
        this.onComplete(this.enumAnalysisType.aspectAnalysis, "");
    },


	/**
     * APIMethod: slopeAnalysis
     * 坡度分析。
     * 
     */
    slopeAnalysis: function() {
        var globe = this.map.activexObj;
        if (globe) {
            var id = OpenLayers.Util.createUniqueID();
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerPolygon);
            this.slopeTrackedHandler = OpenLayers.Function.bind(function(eventObj) {
                this._slopeTrackedHandler(eventObj);
            }, this);
            this.slopeFinishedHandler = OpenLayers.Function.bind(function(eventObj) {
                this._slopeFinishedHandler(eventObj);
            }, this);
            //		globe.attachEvent("OnGeometryTracked", this.slopeTrackedHandler); 
            if (globe.attachEvent) {
                globe.attachEvent("OnGeometryTracked", this.slopeTrackedHandler);
            } else if (globe.addEventListener) {
                globe.addEventListener("GeometryTracked", this.slopeTrackedHandler, false);
            }
            //		globe.attachEvent("OnAnalysisFinished", this.slopeFinishedHandler); 
            if (globe.attachEvent) {
                globe.attachEvent("OnAnalysisFinished", this.slopeFinishedHandler);
            } else if (globe.addEventListener) {
                globe.addEventListener("AnalysisFinished", this.slopeFinishedHandler, false);
            }
            this.trackerIds.push(id);
            this.keyEventHandlers.push(this.slopeTrackedHandler);
            this.keyEventHandlers.push(this.slopeFinishedHandler);
        }
    },
    _slopeTrackedHandler: function(vObjGeo) {
        var globe = this.map.activexObj;
        //	globe.detachEvent("OnGeometryTracked", this.slopeTrackedHandler);
        if (globe.detachEvent) {
            globe.detachEvent("OnGeometryTracked", this.slopeTrackedHandler);
        } else if (globe.removeEventListener) {
            globe.removeEventListener("GeometryTracked", this.slopeTrackedHandler, false);
        }
        this.m_slopeAnalysis_Result = globe.AnalysisBox.RangeSlope(vObjGeo, 10);
        globe.ScreenBox.AppendElement(this.m_slopeAnalysis_Result.ProgressDisplayElement);
        this.elementsKeys.push(this.m_slopeAnalysis_Result.ProgressDisplayElement.Key);
        //开始分析
        this.m_slopeAnalysis_Result.DoAnalysis(null);
    },
    _slopeFinishedHandler: function(varResultObject, resultType) {
        var globe = this.map.activexObj;
        //	globe.detachEvent("OnAnalysisFinished", this.slopeFinishedHandler); 
        if (globe.detachEvent) {
            globe.detachEvent("OnAnalysisFinished", this.slopeFinishedHandler);
        } else if (globe.removeEventListener) {
            globe.removeEventListener("AnalysisFinished", this.slopeFinishedHandler, false);
        }
        globe.ScreenBox.RemoveElement(this.m_slopeAnalysis_Result.ProgressDisplayElement);
        globe.ScreenBox.AppendElement(this.m_slopeAnalysis_Result.ResultDisplayElement);
        this.elementsKeys.push(this.m_slopeAnalysis_Result.ResultDisplayElement.Key);
        this.onComplete(this.enumAnalysisType.slopeAnalysis, "");
    },

	/**
     * APIMethod: cutFillAnalysis
     * 填挖方分析。
     * 
     */
    cutFillAnalysis: function() {
        var globe = this.map.activexObj;
        if (globe) {
            var id = OpenLayers.Util.createUniqueID();
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerPolygon);
            this.cutFillTrackedHandler = OpenLayers.Function.bind(function(eventObj) {
                this._cutFillTrackedHandler(eventObj);
            }, this);
            //	globe.attachEvent("OnGeometryTracked", this.cutFillTrackedHandler);
            if (globe.attachEvent) {
                globe.attachEvent("OnGeometryTracked", this.cutFillTrackedHandler);
            } else if (globe.addEventListener) {
                globe.addEventListener("GeometryTracked", this.cutFillTrackedHandler, false);
            }
            this.trackerIds.push(id);
            this.keyEventHandlers.push(this.cutFillTrackedHandler);
        }
    },
    _cutFillTrackedHandler: function(vObjGeo) {
        var globe = this.map.activexObj;
        //	globe.detachEvent("OnGeometryTracked", this.cutFillTrackedHandler);
        if (globe.detachEvent) {
            globe.detachEvent("OnGeometryTracked", this.cutFillTrackedHandler);
        } else if (globe.removeEventListener) {
            globe.removeEventListener("GeometryTracked", this.cutFillTrackedHandler, false);
        }
        this.m_cutFillAnalysis_result = globe.AnalysisBox.CutFill(vObjGeo);
        globe.ScreenBox.AppendElement(this.m_cutFillAnalysis_result.ResultDisplayElement);
        this.elementsKeys.push(this.m_cutFillAnalysis_result.ResultDisplayElement.Key);
        //分析
        this.m_cutFillAnalysis_result.CutFillTo(this.cutFillAnalysisHeight);
        this.onComplete(this.enumAnalysisType.cutFillAnalysis, this.m_cutFillAnalysis_result);
    },


	/**
     * APIMethod: nosSourceFloodAnalysis
     * 洪水淹没。
     * 
     */
    nosSourceFloodAnalysis: function() {
        var globe = this.map.activexObj;
        if (globe) {
            var id = OpenLayers.Util.createUniqueID();
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerPolygon);
            this.nosSourceFloodTrackedHandler = OpenLayers.Function.bind(function(eventObj) {
                this._nosSourceFloodTrackedHandler(eventObj);
            }, this);
            //	globe.attachEvent("OnGeometryTracked", this.nosSourceFloodTrackedHandler);
            if (globe.attachEvent) {
                globe.attachEvent("OnGeometryTracked", this.nosSourceFloodTrackedHandler);
            } else if (globe.addEventListener) {
                globe.addEventListener("GeometryTracked", this.nosSourceFloodTrackedHandler, false);
            }
            this.trackerIds.push(id);
            this.keyEventHandlers.push(this.nosSourceFloodTrackedHandler);
        }
    },
    _nosSourceFloodTrackedHandler: function(vObjGeo) {
        var globe = this.map.activexObj;
        //	globe.detachEvent("OnGeometryTracked", this.nosSourceFloodTrackedHandler);
        if (globe.detachEvent) {
            globe.detachEvent("OnGeometryTracked", this.nosSourceFloodTrackedHandler);
        } else if (globe.removeEventListener) {
            globe.removeEventListener("GeometryTracked", this.nosSourceFloodTrackedHandler, false);
        }
        this.m_nosSourceFlood_Result = globe.AnalysisBox.NoSourceFlood(vObjGeo);
        globe.ScreenBox.AppendElement(this.m_nosSourceFlood_Result.ResultDisplayElement);
        this.elementsKeys.push(this.m_nosSourceFlood_Result.ResultDisplayElement.Key);
        this.m_nosSourceFlood_Result.FloodTo(this.floodAnalysisHeight);
        this.onComplete(this.enumAnalysisType.noSourceFloodAnalysis, this.m_nosSourceFlood_Result);
    },

	/**
     * APIMethod: sectionPlaneAnalysis
     * 剖面分析。
     * 
     */
    sectionPlaneAnalysis: function() {
        var globe = this.map.activexObj;
        if (globe) {
            var id = OpenLayers.Util.createUniqueID();
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerPolyline);
            this.sectionPlaneTrackedHandler = OpenLayers.Function.bind(function(eventObj) {
                this._sectionPlaneTrackedHandler(eventObj);
            }, this);
            //	globe.attachEvent("OnGeometryTracked", this.sectionPlaneTrackedHandler);
            if (globe.attachEvent) {
                globe.attachEvent("OnGeometryTracked", this.sectionPlaneTrackedHandler);
            } else if (globe.addEventListener) {
                globe.addEventListener("GeometryTracked", this.sectionPlaneTrackedHandler, false);
            }
            this.trackerIds.push(id);
            this.keyEventHandlers.push(this.sectionPlaneTrackedHandler);
        }
    },
    _sectionPlaneTrackedHandler: function(vObjGeo) {
        //	globe.detachEvent("OnGeometryTracked", this.sectionPlaneTrackedHandler);
        if (globe.detachEvent) {
            globe.detachEvent("OnGeometryTracked", this.sectionPlaneTrackedHandler);
        } else if (globe.removeEventListener) {
            globe.removeEventListener("GeometryTracked", this.sectionPlaneTrackedHandler, false);
        }
        var globe = this.map.activexObj;
        this.m_sectionPlane_Result = globe.AnalysisBox.SectionPlane(vObjGeo, 50);
        var line = this.m_sectionPlane_Result.InterpolationGeometry;
        var drawBox = globe.DrawBox;
        var str = "";
        var wkt = line.ExportToData(1, str);
        //定义数组对象
        var resultData = [];
        /**
        for (var i = 0; i < line.PointCount; i++)
        {
        //var x, y, z;
        //line.GetPoint(i, x, y, z);
        var x, y, z;
        line.ExportToData(i, 'out'+ 'x', out y, out z);
        //resultData.Add(z);
        resultData.push(z);
        }*/
        //				 m_ResultView.Result = resultData;
        alert(resultData);
    },


	/**
     * APIMethod: spatialLengthAnalysis
     * 空间距离量算。
     * 
     */
    spatialLengthAnalysis: function() {
        var id = OpenLayers.Util.createUniqueID();
        var globe = this.map.activexObj;
        if (globe) {
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerPolyline3D);
            this.length3DHandler = OpenLayers.Function.bind(function(eventObj) {
                this._length3DHandler(eventObj);
            }, this);

            //     globe.attachEvent("OnGeometryTracked", this.length3DHandler);
            if (globe.attachEvent) {
                globe.attachEvent("OnGeometryTracked", this.length3DHandler);
            } else if (globe.addEventListener) {
                globe.addEventListener("GeometryTracked", this.length3DHandler, false);
            }
            this.keyEventHandlers.push(this.length3DHandler);
            this.trackerIds.push(id);
        }
    },

    _length3DHandler: function(vObjGeo) {
        var globe = this.map.activexObj;
		var result = globe.AnalysisBox.Length(vObjGeo, 2);
        this.onComplete(this.enumAnalysisType.spatialLength, result);
        //   globe.detachEvent("OnGeometryTracked", this.length3DHandler);
        if (globe.detachEvent) {
            globe.detachEvent("OnGeometryTracked", this.length3DHandler);
        } else if (globe.removeEventListener) {
            globe.removeEventListener("GeometryTracked", this.length3DHandler, false);
        }
    },

	/**
     * APIMethod: spatialAreaAnalysis
     * 空间面积量算。
     * 
     */
    spatialAreaAnalysis: function() {
        var id = OpenLayers.Util.createUniqueID();
        var globe = this.map.activexObj;
        if (globe) {
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerPolygon3D);
            this.surfaceArea3DHandler = OpenLayers.Function.bind(function(eventObj) {
                this._surfaceArea3DHandler(eventObj);
            }, this);
            this.surfaceArea3DFinishedHandler = OpenLayers.Function.bind(function(eventObj) {
                this._surfaceArea3DFinishedHandler(eventObj);
            }, this);
            //		globe.attachEvent("OnTrackerFinished", this.surfaceArea3DHandler);
            if (globe.attachEvent) {
                globe.attachEvent("OnTrackerFinished", this.surfaceArea3DHandler);
            } else if (globe.addEventListener) {
                globe.addEventListener("TrackerFinished", this.surfaceArea3DHandler, false);
            }
            //			globe.attachEvent("OnGeometryTracked", this.surfaceArea3DHandler);
            //         globe.attachEvent("OnAnalysisFinished", this.surfaceArea3DFinishedHandler);
            if (globe.attachEvent) {
                globe.attachEvent("OnAnalysisFinished", this.surfaceArea3DFinishedHandler);
            } else if (globe.addEventListener) {
                globe.addEventListener("AnalysisFinished", this.surfaceArea3DFinishedHandler, false);
            }

            this.trackerIds.push(id);
            this.keyEventHandlers.push(this.surfaceArea3DHandler);
            this.keyEventHandlers.push(this.surfaceArea3DFinishedHandler);
        }
    },
    _surfaceArea3DHandler: function(vObjGeo, type) {
        var globe = this.map.activexObj;
        //	globe.detachEvent("OnTrackerFinished", this.surfaceAreaHandler);
        if (globe.detachEvent) {
            globe.detachEvent("OnTrackerFinished", this.surfaceArea3DHandler);
        } else if (globe.removeEventListener) {
            globe.removeEventListener("TrackerFinished", this.surfaceArea3DHandler, false);
        }
        var globe = this.map.activexObj;
        this.m_surfaceArea3D_result = globe.AnalysisBox.AreaAsynchronous(vObjGeo.Result, 10);
        globe.ScreenBox.AppendElement(this.m_surfaceArea3D_result.ProgressElement);
        this.m_surfaceArea3D_result.DoAnalysis();
        this.elementsKeys.push(this.m_surfaceArea3D_result.ProgressElement.Key);
    },
    _surfaceArea3DFinishedHandler: function(vObjGeo) {
        var globe = this.map.activexObj;
        //	globe.detachEvent("OnAnalysisFinished", this.surfaceAreaFinishedHandler);
        if (globe.detachEvent) {
            globe.detachEvent("OnAnalysisFinished", this.surfaceArea3DFinishedHandler);
        } else if (globe.removeEventListener) {
            globe.removeEventListener("AnalysisFinished", this.surfaceArea3DFinishedHandler, false);
        }
        //alert(this.m_surfaceArea3D_result.Area);
        this.onComplete(this.enumAnalysisType.spatialArea, this.m_surfaceArea3D_result);
    },

	/**
     * APIMethod: observerPointsRangeAnalysis
     * 单点可视。
     * 
     */
    observerPointsRangeAnalysis: function() {//开始单点可视功能
        var globe = this.map.activexObj;

        //监听GeometryTrackered事件    
        this.observerPointsGeometryTrackeredHandler = OpenLayers.Function.bind(function(eventObj) {
            this._observerPointsGeometryTrackeredHandler(eventObj);
        }, this);
        if (globe.attachEvent) {
            globe.attachEvent("OnGeometryTracked", this.observerPointsGeometryTrackeredHandler);
        } else if (globe.addEventListener) {
            globe.addEventListener("GeometryTracked", this.observerPointsGeometryTrackeredHandler, false);
        }

        //开始进行画面
        if (globe) {
            var id = OpenLayers.Util.createUniqueID();
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerPolygon);
            this.trackerIds.push(id);
        }
    },


    _observerPointsGeometryTrackeredHandler: function(vObjGeo) { //单点可视的范围设置
        //取消订阅GeometryTracked事件
        var globe = this.map.activexObj;
        if (globe.detachEvent) {
            globe.detachEvent("OnGeometryTracked", this.observerPointsGeometryTrackeredHandler);
        } else if (globe.removeEventListener) {
            globe.removeEventListener("GeometryTracked", this.observerPointsGeometryTrackeredHandler, false);
        }

        //设置观察范围
        this.m_Range = vObjGeo;

        //开始画观察点
        var id = OpenLayers.Util.createUniqueID();
        m_pTracker = globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerVerticalLine);
        this.trackerIds.push(id);


        //开始监听TrackerFinished事件
        this.observerPointsTrackerFinishedHandler = OpenLayers.Function.bind(function(eventObj) {
            this._observerPointsTrackerFinishedHandler(eventObj);
        }, this);
        if (globe.attachEvent) {
            globe.attachEvent("OnTrackerFinished", this.observerPointsTrackerFinishedHandler);
        } else if (globe.addEventListener) {
            globe.addEventListener("TrackerFinished", this.observerPointsTrackerFinishedHandler, false);
        }

    },

    _observerPointsTrackerFinishedHandler: function(varTrackerObject, eType) {//Tracker结束事件
        var globe = this.map.activexObj;
        if (typeof (varTrackerObject.Location) != "undefined") {

            //监听分析结束事件
            this.observerPointsAnalysisFinishedHandler = OpenLayers.Function.bind(function(eventObj) {
                this._observerPointsAnalysisFinishedHandler(eventObj);
            }, this);
            if (globe.attachEvent) {
                globe.attachEvent("OnAnalysisFinished", this.observerPointsAnalysisFinishedHandler);
            }
            else if (globe.addEventListener) {
                globe.addEventListener("AnalysisFinished", this.observerPointsAnalysisFinishedHandler, false);
            }


            //开始分析
            var pt3D = varTrackerObject.Location;
            pt3D.Z += m_pTracker.Length;

            this.m_oObserverPoints_Result = globe.AnalysisBox.ObserverPointsInRange(this.m_Range, pt3D);
            globe.ScreenBox.AppendElement(this.m_oObserverPoints_Result.ShowProcessElement);
            this.elementsKeys.push(this.m_oObserverPoints_Result.ShowProcessElement.Key);
            this.m_oObserverPoints_Result.StartAnalysisProcess();

            //取消监听TrackerFinished事件
            if (globe.detachEvent) {
                globe.detachEvent("OnTrackerFinished", this.observerPointsTrackerFinishedHandler);
            }
            else if (globe.removeEventListener) {
                globe.removeEventListener("TrackerFinished", this.observerPointsTrackerFinishedHandler, false);
            }
        }

    },

    //分析结束事件
    _observerPointsAnalysisFinishedHandler: function(varTrackerObject, enumAnalysisType) {
		var globe = this.map.activexObj;
        //结束监听分析结束事件
        if (globe.detachEvent) {
            globe.detachEvent("OnAnalysisFinished", this.observerPointsAnalysisFinishedHandler);
        }
        else if (globe.removeEventListener) {
            globe.removeEventListener("AnalysisFinished", this.observerPointsAnalysisFinishedHandler, false);
        }
        this.onComplete(this.enumAnalysisType.opserverPoints, this.m_oObserverPoints_Result);
    },

	/**
     * APIMethod: lineOfSightAnalysis
     * 两点通视。
     * 
     */
    lineOfSightAnalysis: function() {
        var globe = this.map.activexObj;
        this.LineOfSightClickCount = 0;
        this.LineOfSightMovePoint = null;
        this.LineOfSightStartTracker = null;
        this.LineOfSightEndTracker = null;
        //监听鼠标事件
        this.lineOfSightMouseEventHandler = OpenLayers.Function.bind(function(eventObj) {
            this._lineOfSightMouseEventHandler(eventObj);
        }, this);
        if (globe.attachEvent) {
            globe.attachEvent("OnMouseEvent", this.lineOfSightMouseEventHandler);
        }
        else if (globe.addEventListener) {
            globe.addEventListener("MouseEvent", this.lineOfSightMouseEventHandler, false);
        }
    },

    _lineOfSightMouseEventHandler: function(e) {
        var geoSpace3D = this.map.activexObj;
        switch (e.MouseState) {
            case 3:
                {
                    //改变橡皮条效果
                    if (this.LineOfSightMovePoint == null) {
                        this.LineOfSightMovePoint = geoSpace3D.ObjectFactory.CreateObject(100);
                    }
                    this.LineOfSightMovePoint.PutCoords(e.X, e.Y, e.Altitude);
                    if (null != this.m_lineOfSight_Result) {
                        if (null == this.LineOfSightEndTracker) {
                            this.m_lineOfSight_Result.EndPoint = this.LineOfSightMovePoint;
                        }
                        else {
                            this.m_lineOfSight_Result.EndPointHeight = this.LineOfSightEndTracker.Length;
                        }
                    }

                    break;
                }
            case 1:
                {
                    if (e.MouseButton != 1)
                        return;
                    //获取当前点
                    var pt = geoSpace3D.ObjectFactory.CreateObject(100);
                    pt.PutCoords(e.X, e.Y, e.Altitude);
                    //控制通视操作
                    this.LineOfSightMouseDown(pt);
                }
                break;
        }

        if (this.m_lineOfSight_Result == null)
            return;

    },

    LineOfSightMouseDown: function(point) {
        var geoSpace3D = this.map.activexObj;
        switch (this.LineOfSightClickCount) {
            case 0: //设置首点起点
                {
                    var id = OpenLayers.Util.createUniqueID();
                    this.LineOfSightStartTracker = geoSpace3D.DrawBox.StartTracker(id, 5);
                    this.LineOfSightStartTracker.Location = point;
                    this.trackerIds.push(id);

                }
                break;
            case 1: //设置首点结束位置
                {
                    //获取通视点
                    this.m_lineOfSight_Result = geoSpace3D.AnalysisBox.StartLineOfSight();
                    this.m_lineOfSight_Result.EnableTracker = false;
                    //添加屏幕显示
                    geoSpace3D.ScreenBox.AppendElement(this.m_lineOfSight_Result);
                    this.elementsKeys.push(this.m_lineOfSight_Result);

                    //设置通视起点
                    var pt = this.LineOfSightStartTracker.Location;
                    this.m_lineOfSight_Result.StartPoint = pt;
                    this.m_lineOfSight_Result.StartPointHeight = this.LineOfSightStartTracker.Length;
                }
                break;
            case 2: //设置尾点起点
                {
                    var id = OpenLayers.Util.createUniqueID();
                    this.LineOfSightEndTracker = geoSpace3D.DrawBox.StartTracker(id, 5);
                    this.LineOfSightEndTracker.Location = point;
                    this.trackerIds.push(id);

                    this.m_lineOfSight_Result.EndPoint = point;  //设置终点的位置
                }
                break;
            case 3: //修改通视结束点高度
                {
                    //修改终点的高度
                    this.m_lineOfSight_Result.EndPointHeight = this.LineOfSightEndTracker.Length;

                    //解绑定鼠标事件
                    if (geoSpace3D.detachEvent) {
                        geoSpace3D.detachEvent("OnMouseEvent", this.lineOfSightMouseEventHandler);
                    }
                    else if (geoSpace3D.removeEventListener) {
                        geoSpace3D.removeEventListener("MouseEvent", this.lineOfSightMouseEventHandler, false);
                    }
                }
                break;
        }
        //计数加1
        this.LineOfSightClickCount++;
    },

	/**
     * APIMethod: mulitiPointLineOfSightAnalysis
     * 多点通视。
     * 
     */
    mulitiPointLineOfSightAnalysis: function() {
        var globe = this.map.activexObj;
        if (globe) {
            this.m_movePoint = null;
            this.m_nClickCount = 0;
            //监听OnMouseEvent事件
            this.mulitiPointLineOfSightMouseEventHandler = OpenLayers.Function.bind(function(eventObj) {
                this._mulitiPointLineOfSightMouseEventHandler(eventObj);
            }, this);
            if (globe.attachEvent) {
                globe.attachEvent("OnMouseEvent", this.mulitiPointLineOfSightMouseEventHandler);
            }
            else if (globe.addEventListener) {
                globe.addEventListener("MouseEvent", this.mulitiPointLineOfSightMouseEventHandler, false);
            }
        }
    },

    _mulitiPointLineOfSightMouseEventHandler: function(e) {
        var geoSpace3D = this.map.activexObj;
        switch (e.MouseState) {
            case 3:
                //改变橡皮条效果
                if (this.m_movePoint == null) {
                    this.m_movePoint = geoSpace3D.ObjectFactory.CreateObject(100);
                }
                this.m_movePoint.PutCoords(e.X, e.Y, e.Altitude);
                if (null != this.m_mulitiPointLineOfSight_Result) {
                    if (this.m_nClickCount > 1) {
                        this.m_mulitiPointLineOfSight_Result.EndPoint = this.m_movePoint;
                    }
                }
                break;
            case 1:
                {
                    if (e.MouseButton != 1)
                        return;
                    //获取当前点
                    var pt = geoSpace3D.ObjectFactory.CreateObject(100);
                    pt.PutCoords(e.X, e.Y, e.Altitude);
                    //控制通视操作
                    if (this.m_nClickCount == 2) {
                        this.m_mulitiPointLineOfSight_Result.EndPoint = pt;
                        this.m_nClickCount = 1;
                    }
                    this.MouseDown(pt);
                }
                break;
            case 4:
                {

                    //解绑定鼠标事件

                    if (geoSpace3D.detachEvent) {
                        geoSpace3D.detachEvent("OnMouseEvent", this.mulitiPointLineOfSightMouseEventHandler);
                    }
                    else if (geoSpace3D.removeEventListener) {
                        geoSpace3D.removeEventListener("MouseEvent", this.mulitiPointLineOfSightMouseEventHandler, false);
                    }
                    break;
                }
        }
    },

    MouseDown: function(point) {
        var geoSpace3D = this.map.activexObj;
        switch (this.m_nClickCount) {
            case 0: //设置首点起点
                {
                    //开始绘制垂直Tracker
                    var id = OpenLayers.Util.createUniqueID();
                    this.pTracker = geoSpace3D.DrawBox.StartTracker(id, 5);
                    this.pTracker.Location = point;
                    this.trackerIds.push(id);
                }
                break;
            case 1: //设置首点结束位置
                {
                    //获取通视点
                    this.m_mulitiPointLineOfSight_Result = geoSpace3D.AnalysisBox.StartLineOfSight3D();
                    this.m_mulitiPointLineOfSight_Result.EnableTracker = false;
                    //添加屏幕显示
                    geoSpace3D.ScreenBox.AppendElement(this.m_mulitiPointLineOfSight_Result);
                    this.elementsKeys.push(this.m_mulitiPointLineOfSight_Result);
                    //设置通视起点
                    var pt = this.pTracker.Location;
                    this.m_mulitiPointLineOfSight_Result.StartPoint = pt;
                    this.m_mulitiPointLineOfSight_Result.StartPointHeight = this.pTracker.Length;

                }
                break;
            default:
                {
                    //解绑定鼠标事件
                    if (geoSpace3D.detachEvent) {
                        geoSpace3D.detachEvent("OnMouseEvent", this.mulitiPointLineOfSightMouseEventHandler);
                    }
                    else if (geoSpace3D.removeEventListener) {
                        geoSpace3D.removeEventListener("MouseEvent", this.mulitiPointLineOfSightMouseEventHandler, false);
                    }
                }
                break;
        }
        //计数加1
        this.m_nClickCount++;
    },

	/**
     * APIMethod: viewshedAnalysis
     * 相机可视域分析。
     * 
     */
    viewshedAnalysis: function() {
        var globe = this.map.activexObj;
        if (globe) {
            //监听OnMouseEvent事件
            this.viewshedTrackerFinishedHandler = OpenLayers.Function.bind(function(eventObj, eType) {
                this._viewshedTrackerFinishedHandler(eventObj, eType);
            }, this);
            if (globe.attachEvent) {
                globe.attachEvent("OnTrackerFinished", this.viewshedTrackerFinishedHandler);
            }
            else if (globe.addEventListener) {
                globe.addEventListener("TrackerFinished", this.viewshedTrackerFinishedHandler, false);
            }
            var id = OpenLayers.Util.createUniqueID();
            //开始第一个点
            globe.DrawBox.StartTracker(id, this.enumTrackerType.eTrackerVerticalLine);
            this.trackerIds.push(id);
        }
    },

    _viewshedTrackerFinishedHandler: function(eventObj, eType) {
        var geoSpace3D = this.map.activexObj;
        //取消监听TrackerFinished事件
        if (geoSpace3D.detachEvent) {
            geoSpace3D.detachEvent("OnTrackerFinished", this.viewshedTrackerFinishedHandler);
        }
        else if (geoSpace3D.removeEventListener) {
            geoSpace3D.removeEventListener("TrackerFinished", this.viewshedTrackerFinishedHandler, false);
        }
        var endPt = eventObj.Location;
        var endPtLength = eventObj.Length;
        //开始分析，监听分析结束事件
        this.viewshedAnalysisFinishedHandler = OpenLayers.Function.bind(function(eventAnalyseObj, eAnalyseType) {
            this._viewshedAnalysisFinishedHandler(eventAnalyseObj, eAnalyseType);
        }, this);
        if (geoSpace3D.attachEvent) {
            geoSpace3D.attachEvent("OnAnalysisFinished", this.viewshedAnalysisFinishedHandler);
        }
        else if (geoSpace3D.addEventListener) {
            geoSpace3D.addEventListener("AnalysisFinished", this.viewshedAnalysisFinishedHandler, false);
        }

        //分析
        this.m_viewshedAnalysis_Result = geoSpace3D.AnalysisBox.StartObserverCamera3D();

        geoSpace3D.ScreenBox.AppendElement(this.m_viewshedAnalysis_Result);
        this.elementsKeys.push(this.m_viewshedAnalysis_Result);

        //设置参数
        this.m_viewshedAnalysis_Result.VerticalFOVAngle = this.viewshedAnalysisVerticalFOVAngle;
        this.m_viewshedAnalysis_Result.HorizontalFOVAngle = this.viewshedAnalysisHorizontalFOVAngle;
        this.m_viewshedAnalysis_Result.ViewDistance = this.viewshedAnalysisViewDistance;
        endPt.Z = endPt.Z + endPtLength;
        this.m_viewshedAnalysis_Result.Location = endPt;
        this.m_viewshedAnalysis_Result.HeadingAngle = this.viewshedAnalysisHeadingAngle * 0.3;
        this.m_viewshedAnalysis_Result.TiltAngle = this.viewshedAnalysisTiltAngle *0.3 ;
        if (this.viewshedAnalysisResultPresentatio == 0) {
            this.m_viewshedAnalysis_Result.ResultPresentation = 0;
        }
        else {
            this.m_viewshedAnalysis_Result.ResultPresentation = 1;
        }
        this.m_viewshedAnalysis_Result.VerticalLineCount = this.viewshedAnalysisVerticalFOVAngle;
        this.m_viewshedAnalysis_Result.HorizontalLineCount = this.viewshedAnalysisHorizontalFOVAngle;
        this.m_viewshedAnalysis_Result.DoAnalysis();

    },

    _viewshedAnalysisFinishedHandler: function(eventAnalyseObj, eAnalyseType) {
        var geoSpace3D = this.map.activexObj;
        //取消监听AnalysisFinished事件
        if (geoSpace3D.detachEvent) {
            geoSpace3D.detachEvent("OnAnalysisFinished", this.viewshedAnalysisFinishedHandler);
        }
        else if (geoSpace3D.removeEventListener) {
            geoSpace3D.removeEventListener("AnalysisFinished", this.viewshedAnalysisFinishedHandler, false);
        }
        this.onComplete(this.enumAnalysisType.viewshedAnalysis, null);
    },

	/**
     * APIMethod: clearAnalysisResult
     * 清除分析结果。
     * 
     */
    clearAnalysisResult: function() {
        var globe = this.map.activexObj;
        if (globe) {
            for (var i = 0, len = this.trackerIds.length; i < len; i++) {
                globe.DrawBox.RemoveTracker(this.trackerIds[i]);
            }
            for (var i = 0, len = this.elementsKeys.length; i < len; i++) {
                globe.ScreenBox.RemoveElement(this.elementsKeys[i]);
            }
            //		map.activexObj.DrawBox.RemoveAllTracker();
            for (var i = 0, len = this.keyEventHandlers.length; i < len; i++) {
                //		globe.detachEvent("OnGeometryTracked", this.keyEventHandlers[i]);
                if (globe.detachEvent) {
                    globe.detachEvent("OnGeometryTracked", this.keyEventHandlers[i]);
                } else if (globe.removeEventListener) {
                    globe.removeEventListener("GeometryTracked", this.keyEventHandlers[i], false);
                }
                //		globe.detachEvent("OnAnalysisFinished", this.keyEventHandlers[i]);
                if (globe.detachEvent) {
                    globe.detachEvent("OnAnalysisFinished", this.keyEventHandlers[i]);
                } else if (globe.removeEventListener) {
                    globe.removeEventListener("AnalysisFinished", this.keyEventHandlers[i], false);
                }
                //		globe.detachEvent("OnTrackerFinished", this.keyEventHandlers[i]);
                if (globe.detachEvent) {
                    globe.detachEvent("OnTrackerFinished", this.keyEventHandlers[i]);
                } else if (globe.removeEventListener) {
                    globe.removeEventListener("TrackerFinished", this.keyEventHandlers[i], false);
                }
                //		globe.detachEvent("OnMouseEvent", this.keyEventHandlers[i]);
                if (globe.detachEvent) {
                    globe.detachEvent("OnMouseEvent", this.keyEventHandlers[i]);
                } else if (globe.removeEventListener) {
                    globe.removeEventListener("MouseEvent", this.keyEventHandlers[i], false);
                }
            }
        }
    },

	/**
     * APIMethod: activate
     * 激活控件。
     * 
     */
    activate: function() {
        if (Geo.View3D.Control.prototype.activate.apply(this, arguments)) {
            return true;
        }
        return false;
    },
	
	/**
     * APIMethod: deactivate
     * 禁用控件。
     * 
     */
    deactivate: function() {
        //清除结果
        this.clearAnalysisResult();
        //清除全局变量
        this.keyEventHandlers = [];
        this.trackerIds = [];
        this.elementsKeys = [];
        this.analysisResult = [];
        this.m_surfaceArea_result = null;
        this.m_surfaceArea3D_result = null;
        this.m_aspectAnalysis_Result = null;
        this.m_slopeAnalysis_Result = null;
        this.m_cutFillAnalysis_result = null;
        this.m_nosSourceFlood_Result = null;
        this.m_sectionPlane_Result = null;
        this.m_oObserverPoints_Result = null;
        this.m_lineOfSight_Result = null;
        if (Geo.View3D.Control.prototype.deactivate.apply(this, arguments)) {
            return true;
        }
        return false;
    },

    /**
    * Method: destroy
    */
    destroy: function() {
        this.deactivate();
        Geo.View3D.Control.prototype.destroy.apply(this, arguments);
    },
	
    /**
    * Method: updateAttribution
    * 关联地图，私有。
    */
    setMap: function(map) {
        Geo.View3D.Control.prototype.setMap.apply(this, arguments);
    },

    CLASS_NAME: "Geo.View3D.Control.Analysis"
});

/**
 * Class: Geo.View3D.Control.Keyboard
 * 三维视图键盘动作类。使用本控件可以实现通过键盘上下左右键动作来捕捉到三维地图的键盘事件对象。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.Keyboard = Geo.Class(Geo.View3D.Control,{
	
	 /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: null,
	
    /**
     * Constructor: Geo.View3D.Control.Keyboard
     * Geo.View3D.Control.Keyboard构造函数。
     */
    initialize: function(options){
       Geo.View3D.Control.prototype.initialize.apply(this, [options]);
		this.callbacks = OpenLayers.Util.extend(
            {
                "keyboardDown": this.onKeyboardDown,
				"keyboardUp": this.onKeyboardUp
            },
            this.callbacks
        );
		this.handlerOptions = this.handlerOptions || {};
    	this.handler = new Geo.View3D.Handler.Keyboard(this,this.callbacks, this.handlerOptions);
    },
    
    /**
     * APIMethod: onKeyboardDown
     * 键盘按下。
     */
    onKeyboardDown: function(e){
    },
    
    /**
     * APIMethod: onKeyboardUp
     * 键盘抬起。
     */
    onKeyboardUp: function(e){
    },
	
	CLASS_NAME: "Geo.View3D.Control.Keyboard"
});/**
 * Class: Geo.View3D.Fly
 * 三维视图飞行控制对象。
 */
Geo.View3D.Fly = Geo.Class({
    
    /**
     * APIProperty: layer
     * {<Geo.View3D.Layer.Vector>} 供飞行路径及路径节点显示的矢量图层。
     */
    layer: null,
	
    /**
     * APIProperty: layerOptions
	 * {Object} 路径绘制矢量图层构造参数。
     */
	layerOptions: null,
	
    /**
     * APIProperty: map
	 * {Geo.View3D.Map} 三维视图对象。
     */
	map: null,
	
    /**
     * APIProperty: drawPathControl
     * {<Geo.View3D.Control.DrawFeature>} 用于飞行路径及路径节点的矢量绘制控件。
     */	
	drawPathControl:null,
	
	
	drawPointControl:null,
    /**
     * APIProperty: defaultFlyParams
     * {Object} 默认飞行路径节点相关设置参数。一条飞行路径是由一系列路径节点组成的，如果没有特别指定，
     * 添加路径节点时会应用默认设置参数。
     * 
     */	
	defaultFlyParams:{
		//默认飞行高度（米）
		height: 0,
		//默认飞行速度(千米/秒)，一般情况下为了取得比较好的视觉效果，飞行速度宜设置为：高度/10000
		speed: 0,
		//俯仰角
		tilt: 0,
		//侧倾角
		heading: 0
	},

    /**
     * APIProperty: model
     * {Object} 飞行当前中心点模型相关设置选项，有如下选项：
     * path - {String} 模型路径，默认值为空字符串。
     * visible - {Boolean} 该模型是否可见，默认值为false。
     */		
	model: null,
	
    /**
     * APIProperty: points
     * {Array(<Geo.Geometry.Point>)} 所有飞行途经点，包含点坐标、高度、俯仰角、侧倾角参数设置。
     */	
	points:null,

    /**
     * APIProperty: pathVisible
     * {Boolean} 飞行路径是否可见。
     */	
	pathVisible: true,
	
	/**
	 * APIProperty: pathVisible
	 * {Number} 飞行路径模式。0、贴地。1、恒高。
	 */
	pathFlyMode: 0,
	
	/**
     * APIProperty: eventListeners
     * {Object} 三维视图事件监听器。
     */      
    eventListeners: null, 
    
 	/**
 	 * APIProperty: EVENT_TYPES
 	 * {Array} 支持的事件类型。
 	 */
    EVENT_TYPES: ["OnFlyFinished"],
    
    /**
     * APIProperty: events
     * {Object} 三维飞行事件对象。
     */      
    events: null,
	/**
     * APIProperty: modelPath  
     * {String} 飞机模型地址（绝对路径）。
     */
    modelPath:"C:\\airplane\\airplane.x",
    /**
     * APIProperty: modelScale  
     * {String} 飞机模型缩小到原来的0.3倍，不能为负数。
     */
	modelScale:0.3,
	/**
     * APIProperty: modelDisToScreen  
     * {String} 飞机模型距相机的距离,不能为负数。
     */
	modelDisToScreen:5.0,
    /** 
     * Constructor: Geo.View3D.Fly
     * Geo.View3D.Fly 构造函数。
     *
     * Parameters:
     * options - {Object} 选项。
     *
     */	
	initialize: function(options){
		
        Geo.View3D.Control.prototype.initialize.apply(this, arguments);
		
        var options = OpenLayers.Util.extend({
            displayInLayerSwitcher: false,
			isOnTop: true
        }, this.layerOptions);
        
        this.events = new OpenLayers.Events(this, null, this.EVENT_TYPES);
        if(this.eventListeners instanceof Object) {
            this.events.on(this.eventListeners);
        }
        
		this.layer = new Geo.View3D.Layer.Vector(this.CLASS_NAME + "_layer", options);
		
        this.drawPathControl = new Geo.View3D.Control.DrawFeature(this.layer, Geo.View3D.Handler.Path, {
            featureAdded: OpenLayers.Function.bind(function(feature){
            	//停止飞行（避免多次绘制飞行路径的时候无法飞行）
            	this.controlFly(Geo.View3D.FLY_STOP);
				//设置飞行路径模式。0、贴地。1、恒高。
				this.setPathFlyMode(this.pathFlyMode);
				//绘制飞行线路完成后，设置飞行高度，速度，俯仰角，航仰角
//				this.setFlyCameraHeight(this.defaultFlyParams.height);
//                this.setFlySpeed(this.defaultFlyParams.speed);
//                this.setTilt(this.defaultFlyParams.tilt);
//                this.setHeading(this.defaultFlyParams.heading);
                //添加绘制要素到飞行点数组后进行飞行
                this.addFeatureToPoints(feature);
                this.drawPathControl.deactivate();
            }, this),
            //定义样式 
            handlerOptions: {   
                layerOptions: {   
	                style : {   
	                    fillOpacity : 0.8,   
	                    strokeWidth : 5,   
	                    pointRadius:20   
	                }   
	            }  
            }
        });
        this.drawPointControl = new Geo.View3D.Control.DrawFeature(this.layer, Geo.View3D.Handler.Point, {
            featureAdded: OpenLayers.Function.bind(function(feature){
				if(!feature)
					return;
        		//先停止飞行
	        	this.controlFly(Geo.View3D.FLY_STOP);
	        	//飞行的起点
	            var starPoint = new Geo.LonLat(feature.geometry.x, feature.geometry.y);
				//设置飞行参数
				this.setFlyFreePath(starPoint);
				//设置飞行高度
//				this.setFlyCameraHeight(2000);
				//设置飞行速度
//	            this.setFlySpeed(2000);
				//开始飞行,参数:Geo.View3D.FLY_START = 1;Geo.View3D.FLY_PASUE = 2;Geo.View3D.FLY_CONTINUE = 3;Geo.View3D.FLY_STOP = 4;
				this.controlFly(Geo.View3D.FLY_START);
				//设置飞行俯仰角
			//	this.setTilt(80);
                this.drawPointControl.deactivate();
            }, this)
        });
		this.points = [];
		this.model = {
			path: "",
			visible: false
		};
    },
     /**
     * APIMethod: showFlyModel
     * 显示隐藏飞机模型。
     * 
     */
    showFlyModel: function(){
    	var cross = this.map.activexObj.ScreenBox.QueryScreenElement(5);
        //如果已经显示，则隐藏
        if (cross.ModelVisible) {
            cross.ModelVisible = false;
        }
        else {
            //如果没有显示，则显示飞机模型；由于飞模型在建模时
            cross.ModelPath = this.modelPath;
            cross.ModelVisible = true;
            cross.ModelScale = this.modelScale; //模型的缩小到原来的0.3倍，不能为负数
            cross.ModelYaw = 0.0;   //绕Y轴旋转
            cross.ModelPitch = 90.0;//绕X轴旋转90度
            cross.ModelRoll = 180.0;//绕Z轴旋转180度
            cross.ModelDisToScreen = this.modelDisToScreen;//距相机的距离,不能为负数
        }
    },
    /**
     * APIMethod: initFlySet
     * 飞行参数初始化设置。
     * 
     * Parameters:
     * height - {Number} 飞行高度。
     * speed - {Number} 飞行速度。
     * tilt - {Number} 飞行俯仰角。
     * heading - {Number} 飞行侧倾角。
     */	
    initFlySet: function(height,speed,tilt,heading){
    	this.defaultFlyParams.height = height;
    	this.defaultFlyParams.speed = speed;
    	this.defaultFlyParams.tilt = tilt;
    	this.defaultFlyParams.heading = heading;
    },
	
	/**
	 * APIMethod: onFlyFinished
	 * 飞行完成时执行此函数，用户可覆写此函数，自定义飞行完成后的操作。
	 * 
	 * Parameters:
	 * event - {Object} 事件对象
	 */
	onFlyFinished:function(event){
	},
		
    /**
     * Method: setMap
     * 将飞行控件对象关联到指定三维视图对象。
     * 
     * Parameters:
     * map - {<Geo.View3D.Map>} 三维视图对象。
     */		
	setMap: function(map){
		if(this.map){
			return;
		}
		this.map = map;
        //绑定飞行完成事件
        this._onFlyFinished = OpenLayers.Function.bind(function(eventObj){
            this.onFlyFinished(eventObj);
        }, this);
   //     this.map.activexObj.attachEvent("OnFlyFinished", this._onFlyFinished);
		if (this.map.activexObj.attachEvent){
			this.map.activexObj.attachEvent("OnFlyFinished",this._onFlyFinished);        
		}else if (this.map.activexObj.addEventListener){
			this.map.activexObj.addEventListener("FlyFinished",this._onFlyFinished,false);      
		}		
        
		this._initFlyOption();
		map.addLayers([this.layer]);
		map.addControls([this.drawPathControl,this.drawPointControl]);
	},
	
	/**
	 * 解除地图关联
	 */
	removeMap: function(){
		if(this.map){
		//	this.map.activexObj.detachEvent("OnFlyFinished", this._onFlyFinished);
		if (this.map.activexObj.detachEvent){
			this.map.activexObj.detachEvent("OnFlyFinished",this._onFlyFinished);        
		}else if (this.map.activexObj.removeEventListener){
			this.map.activexObj.removeEventListener("FlyFinished",this._onFlyFinished,false);      
		}			
			this.layer && this.map.removeLayer(this.layer);
			this.drawPathControl && this.map.removeControl(this.drawPathControl);
			this.drawPointControl && this.map.removeControl(this.drawPointControl);
		};
		this.map = null;
	},

	/**
	 * APIMethod: destroy
	 * 销毁。
	 */	  
    destroy: function () {
    	this.removeMap();
        if (this.events) {
            if(this.eventListeners) {
                this.events.un(this.eventListeners);
            }
            this.events.destroy();
        }
        this.eventListeners = null;
        this.events = null;
    },
    
    /**
     * APIMethod: setPathVisible
     * 设置当前飞行路径是否可见。
     * 
     * Parameters:
     * isVisible - {Boolean} 路径是否可见的标识。
     */			
	setPathVisible: function(isVisible){
		this.drawPathControl.deactivate();
		this.layer.setVisibility(isVisible);
		this.pathVisible = isVisible;
	},
	
    /**
     * APIMethod: clearFlyPath
     * 清除本次设置的飞行路径。调用本方法后会停止当前飞行，移除飞行路径绘制图层上所有要素，并且清空所有飞行路径点。
     * 
     */		
	clearFlyPath: function(){
		this.controlFly(Geo.View3D.FLY_STOP);
		this.layer.removeFeatures(this.layer.features);
		this.points = [];
		this._clearAllFlyPoint();
		this.drawPathControl.deactivate();
	},
	
    /**
     * APIMethod: activate
     * 激活飞行控件。
     */	
	activate: function(){
		Geo.View3D.Control.prototype.activate.apply(this, arguments);
		this._initFlyOption();
	},
	
	onComplete: function(geometry){},
	
	onAddPoint: function(point,time,allPoints){},
	
	addPoints: function(){
		
	},
	
	/**
	 * APIMethod: addFeatureToPoints
	 * 添加飞行路径的点要素到飞行路径点要素数组。
	 *
	 * Parameters:
	 * feature - {<Geo.Feature.Vector>} 要素。
	 */	
	addFeatureToPoints:function(feature){
		this.points = [];
		var _points = feature.geometry.components;
		for(var i=0; i<_points.length; i++){
			this.points.push({
				longitude: _points[i].x,
				latitude: _points[i].y 
			});
		}
		this.setFlyPath();
//		this.controlFly(Geo.View3D.FLY_START);		
	},
	
    /**
     * APIMethod: setTilt
     * 在飞行过程中实时调整俯仰角，有效值在0～90之间。
     * 
     * Parameters:
     * tilt - {Float} 俯仰角角度。
     */	
    setTilt: function(tilt){
		tilt = (tilt <= 0) ? 1 : tilt;
		tilt = (tilt >= 90) ? 89 : tilt;
		
//		this.defaultFlyParams.tilt = tilt;
//		this._flyMotion.FlyTilt = tilt;
//		this._flyMotion.IsRealtimeAdjust = true;
		this._camera.Tilt = tilt;
	},

    /**
     * APIMethod: setHeading
     * 在飞行过程中实时调整航向角，有效值在180～-180之间。
     * 
     * Parameters:
     * heading - {Float} 航向角角度。
     */		
	setHeading: function(heading){
//		this._flyMotion.FlyHeading = heading;
//		this._flyMotion.IsRealtimeAdjust = true;
		//自动恢复航向角 
		this._flyBox.ChangeAutoAdjustAttitude(0, false);
		this._camera.Heading = heading;
//		this.defaultFlyParams.heading = heading;
	},

    /**
     * APIMethod: setFlyPath
     * 设置描述飞行路径的几何对象。
     */		
    setFlyPath: function(){
		this._clearAllFlyPoint();
		
        for (var i = 0; i < this.points.length - 1; i++) {
            var pointStart = OpenLayers.Util.extend({}, this.points[i]);
            var pointEnd = OpenLayers.Util.extend({}, this.points[i + 1]);
            //创建一个飞行片段
            var flySegment = this._flyBox.CreateFlySegment(0);
            // 设置起点，相机所处高度默认为2000，暂时设置无效果，会被飞机高度取代
            flySegment.SetStartCoord(pointStart.longitude, pointStart.latitude, 2000);
            // 设置终点，相机所处高度默认为2000，暂时设置无效果，会被飞机高度取代
            flySegment.SetEndCoord(pointEnd.longitude, pointEnd.latitude, 2000);
            this._flyBox.AddFlySegment(flySegment);
        }
    },

    /**
     * APIMethod: getFlyPath
     * 获取飞行路径。
     */
	getFlyPath: function(){
		return this.points;
	},
	
    /**
     * APIMethod: setFlyCirclePath
     * 创建绕点飞行的路径。
     * 
     * Parameters:
     * starPoint - {<Geo.LonLat>} 起点坐标。
     * centerPoint - {<Geo.LonLat>} 绕点的中心坐标。
     * flyAngle - {Number} 设置飞行路径围绕中心点的角度。
     */
    setFlyCirclePath: function(starPoint, centerPoint, flyAngle){
        // 清除飞行片段
		this._clearAllFlyPoint();
        
        // 创建绕点飞行片段，设置起点，绕点中心和角度
		var flySegmentCircle = 1;
        var circleFlySegment = this._flyBox.CreateFlySegment(flySegmentCircle);
		
		var starPoint = starPoint ? starPoint : new Geo.LonLat(116.374153890879, 41.1);
		var centerPoint = centerPoint ? centerPoint : new Geo.LonLat(116.374153890879, 39.9056146840283);
		// 设置起点，相机所处高度默认为2000，暂时设置无效果，会被飞机的飞行高度取代
		circleFlySegment.SetStartCoord(starPoint.lon, starPoint.lat, 2000);
		// 设置绕点中心，相机所处高度默认为0，可以使相机俯视大地
        circleFlySegment.SetCentre(centerPoint.lon, centerPoint.lat, 0);
        // 设置飞行路径围绕中心点的角度
        circleFlySegment.FlyAngle = flyAngle ? flyAngle : 360;
        this._flyBox.AddFlySegment(circleFlySegment);
    },
	
	/**
     * APIMethod: setFlyFreePath
     * 设置自由飞行。
     * 
     * Parameters:
     * starPoint - {<Geo.LonLat>} 起点坐标。
     */
    setFlyFreePath: function(starPoint){
        // 清除飞行片段
		this._clearAllFlyPoint();
        // 创建绕点飞行片段，设置起点，绕点中心和角度
    	var circleFlySegment = this._flyBox.CreateFlySegment(2);
    	// 定义起点
		var starPoint = starPoint ? starPoint : new Geo.LonLat(116.374153890879, 41.001);
		// 设置起点
		circleFlySegment.SetStartCoord(starPoint.lon, starPoint.lat, 1000);
        // 设置飞行路径围绕中心点的角度
        this._flyBox.AddFlySegment(circleFlySegment);
    },			
				
    /**
     * APIMethod: controlFly
     * 控制飞行状态，可以设置开始飞行、暂停飞行、继续飞行和停止飞等状态。控制状态代码被定义为一系列常量，如下：
     * Geo.View3D.FLY_START: 1
     * Geo.View3D.FLY_PASUE: 2
     * Geo.View3D.FLY_CONTINUE: 3
     * Geo.View3D.FLY_STOP: 4
     * 
     * Parameters:
     * mode - {Integer} 控制状态代码。
     */			
	controlFly: function(mode){
		
		switch(mode) {
			case Geo.View3D.FLY_START:
				if(this.points != ""){
					this.setFlyPath();
				}
				this._startFly();
				break;
			case Geo.View3D.FLY_PASUE:
				this._flyPause();
				break;
			case Geo.View3D.FLY_CONTINUE:
				this._flyContinue();
				break;
			case Geo.View3D.FLY_STOP:
				this._flyStop();
				break;
		}
	},

    /**
     * APIMethod: setFlyCameraHeight
     * 在飞行过程中实时调整飞行高度，有效值在5～63781370之间。在调整飞行高度后，为了保证正常的显示效果会自动根据高度调整飞行速度。
     * 
     * Parameters:
     * height - {Float} 飞行高度（单位：米）。
     */	    
    setFlyCameraHeight: function(height){
//    	this.defaultFlyParams.height = height;
    	this._flyBox.RelativeHeight = height;
//		this._flyMotion.FlyHeight = height;
//		this._flyMotion.IsRealtimeAdjust = true;
	},

    /**
     * APIMethod: setFlySpeed
     * 在飞行过程中实时调整飞行速度。
     * 
     * Parameters:
     * speed - {Float} 飞行速度（单位：公里/小时）。
     */	  	
    setFlySpeed: function(speed){
//    	this.defaultFlyParams.speed = speed;
		this._flyBox.FlySpeed = speed;
//		this._flyMotion.FlySpeed = speed;
//		this._flyMotion.IsRealtimeAdjust = true;
	},
	
    /**
     * Method: setFlyMode
     * 设置飞行模式。在geospace3D中，没有提供飞行模式的设置。之前activeX有提供飞行模式的设置。
     * 暂时保留这个接口。
     * 
     * Parameters:
     * mode - {Number} 0 正常飞行，1绕点。
     */	
	setFlyMode: function(mode){
	},
	
	/**
     * APIMethod: setPathFlyMode
     * 设置飞行路径模式。
     * 
     * Parameters:
     * pathFlyMode - {Number} 0：贴地。1：恒高。
     */	
	setPathFlyMode: function(pathFlyMode){
		//贴地
		if(pathFlyMode == 0){
			this.pathFlyMode = 0;
			this._flyBox.FlyHeightStyle = 2;
		}
		//恒高
		if (pathFlyMode == 1) {
			this.pathFlyMode = 1;
			this._flyBox.FlyHeightStyle = 3;
		}
	},
    
    /**
     * Method: saveFlyPathToFile
     * 保存飞行路径至文件。
     * 
     * Parameters:
     * path - {String} 路径。
     */	
    saveFlyPathToFile:function(path){
      //this._flyRoute.SaveFlyPathToFile(path);  
    },
	
    /**
     * Method: loadFlyPathFromFile
     * 从文件里面加载飞行路径
     * 
     * Parameters:
     * path - {String} 路径
     */
    loadFlyPathFromFile:function(path){
      //this._flyRoute.LoadFlyPathFromFile(path);  
    },
	
	/**
     * APIMethod: getGeometryFromFlyPoints
     * 从三维控件里面获取飞行路径点信息，并生成Geometry。
	 */
	getGeometryFromFlyPoints: function(){
		if(this._flyRoute){
			var pointsVar= [];
			for (var i=0; i< this._flyRoute.GetCount(); i++) {
				var pointInfo = this._flyMotionWrapper.GetPoint(this._flyRoute , i);
				var lon = pointInfo.XVal; //longitude
				var lat = pointInfo.YVal; //latitude
				var point = new Geo.Geometry.Point(lon, lat);
				pointsVar.push(point);
			}
			var pathGeometry = new Geo.Geometry.LineString(pointsVar);
			return pathGeometry;
		}
		return null;
	},

    /**
     * Method: setModelPath
     * 设置飞行模型文件路径。只接受绝对路径，可以传入url或本地文件路径。例如：
     * "http://localhost:8080/demo/images/airplane/airplane.x"或"c:\\airplane\\airplane.x"。
     * 设置新的模型文件路径后，模型的可见状态将被设置为false，调用setModelVisible(true)方法可将模型显示打开。
     * 
     * Parameters:
     * filePath - {String} 模型文件路径。
     */		
	setModelPath: function(filePath){
//		var globe = this.map.activexObj;
//		if (globe && (this.model.path !== filePath)) {
//			this.model.path = filePath;
//			this.model.visible = false;
//			globe.SetModelVisible(filePath,this.model.visible);
//		}
	},

    /**
     * APIMethod: setModelVisible
     * 设置当前飞行模型是否可见。
     * 
     * Parameters:
     * isVisible - {Boolean} 模型是否可见。
     */		
	setModelVisible: function(isVisible){
//		var globe = this.map.activexObj;
//		if (globe) {
//			this.model.visible = isVisible;
//			globe.SetModelVisible(this.model.path,isVisible);
//		}
	},

    /**
     * APIMethod: setCameraMode
     * 设置当前相机人称视角。
     * 
     * Parameters:
     * mode - {Number} mode值为0，代表第一人称视角表现飞行功能；mode值为1，代表第三人称视角。
     */		
	setCameraMode: function(mode){
		this._camera.CameraMode = mode;// mode为0，代表第一人称视角表现飞行功能
	},

    /**
     * APIMethod: getCameraMode
     * 获取当前相机人称视角
     * 
     * Returns:
     * {Number} 用于表示第一或第三人称视角表现飞行功能；值为0(1)，代表第一（三）人称视角。
     */		
	getCameraMode: function(){
		return this._camera.CameraMode;
	},
	
	//调整高度后，重新根据高度设置速度
	_getFlySpeed: function(height){
		return height * 14;
	},
	
	_flyRoute: null,
	
	_flyMotion: null,
	
	_camera: null,
	
	//初始化飞行所需对象
	_initFlyOption: function(){
		var globe = this.map.activexObj;
		if(globe){
			this._flyBox = globe.FlyBox;
			this._camera = globe.Camera;
			//geoSpace3D.FlyBox.FlyControl.Camera.CameraMode = 0;
			
//			this._flyRoute = globe.CreateFlyRoute();
//			this._flyMotion = globe.CreateFlyMotion();
//			this._flyMotionWrapper  = globe.GetFlyMotionWrapper();
//			this._camera = globe.GetCamera();

		}
		
	},
	
	//绘制飞行路径后，开始飞行之前，做相应参数设置
	_startFly: function(options){
		if(this._flyBox){
			this._flyBox.StartFly(0);
			//this._camera.CameraMode = 0;
			//this._flyMotion.SetFlyRoute(this._flyRoute);
	        //this._flyMotion.SetCamera(this._camera);
			//this._flyContinue();
		}
	},
	
	_flyPause: function(){
		if(this._flyBox){
			this._flyBox.PauseFly();
			//this._camera.CameraMode = 1;// 不是飞行状态时，恢复第三人称视角。
			//this._flyMotion.Pause();
		}
	},
	
	_flyContinue: function(){
		if(this._flyBox){
			this._flyBox.ResumeFly();
			//this._camera.CameraMode = 0;// 第一人称视角表现飞行功能
			//this._flyMotion.Fly();
		}
	},
	
	_flyStop: function(){
		if(this._flyBox){
			this._flyBox.StopFly();
			this._flyBox.ClearFlySegment();
			//this._camera.CameraMode = 1;// 不是飞行状态时，恢复第三人称视角。
			//this._flyMotion.Stop();
		}
		
	},	
	
	// 清除所有添加的飞行片段
	_clearAllFlyPoint: function(){
//		if(this._flyRoute){
//			this._flyRoute.removeAll();
//		}
		if (this._flyBox) {
			this._flyBox.ClearFlySegment();
		}
	},	
	
    CLASS_NAME: "Geo.View3D.Fly"

});

/**
 * Constant: Geo.View3D.FLY_START
 * 开始飞行的常量。
 */
Geo.View3D.FLY_START = 1;

/**
 * Constant: Geo.View3D.FLY_PASUE
 * 暂停飞行的常量。
 */
Geo.View3D.FLY_PASUE = 2;

/**
 * Constant: Geo.View3D.FLY_CONTINUE
 * 继续飞行的常量。
 */
Geo.View3D.FLY_CONTINUE = 3;

/**
 * Constant: Geo.View3D.FLY_STOP
 * 停止飞行的常量。
 */
Geo.View3D.FLY_STOP = 4;

Geo.View3D.Fly_MODE_ROUND = 1;
Geo.View3D.Fly_MODE_PATH = 0;
/**
 * Class: Geo.View3D.Popup
 * > popup是可以在三维地图上打开和关闭的小型弹出窗口，通常是用于在选中一个矢量要素时，显示该要素的详细信息。
 * > popup通过<Geo.View3D.Map.addPopup>方法添加到三维地图中。
 *
 * Examples:
 * (code)
 * popup = new Geo.View3D.Popup("3dPoup", 
 *                    new Geo.LonLat(5,40),
 *                    new Geo.Size(200,200),
 *                    "这是一个弹出框示例",
 *                    true);
 * map.addPopup(popup);
 * (end)
 */
Geo.View3D.Popup = Geo.Class({

    
    /** APIProperty: id
     * {String} 唯一标识。
     */
    id: "",

    /** 
     * APIProperty: lonlat 
     * {<Geo.LonLat>} 弹出框在地图中的坐标。
     */
    lonlat: null,


    /** 
     * APIProperty: size 
     * {<Geo.Size>} 弹出框的尺寸。
     */
    size: null,    

    /** 
     * APIProperty: contentHTML 
     * {String} 弹出框内显示的内容，如果contentHTML内容用到了CSS样式文件，注意使用CSS文件的绝对地址，否则无效果。
     */
    contentHTML: null,
    
    
    /** 
     * APIProperty: map 
     * {<Geo.View3D.Map>} 三维地图对象的引用。
     */
    map: null,
	
    /** 
     * APIProperty: contentType 
     * {int} 弹出框的内容类型，0.text 1.html 2.url，默认为html。
     */
    contentType: 1,

    //关闭时的回调函数
    _closeBoxCallback: null,
	
	 /** 
     * APIProperty: z 
     * {double} 浮云框锚点位置Z坐标，默认为0.0。
     */
	z: 0,
	
	 /**
     * APIMethod: setPositionZ
     * 绘制弹出框。
     *
     * Parameters:
     * pZ - {Object} z坐标值
     */
    setPositionZ: function(pZ) {
		z = pZ;
	},
	
    /**
     * Constructor: Geo.View3D.Popup
     * Geo.View3D.Popup构造函数。
     *
     * Parameters:
     * id - {Object} 编号。
     * lonlat - {Object} 经纬度信息。
     * contentSize - {Object} 尺寸大小。
     * contentHTML - {Object} HTML代码。
     * closeBox - {Boolean} 是否显示关闭按钮。
     * closeBoxCallback - {Object} 点击关闭按钮的回调函数。
     */
    initialize:function(id, lonlat, contentSize, contentHTML, closeBox, closeBoxCallback) {
        if (id == null) {
            id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");
        }

        this.id = id;
        this.lonlat = lonlat;

        this.contentSize = (contentSize != null) ? contentSize 
                                  : new Geo.Size(
                                                   Geo.View3D.Popup.WIDTH,
                                                   Geo.View3D.Popup.HEIGHT);
        if (contentHTML != null) { 
             this.contentHTML = contentHTML;
        }
		
		this._closeBox = new Boolean(closeBox);
		this._closeBoxCallback = closeBoxCallback;
    },
	
    //三维浮云框关闭按钮事件响应
    _closeBoxHandler: function(eType, bubbleWindwo, param) {
        var closeBoxCallback = this._closeBoxCallback;
        if (!closeBoxCallback) {
            return;
        }

        if (eType == 0) {
            closeBoxCallback();
        }
	    if(this.map && this.map.activexObj){
		   this._removeCloseBoxHandler();
		}
    },

    //附加关闭按钮事件响应
    _addCloseBoxHandler: function() {
        var globe = this.map.activexObj;
        this._closeBoxHandler = OpenLayers.Function.bind(this._closeBoxHandler, this);
    //    globe.attachEvent("OnBubbleWindowEvent", this._closeBoxHandler);
		if (globe.attachEvent){
			globe.attachEvent("OnBubbleWindowEvent",this._closeBoxHandler);        
		}else if (globe.addEventListener){
			globe.addEventListener("BubbleWindowEvent",this._closeBoxHandler,false);      
		}	
    },

    //移除关闭按钮事件响应
    _removeCloseBoxHandler: function(callbackFn) {
        var globe = this.map.activexObj;
    //    globe.detachEvent("OnBubbleWindowEvent", this._closeBoxHandler);
		if (globe.detachEvent){
			globe.detachEvent("OnBubbleWindowEvent",this._closeBoxHandler);        
		}else if (globe.removeEventListener){
			globe.removeEventListener("BubbleWindowEvent",this._closeBoxHandler,false);      
		}	
    },
    
    /**
     * APIMethod: draw
     * 绘制弹出框。
     *
     * Parameters:
     * px - {Object} 
     */
    draw: function(px) {
		var lonlat = px;
		var contentSize = this.contentSize;
		var contentHTML = this.contentHTML; 
        this._draw();//lonlat.lon,lonlat.lat,contentSize.w

    },
	
     //设置浮云框内容类型，可以为纯文本、HTML、URL
    _setContentType: function(){
        var globe = this.map.activexObj;
        globe.SceneGroup.SetBubbleContentType(this.contentType);
    },
    
	// 绘制
	_draw: function(){
		var map = this.map;
		if(map && map.activexObj){
		   var globe = map.activexObj;		  
		   var lonlat = this.lonlat;
		   var size = this.contentSize;
		   var sg = globe.SceneGroup;
		   var screenLoaction = map.lonlatToScreen(lonlat.lon,lonlat.lat,this.z);
		   // 改用SceneGroup
		   sg.BubbleWindow.Visible = true;
		   sg.BubbleWindow.SetMinMaxSize(200, 250, 900, 900);
           sg.BubbleWindow.PinMap(lonlat.lon,lonlat.lat,this.z);   
		   this._setContentType();
           sg.BubbleWindow.Height = size.h;
	       sg.BubbleWindow.Width = size.w;
	       sg.BubbleWindow.Content = this.contentHTML;
		   sg.BubbleWindow.ScreenX = screenLoaction.x + 100;
		   sg.BubbleWindow.ScreenY = screenLoaction.y + 100;
		   this._addCloseBoxHandler();
		}
		
	},
	
	// 清除弹出框
	_clear: function(){
		var map = this.map;
		if(map && map.activexObj){
			var globe = map.activexObj;
		   	var sg = globe.SceneGroup;
		   	sg.DeleteBubbleWindow();
		   	this._removeCloseBoxHandler();
		}
	},
	
    CLASS_NAME: "Geo.View3D.Popup"
});

Geo.View3D.Popup.WIDTH = 270;
Geo.View3D.Popup.HEIGHT = 152;
Geo.View3D.Popup.COLOR = "white";
Geo.View3D.Popup.OPACITY = 1;
Geo.View3D.Popup.BORDER = "0px";
Geo.View3D.Popup.CONTENT_TYPE_TEXT = 0;
Geo.View3D.Popup.CONTENT_TYPE_HTML = 1;
Geo.View3D.Popup.CONTENT_TYPE_URL = 2;
/**
 * Class: Geo.View3D.Popup.FramedCloud
 * 三维视图浮云框。
 *
 * Inherits from:
 *  - <Geo.View3D.Popup>
 */
Geo.View3D.Popup.FramedCloud = Geo.Class(Geo.View3D.Popup,{
	
	/** 
     * Constructor: Geo.View3D.Popup.FramedCloud
     * Geo.View3D.Popup.FramedCloud构造函数。
     * 
     * Parameters:
     * id - {String}  浮云框的唯一标识，如果没有设置将会自动生成一个。
     * lonlat - {<Geo.LonLat>} 地图上浮云显示的位置。
     * contentSize - {<Geo.Size>} 浮云的尺寸。
     * contentHTML - {String} 浮云内容，浮云内容为HTML要素的字符串。如果HTML内容引用了CSS样式文件，注意引用CSS文件的绝对地址，否则无效果。
     * anchor - {Object} 锚点。包含一个大小信息{<Geo.Size>}和偏移信息{<Geo.Pixel>}的对象。
     * closeBox - {Boolean} 是否显示关闭浮云窗口的按钮。
     * closeBoxCallback - {Function} 关闭浮云触发该回调函数。
     */
    initialize:function(id, lonlat, contentSize, contentHTML, anchor, closeBox, 
                        closeBoxCallback) {
		var newArguments = [
            id, lonlat, contentSize, contentHTML, closeBox, closeBoxCallback
        ];
        Geo.View3D.Popup.prototype.initialize.apply(this, newArguments);
    },

    CLASS_NAME: "Geo.View3D.Popup.FramedCloud"
});/**
 * Class: Geo.View3D.FeatureManager
 * 要素结果管理器。提供了与矢量要素相关的一系列功能。支持对同一矢量图层上的要素进行分类管理，包含矢量图层样式设置、
 * 要素选择功能、要素浮云显示、要素集客户端分页等功能。
 */
Geo.View3D.FeatureManager = Geo.Class({
	
    /**
     * APIProperty: id
     * {String} 唯一标识。
     */
    id: null,	
    
    /**
     * APIProperty: map
     * {<Geo.View3D.Map>} 所属的地图对象。
     */
    map: null,
	
	//结果类型映射
	_typeMapping: null,
	
	/**
     * APIProperty: featureSortField
     * {String} 标识要素分类的属性名。
     */
	featureSortField: "featureSort",

	/**
     * APIProperty: orderNumberField
     * {String} 标识要素序号的属性名。
     */	
	orderNumberField: "orderNumber",

	/**
     * APIProperty: vectorLayer
     * {<Geo.View3D.Layer.Vector>} 矢量图层。
     */		
	vectorLayer: null,

	/**
     * APIProperty: selectControl
     * {<Geo.View3D.Control.SelectFeature>} 矢量要素选择控件。
     */	
	selectControl: null,

	/**
     * APIProperty: selectControl
     * {Integer} 默认的要素分页数量。
     */	
	maxFeaturesPerPage: 15,

    /**
     * Constructor: Geo.View3D.FeatureManager
     * Geo.View3D.FeatureManager对象构造函数
     * 
     * Parameters:
     * options - {Object} 相关选项设置
     */
	initialize: function(options){
		this._typeMapping = {};
		this.registerResultType("default");
		OpenLayers.Util.extend(this, options);
	},
	
	/**
     * APIMethod: setMap
     * 将要素管理对象关联到相应的地图对象。在关联到地图对象时,会在地图对象中加入一个矢量图层和相关控件。
     *
     * Parameters:
     * map - {<Geo.View3D.Map>} 地图对象
     */
	setMap: function(map){
		if(map && !this.map){
			this.map = map;
			
			//添加结果图层
			this.vectorLayer = new Geo.View3D.Layer.Vector("GeoGlobeFeatureManagerVector", {
				isOnTop: true,
				displayInLayerSwitcher: false
			});
			this.map.addLayer(this.vectorLayer);
			this._initSelectControl();
		}
	},

	/**
     * APIMethod: registerFeatureSort
     * 注册要素类别。如果希望对多个分类的要素进行管理，则需要先注册要素类别加以区分，
     * 然后再调用addFeatures方法向分类中添加要素集。
     *
     * Parameters:
     * sort - {String} 要素分类
     * options - {Object} 参数设置
     */	
	registerFeatureSort: function(sort,options){
		var DEFAULT_PARAMS = {
			features:[],
			currentPage:0,
			maxFeaturesPerPage: this.maxFeaturesPerPage,
			onTurnToPage: this.onTurnToPage,
			onFeatureSelect: Geo.View3D.FeatureManager.showFramedCloud,
			onFeatureUnselect: Geo.View3D.FeatureManager.closeFramedCloud,
			onFeatureOver: Geo.View3D.FeatureManager.showTopic,
			onFeatureOut: Geo.View3D.FeatureManager.closeTopic
		};
		this._typeMapping[sort] = OpenLayers.Util.extend(DEFAULT_PARAMS,options);
	},

     
    //此方法已被废弃，推荐使用registerResultSort
	registerResultType: function(sort,options){
        this.registerFeatureSort(sort,options);
	},
	
	/**
     * APIMethod: addFeatures
     * 向类别中添加要素，要素添加到类别后将为要素的外部属性中加上类型标识。
     *
     * Parameters:
     * features - {Array(<Geo.Feature.Vector>)} 添加的要素数组
     * sort - {String} 要素类别
     * isAppend - {Boolean} 是否追加要素
     */		
	addFeatures: function(features,sort,isAppend){
		sort = sort || "default";
        if(!(Geo.Util.isArray(features))) {
			features = [features];
		}
		
		if(this._typeMapping[sort]){
			var features =  this._addTypeMarker(features,sort);
			
			//为要素添加自定义样式
			var style = this._typeMapping[sort].style;
			if(style){
				this._addStyleForFeatures(features,style);
			}
			
			if(!isAppend){
				this.clearResultFromMap(sort);
				this._typeMapping[sort].features = features;
			} else {
				this._typeMapping[sort].features.concat(features);
			}
			this._typeMapping[sort].currentPage = 0;
		}
	},
	
	/*
	 * APIMethod: onTurnToPage
	 * 获取当前页的要素，本方法需要用户自己去覆盖
	 * 
	 */
	onTurnToPage: function(feature){
		
	},
	
	/**
     * APIMethod: turnToPageN
     * 翻到指定页数。
     *
     * Parameters:
     * page - {Integer} 当前第几页
     * sort - {String} 要素类别
     * isDrawToMap - {Boolean} 是否绘制到地图上
     * 
     * Returns:
     * features - {Array(<Geo.Feature.Vector>)} 要素数组。
     */	
	turnToPageN: function(page, sort, isDrawToMap){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];

		var pageNum = this.getTotalPageNumber(sort);
		page = (page <= 0) ? 1 : page;
		page = (page > pageNum) ? pageNum : page; 
				
		var features = this._pagingFeatures({
			maxPerPage: mapping.maxFeaturesPerPage,
			pageNum:page,
			resultArr:mapping.features
		});
        
        this.addOrderForFeatures(features);
				
		if(page !== mapping.currentPage){
			this.clearResultFromMap(sort);
			this.drawFeaturesToMap(features);
			mapping.currentPage = page;
		}
		mapping.onTurnToPage(features);
		
		return features;
	},
	
	/**
     * APIMethod: turnToFirst
     * 翻到首页。
     *
     * Parameters:
     * sort - {String} 要素类别
     * isDrawToMap - {Boolean} 是否绘制到地图上
     * 
     * Returns:
     * features - {Array(<Geo.Feature.Vector>)} 要素数组。 
     */		
	turnToFirst:function(sort, isDrawToMap){
		sort = sort || "default";
		return this.turnToPageN(1,sort, isDrawToMap);
	},
	
	/**
     * APIMethod: turnToNext
     * 翻到下页。
     *
     * Parameters:
     * sort - {String} 要素类别
     * isDrawToMap - {Boolean} 是否绘制到地图上
     * 
     * Returns:
     * features - {Array(<Geo.Feature.Vector>)} 要素数组。
     */		
	turnToNext:function(sort, isDrawToMap){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		return this.turnToPageN(mapping.currentPage + 1, sort, isDrawToMap);
	},
	
	/**
     * APIMethod: turnToPre
     * 翻到前页。
     *
     * Parameters:
     * sort - {String} 要素类别
     * isDrawToMap - {Boolean} 是否绘制到地图上
     * 
     * Returns:
     * features - {Array(<Geo.Feature.Vector>)} 要素数组。 
     */		
	turnToPre:function(sort, isDrawToMap){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		return this.turnToPageN(mapping.currentPage - 1, sort, isDrawToMap);
	},
	
	/**
     * APIMethod: turnToLast
     * 翻到尾页。
     *
     * Parameters:
     * sort - {String} 要素类别
     * isDrawToMap - {Boolean} 是否绘制到地图上
     */		
	turnToLast:function(sort, isDrawToMap){
		sort = sort || "default";
		var last = this.getTotalPageNumber(sort);
		this.turnToPageN(last, sort, isDrawToMap);
	},
	
	/**
     * APIMethod: getPageInfo
     * 获取分页相关情况。
     *
     * Parameters:
     * sort - {String} 要素类别
     * 
     * Returns:
     * pageInfo - {Integer} 分页相关情况。
     */		
	getPageInfo: function(sort){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		var features = mapping.features;
		return Math.ceil(features.length / mapping.maxFeaturesPerPage);
	},
	
	/**
     * APIMethod: getTotalPageNumber
     * 获取指定类别的要素分页页数。
     *
     * Parameters:
     * sort - {String} 要素类别
     * 
     * Returns:
     * pageInfo - {Integer} 分页相关情况。
     */			
	getTotalPageNumber: function(sort){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		var features = mapping.features;
		return Math.ceil(features.length / mapping.maxFeaturesPerPage);
	},
	
	/**
     * APIMethod: getFeatures
     * 获取指定结果类型的要素。
     *
     * Parameters:
     * sort - {String} 要素类别
     * 
     * Returns:
     * features - {Array(<Geo.Feature.Vector>)} 要素数组。  
     */		
	getFeatures:function(sort){
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		return mapping.features;
	},
	
	/**
     * APIMethod: drawFeaturesToMap
     * 将要素绘制到地图上，可以是指定类别名或指定要素数组。
     *
     * Parameters:
     * content - {String|<Array(Geo.Feature.Vector)>} 
     */		
	drawFeaturesToMap: function(content){
		var map, layer, features;
		map = this.map;
		layer = this.vectorLayer;
		
		if( typeof(content) == "string"){
			var sort = content || "default";
			if(this._typeMapping[sort] && map){
				features = this.getFeatures(sort);
			}

		};
		
		if( content instanceof  Array){
			features = content;
		};
		layer.addFeatures(features);
		layer.map.zoomToExtent(layer.getDataExtent());
	},
	
	/**
     * APIMethod: selectFeatureById
     * 通过ID来指定要素,通过选择控件来选择。
     *
     * Parameters:
     * featureid - {String|<Array(Geo.Feature.Vector)>} 要素编号
     */	
	selectFeatureById:function(featureid){
		this.selectControl.unselectAll();
//		var feature = this.vectorLayer.getFeatureById(featureid);
//		this.selectControl.select(feature);
		this.selectControl.select(featureid);
	},

	/**
     * APIMethod: clearFeatureFromMap
     * 清除指定类别要素,如无指定类别则默认清除"default"类别，如果指定值为"allType"则清除所有分类要素。
     *
     * Parameters:
     * sort - {String|<Array(Geo.Feature.Vector)>} 要素类别
     */		
	clearFeatureFromMap: function(sort){		
		sort = sort || "default";
		var mapping = this._typeMapping[sort];
		var features;
		var layer = this.vectorLayer;
		if(sort == "allType"){
			features = this.vectorLayer.features;
		} else {
			features = mapping ? mapping.features : [];
		}
		
		if(layer){
			this.selectControl.unselectAll();
			layer.removeFeatures(features);
		}
		
		
	},

    //此方法被废弃，推荐使用clearFeatureFromMap
	clearResultFromMap: function(sort){		
		this.clearFeatureFromMap(sort);
	},
	
	/**
     * APIMethod: addOrderForFeatures
     * 为要素数组中每个要素按顺序添加编号，编号是记录在“orderNumberField”属性指定的要素
     * 外部属性中。
     *
     * Parameters:
     * features - {Array<Geo.Feature.Vector>} 要素数组
     * 
     * Returns:
     * {Array<Geo.Feature.Vector>}
     */	
	addOrderForFeatures: function(features){
		//添加带序号的结果图标
	    for (var i = 0; i < features.length; i++) {
	        features[i].attributes[this.orderNumberField] = i;
	    }
		return features;
	},
    	
	//为要素加上样式
	_addStyleForFeatures: function(features, style){
		for(var i=0; i<features.length; i++){
			var f = features[i];
			if(!f.style){
				f.style = style;
			}
		}
	},
	
	//为每个要素添加类型标识属性
	_addTypeMarker: function(features,type){
		for(var i=0; i<features.length; i++){
			var feature = features[i];
			feature.attributes[this.featureSortField] = type;
		}
		return features;
	},
	
	/**
	 * 对指定结果要素数组进行分页处理
	 * options示例:
	 * {
	 * 		maxPerPage:15,
	 * 		pageNum:1,
	 * 		resultArr:[]
	 * }
	 */
	_pagingFeatures: function(options){
	    var start, end, 
			maxPerPage = options.maxPerPage, 
			pageNum = options.pageNum, 
			resultArr = options.resultArr;
	    start = (pageNum - 1) * maxPerPage;
	    end = pageNum * maxPerPage - 1;
	    
		var features = resultArr.slice(start, end + 1);
	    
	    //添加带序号的结果图标
	    var prefix = "images/resultIcons/";
	    for (var i = 0; i < features.length; i++) {
	        features[i].attributes[this.orderNumberField] = i;
	    }
	    
	    return features;
	},
	
	//根据事件类型分派事件
	_dispatchEvent: function(scope,feature,eventType){
		var resultType = feature.attributes[scope.featureSortField];
		var mapping = scope._typeMapping[resultType];
		mapping[eventType](feature);
	},
	
	//激活选择控件,自动检查是否控件初始化
	_initSelectControl: function(){
		if(!this.map){
			return;
		}
		if(!this.selectControl){
			
			//添加选择控件
			this.selectControl = new Geo.View3D.Control.SelectFeature(this.vectorLayer,{
				onSelect: OpenLayers.Function.bind(function(feature){
					this._dispatchEvent(this,feature,"onFeatureSelect");
				},this),
				onUnselect: OpenLayers.Function.bind(function(feature){
					this._dispatchEvent(this,feature,"onFeatureUnselect");
				},this),
				callbacks:{
					over: OpenLayers.Function.bind(function(feature){
						this._dispatchEvent(this,feature,"onFeatureOver");
					},this),
					out: OpenLayers.Function.bind(function(feature){
						this._dispatchEvent(this,feature,"onFeatureOut");
					},this)
				}
			})
			this.map.addControl(this.selectControl);
		}
	}
});

/**
 * APIProperty: Geo.View3D.FeatureManager.defaultStyleMap
 * {<Geo.StyleMap>} FeatureManager中vectorLayer图层的默认要素样式。
 */
Geo.View3D.FeatureManager.defaultStyleMap = new Geo.StyleMap({
    "default": new Geo.Style({
    	externalGraphic: OpenLayers.Util.getImagesLocation() + "marker.png",
    	graphicWidth:21,
		graphicHeight:25,
		graphicXOffset:-10,
		graphicYOffset:-12
    }) ,
    "select": new Geo.Style({
        externalGraphic: OpenLayers.Util.getImagesLocation() + "marker-blue.png",
    	graphicWidth:21,
		graphicHeight:25,
		graphicXOffset:-10,
		graphicYOffset:-12
    })
});

/**
 * APIMethod: Geo.View3D.FeatureManager.showFramedCloud
 * 为要素添加浮云，如果指定指定内容模板则浮云内空按模板规则生成。
 * 
 * Parameters:
 * feature - 浮云所属的矢量要素
 * templateString - 字符串内容模板
 * 
 */
Geo.View3D.FeatureManager.showFramedCloud = function(feature, templateString){
	var layer = feature.layer, map = layer ? layer.map : null;
	if(!layer || !map){
		return;
	}
	var str;
	if(templateString){
		var obj = {}
		for(var item in feature.attributes){
			obj[item] = feature.attributes[item];
		}
		str = OpenLayers.String.format(templateString,obj);
	} else {
		str = (function(){
	        var str = "";
	        for (var myitem in feature.attributes) {
	            str += myitem + ":" + feature.attributes[myitem] + "<br>";
	        }
	        return str;
	    })();
	}
    

	var lonlat = feature.geometry.getBounds().getCenterLonLat();
	
    if (map) {
        //map.panTo(lonlat);
		// 4000为设置的三维俯视高度
		map.flyTo(lonlat, 4000);
    }
    
    var popup = new Geo.View3D.Popup.FramedCloud(
		"featureInfo", 
		lonlat, 
		null, 
		str, 
		null, 
		true, 
		Geo.View3D.FeatureManager.onPopupClose
	);
    feature.popup = popup;
    map.addPopup(popup);
};

/**
 * APIMethod: Geo.View3D.FeatureManager.closeFramedCloud
 * 关闭并消毁指定要素上添加的浮云。
 * 
 * Parameters:
 * feature - 浮云所属的矢量要素
 * 
 */
Geo.View3D.FeatureManager.closeFramedCloud = function(feature){
    
};

/**
 * APIMethod: Geo.View3D.FeatureManager.onPopupClose
 * 浮云关闭时触发的方法。
 */
Geo.View3D.FeatureManager.onPopupClose = function(){
   
}
	
Geo.View3D.FeatureManager.showTopic = function(feature){
	
};
	
Geo.View3D.FeatureManager.closeTopic = function(feature){
	
};
/**
 * Class: Geo.View3D.Control.Measure.PointInfo
 * 量算出一个点的信息结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.PointInfo = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Point,
    
    //MEASURE_PARAM: 6,
    /**
     * Constructor: Geo.View3D.Control.Measure.PointInfo
     * 构造函数。生成一个Geo.View3D.Control.Measure.PointInfo的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
	
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
	
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
	
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
        var pointsString = geometry.x + "," + geometry.y;
        var options = {};
        options.coordinates = pointsString;
        
		var longitude = parseFloat(geometry.x);
		var latitude = parseFloat(geometry.y);
		var altitude = this.map.activexObj.AnalysisBox.QueryAltitude(longitude, latitude);
        //最终结果定义
        var finalResult = {
            longitude: longitude,
            latitude: latitude,
            altitude: altitude,
            slope: null,
            aspect: null
        };
        
		
		this.onComplete(finalResult);
//        //分三次异步请求查询高程、坡度、坡向
//        this._getMeasureResult("pointAltitude", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            finalResult.altitude = result.Result.Value;
//            this._getMeasureResult("pointSlope", options, OpenLayers.Function.bind(function(result){
//                if (this._terrainAnalysisService._isException(result)) {
//                    this.onComplete(result);
//                    return result;
//                }
//                finalResult.slope = result.Result.Value;
//                this._getMeasureResult("pointAspect", options, OpenLayers.Function.bind(function(result){
//                    if (this._terrainAnalysisService._isException(result)) {
//                        this.onComplete(result);
//                        return result;
//                    }
//                    finalResult.aspect = result.Result.Value;
//                    this.onComplete(finalResult);
//                }, this));
//            }, this));
//        }, this));
        
        
    },
	
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(){
    },
	
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.PointInfo"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.PointInfo"

});

/**
 * Class: Geo.View3D.Control.Measure.Distance
 * 量算出距离结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.Distance = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Path,
    
    /**
     * APIProperty: isRealTime
     * {Boolean} 是否实时获取结果。 默认值为false。
     */
    isRealTime: false,
    //MEASURE_PARAM: 7,
    /**
     * Constructor: Geo.View3D.Control.Measure.Distance
     * 构造函数。生成一个Geo.View3D.Control.Measure.Distance的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
    
    /*
     _measureHandler: function(mouseEvent){
     var result = {
     distance: mouseEvent.Distance,
     surfDistance: mouseEvent.SurfDistance
     };
     this._result = result;
     this.onAddPoint(result);
     },
     */
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
    
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
    
        var pointsString = this._points.join(",");
        var options = {};
        options.coordinates = pointsString;
        
        var finalResult = {
            distance: null,
            surfDistance: null
        };
        finalResult.distance = geometry.getGeodesicLength();
		
		this.onComplete(finalResult);
//        this._getMeasureResult("surfaceDistance", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            finalResult.surfDistance = result.Result.Value;
//            this.onComplete(finalResult);
//        }, this));
    },
    
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length <= 1) {
            return;
        }
        
        if (this.isRealTime) {
        
            var pointsString = this._points.join(",");
            
            var options = {};
            options.coordinates = pointsString;
            var finalResult = {
                surfDistance: null
            };
            
            this._getMeasureResult("surfaceDistance", options, OpenLayers.Function.bind(function(result){
            
                finalResult.surfDistance = result.Result.Value;
                this.onAddPoint(finalResult);
            }, this));
        }
        
        
        //this._setMeasureParams(this.MEASURE_PARAM, points.join(" "), 0);     
    },
    
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.PointInfo"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.PointInfo"

});

/**
 * Class: Geo.View3D.Control.Measure.Area
 * 量算出一个面结果。
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.Area = Geo.Class(Geo.View3D.Control.Measure, {

    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型。
     */
    handlerType: Geo.View3D.Handler.Polygon,
    
    //MEASURE_PARAM: 2,
    
    /**
     * APIProperty: isRealTime
     * {Boolean} 是否实时获取结果。 默认值为false。
     */
    isRealTime: false,
    
    /**
     * Constructor: Geo.View3D.Control.Measure.Area
     * 构造函数。生成一个Geo.View3D.Control.Measure.Area的实例。
     * 
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
    
    /*
     _measureHandler: function(mouseEvent){
     var result = {
     area: mouseEvent.Area,
     surfArea: mouseEvent.SurfArea
     };
     this._result = result;
     this.onAddPoint(result);
     },
     */
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法。
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
    
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法。
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
    
    /**
     * 在三维视图上结束绘制图形时，调用此方法。
     * geometry - {Object} 要素。
     */
    _onComplete: function(geometry){
    
        var pointsString = this._points.join(",");
        var options = {};
        options.coordinates = pointsString;
        
        var finalResult = {
            area: null,
            surfaceArea: null
        };
        finalResult.area = geometry.getGeodesicArea();
		
		this.onComplete(finalResult);
//        this._getMeasureResult("surfaceArea", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            finalResult.surfaceArea = result.Result.Value;
//            this.onComplete(finalResult);
//        }, this));
    },
    
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法。
     * pointGeometry - {Object}
     * lineGeometry - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components[0].components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length <= 2) {
            return;
        }
        
        if (this.isRealTime) {
        
            var pointsString = this._points.join(",");
            
            var options = {};
            options.coordinates = pointsString;
            var finalResult = {
                surfaceArea: null
            };
            
            this._getMeasureResult("surfaceArea", options, OpenLayers.Function.bind(function(result){
            
                finalResult.surfaceArea = result.Result.Value;
                this.onAddPoint(finalResult);
            }, this));
        }
        
        
        //this._setMeasureParams(this.MEASURE_PARAM, points.join(" "), 0);     
    },
    
    /*
     _onComplete:function(geometry){
     this.onComplete(this._result);
     },
     
     _onAddPoint: function(pointGeometry,polygonGeometry){
     
     //检查多于两个点才计算
     var linearRing = polygonGeometry.components[0];
     var allPoints = linearRing.components;
     if(allPoints.length <= 2){
     return;
     }
     //正式量算
     var pointsStr = this._getPointsSpaceSplitStr(polygonGeometry,0);
     this._setMeasureParams(this.MEASURE_PARAM, pointsStr, 0);
     },
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.Area"
});

/**
 * Class: Geo.View3D.Control.Measure.Volume
 * 量算体积的分析结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.Volume = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Polygon,
    
    //MEASURE_PARAM: 2,
    /**
     * APIProperty: height
     * {Integer} 海拔高度。 默认值为200。
     */
    height: 200,
	
    /**
     * Constructor: Geo.View3D.Control.Measure.Volume
     * 构造函数。生成一个Geo.View3D.Control.Measure.Volume的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
    
    /*
     _measureHandler: function(mouseEvent){
     var result = {
     height: this.height,
     volume: mouseEvent.Volume
     };
     this._result = result;
     this.onAddPoint(result);
     },
     */
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
	
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
    
    /*
     _onComplete:function(geometry){
     this.onComplete(this._result);
     },
     
     _onAddPoint: function(pointGeometry,polygonGeometry){
     var linearRing = polygonGeometry.components[0];
     var allPoints = linearRing.components;
     if(allPoints.length <= 2){
     return;
     }
     var pointsStr = this._getPointsSpaceSplitStr(polygonGeometry);
     this._setMeasureParams(this.MEASURE_PARAM, pointsStr, this.height);
     },
     */
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
    
        var pointsString = this._points.join(",");
        var options = {};
        options.coordinates = pointsString;
        options.subjoin = this.height;
        var finalResult = {
            height: this.height,
            geometry: geometry,
            //excavate:null,
            //file:null,
            volume: null
        };
		
		
		this.onComplete(finalResult);
//        this._getMeasureResult("volume", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            var arr = result.Result.Value.split(" ");
//            finalResult.volume = arr[0];
//            //finalResult.excavate = arr[1];
//            //finalResult.fill = arr[2];
//            this.onComplete(finalResult);
//        }, this));
    },
	
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components[0].components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length <= 2) {
            return;
        }
        
        if (this.isRealTime) {
        
            var pointsString = this._points.join(",");
            
            var options = {};
            options.coordinates = pointsString;
            options.subjoin = this.height;
            var finalResult = {
                height: this.height,
                geometry: lineGeometry,
                //excavate: null,
                //fill: null,
                volume: null
            };
            
            this._getMeasureResult("volume", options, OpenLayers.Function.bind(function(result){
            
                //finalResult.volume = result.Result.Value;
                var arr = result.Result.Value.split(" ");
                finalResult.volume = arr[0];
                finalResult.excavate = arr[1];
                finalResult.fill = arr[2];
                this.onAddPoint(finalResult);
            }, this));
        }

        //this._setMeasureParams(this.MEASURE_PARAM, points.join(" "), 0);     
    },
	
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.Volume"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.Volume"

});

/**
 * Class: Geo.View3D.Control.Measure.Excavate
 * 量算填挖方的分析结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.Excavate = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Polygon,
    
    //MEASURE_PARAM: 0,
    /**
     * APIProperty: height
     * {Integer} 海拔高度。 默认值为200。
     */
    height: 200,
	
    /**
     * APIProperty: lowHeight
     * {Integer} 挖填方高度(低)。 默认值为0。
     */
	lowHeight: 0,
	
    /**
     * APIProperty: highHeight
     * {Integer} 挖填方高度(高)。 默认值为200。
     */
	highHeight: 200,
    /**
     * Constructor: Geo.View3D.Control.Measure.Excavate
     * 构造函数。生成一个Geo.View3D.Control.Measure.Excavate的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
	
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
	
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
	
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
    
        var pointsString = this._points.join(",");
        var options = {};
        options.coordinates = pointsString;
        options.subjoin = this.height;
        var finalResult = {
            height: this.height,
            geometry: geometry,
            excavate: null,
            fill: null,
            volume: null
        };
		
		var ringStr = geometry.toString().replace("POLYGON","Ring");
		var ringStr = ringStr.replace("((","(");
		var ringStr = ringStr.replace("))",")");
        var polygon3D = this.map.activexObj.DrawBox.CreateGeometryObject(ringStr, "", 3, 1);
        //var polygon = this.map.activexObj.DrawBox.CreateGeometryObject("Ring(114 30,115 30,115 31,114 31,114 30)", "", 3, 1);
		var result3D = this.map.activexObj.AnalysisBox.CutFill(polygon3D, this.lowHeight, this.height);
        //var result = this.map.activexObj.AnalysisBox.CutFill(polygon, 0, 1);
		finalResult.excavate = result3D.CutVolume;
		finalResult.fill = result3D.FillVolume;
		finalResult.volume = 0;
		this.onComplete(finalResult);
		
       // alert("填：" + result.FillVolume + "挖：" + result.CutVolume);
//        this._getMeasureResult("volume", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            var arr = result.Result.Value.split(" ");
//            finalResult.volume = arr[0];
//            finalResult.excavate = arr[1];
//            finalResult.fill = arr[2];
//            this.onComplete(finalResult);
//        }, this));
    },
	
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components[0].components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length <= 2) {
            return;
        }
        
        if (this.isRealTime) {
        
            var pointsString = this._points.join(",");
            
            var options = {};
            options.coordinates = pointsString;
            options.subjoin = this.height;
            var finalResult = {
                height: this.height,
                geometry: lineGeometry,
                excavate: null,
                fill: null,
                volume: null
            };
            
            this._getMeasureResult("volume", options, OpenLayers.Function.bind(function(result){
            
                //finalResult.volume = result.Result.Value;
                var arr = result.Result.Value.split(" ");
                finalResult.volume = arr[0];
                finalResult.excavate = arr[1];
                finalResult.fill = arr[2];
                this.onAddPoint(finalResult);
            }, this));
        }
    },
    
    /**
     * APIMethod: deactivate
     * 取消激活控件并清除盒子图层
     * Returns:
     * {Boolean} true
     */
    deactivate: function(){
        if (Geo.View3D.Control.prototype.deactivate.apply(this, arguments)) {
            //this._clearBoxLayer();
        }
        return true;
    },
	
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.Excavate"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.Excavate"

});

/**
 * Class: Geo.View3D.Control.Measure.Flood
 * 量算淹没分析的结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.Flood = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Polygon,
    
    //MEASURE_PARAM: 1,
    /**
     * APIProperty: height
     * {Integer} 海拔高度。 默认值为2000。
     */
    height: 2000,
    
    solidOptions: null,
    
    solid: null,
    /**
     * Constructor: Geo.View3D.Control.Measure.Flood
     * 构造函数。生成一个Geo.View3D.Control.Measure.Flood的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
    
    _measureHandler: function(mouseEvent){
        var result = {
            height: this.height,
            volume: mouseEvent.Volume,
            inundatedArea: mouseEvent.InundatedArea,
            floodArea: mouseEvent.FloodArea,
            floodVolume: mouseEvent.FloodVolume
        };
        this._result = result;
        this.onAddPoint(result);
    },
	
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
	
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
    
    /*
     _onComplete:function(geometry){
     this._createBoxLayer(geometry);
     this.onComplete(this._result);
     },
     
     _onAddPoint: function(pointGeometry,polygonGeometry){
     var linearRing = polygonGeometry.components[0];
     var allPoints = linearRing.components;
     if(allPoints.length <= 2){
     return;
     }
     var pointsStr = this._getPointsSpaceSplitStr(polygonGeometry);
     this._setMeasureParams(this.MEASURE_PARAM, pointsStr, this.height);
     },
     */
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
    
        var pointsString = this._points.join(",");
        var options = {};
        options.coordinates = pointsString;
        options.subjoin = this.height;
        var finalResult = {
            height: this.height,
            inundatedArea: null,
            floodArea: null,
            floodVolume: null
        };
		
		this.onComplete(finalResult);
//        this._getMeasureResult("floodAnalysis", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            var arr = result.Result.Value.split(" ");
//            finalResult.inundatedArea = arr[0];
//            finalResult.floodArea = arr[1];
//            finalResult.floodVolume = arr[2];
//            this._drawSolid(geometry);
//            this.onComplete(finalResult);
//        }, this));
    },
	
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components[0].components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length <= 2) {
            return;
        }
        
        if (this.isRealTime) {
            var options = {};
            options.coordinates = pointsString;
            options.subjoin = this.height;
            var finalResult = {
                height: this.height,
                inundatedArea: null,
                floodArea: null,
                floodVolume: null
            };
            this._getMeasureResult("floodAnalysis", options, OpenLayers.Function.bind(function(result){
                var arr = result.Result.Value.split(" ");
                finalResult.inundatedArea = arr[0];
                finalResult.floodArea = arr[1];
                finalResult.floodVolume = arr[2];
                this.onComplete(finalResult);
            }, this));
        }
        
        
        //this._setMeasureParams(this.MEASURE_PARAM, points.join(" "), 0);     
    },
    /**
     * 在三维视图上画一个盒子图层
     * geometry - {Object}
     */
    _drawSolid: function(geometry){
        if (this.solid) {
            this._clearSolid();
        }
        this.solid = new Geo.View3D.Layer.Solid(this.id + "_solid", geometry, this.height, this.solidOptions);
        this.map.addLayer(this.solid);
    },
    
    /**
     * 清除盒子图层
     */
    _clearSolid: function(){
        if (this.solid && this.map) {
            this.map.removeLayer(this.solid);
        }
    },
    
    /**
     * APIMethod: deactivate
     * 取消激活控件并清除盒子图层
     * 
     * Returns:
     * {Boolean} true
     */
    deactivate: function(){
        if (Geo.View3D.Control.prototype.deactivate.apply(this, arguments)) {
            this._clearSolid();
        }
        return true;
    },
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.Flood"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.Flood"

});

/**
 * Class: Geo.View3D.Control.Measure.Profile
 * 量算出两个点的剖面地形分析结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.Profile = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Path,
	
    /**
     * Constructor: Geo.View3D.Control.Measure.Profile
     * 构造函数。生成一个Geo.View3D.Control.Measure.Profile的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
        this.serviceUrl = serviceUrl;
        this._terrainAnalysisService = new Geo.Service.TAS(this.id + "_service", serviceUrl);
        this.callbacks = OpenLayers.Util.extend({
            point: this._onAddPoint
        }, this.callbacks);
        this.handlerOptions = this.handlerOptions || {};
        if (this.handlerType) {
            this.handler = new this.handlerType(this, this.callbacks, this.handlerOptions);
        }
        
    },
	
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
	
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
	
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
        var pointsString = this._points.join(",");
        
        var options = {};
        options.coordinates = pointsString;
        var finalResult = {
            heightArray: null
        };
        
		
		this.onComplete(finalResult);
//        this._getMeasureResult("profileAnalysis", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            finalResult.heightArray = result.Result.Value;
//            this.onComplete(finalResult);
//        }, this));
        
    },
	
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length == 2) {
            this._onComplete();
            this.handler.deactivate();
            this.handler.activate();
            return;
        }
        
    },
    
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.Profile"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.Profile"

});
/**
 * Class: Geo.View3D.Control.Measure.TwoPointThrough
 * 量算出两个点是否可见以及分析的结果
 *
 * Inherits from:
 *  - <Geo.View3D.Control.Measure>
 */
Geo.View3D.Control.Measure.TwoPointThrough = Geo.Class(Geo.View3D.Control.Measure, {
    /**
     * APIProperty: handlerType
     * 三维视图事件监听类型
     */
    handlerType: Geo.View3D.Handler.Path,
	
    /**
     * Constructor: Geo.View3D.Control.Measure.TwoPointThrough
     * 构造函数。生成一个Geo.View3D.Control.Measure.TwoPointThrough的实例。
     */
    initialize: function(serviceUrl, options){
        Geo.View3D.Control.Measure.prototype.initialize.apply(this, arguments);
    },
    
    /**
     * APIMethod: onAddPoint
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onAddPoint: function(result){
    },
	
    /**
     * APIMethod: onComplete
     * 在三维视图上结束绘制图形时，调用此方法
     *
     * Paramters:
     * result - {Object}
     */
    onComplete: function(result){
    },
	
    /**
     * 在三维视图上结束绘制图形时，调用此方法
     * geometry {Object}
     */
    _onComplete: function(geometry){
        var pointsString = this._points.join(",");
        
        var options = {};
        options.coordinates = pointsString;
        var finalResult = {
            from: null,
            to: null,
            isVisible: null,
            firstUnseenHeight: null,
            heightArray: null
        };
        
		
		this.onComplete(finalResult);
//        this._getMeasureResult("profileAnalysis", options, OpenLayers.Function.bind(function(result){
//            if (this._terrainAnalysisService._isException(result)) {
//                this.onComplete(result);
//                return result;
//            }
//            finalResult.heightArray = result.Result.Value;
//            finalResult.isVisible = this.getVisible(finalResult.heightArray).isVisible;
//            finalResult.firstUnseenHeight = this.getVisible(finalResult.heightArray).firstUnseenHeight;
//            this.onComplete(finalResult);
//        }, this));
        
    },
	
    /**
     * 在三维视图上鼠标点击添加一个点时，调用此方法
     * result - {Object}
     */
    _onAddPoint: function(pointGeometry, lineGeometry){
        var allPoints = lineGeometry.components;
        this._points = [];
        for (var i = 0; i < allPoints.length; i++) {
            this._points.push(allPoints[i].x);
            this._points.push(allPoints[i].y);
        }
        
        if (allPoints.length == 2) {
            this._onComplete();
            this.handler.deactivate();
            this.handler.activate();
            return;
        }
        
    },
	
    /**
     * APIMethod: getVisible
     * 得到是否可见的结果
     *
     * Paramters:
     * arrayString - {String} 一些高度的字符串
     */
    getVisible: function(arrayString){
        var array = arrayString.split(" ");
        var length = array.length;
        var isVisible = true;
        // 第一个障碍点高程值
        var firstUnseenHeight = null;
        for (var i = 0; i < length; i++) {
        
            //起点和终点之间的高度差
            var num1 = array[length - 1] - array[0];
            //高度差分成点总数的段数
            var num2 = num1 / (length - 1);
            //每段乘以第i个点，得到第i个点的高度
            var num3 = num2 * i;
            //第i个点的高度加上第一个点的高度
            var lineY = Number(array[0]) + num3;
            
            //判断第二个点至倒数第二个点是否有障碍点
            if (i > 0 && i < (length - 1) && isVisible && array[i] >= lineY) {
                isVisible = false;
                // 第一个障碍点高程值
                firstUnseenHeight = lineY;
            }
        }
        //     alert("firstUnseenPoint:" + firstUnseenPoint);
        var result = {
            firstUnseenHeight: firstUnseenHeight,
            isVisible: isVisible
        };
        return result;
    },
	
    /**
     * APIProperty: CLASS_NAME
     * 类名标识 - "Geo.View3D.Control.Measure.TwoPointThrough"
     */
    CLASS_NAME: "Geo.View3D.Control.Measure.TwoPointThrough"

});

/**
 * Class: Geo.View3D.Control.ModelChoose
 * 三维视图模型选择控件类。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.ModelChoose = Geo.Class(Geo.View3D.Control, {
	
	 /**
     * APIProperty: handlerOptions
     * {Object} 监听器的构造参数。
     */
    handlerOptions: null,
	
	 /**
     * APIProperty: layer
     * {<Geo.View3D.Layer.Model>} 模型图层。
     */
    layer: null,

    /**
     * APIProperty: callbacks
     * {Object} 回调函数定义。
     */    
    callbacks: {},
	
    /**
     * Constructor: Geo.View3D.Control.ModelChoose
     * Geo.View3D.Control.ModelChoose构造函数。
     */
    initialize: function(layer, options) {
		Geo.View3D.Control.prototype.initialize.apply(this, [options]);
		this.layer = layer;
		this.callbacks = OpenLayers.Util.extend(
            {
                "chooseModel": this.chooseModel
            },
            this.callbacks
        );
		this.handlerOptions = this.handlerOptions || {};
    	this.handler = new Geo.View3D.Handler.ModelChoose(this,
                            this.callbacks, this.handlerOptions);
    },	
	
	chooseModel: function(mouseEvent, isSelected, fid) {
		
	},
	
	CLASS_NAME: "Geo.View3D.Control.ModelChoose"
});/**
 * Class: Geo.View3D.Control.DrawBox
 * 屏幕元素绘制控件类。使用本控件可以在三维地图上创建纹理源模块、创建屏幕元素模块、创建贴地立体元素模块、创建特效元素模块、元素管理模块。
 * 
 * Inherits from:
 *  - <Geo.View3D.Control>
 */
Geo.View3D.Control.DrawBox = Geo.Class(Geo.View3D.Control, {

 	/**
	 * Constructor: Geo.View3D.Control.DrawBox
	 * Geo.View3D.Control.DrawBox构造函数。
	 */   
    initialize: function(options){
        Geo.View3D.Control.prototype.initialize.apply(this, [options]);
    },
	
	/**
	 * APIMethod: createScreenPictureElement
	 * 创建屏幕图片元素
	 * 
	 * Paramters:
	 * x - {Number} 元素定位点的左侧X坐标，单位像素
	 * y - {Number} 元素定位点的上侧Y坐标，单位像素
	 * varImg - {String} 图片地址
	 * nWidth - {Number} 元素的宽度，单位像素
	 * nHeight - {Number} 元素的高度，单位像素
	 * 
	 * Returns:
     * {Object} IScreenPictureElement3D*类型。
	 */
	createScreenPictureElement: function(x, y, varImg, nWidth, nHeitht){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				var pictureTextureSource = this.createPictureTextureSource(varImg);
				return globe.ElementBox.CreateScreenPictureElement(x, y, pictureTextureSource, nWidth, nHeitht);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createTextElement
	 * 创建屏幕文本元素
	 * 
	 * Paramters:
	 * x - {Number} 元素定位点的左侧X坐标，单位像素
	 * y - {Number} 元素定位点的上侧Y坐标，单位像素
	 * bstrtext - {String} 元素文本内容
	 * nWidth - {Number} 元素的宽度，单位像素
	 * nHeight - {Number} 元素的高度，单位像素
	 * fontName - {String}  字体
	 * nFontSize - {Number} 字号
	 * nFontColor - {String} 字体颜色
	 * 
	 * Returns:
     * {Object} ITextElement3D*类型。
	 */
	createTextElement: function(x, y, bstrtext, nWidth, nHeight, fontName,  nFontSize, nFontColor){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				return globe.ElementBox.CreateTextElement(x, y, bstrtext, nWidth, nHeight);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createButtonWidgetElement
	 * 创建屏幕按钮元素
	 * 
	 * Paramters:
	 * x - {Number} 元素定位点的左侧X坐标，单位像素
	 * y - {Number} 元素定位点的上侧Y坐标，单位像素
	 * varImage - {String} 元素的显示图片
	 * varPressImage - {String} 点击时元素图片
	 * varHoverImage - {String} 在元素上停留时图片
	 * nWidth - {Number}  图片的宽度，单位像素
	 * nHeight - {Number} 图片的高度，单位像素
	 * 
	 * Returns:
     * {Object} IButtonWidgetElement*类型。
	 */
	createButtonWidgetElement: function(x, y, varImage, varPressImage, varHoverImage, nWidth, nHeight){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				var varImage = this.createPictureTextureSource(varImage);
				var varPressImage = this.createPictureTextureSource(varPressImage);
				var varHoverImage = this.createPictureTextureSource(varHoverImage);
				return globe.ElementBox.CreateButtonWidgetElement(x, y, varImage, varPressImage, varHoverImage, nWidth, nHeight);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createScreenGeometryElement
	 * 创建屏幕几何元素
	 * 
	 * Paramters:
	 * varCoord - {String} 线的点坐标数组,支持WKT字符串
	 * nColor - {String} 线的颜色
	 * nWidth - {Number} 线的宽度，单位像素
	 * bPattern - {Boolean} 是否使用虚线
	 * fPatternScale - {Number} 虚线间隔
	 * 
	 *  Returns:
     * {Object} IScreenGeometryElement*类型。
	 */
	createScreenGeometryElement: function(varCoord, nColor, nWidth, bPattern, fPatternScale){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				return globe.ElementBox.CreateScreenGeometryElement(varCoord, nColor, nWidth, bPattern, fPatternScale);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createBillBoardElement3D
	 * 创建广告片元素
	 * 
	 * Paramters:
	 * lon - {Number} 经度
	 * lat - {Number} 纬度
	 * alt - {Number} 高程，单位米
	 * varImg - {String} 显示图片
	 * 
	 *  Returns:
     * {Object} IBillboardElement3D*类型。
	 */
	createBillBoardElement3D: function(lon, lat, alt, varImg){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				var pictureTextureSource = this.createPictureTextureSource(varImg);
				return globe.ElementBox.CreateBillBoardElement3D(lon, lat, alt, pictureTextureSource);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createPOIElement3D
	 * 创建POI元素
	 * 
	 * Paramters:
	 * lon - {Number} 经度
	 * lat - {Number} 纬度
	 * alt - {Number} 高程，单位米
	 * eTexPos - {String} 显示方式
	 * bstrCaption - {String} 文本
	 * varIcon - {String} 图标
	 * bstrFontName - {String} 字体名称
	 * nFontSize - {Number} 字号
	 * nFontColor - {String} 字体颜色
	 * 
	 * Returns:
	 * {Object} IPOIElement3D*类型。
	 */
	createPOIElement3D: function(lon, lat, alt, eTexPos, bstrCaption, varIcon, bstrFontName, nFontSize, nFontColor){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				return globe.ElementBox.CreatePOIElement3D(lon, lat, alt, eTexPos, bstrCaption, varIcon);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createGeoPictureElement3D
	 * 创建贴地图片元素
	 * 
	 * Paramters:
	 * minX - {Number} 球面最小经度坐标
	 * minY - {Number} 球面最小纬度坐标 
	 * maxX - {Number} 球面最大经度坐标
	 * maxY - {Number} 球面最大纬度坐标
	 * varImage - {String} 图片
	 * 
	 * Returns:
	 * {Object} IGeoPictureElement3D*类型。
	 */
	createGeoPictureElement3D: function(minX, minY, maxX, maxY, varImage){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				var pictureTextureSource = this.createPictureTextureSource(varImage);
				return globe.ElementBox.CreateGeoPictureElement3D(minX, minY, maxX, maxY, pictureTextureSource);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createMeshElement3D
	 * 创建球面立体元素
	 * 
	 * Paramters:
	 * lon - {Number} 元素的定位点lon坐标，经度
	 * lat - {Number} 元素的定位点lat坐标，纬度
	 * alt - {Number} 元素的定位点alt坐标，高程，单位米
	 * varMesh - {Object} 立体几何对象
	 * varMaterial - {Object} 材质对象
	 * varTextureSource - {Object} 纹理
	 * 
	 * Returns:
	 * {Object} IMeshElement3D*类型。
	 */
	createMeshElement3D: function(lon, lat, alt, varMesh, varMaterial, varTextureSource){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				return globe.ElementBox.CreateMeshElement3D(lon, lat, alt, varMesh, varMaterial, varTextureSource);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createMaterial3D
	 * 创建3D材质
	 * 
	 * Paramters:
	 * nAmbient - {Number} 环境光，值域0-0xffffffff
	 * nDiffuse - {Number} 漫反射光，值域0-0xffffffff
	 * nSpecular - {Number} 镜面反射光，值域0-0xffffffff
	 * nEmissive - {Number} 自发光，值域0-0xffffffff
	 * fPower - {Number} 镜面高光
	 * 
	 * Returns:
	 * {Object} IMaterial3D*类型。
	 */
	createMaterial3D: function(nAmbient, nDiffuse, nSpecular, nEmissive, fPower){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				return globe.ElementBox.CreateMaterial3D(nAmbient, nDiffuse, nSpecular, nEmissive, fPower);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createPictureTextureSource
	 * 创建图片纹理源
	 * 
	 * Paramters:
	 * varData - {Number} 指定了图片的来源，支持url、字符串路径、图片字节流；
	 * 
	 * Returns:
	 * {Object} IPictureTextureSource*类型。
	 */
	createPictureTextureSource: function(varData){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				var ptex = globe.ElementBox.CreatePictureTextureSource(varData);
				return ptex;
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createCuboidMesh
	 * 创建长方体
	 * 
	 * Paramters:
	 * dblLength - {Number} 长，单位米
	 * dblBreadth - {Number} 宽，单位米
	 * dblHeight - {Number} 高，单位米
	 * etxtStyle - {Number} 纹理贴图类型
	 * 
	 * Returns:
	 * {Object} IMesh3D*类型。
	 */
	createCuboidMesh: function(dblLength, dblBreadth, dblHeight, etxtStyle){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				var pCuboid = globe.ElementBox.CreateCuboidMesh(dblLength, dblBreadth, dblHeight, etxtStyle);
				return pCuboid;
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createFireElement3D
	 * 创建特效火元素
	 * 
	 * Paramters:
	 * lon - {Number} 元素的定位点lon坐标，经度
	 * lat - {Number} 元素的定位点lat坐标，纬度
	 * alt - {Number} 元素的定位点alt坐标，高程，单位米
	 * ePowerLevel - {Number} 火焰火力等级，2-最高等级 1-中等等级 0-最低等级 
	 * dblRadius - {Number} 火焰半径，单位米
	 * nColor - {Number} 火焰颜色，没有A通道，只有RGB
	 * 
	 * Returns:
	 * {Object} IFireElement3D*类型。
	 */
	createFireElement3D: function(lon, lat, alt, ePowerLevel, dblRadius, nColor){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				return globe.ElementBox.CreateFireElement3D(lon, lat, alt, ePowerLevel, dblRadius, nColor);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createSmokeElement3D
	 * 创建特效烟元素
	 * 
	 * Paramters:
	 * lon - {Number} 元素的定位点lon坐标，经度
	 * lat - {Number} 元素的定位点lat坐标，纬度
	 * alt - {Number} 元素的定位点alt坐标，高程，单位米
	 * eDensity - {Number} 烟浓度，大、中、小三个值，10-最大密度 5-中等密度 1-最低密度
	 * dblRadius - {Number} 烟的半径，单位米
	 * nColor - {Number} 烟的颜色,没有A通道，只有RGB
	 * 
	 * Returns:
	 * {Object} ISmokeElement3D*类型。
	 */
	createSmokeElement3D: function(lon, lat, alt, eDensity, dblRadius, nColor){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				return globe.ElementBox.CreateSmokeElement3D(lon, lat, alt, eDensity, dblRadius, nColor);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createSpringElement3D
	 * 创建特效水柱或喷泉元素
	 * 
	 * Paramters:
	 * lon - {Number} 元素的定位点lon坐标，经度
	 * lat - {Number} 元素的定位点lat坐标，纬度
	 * alt - {Number} 元素的定位点alt坐标，高程，单位米
	 * dblHeading - {Number} 水柱喷射的方位角
	 * dblTilt - {Number} 水柱喷射的俯仰角
	 * dblRadius - {Number} 水柱的粗细
	 * dblMinDistance - {Number} 水柱喷射的最近距离，单位米
	 * dblMaxDistance - {Number} 水柱喷射的最大距离，单位米
	 * 
	 * Returns:
	 * {Object} ISpringElement3D*类型。
	 */
	createSpringElement3D: function(lon, lat, alt, dblHeading, dblTilt, dblRadius, dblMinDistance, dblMaxDistance){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				return globe.ElementBox.CreateSpringElement3D(lon, lat, alt, dblHeading, dblTilt, dblRadius, dblMinDistance, dblMaxDistance);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: createRainElement3D
	 * 创建特效雨元素
	 * 
	 * Paramters:
	 * lon - {Number} 元素的定位点lon坐标，经度
	 * lat - {Number} 元素的定位点lat坐标，纬度
	 * alt - {Number} 元素的定位点alt坐标，高程，单位米
	 * dblLength - {Number} 范围的长，单位米
	 * dblWidth - {Number} 范围的宽，单位米
	 * eDensity - {Number} 雨的等级
	 * 
	 * Returns:
	 * {Object} IRainElement3D*类型。
	 */
	createRainElement3D: function(lon, lat, alt, dblLength, dblWidth, eDensity){
		var globe = this.map.activexObj;
		try {
			if (globe) {
				return globe.ElementBox.CreateRainElement3D(lon, lat, alt, dblLength, dblWidth, eDensity);
			}
		}catch(e){
	        return null;
	    }
		return null;
	},
	
	/**
	 * APIMethod: setSkyBoxVisible
	 * 设置天空盒显示和隐藏状态
	 * 
	 * Paramters:
	 * visible - {Boolean} 是否显示
	 */
	setSkyBoxVisible: function(visible){
		var globe = this.map.activexObj;
		if (globe) {
			globe.ScreenBox.ChangeScreenElementVisible(2, !visible);
			globe.ElementBox.SkyBox.Visible = visible;
		}
	},     
	
	/**
	 * APIMethod: setSunVisible
	 * 设置光晕显示和隐藏状态
	 * 
	 * Paramters:
	 * visible - {Boolean} 是否显示
	 */
	setSunVisible: function(visible){
		var globe = this.map.activexObj;
		if (globe) {
			globe.ConfigBox.SaveConfigItem(22, visible); 
			if(!visible) globe.Camera.CameraMode = 1;
			globe.ElementBox.Sun.Visible = visible;
		}
	}, 
	
	/**
	 * APIMethod: removeBoxs
	 * 删除全部元素
	 * 
	 */
	removeBoxs: function(){
		var globe = map.activexObj;
		if (globe) {
			var elementBox = globe.ElementBox;
			var count = elementBox.ElementCount;
//			for (var i = 0; i < count; i++) {
//				elementBox.RemoveElementAt(i);
//			}
			for (var i = count - 1; i >= 0; i--)
            {
                elementBox.RemoveElementAt(i);
            }
		}
	},
	
	CLASS_NAME: "Geo.View3D.Control.DrawBox"
});
/**
 * Class: Geo.CombineView
 * 地图视图类(复合视图),封装了二三维视图。
 * 
 * 复合视图是将二维地图和三维地图整合到一起，为用户提供不同的地理信息数据视图方式，
 * 并且可以方便的在两种视图方式之间切换、同步。具体实现过程是分别构造二维和三维两个
 * 地图对象，将两者同时放置在一个 div元素中，同一时间只显示一个地图对象，在切换到另
 * 一个地图对象时隐藏前一个，并将中心点位置和当前级别进行同步。用户可以分别对二、三
 * 维地图对象独立控制，比如进行相关控件、图层对象添加，属性的更改等操作。
 */
Geo.CombineView = Geo.Class({
	
	/**
     * APIProperty: id
     * {String} id号，视图中地图的唯一标识。
     */
    id: null,
    
 	/**
     * APIProperty: div
     * {DOMElement|String} 视图所在容器。
     */
    div: null,
    
  	/**
     * APIProperty: map2D
     * {<Geo.View2D.Map>} 二维地图对象,为与三维保持一致,二维视图对象只能为360金字塔。
     */
    map2D: null,
    
  	/**
     * APIProperty: map2DOptions
     * {Object} 可选二维地图初始化参数。
     */
    map2DOptions: null,
    
  	/**
     * APIProperty: map3D
     * {<Geo.View3D.Map>} 三维地图对象。
     */
    map3D: null,
    
   	/**
     * APIProperty: map3DOptions
     * {Object} 可选三维地图初始化参数。
     */
    map3DOptions: null,
	
	/**
     * Property: mapFlash
     * {<Geo.ViewFl.Map>} flash地图对象。
     */
	mapFlash: null,
	
	/**
     * Property: mapFlashOptions
     * {Object} flash地图构造参数。
     */
	mapFlashOptions: null,
    
   	/**
     * APIProperty: currentView
     * {Object} 当前视图。
     */
    currentView: null,
    
   	/**
     * APIProperty: viewList
     * {Object} 支持的视图列表及相关映射。
     */
    viewList: null,
    
   	/**
     * APIProperty: defaultView
     * {String} 缺省视图。可选：“2D”、“3D”，默认值为“2D”（即默认为二维视图）。
     */
    defaultView: "2D",
	
   	/**
     * APIProperty: defaultLayout
     * {String | <Geo.CombineView.layoutList>} 缺省布局。默认值为“single”。
     */
	defaultLayout: "single",
	
   	/**
     * APIProperty: currentLayout
     * {String} 当前布局。
     */
	currentLayout: null,
	
   	/**
     * APIProperty: center
     * {<Geo.LonLat>} 当前中心点。
     */
	center: null,
	
   	/**
     * APIProperty: zoom
     * {Integer} 当前级别。
     */
	zoom: null,
	
   	/**
     * APIProperty: ayncType
     * {Boolean} 视图同步方式"all","center","layers"。
     */
	ayncType: "all",
	
   	/**
     * APIProperty: layoutList
     * {Array} 支持的布局。
     */
	layoutList: ["single","vertical","horizontal"],
    
   	/**
     * APIProperty: EVENT_TYPES
     * {Array} 事件类型。
     */
    EVENT_TYPES: ["viewswitch", "addlayer", "loadlayergroup"],
    
   	/**
     * APIProperty: events
     * 复合视图对象的事件。
     */
    events: null,
    
   	/**
     * APIProperty: eventListeners
     * 复合视图对象的事件监听器。
     */
    eventListeners: null,
    
    /**
     * Constructor: Geo.CombineView
     * 构造函数。生成一个二三维复合视图对象实例。
     * 
     * Parameters:
     * div - {String} 指定地图对象将被渲染到哪个div 元素中。
     * options - {Object} 地图对象相关选项设置。
     */
	initialize: function(div, options){
        this.id = OpenLayers.Util.createUniqueID("Geo.CombineView_");
        this.div = OpenLayers.Util.getElement(div);
        
        this.viewList = {
            "2D": {
                title: "二维视图",
                getMapObj: OpenLayers.Function.bind(function(){
                    return this.map2D;
                }, this),
                initFn: OpenLayers.Function.bind(this.initMap2D, this),
                getInitOptions: OpenLayers.Function.bind(function(){
                    return this.map2DOptions;
                }, this)
            },
            "3D": {
                title: "三维视图",
                getMapObj: OpenLayers.Function.bind(function(){
                    return this.map3D;
                }, this),
                initFn: OpenLayers.Function.bind(this.initMap3D, this),
                getInitOptions: OpenLayers.Function.bind(function(){
                    return this.map3DOptions;
                }, this)
            },
			"flash": {
				title: "flash视图",
				getMapObj: OpenLayers.Function.bind(function(){
                    return this.mapFlash;
                }, this),
				initFn: OpenLayers.Function.bind(this.initMapFlash, this),
				getInitOptions: OpenLayers.Function.bind(function(){
                    return this.mapFlashOptions;
                }, this)
			}
        };
        OpenLayers.Util.extend(this, options);
		this.initLayout();
		
        //初始化缺省视图
        this.currentView = this.defaultView;
        var initFn = this.viewList[this.currentView].initFn;
        var initOptions = this.viewList[this.currentView].getInitOptions();
        initFn(initOptions);
        
        this.events = new OpenLayers.Events(this, this.div, this.EVENT_TYPES, this.fallThrough, {
            includeXY: true
        });
        if (this.eventListeners instanceof Object) {
            this.events.on(this.eventListeners);
        }
        

    },
    
    /**
     * APIMethod: initMap2D
     * 初始化二维地图对象。
     * 
     * Parameters:
     * options - {Object} 地图对象相关选项设置。
     * 
     * Returns
     * {Boolean} true为初始化成功。
     */
	initMap2D: function(options){
        if (!this.map2D) {
            var map2DDiv = document.createElement("div");
            map2DDiv.style.height = "100%";
            map2DDiv.style.width = "100%";
            map2DDiv.id = this.id + "_map2D";
            this.div.appendChild(map2DDiv);
            this.map2D = new Geo.View2D.Map(map2DDiv, options);
			
			this.map2D.events.on({
	            "move": function(){
					this.center = this.map2D.getCenter();
					this.zoom = this.map2D.getZoom();
				},
	            scope: this
	        });

            //this.map2D.setCenter(0,0);
        }
        return true;
    },
    
    /**
     * APIMethod: initMap3D
     * 初始化三维地图对象。
     * 
     * Parameters:
     * options - {Object} 地图对象相关选项设置。
     * 
     * Returns
     * {Boolean} true为初始化成功。
     */
    initMap3D: function(options){
        if (!this.map3D) {
            var map3DDiv = document.createElement("div");
            map3DDiv.style.height = "100%";
            map3DDiv.style.width = "100%";
            map3DDiv.id = this.id + "_map3D";
            this.div.appendChild(map3DDiv);
            this.map3D = new Geo.View3D.Map(map3DDiv, options);
        }
        return true;
    },
	
	/**
     * APIMethod: initMapFlash
     * 初始化三维地图对象。
     * 
     * Parameters:
     * options - {Object} 地图对象相关选项设置。
     * 
     * Returns
     * {Boolean} true为初始化成功。
     */
    initMapFlash: function(options){
        if (!this.mapFlash) {
            var mapFlashDiv = document.createElement("div");
            mapFlashDiv.style.height = "100%";
            mapFlashDiv.style.width = "100%";
            mapFlashDiv.id = this.id + "_mapFlash";
            this.div.appendChild(mapFlashDiv);
            this.mapFlash = new Geo.ViewFl.Map(mapFlashDiv, options);
        }
        return true;
    },
	
	//初始化布局
	initLayout:function(){
		
	},
	
    /**
     * APIMethod: switchView
     * 切换视图。
     * 
     * Parameters:
     * view - 要切换到的视图。
     */
	switchView: function(view){
        if (view == this.currentView) {
            return;
        }
        
        //未指视图或视图名字未找到，则切换到下一视图
        if (!view || !this.viewList[view]) {
            view = this.getNextView(this.currentView);
        };
		
		//如果将切换的视图未初始化，则初始化
        if (!this.viewList[view].mapObj) {
            this.viewList[view].initFn();
        };
        var currMapObj = this.viewList[this.currentView].getMapObj();
        currMapObj.div.style.display = "none";
        var mapObj = this.viewList[view].getMapObj();
		//设置三维组件线程启用
		if(view == "3D"){
			mapObj.activexObj.Suspend = false;
		}else {
			//设置三维组件线程关闭
			currMapObj.activexObj.Suspend = true;
		}
        mapObj.div.style.display = "";
        this.syncView();
        this.currentView = view;
        this.events.triggerEvent("viewswitch", {
            view: view
        });
    },
	
     /**
     * APIMethod: zoomIn
     * 视图放大。
     */
	zoomIn: function(){
		var map = this.getCurrentMapObj();
		map.zoomIn();
	},
	
     /**
     * APIMethod: zoomOut
     * 视图缩小。
     */
	zoomOut: function(){
		var map = this.getCurrentMapObj();
		map.zoomOut();
	},
	
	/**
	 * APIMethod: setCenter
	 * 对视图进行中心定位，并放大到指定级别。
	 * 
	 * Parameters:
	 * center - {<Geo.LonLat>} 中心点的坐标。
	 * level - {Int}要放大的级别。
	 */
	setCenter: function(center, level){
		this.center = center;
		this.zoom = level;
		var map = this.getCurrentMapObj();
		map.setCenter(center, level);	
	},
	
   /**
    * APIMethod: addLayer
    * 添加图层。
    *
    * Parameters:
    * layer - {<OpenLayers.Layer>} 
    */	
	addLayer: function(layer){
		var map = this.getCurrentMapObj();
		map.addLayer(layer);
	},
	
	/**
	 * APIMethod: addLayers
	 * 添加多个图层。
	 * 
     * Parameters:
	 * layers - {Array(<OpenLayers.Layer>)} 
	 */
	addLayers: function(layers){
		if(!(Geo.Util.isArray(layers))){
			layers = [layers];
		}
		for(var i=0; i<layers.length; i++){
			this.addLayer(layers[i]);
		}
	},

	/**
	 * APIMethod: loadLayerGroup
	 * 加载图层组。
	 * 
     * Parameters:
	 * layerGroup - {<Geo.View2D.LayerGroup>|Geo.View3D.LayerGroup} 
	 */
	loadLayerGroup:function(layerGroup){
		var map = this.getCurrentMapObj();
		map.loadLayerGroup(layerGroup);
	},

	/**
	 * APIMethod: unloadLayerGroup
	 * 卸载图层组。
	 */
	unloadLayerGroup: function(){
        var map = this.getCurrentMapObj();
		map.unloadLayerGroup();
    },
    	
	/**
	 * APIMethod: getCurrentMapObj
	 * 获取当前地图对象。
	 * 
	 * Return:
	 * {<Geo.View2D.Map>|<Geo.View3D.Map>} 当前地图对象的引用。
	 */
	getCurrentMapObj:function(){
		var view = this.currentView;
		var list = this.viewList;
		
		var map = list[view].getMapObj();
		if(!map){
			return null;
		}
		return map;
	},
	
	/**
	 * APIMethod: syncView
	 * 同步视图。
	 */
	syncView: function(){
		var list = this.viewList;
		var currentView = this.currentView;
		var currentMap = list[currentView].getMapObj();
		
		
		for(var item in list){
			if(currentView == item){
				continue;
			}
			var targetMap = list[item].getMapObj();
			if(!targetMap){
				return;
			}
			var currentRes = currentMap.getResolution();
            var targetZoom = targetMap.getZoomForResolution(currentRes);
            var targetCenter = currentMap.getCenter();
            targetMap.setCenter(targetCenter, targetZoom);
		}
	},

    	
	/**
	 * APIMethod: getNextView
	 * 获取下一个视图名称,用于循环切换视图。
	 * 
	 * Parameters:
	 * view - 指定的视图。
	 * 
	 * Returns:
	 * {Object} 当前视图。
	 */	
	getNextView:function(view){

		var firstView = null;
		var nextView = null;
		var isFisrt = true;
		var isNext = false;
		for(var item in this.viewList){
			if(isFisrt){
				firstView = item;
				isFisrt = false;
			}

			if (isNext){
				nextView = item;
				break;
			}
			
			if(item === view){
				isNext = true;
				continue;
			}
		}
		//如果下一视图为空,说明两种情况一是没有指定视图,
		//二是指定视图为最后一个视图,均返回第一个视图.
		if(!nextView){
			return firstView;
		}
		return nextView;
	},
	
    CLASS_NAME: "Geo.CombineView"
});

/**
 * Class: Geo.LayerManager
 * 图层管理器类，提供同时对二维、三维视图的图层操作相关功能,包括图层的添加，删除，图层的透明度设置，上移下移，定位等功能。
 */
Geo.LayerManager = Geo.Class({

    /**
     * APIProperty: map
     * {<Geo.View2D.Map>|<Geo.View3D.Map>|<Geo.CombineView>}关联的地图对象。 
     */
	map:null,
	
    /**
     * APIProperty: autoUpdateList
     * {Boolean} 是否自动触发更新图层列表方法updateLayerList，默认为"true"。 
     */
	autoUpdateList: true,
	
    /**
     * APIProperty: isAllLayers
     * {Boolean} 是否管理全部图层，默认为否，在使用getLayers方法获取地图对象所有图层时，
     * 图层属性displayInLayerSwitcher为false的图层对象将不在返回值的数组中。 
     */
	isAllLayers: false,
	
	 /**
     * APIProperty: template
     * {Object} 图层列表模板，json格式，是否自动触发更新图层列表方法updateLayerList，默认为"true"。 
     */
	template: {
		//外部容器
		wrapper: "<ul>${layerItemTemplate}</ul>",
		
		//图层列表表现模板
		item: "<li><input type='checkbox' ${visibility} " + 
			  "onchange='lm.toggleLayerVisibility(${layerid})' />${layerName}</li>" +
			  "",
	
		//无图层提示
		noLayer: "<li>当前没有图层</li>"
	},
	
	
    /**
     * APIProperty: ascending
     * 图层排列顺序。默认为“true”，表示按升序排序；当取值为“false”表示按降序排列。 
     */
	ascending: true,
	
	/**
	 * Constructor: Geo.LayerManager
	 * 构造方法。
	 * 
	 * Parameters:
	 * options - {Object} 可选的实例属性设置对象。
	 */
	initialize:function(options){
		OpenLayers.Util.extend(this,options);
	},
	
	/**
	 * Method: setMap
	 * 关联地图对象。
	 * 
	 * Parameters:
	 * map - {<Geo.View2D.Map>|<Geo.View3D.Map>|<Geo.CombineView>} 要关联的地图对象。
	 */
	setMap:function(map){
		this.map = map;
		this._updateLayerList();
	},

	/**
	 * APIMethod: getCurrentMapObj
	 * 获取当前地图对象。
	 * 
	 * Return:
	 * map - {<Geo.View2D.Map>|<Geo.View3D.Map>|<Geo.CombineView>} 要关联的地图对象。
	 */	
	getCurrentMapObj:function(){
		var map = this.map;
		if(map.CLASS_NAME == "Geo.CombineView"){
			map = map.getCurrentMapObj();
		}
		return map;
	},

	/**
	 * APIMethod: updateLayerList
	 * 更新图层列表回调函数，可以由用户自定义覆盖。
	 * 
	 * layers - {Array(<Openlayers.Layer>|<Geo.View3D.Layer>)} 当前地图中加载的图层对象。
	 */		
	updateLayerList:function(layers){
	},
	
	//获取当前地图中的图层对象，调用更新图层方法。
	_updateLayerList: function(){
		var layers = this.getLayers();
		if (this.map && this.autoUpdateList) {
			this.updateLayerList(layers);
		}
	},
	
	/**
	 * APIMethod: getLayers
	 * 获取当前地图对象中所有加载的图层。如果isAllLayers属性设置false，
	 * 则只获取那些图层属性displayInLayerSwitcher为false图层。
	 * 
	 * Return:
	 * {Array(<Openlayers.Layer>|<Geo.View3D.Layer>)} 图层数组。
	 */
	getLayers:function(){
		var layers = [];
		var map = this.getCurrentMapObj();
		
		//不存在地图,返回空图层数组
		if(!map){
			return layers;
		}
		
		//如果未设置全部图层,则只获在图层管理器里显示的图层
		var allLayers = map.layers;
		if(!this.isAllLayers){			
			for(var i = 0; i<allLayers.length; i++){
				var layer = allLayers[i];
				if(layer.displayInLayerSwitcher){
					layers.push(layer);
				}
			}			
		}
		if (!this.ascending) { layers.reverse(); }
		return layers;
	},
	
	/**
	 * APIMethod: setOpacity
	 * 设置图层透明度。
	 * 
	 * Parameters:
	 * layerid - 图层的标识。
	 * opacity - {Float} 透明度值。
	 */
	setOpacity: function(layerid, opacity){
		var map = this.getCurrentMapObj();
        var layer = map.getLayer(layerid);
        if (layer) {
            layer.setOpacity(opacity);
        }
		this._updateLayerList();
    },
	
	/**
	 * APIMethod: raisLayer
	 * 上移,下移图层。通过指定增量值更改指定图层的索引。当指定增量值为正时图层上移，当指定增量值为负时图层下移。
	 * 
	 * Parameters:
	 * layerid - 指定图层的标识。
	 * delta - 指定的增量值，决定图层的移动方式。
	 */
	raisLayer: function(layerid, delta){
		var map = this.getCurrentMapObj();
        var layer = map.getLayer(layerid);
        if (layer) {
            map.raiseLayer(layer, delta);
        }
		this._updateLayerList();
    },
	
	/**
	 * APIMethod: raisLayerToTop
	 * 将指定图层移动到顶层。
	 * 
	 * Parameters:
	 * layerid - 指定图层的标识。
	 */
	raisLayerToTop:function(layerid){
		var map = this.getCurrentMapObj();
		var layer = map.getLayer(layerid);
        if (layer) {
            var layers = map.layers;
			var index = OpenLayers.Util.indexOf(layers,layer);
			var delta = layers.length - index;
			this.raisLayer(layerid,delta);
        }
	},
	
	/**
	 * APIMethod: raisLayerToBottom
	 * 将指定图层移动到底层。
	 * 
	 * Parameters:
	 * layerid - 指定图层的标识。
	 */
	raisLayerToBottom: function(layerid){
		var map = this.getCurrentMapObj();
		var layer = map.getLayer(layerid);
        if (layer) {
			var layers = map.layers;
			var index = OpenLayers.Util.indexOf(layers,layer);
			var delta = 0 - index;
			this.raisLayer(layerid,delta)
        }
	},
	
	/**
	 * APIMethod: toggleLayerVisibility
	 * 切换图层可视性。
	 * 
	 * Parameters:
	 * layerid - 指定图层的标识。
	 * isUpdateLayerList - 是否自动更新图层列表。
	 */
	toggleLayerVisibility: function(layerid, isUpdateLayerList){
		var map = this.getCurrentMapObj();
        var layer = map.getLayer(layerid);
        layer.setVisibility(!layer.getVisibility());
//		this._updateLayerList();
    },
	
	/**
	 * APIMethod: gotoLayer
	 * 将地图视图定位到指定图层。
	 * 
	 * Parameters:
	 * layerid - 指定图层的标识。
	 */
	gotoLayer: function(layerid){
		var map = this.getCurrentMapObj();
        var layer = map.getLayer(layerid);
        if(layer.gotoCenter){
            layer.gotoCenter();
            return;
        }
        var extent, zoom;
		if(layer instanceof Geo.View2D.Layer.WMTS) {
			extent = layer.tileFullExtent;
		}else if(layer instanceof OpenLayers.Layer.Vector) {
			extent = layer.getDataExtent();
			extent = extent ? extent : (layer.maxExtent ? layer.maxExtent : map.maxExtent);
			map.zoomToExtent(extent);
			return;
		}else if(layer instanceof Geo.View2D.Layer.WMS) {
			extent = layer.maxExtent ? layer.maxExtent : map.maxExtent;
			map.zoomToExtent(extent);
			return;
		}else if(layer instanceof Geo.View2D.Layer.DynamicMapService) {
			extent = layer.maxExtent ? layer.maxExtent : map.maxExtent;
			map.zoomToExtent(extent);
			return;
		}else if(layer instanceof Geo.View2D.Layer.TileMapService) {
			extent = layer.maxExtent ? layer.maxExtent : map.maxExtent;
			map.zoomToExtent(extent);
			return;
		}else{
			extent = layer.maxExtent ? layer.maxExtent : map.maxExtent;
		}
        //判断当前地图是否是flex，如果是flex，从layer中获取extent和maxRes的值。
        var maxRes
        var currentView = this.getCurrentMapObj().CLASS_NAME;
		if(currentView == "Geo.ViewFl.Map"){
			extent = layer.maxExtent ? layer.maxExtent : layer.getExtent();
			maxRes = layer.getResolution();
		}else {
        	maxRes = layer.maxResolution ? layer.maxResolution : map.maxResolution;
		}
        zoom = map.getZoomForResolution(maxRes,true);
        map.setCenter(extent.getCenterLonLat(), zoom);
    },
	
	/**
	 * APIMethod: removeLayer
	 * 移除指定的图层。
	 * 
	 * Parameters:
	 * layerid - 指定图层的标识。
	 * isUpdateLayerList - 是否自动更新图层列表。
	 */
	removeLayer:function(layerid, isUpdateLayerList){
		var map = this.getCurrentMapObj();
        var layer = map.getLayer(layerid);
        if (layer) {
            map.removeLayer(layer);
        }
		this._updateLayerList();
	},
	
	/**
	 * APIMethod: addLayer
	 * 加载图层。
	 * 
	 * Parameters:
	 * type - {String} 图层类型。
	 * allOptions - 属性设置项对象。
	 * 
	 * Returns:
	 * {Boolean} 添加成功返回true，反之返回false。
	 */
	addLayer: function(type, allOptions){
		var map = this.getCurrentMapObj();
        var view = map.CLASS_NAME;
		type = type.toUpperCase();
		var layerObj = Geo.LayerManager.supportService[view][type];
		var layer = null;
		if(layerObj){
			layer = layerObj(allOptions);
			map.addOverLayer(layer);
			this._updateLayerList();
			return true;
		}
		return false;
	},
	
	CLASS_NAME: "Geo.LayerManager"
});

/**
 * APIProperty: Geo.LayerManager.supportService
 * {Object} Geo.LayerManager对图层类型的支持。
 */
Geo.LayerManager.supportService = {
    "Geo.View2D.Map": {
        "OGC_WMS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var params = allOptions.params;
            var options = allOptions.options;
            var isSeparate = allOptions.isSeparate;
            var layersStr = allOptions.params.layers
            
            //分开加载各个图层
            if (isSeparate) {
                var arrLayersStr = layersStr.split(",");
                var arrLayer = [];
                for (var i = 0, l = arrLayers.length; i < l; i++) {
                    OpenLayers.Util.extend(params, {
                        layers: arrLayers[i]
                    });
                    arrLayer.push(new OpenLayers.Layer.WMS(name, url, params, options));
                }
                return arrLayer;
            }
            
            return new OpenLayers.Layer.WMS(name, url, params, options);
        },
        "GEO_TILE": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View2D.Layer.GlobeTile(name, url, options);
        },
        "OGC_WMTS": function(allOptions){
            return new OpenLayers.Layer.WMTS(allOptions);
        },
		"GEO_CWMS": function(allOptions){
			var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View2D.Layer.CWMS(name, url, options);
        },
		"ARCGIS_REST": function(allOptions){
			var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View2D.Layer.ArcGIS93Rest(name, url, options);
        },
		"OGC_WFS": function(allOptions){
			var name = allOptions.name;
            var url = allOptions.url;
			var version = allOptions.version;
            var options = allOptions.options;
			
			
            var strategies = [];
            // 如果IsViewPort为true，则根据可视范围来查询
        //  if (options.isViewPort == "true") {
            	strategies.push(new OpenLayers.Strategy.BBOX());
       //   }
            
            // 如果有关键字，则在策略中加入一个过滤器。
            if (options.keyWord) {
                var filter = new Geo.Filter.Comparison({
                    type: Geo.Filter.Comparison.LIKE,//关系运算
                    property: options.featurePropertyName,//查询字段
                    value: "/*" + options.keyWord + "/*"// 值
                });
                var strategyFilter = new OpenLayers.Strategy.Filter({
                    filter: filter
                });
                strategies.push(strategyFilter);
            }
            var wfsLayer = new Geo.View2D.Layer.Vector(name, {
                //使用bbox查询策略
                strategies: strategies,
                //使用WFS协议方法
                protocol: new OpenLayers.Protocol.WFS({
                    maxFeatures: options.maxFeatures,//现在服务返回的结果数
                    geometryName: options.geometry,
                    url: url,
					version:version,
                    featureType: options.featureType//要素类型
                })
            });
            return wfsLayer;
        }
    },
    "Geo.View3D.Map": {
        "OGC_WMS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var params = allOptions.params;
            var options = allOptions.options;
            var isSeparate = allOptions.isSeparate;
            var layersStr = allOptions.params.layers
            
            //分开加载各个图层
            if (isSeparate) {
                var arrLayersStr = layersStr.split(",");
                var arrLayer = [];
                for (var i = 0, l = arrLayers.length; i < l; i++) {
                    OpenLayers.Util.extend(params, {
                        layers: arrLayers[i]
                    });
                    arrLayer.push(new Geo.View3D.Layer.WMS(name, url, params, options));
                }
                return arrLayer;
            }
            
            return new Geo.View3D.Layer.WMS(name, url, params, options);
        },
        "GEO_TILE": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View3D.Layer.GlobeTile(name, url, options);
        },
        "GEO_TERRAIN": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View3D.Layer.Terrain(name, url, options);
        },
        "GEO_MODEL": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View3D.Layer.Model(name, url, options);
        },
        "OGC_WMTS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions;
            return new Geo.View3D.Layer.WMTS(name, url, options);
        },
		"GEO_WTFS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View3D.Layer.WTFS(name, url, options);
        },
		"ARCGIS_REST": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View3D.Layer.ArcgisRest(name, url, options);
        },
		"OGC_WFS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.View3D.Layer.WFS(name, url, options);
        }
    },
    "Geo.ViewFl.Map": {
        "OGC_WMS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var params = allOptions.params;
            var options = allOptions.options;
            var isSeparate = allOptions.isSeparate;
            var layersStr = allOptions.params.layers
            
            //分开加载各个图层
            if (isSeparate) {
                var arrLayersStr = layersStr.split(",");
                var arrLayer = [];
                for (var i = 0, l = arrLayers.length; i < l; i++) {
                    OpenLayers.Util.extend(params, {
                        layers: arrLayers[i]
                    });
                    arrLayer.push(new Geo.ViewFl.Layer.WMS(name, url, params, options));
                }
                return arrLayer;
            }
            
            return new Geo.ViewFl.Layer.WMS(name, url, params, options);
        },
        "GEO_TILE": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions.options;
            return new Geo.ViewFl.Layer.GlobeTile(name, url, options);
        },
        "OGC_WMTS": function(allOptions){
            var name = allOptions.name;
            var url = allOptions.url;
            var options = allOptions;
            return new Geo.ViewFl.Layer.WMTS(name, url, options);
        }
    }
};
/**
 * Class: Geo.Analysis.BufferAnalysis
 * 缓冲区分析类。
 */
Geo.Analysis.BufferAnalysis = Geo.Class({

	/**
     * APIProperty: url
     * {String} 缓冲分析操作所需要的WPS服务地址。
     */	
	url: null,

	/**
     * APIProperty: type
     * {Integer} 缓冲区的端点类型，默认值为Geo.Analysis.BufferAnalysis.CAP_ROUND。
     * 可以为Geo.Analysis.BufferAnalysis.CAP_ROUND、Geo.Analysis.BufferAnalysis.CAP_BUTT、
     * Geo.Analysis.BufferAnalysis.CAP_SQUARE三者之一。
     */
	type: 1,
	
	/**
     * APIProperty: accuracy
     * {Integer} 缓冲的拟合精度。默认值为32。
     */
	accuracy: 32,

	/**
	 * Constructor: Geo.Analysis.BufferAnalysis
	 * Geo.Analysis.BufferAnalysis类构造函数。
	 *
	 * Parameters:
	 * url - {String} WPS服务地址。
	 * options - {Object} 相关属性的设置项，可选。
	 */	
	initialize: function(url,options){
		this.url = url;
		OpenLayers.Util.extend(this, options);
	},
	
    
    /**
     * 构造查询字串。将要缓冲的要素和缓冲半径来构造用于Post查询的字符串。
     * 参数:
     * features - 要执行缓冲分析的要素。
     * distance - 缓冲半径。
     */
	_buildPostXML: function(features,distance){
				
		var gmlParser = new OpenLayers.Format.GML();
        var geoStr = gmlParser.write(features);
		var xmlstr = 
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + 
			    '<wps:Execute service="WPS" version="1.0.0" xmlns:gml="http://www.opengis.net/gml" xmlns:wps="http://www.opengis.net/wps/1.0.0" xmlns:ows="http://www.opengis.net/ows/1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 ../wpsExecute_request.xsd">' + 
			    '<ows:Identifier>Buffer</ows:Identifier>' +
			    '<wps:DataInputs><wps:Input><ows:Identifier>InputPolygon</ows:Identifier><wps:Data><wps:ComplexData schema="http://foo.bar/MyComplexValueSchema.xsd" mimeType="text/xml" encoding="UTF-8">' + 
			    geoStr + '</wps:ComplexData></wps:Data></wps:Input>' + 
			'<wps:Input><ows:Identifier>BufferDistance</ows:Identifier><wps:Data><wps:LiteralData>' + distance + '</wps:LiteralData></wps:Data>' + 
			'</wps:Input><wps:Input><ows:Identifier>BufferType</ows:Identifier><wps:Data><wps:LiteralData>' + this.type + '</wps:LiteralData></wps:Data></wps:Input><wps:Input><ows:Identifier>BufferAccuracy</ows:Identifier><wps:Data><wps:LiteralData>' + this.accuracy + '</wps:LiteralData></wps:Data></wps:Input></wps:DataInputs><wps:ResponseForm><wps:RawDataOutput><ows:Identifier>BufferedPolygon</ows:Identifier></wps:RawDataOutput></wps:ResponseForm></wps:Execute>';
        return xmlstr;
	},

    /**
     * 获取所有要素范围之合的中心点。
     * 
     * 参数:
     * features - 要执行缓冲分析的要素。
     * 
     * 返回值:
     * {<Geo.LonLat>} 中心点的坐标。
     */
	_getFeaturesCenter: function(features){		
		var bounds = this._getFeaturesExtent(features);
		return bounds.getCenterLonLat();
	},
	
	/**
	 * 获取要素数组范围之合。
	 *
	 * 参数:
	 * features - 要查看的要素数组。
	 * 
	 * 返回值:
	 * {<Geo.Bounds>} 要素数组的总的范围。
	 */
	_getFeaturesExtent: function (features) {
        if(!(Geo.Util.isArray(features))){
			features = [features];
		}
        var maxExtent = null;
        if(features && (features.length > 0)) {
            maxExtent = new Geo.Bounds();
            var geometry = null;
            for(var i=0, len=features.length; i<len; i++) {
                geometry = features[i].geometry;
                if (geometry) {
                    maxExtent.extend(geometry.getBounds());
                }
            }
        }
        return maxExtent;
    },
	
	
	/**
	 * APIMethod: startAnalysis
	 * 开始执行分析，如果服务端正确返回结果会触发successFn回调函数。
	 *
	 * Parameters:
	 * feature - {<Geo.Feature.Vector>}要分析的要素。
	 * distance - {Integer}缓冲半径。
	 * unit - {String} 长度计量单位。取值"m","km","degree"，可选，默认值为"m"。
	 * 
	 * Example:
	 * (code)
	 * //绘制一个被缓冲的中心点
     * var geometry = new Geo.Geometry.Point(110, 35);
     * var feature = new Geo.Feature.Vector(geometry);
     * 
	 * //设置缓冲距离500米
     * var distance = 500;
     * 
     * //缓冲单位
     * var unit = "m";
     * 
     * //开始缓冲分析
     * ba.startAnalysis(feature, distance, unit);
     * (end)
	 */
	startAnalysis: function(feature,distance,unit){
		var unitList = ["m","km","degree"];
		
		var lonlat = this._getFeaturesCenter(feature);
		
		//距离单位默认为米
		if(!unit || (OpenLayers.Util.indexOf(unitList,unit) == -1)){
			unit = "m";
		}
		
		switch(unit){
			case "km":
				distance = 1000 * distance;
			case "m":
				distance = this._meterToDegree(distance,lonlat);				
		}
		var postStr = this._buildPostXML(feature,distance);
		var xhr = new OpenLayers.Request.POST({
			url: this.url,
			data: postStr,
			scope: this,
			success:function(result){
				if("" == result.responseText || null == result.responseText){
					this.failFn();
					return;
				}
                var feature = this._parserResult(result);
                this.successFn(feature);
            },
			failure:this.failFn
			
		});
	},
	
	/**
	 * 根据地理坐标位置，将米转换成经纬度。
	 *
	 * 参数:
	 * meter - 要转换的地理坐标。
	 * lonlat - 经纬度。
	 */
	_meterToDegree: function(meter,lonlat){
		var a = 0.00000899; //赤道上的距离1公里=0.000008993220293度
		var templat = lonlat.lat;
		return meter * ( a / Math.cos(OpenLayers.Util.rad(templat)) );
	},
	
	/**
	 * APIMethod: successFn
	 * 缓冲分析操作成功的回调函数，由用户使用自己定义的方法替代。
	 *
	 * Parameters:
	 * features - {Array(<Geo.Feature.Vector>)} 结果要素数组。
	 */	
	successFn:function(features){
	},

	/**
	 * APIMethod: failFn
	 * 缓冲分析操作失败回调函数，默认提示"缓冲分析操作失败，请检测服务是否正常运行。"，
	 * 用户可以使用自定义方法覆写。
	 */		
	failFn:function(){
		alert("缓冲分析操作失败，请检测服务是否正常运行。");
	},
	
    /**
     * 解析缓冲分析操作返回结果
     */
	_parserResult: function(result){
		var feature = null;
		var xmlParser = new OpenLayers.Format.XML();
		if(!result.responseXML){
			result.responseXML = xmlParser.read(result.responseText);
		}
		var gmlParser = new OpenLayers.Format.GML();		
			feature = gmlParser.read(result.responseXML);
		return feature;
	},

	CLASS_NAME: "Geo.Analysis.BufferAnalysis"
});

/**
 * Constant: Geo.Analysis.BufferAnalysis.CAP_ROUND
 * {Integer} 圆形缓冲区端点。
 */
Geo.Analysis.BufferAnalysis.CAP_ROUND = 1;

/**
 * Constant: Geo.Analysis.BufferAnalysis.CAP_ROUND
 * {Integer} 平角缓冲区端点。
 */
Geo.Analysis.BufferAnalysis.CAP_BUTT = 2;


/**
 * Constant: Geo.Analysis.BufferAnalysis.CAP_ROUND
 * {Integer} 矩形缓冲区端点。
 */
Geo.Analysis.BufferAnalysis.CAP_SQUARE = 3;/**
 * Class: Geo.Analysis.SuperposeAnalysis
 * 叠置分析类。
 */
Geo.Analysis.SuperposeAnalysis = Geo.Class({
	
	/**
     * APIProperty: url
     * {String} 叠置分析操作所需要的WPS服务地址。
     */	
	url: null,
	
	/**
     * APIProperty: type
     * {String} 叠置分析操作类型。
     */	
	type:"Intersection",

    //请求串模板
	_requestStringTemplate:
		'<wps:Execute service="WPS" version="1.0.0" xmlns:gml="http://www.opengis.net/gml" xmlns:wps="http://www.opengis.net/wps/1.0.0" xmlns:ows="http://www.opengis.net/ows/1.1" xmlns:wfs="http://www.opengis.net/wfs" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 ../wpsExecute_request.xsd">'+
			'<ows:Identifier>${type}</ows:Identifier>'+
			'<wps:DataInputs>'+
				'<wps:Input>'+
					'<ows:Identifier>InputPolygon</ows:Identifier>'+
					'<wps:Data>'+
						'<wps:ComplexData schema="http://foo.bar/MyComplexValueSchema.xsd" mimeType="text/xml" encoding="UTF-8">'+
							'${dataInputs}'+
						'</wps:ComplexData>'+
					'</wps:Data>'+
				'</wps:Input>'+
			'</wps:DataInputs>'+
			'<wps:ResponseForm>'+
				'<wps:RawDataOutput>'+
					'<ows:Identifier>BufferedPolygon</ows:Identifier>'+
				'</wps:RawDataOutput>'+
			'</wps:ResponseForm>'+
		'</wps:Execute>',

	/**
     * APIProperty: sourceFeatures
     * {Array(<Geo.Feature.Vector>)}  叠置分析操作指定的源要素。
     */	
	sourceFeatures: null,

	/**
     * APIProperty: targetFeatures
     * {Array(<Geo.Feature.Vector>)}  叠置分析操作指定的目标要素。
     */	
	targetFeatures: null,
	
    /**
     * Constructor: Geo.Analysis.SuperposeAnalysis
     * Geo.Analysis.SuperposeAnalysis类构造函数。
     *
     * Parameters:
     * url - {String} WPS服务地址
     * options - {Object} 相关属性的设置项，可选
     */
	initialize: function(url,options){
		this.url = url;
		this.sourceFeatures = [];
		this.targetFeatures = [];
		OpenLayers.Util.extend(this, options);
	},
	
	//构造查询字串
	_buildRequestString: function(){
		var gmlParser = new OpenLayers.Format.GML();
        var sourceStr = gmlParser.write(this.sourceFeatures);
		var targetStr = gmlParser.write(this.targetFeatures);
		
		var string = OpenLayers.String.format(this._requestStringTemplate,{
            type: this.type,
			dataInputs: sourceStr + targetStr
		});
        return string;
	},
	
	/**
	 * APIMethod: startAnalysis
	 * 开始执行分析，如果服务端正确返回结果会触发successFn回调函数。
	 *
	 */
	startAnalysis: function(){
		
		//查询前做设置方面检查
		if(this._checkSet()){
			return false;
		}
		
		//发送分析请求
		var postStr = this._buildRequestString();
		var xhr = new OpenLayers.Request.POST({
			url: this.url,
			data: postStr,
			scope: this,
			success:function(result){
				if("" == result.responseText || null == result.responseText){
					this.failFn();
					return;
				}
                var features = this._parserResult(result);
                this.successFn(features);
            },
			failure:this.failFn
			
		});
	},
	
	//检查相关参数设置
	_checkSet: function(){
		if(!this.url){
			return false;
		}
		if(!this.sourceFeatures || !this.sourceFeatures.length){
			return false;
		}
		if(!this.targetFeatures || !this.targetFeatures.length){
			return false;
		}
	},
	
	/**
	 * APIMethod: successFn
	 * 分析操作成功的回调函数
	 *
	 * Parameters:
	 * features - {Array(<Geo.Feature.Vector>)} 结果要素数组
	 */	
	successFn:function(features){
		
	},

	/**
	 * APIMethod: failFn
	 * 叠置分析操作失败回调函数，默认提示"叠置分析操作失败，请检测服务是否正常运行。"，
	 * 用户可以使用自定义方法替代。
	 */		
	failFn:function(){
		alert("叠置分析操作失败，请检测服务是否正常运行。");
	},
	
	//解析结果
	_parserResult: function(result){
		var feature = [];
		var xmlParser = new OpenLayers.Format.XML();
		if(!result.responseXML){
			result.responseXML = xmlParser.read(result.responseText);
		}
		var gmlPrefix = "gml";
		var gmlUri = xmlParser.lookupNamespaceURI(result.responseXML, gmlPrefix);
		var featureCollection = xmlParser.getElementsByTagNameNS(result.responseXML, gmlUri, "FeatureCollection");
		if(featureCollection.length > 0){
			var gmlstr = xmlParser.write(featureCollection[0]);
			var gmlParser = new OpenLayers.Format.GML();		
			feature = gmlParser.read(gmlstr);
		}
		return feature;
	},				

	CLASS_NAME:"Geo.Analysis.SuperposeAnalysis"
	
});/**
 * Class: Geo.Query.WFSQuery
 * WFS地图要素服务查询类。本类也适用于聚合网络要素服务（Aggregation Web Feature Service简称AWFS）和地名地址要素服务（Web Feature Service Gazetteer简称WFS-G）的查询。
 */
Geo.Query.WFSQuery = Geo.Class({
	
    /**
     * APIProperty: url
     * {String} WFS服务地址。
     */
	url: null,
	
	/**
     * APIProperty: version
     * {String} WFS服务版本
     */
	version: "1.0.0",

    /**
     * APIProperty: featureNS
     * {String} 要素命名空间
     */
    featureNS: null,
	
	/**
	 * APIProperty: isReverse
	 * {Boolean} 是否对请求结果中的几何信息进行轴序反转，默认值为false,
	 * 当取值为false时，对请求结果不做反转操作。
	 * 当取值为true时，对请求结果做反转操作。
	 */
	isReverse: false,
	
	/**
	 * APIProperty: featurePrefix
	 * {String} 要素类型前缀，默认值""
	 */
	featurePrefix:"",
	
    /**
     * APIProperty: featureType
     * {String} 要素类型。
     */	
	featureType: "",
	
    /**
     * APIProperty: maxFeatures
     * {Number} 最大结果数。
     */	
	maxFeatures: 10,
	
    /**
     * APIProperty: filter
     * {<Geo.Filter>} 查询条件。
     */
	filter: null,
    
    /**
     * APIProperty: geometryName
     * {String} 要素中geometry属性的名称，默认为"the_geom"。
     */
    geometryName: "the_geom",


    /**
     * APIProperty: protocol
     * {<Geo.Protocol>} WFS查询协议对象。
     */	
	protocol: null,

    /**
     * APIProperty: format
     * {<Geo.Format>} 用于对查询操作返回结果进行解析的格式解析器，默认为GML解析器。
     */
	format: null,
    
    /**
     * APIProperty: format
     * {<Geo.Format>} 格式解析器构造参数。
     */    
    formatOptions: null,
    
    /**
     * APIProperty: isSeparate
     * {Boolean} 设置是否将查询结果按图层名分类。
     */  
    isSeparate: false,
	
    /**
     * APIProperty: srsName
     * {String} 空间参考名。默认值为"EPSG:4326"。
     */
    srsName: "EPSG:4326",
	
    /**
     * APIProperty: time
     * {String} 可选的。版本时间，此参数只针对多时态矢量数据集。默认为查询最新版本时间。时间格式：2015-5-19 12:12:01
     */
	time: null,
	
    /**
     * APIProperty: userecent
     * {String} 可选的。是否追溯(取值范围：true或false，true为返回最近匹配，false则精确匹配，默认值为true)
     */
	userecent: true,
	
	/**
	 * APIProperty: sortBy
	 * {Array} 设置WFS查询结果的排序参数，该参数为一个数组对象。
     * > sortBy数组内对象所包含的属性:
     * > property - {String} 查询出的要素的某一属性的名称，根据该属性进行排序。
     * > order - {String} 设置正序("ASC")或倒序("DESC")。
     * 
	 * 说明：
	 * 1.wfsg和wfs服务都支持排序；如果wfsg服务中的Post请求串中没有sort节点，那么该服务就不进行排序了（此时用其他字段排序也不起作用了）。当服务在查询中
	 * 有sort节点的时候， 建议用户选择STANDARDNAME和sort字段之一进行排序。如果使用DoMainName作为查询关键字，也可以使用DoMainName进行作为排序字段。
	 * 
	 * 2.wfsg服务和wfs服务默认是以sort字段进行排序，sort字段的值是数字，如果用户以sort字段进行排序，那么sort字段的值（数字）越大，
	 * 在结果列表中越排在后面，相反，sort字段的值越小，则在结果列表中排在越前面，如果sort字段的值相同，则按照其在数据库中读出来的先后顺序排列，
	 * 如果sort字段没值，则排在结果的最后面。
	 * 
	 * 3.若是以STANDARDNAME作为排序字段，如果STANDARDNAME的值是中文，那么排序就是第一个汉字的拼音的首字母的先后顺序作为排序字段（如北京和安徽，
	 * 北京是b为拼音首字母，安徽是a为拼音首字母，那么就是安徽排在北京的前面），若值的第一个汉字拼音首字母相同，则是以第一个汉字拼音的第二个字
	 * 母的先后顺序排列；如果STANDARDNAME的值是英文，也一样，依次类推。
	 * 
	 * Examples:
	 * (code)
	 *		 wfsQueryObj.sortBy = [{
     *              property: "STANDARDNAME",
     *              order: "DESC"
     *          }]
	 * (end)
	 */
	sortBy: null,


	/**
	 * Constructor: Geo.Query.WFSQuery
	 * Geo.Query.WFSQuery类构造函数。
	 * 
	 * Parameters:
	 * url - {String} WFS服务地址。
	 * featureType - {String} 要素类型。
	 * options - {Object} 相关属性的设置项，可选。
	 */	
	initialize: function(url,featureType,options){
		this.url = url;
		this.featureType = featureType;
		var xy = null;
		if(options) {
			if(options.isReverse === true) {
				this.isReverse = options.isReverse;
				xy = !options.isReverse;
			}else if(options.isReverse === false) {
				this.isReverse = options.isReverse;
				//xy顺序即是不反转
				xy = !options.isReverse;
			}else {
				//默认不反转
				xy = !this.isReverse;
			}
			if(!options.format) {
				this.format = new OpenLayers.Format.GML({xy:xy});
			}else if(options.format instanceof OpenLayers.Format.GML.v2 ||options.format instanceof OpenLayers.Format.GML.v3) {
				options.format.setFeatureType_(featureType);
			}
		}
		OpenLayers.Util.extend(this, options);
	},

	/**
	 * APIMethod: query
	 * 开始查询。
	 * 
	 * Parameters:
	 * filter - {Geo.Filter} 过滤器。
	 * 说明：
	 * 1.当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，参数filter中的
	 * 所有几何参数都需要改为纬度，经度的顺序。举例说明：
	 * 以矩形范围为例：
	 * new Geo.Bounds(-180,-90,180,90);
	 * 在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该矩形范围应写成
	 * new Geo.Bounds(-90,-180,90,180);
	 * 
	 * successFn - {Function} 请求成功的回调函数。
	 * > 该回调函数会提供一个形参，该形参是一个数组，名为features。在地名查询2.0及其以上的版本中，features有一个属性叫trueNames，
	 * > 该属性用于存放纠错词信息。在地名查询2.0以下的版本中不提供trueNames属性。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
	 * Examplse:
	 * (code)
	 *  	//查询范围
	 *		var queryBBOX = new Geo.Bounds(-180,-90,180,90);
	 *		 //范围过滤
	 *		 var filter = new Geo.Filter.Spatial({
	 *           type: Geo.Filter.Spatial.BBOX,
	 *           property: this.geometryName,            
	 *		    value: queryBBOX
	 *       });
	 *		 wfsQueryObj.query(filter,successFn,failFn);
	 * (end)
	 */
	query: function(filter,successFn,failFn){
		this.protocol = new OpenLayers.Protocol.WFS({
			readFormat: this.format,
            formatOptions: this.formatOptions,
			propertyNames: this.propertyNames,
			maxFeatures: this.maxFeatures,
            featurePrefix:this.featurePrefix,
            featureNS: this.featureNS,
            url: this.url,
			version: this.version,
			geometryName : this.geometryName,
            featureType: this.featureType,
			time: this.time,//多时态，时间格式：2015-5-19 12:12:01
			userecent: this.userecent,//是否追溯
			srsName: this.srsName
        });
		
        //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
        var queryFilter = filter || this.filter;
        var querySuccessFn = successFn || this.successFn;
        var queryFailFn = failFn || this.failFn;
        
		var callback = OpenLayers.Function.bind(function(result){
				
			//显示查询失败信息
			if(!result.success()){
				queryFailFn();
				return;
			}

			var features = result.features
            
            //根据要求进行按图层名分捡要素
            if(this.isSeparate){
                features = this._separateFeatures(features);
            }
            //对于容错给予提示的节点
            var trueNames = this._read_trueName(result);
			trueNames ? (features.trueNames = trueNames) : features;
			querySuccessFn(features);
			
		},this);

		this.response = this.protocol.read({
			sortBy: this.sortBy,
			filter: queryFilter,
			callback: callback
		});
	},
    
	//读取容错提示节点
	_read_trueName: function(result) {
		var trueNames = [];
		if(result.priv && result.priv.responseText) {
			if(null == this.format){
				return null;
			}
			var trueNameDocs = this.format.getXMLDoc().getElementsByTagName("trueName");
			if (trueNameDocs == null || trueNameDocs.length == 0) {
                return null;
            }
			for(var i = 0; i < trueNameDocs.length; i++) {
				trueNames.push(trueNameDocs[i].text);
			}
			return trueNames;
		}
		return trueNames;
	},
	
	/**
	 * APIMethod: getBufferRegion
	 * 得到缓冲区域。
	 * 
	 * Parameters:
     * point - {<Geo.Feature.Vector>} 点要素。
     * distance - {Integer} 半径。
     * unit - {String} 缓冲单位。
     * 
	 * Returns:
     * {<Geo.Geometry.Polygon>} 几何多边形。
	 */
	getBufferRegion: function(point,distance,unit) {
		var lonlat = this._getFeaturesCenter(point);
		switch(unit){
			case "km":
				distance = 1000 * distance;
			case "m":
				distance = this._meterToDegree(distance,lonlat);				
		}
		return Geo.Geometry.Polygon.createRegularPolygon(point,distance,40,360); 
	},
	
    /**
     * Method: _getFeaturesCenter
     * 获取所有要素范围之合的中心点。
     * 
     * Parameters:
     * features - 要执行缓冲分析的要素。
     * 
     * Returns:
     * {<Geo.LonLat>} 中心点的坐标。
     */
	_getFeaturesCenter: function(features){		
		var bounds = this._getFeaturesExtent(features);
		return bounds.getCenterLonLat();
	},
	
	/**
	 * Method: _getFeaturesExtent
	 * 获取要素数组范围之合。
	 *
	 * Parameters:
	 * features - 要查看的要素数组
	 * 
	 * Returns:
	 * {<Geo.Bounds>} 要素数组的总的范围。
	 */
	_getFeaturesExtent: function (features) {
        if(!(Geo.Util.isArray(features))){
			features = [features];
		}
        var maxExtent = null;
        if(features && (features.length > 0)) {
            maxExtent = new Geo.Bounds();
            var geometry = null;
            for(var i=0, len=features.length; i<len; i++) {
                geometry = features[i].geometry;
                if (geometry) {
                    maxExtent.extend(geometry.getBounds());
                }
            }
        }
        return maxExtent;
    },
	
	/**
	 * Method: _meterToDegree
	 * 根据地理坐标位置，将米转换成经纬度。
	 *
	 * Parameters:
	 * meter - 要转换的地理坐标。
	 * lonlat - 经纬度。
	 */
	_meterToDegree: function(meter,lonlat){
		var a = 0.00000899; //赤道上的距离1公里=0.000008993220293度
		var templat = lonlat.lat;
		return meter * ( a / Math.cos(OpenLayers.Util.rad(templat)) );
	},
	
	/**
	 * APIMethod: pointQuery
	 * 点查询。
	 * 
	 * Parameters:
	 * point - {<Geo.Geometry.Point>} 点要素。
	 * 说明：当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，本查询的point参数需要设置为纬度，经度顺序。
     * 		举例说明：
     * 		以一个点要素为例：new Geo.Geometry.Point(112,20)。
     * 		在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该点要素应写成new Geo.Geometry.Point(20,112)
	 * distance - {Number} 缓冲半径。它是指指定线的距离范围。服务利用这个属性可以对线进行缓冲区分析得到一个面，再用面去进行查询。
 	 *		distance的取值范围：大于等于零。
	 * 		例如：如果距离是5，单位是米，那么服务内部会将这个线以5米为半径对其进行缓冲区分析得到成一个面，再使用面做查询。
	 * unit - {String} 单位  值为"m"或degree。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
	 * Examples:
	 * (code)
	 *   //距离
	 *	 var distance = 50000000;
	 *	 //单位
     *	 var unit = "m";
	 *   //点要素
	 *	 var queryPoint = new Geo.Geometry.Point(110.40056,39.93202);
	 *   wfsQueryObj.pointQuery(queryPoint,distance,unit,successFn,failFn);
	 * (end)
	 */
    pointQuery: function(point,distance,unit,successFn,failFn){
        distance = distance || 0;
        unit = unit || "degree";
        var filter = new OpenLayers.Filter.Spatial({
           type:Geo.Filter.Spatial.INTERSECTS, //OpenLayers.Filter.Spatial.DWITHIN
            property: this.geometryName, 
            distance: distance,
            distanceUnits: unit,
            value: point
        });
        this.query(filter,successFn,failFn);
    },
    
    /**
	 * APIMethod: pathQuery
	 * 线查询。
	 * 
	 * Parameters:
	 * path - {<Geo.Geometry.LineString>} 线要素。
	 * 说明：当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，本查询的path参数需要设置为纬度，经度顺序。
     * 		举例说明：
     * 		以一个线要素为例：new Geo.Geometry.LineString([new Geo.Geometry.Point(118,20),new Geo.Geometry.Point(118.8,20.8)])。
     * 		在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该线要素应写成
     * 		new Geo.Geometry.LineString([new Geo.Geometry.Point(20,118),new Geo.Geometry.Point(20.8,118.8)])。
	 * distance - {Number}缓冲半径。它是指指定线的距离范围。服务利用这个属性可以对线进行缓冲区分析得到一个面，再用面去进行查询。
 	 *		distance的取值范围：大于等于零。
	 * 		例如：如果距离是5，单位是米，那么服务内部会将这个线以5米为半径对其进行缓冲区分析得到成一个面，再使用面做查询。
	 * unit - {String} 单位  值为"m"或degree。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
     * Examples:
     * (code)
     *   //距离
	 *	 var distance = 50000000;
	 *	 //单位
     *	 var unit = "m";
     *   //线要素
	 *	 var queryPath = new Geo.Geometry.LineString([
     *         new Geo.Geometry.Point(110,35),
     *         new Geo.Geometry.Point(110,36)
     *    ]);
     * 	 wfsQueryObj.pathQuery(queryPath, distance, unit, successFn,failFn);
     * (end)
	 */
    pathQuery: function(path,distance,unit,successFn,failFn){
        distance = distance || 0;
        unit = unit || "degree";
        var filter = new OpenLayers.Filter.Spatial({
            type:OpenLayers.Filter.Spatial.DWITHIN,
            property: this.geometryName, 
            distance: distance,
            distanceUnits: unit,
            value: path
        });
        this.query(filter,successFn,failFn);
    },
    
    /**
	 * APIMethod: polygonQuery
	 * 面查询。
	 * 
	 * Parameters:
	 * polygon - {<Geo.Geometry.Polygon>} 面要素。
	 * 说明：当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，本查询的polygon参数需要设置为纬度，经度顺序。
     * 		举例说明：
     * 		以一个面要素为例：
     * 		new Geo.Geometry.Polygon([
     *   	 new Geo.Geometry.LinearRing([
     *       new Geo.Geometry.Point(177.76672363281,37.655639648436),
     *       new Geo.Geometry.Point(177.8884299300619,38.21858951787163),
     *       new Geo.Geometry.Point(177.8884299300619,38.21858951787163),
     *       new Geo.Geometry.Point(177.8884299300619,38.21858951787163)
     *       ])
     * 		在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该面要素应写成
     * 		new Geo.Geometry.Polygon([
     *   	 new Geo.Geometry.LinearRing([
     *       new Geo.Geometry.Point(37.655639648436,177.76672363281),
     *       new Geo.Geometry.Point(38.21858951787163,177.8884299300619),
     *       new Geo.Geometry.Point(38.21858951787163,177.8884299300619),
     *       new Geo.Geometry.Point(38.21858951787163,177.8884299300619)
     *       ])
	 * 
	 * isContain - {Boolean} 是包含还是相交。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
     * Examples:
     * (code)
     * 	 var isContain = false;
	 *	 var queryPolygon = new Geo.Geometry.Polygon([
     *   	 new Geo.Geometry.LinearRing([
     *       new Geo.Geometry.Point(77.76672363281,37.655639648436),
     *       new Geo.Geometry.Point(77.8884299300619,38.21858951787163),
     *       new Geo.Geometry.Point(77.8884299300619,38.21858951787163),
     *       new Geo.Geometry.Point(77.8884299300619,38.21858951787163)
     *       ])                
     *   ]);
     * 	 wfsQueryObj.polygonQuery(queryPolygon, isContain, successFn,failFn);
     * (end)
	 */
    polygonQuery: function(polygon,isContain,successFn,failFn){
        var filterType = isContain ? OpenLayers.Filter.Spatial.CONTAINS : 
                                     OpenLayers.Filter.Spatial.INTERSECTS;
        var filter = new OpenLayers.Filter.Spatial({
            type: filterType,
            property: this.geometryName, 
            value: polygon
        });
        this.query(filter,successFn,failFn);
    },
    
    /**
	 * APIMethod: bboxQuery
	 * 范围查询。
	 * 
	 * Parameters:
	 * bbox - {<Geo.Bounds>} 范围。
	 * 说明：
	 * 1.当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，参数filter中的
	 * 所有几何参数都需要改为纬度，经度的顺序。举例说明：
	 * 以矩形范围为例：
	 * new Geo.Bounds(-180,-90,180,90);
	 * 在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该矩形范围应写成
	 * new Geo.Bounds(-90,-180,90,180);
	 * 
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
	 * Examples:
	 * (code)
	 *   //查询范围
		 var queryBBOX = new Geo.Bounds(-180,-90,180,90);
	 * 	 wfsQueryObj.bboxQuery(queryBBOX, successFn,failFn);
	 * (end)
	 */
    bboxQuery: function(bbox,successFn,failFn){
        var filter = new Geo.Filter.Spatial({
            type: OpenLayers.Filter.Spatial.BBOX,
            property: this.geometryName,            
		    value: bbox
        });
        this.query(filter,successFn,failFn);
    },
    
	/**
	 * APIMethod: attributeQuery
	 * 属性查询。
	 * 
	 * Parameters:
	 * type - {String} 比较类型。
	 * property - {String} 属性名。
	 * value - {Number} or {String} 属性值。
	 * options - {Object} 可选参数。
	 *    lowerBoundary - {Number} or {String} 值小的边界。
	 *    upperBoundary - {Number} or {String} 值大的边界。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
     * Examples:
     * (code)
     *   var type = Geo.Filter.Comparison.LIKE;
	 *		var property = "label";
	 *		var value = "*";
	 *		wfsQueryObj.attributeQuery(type,property,value,{
	 *			matchCase : true
	 *	 },successFn,failFn);
     * (end)
	 * 
	 */
    attributeQuery: function(type, property, value, options, successFn,failFn){
        
        var matchCase = options && options.matchCase;
        var lowerBoundary = options ? options.lowerBoundary : null;
        var upperBoundary = options ? options.upperBoundary : null;
        
        var filter = new OpenLayers.Filter.Comparison({
            type: type,
            property: property,            
		    value: value,
            matchCase: matchCase,
            lowerBoundary: lowerBoundary,
            upperBoundary: upperBoundary
        });
        this.query(filter,successFn,failFn);
    },

    /**
     * APIProperty: successFn
     * 查询成功后的回调函数，用户可以自定义此方法。
	 *
	 * Parameters:
	 * features - {Array(<Geo.Feature.Vector>)} 结果要素数组。
     */
	successFn: function(features){
        
    },

    /**
     * APIMethod: failFn
     * WFS查询失败响应方法，默认提示"对不起,查询失败,请查询服务是否正常"，用户可以根据需要覆盖此方法。
     */    
    failFn: function(){
    	alert("对不起,查询失败,请查询服务是否正常。");
    },
    
    //私有,按图层类型分离要素
    _separateFeatures: function(features){
        var result = {};
        for(var i=0; i<features.length; i++){
            var f = features[i];
            var featureType;
            
            //如果是经GML2解析器则判断gml属性中的featureType，如果是GML3则判断type
            if (f.gml) {
                featureType = f.gml.featureType;
            }
            else {
                featureType = f.type;
            }
            
            if(!result[featureType]){
                result[featureType] = [];
            }
            result[featureType].push(f);
        }
        return result;
    },
	
    /**
     * APIProperty: setTime
     * 设置时间。时间格式：2015-5-19 12:12:01
	 *
	 * Parameters:
	 * time - {String} 结果要素数组。
     */
	setTime: function(time){
		this.time = time;
	},
	
    /**
     * APIProperty: setUserecent
     * 设置是否追溯。
	 *
	 * Parameters:
	 * userecent - {Boolean} 结果要素数组。
     */
	setUserecent: function(userecent){
		this.userecent = userecent;
	},
    	
	CLASS_NAME: "Geo.Query.WFSQuery"
});

Geo.Query.WFSQuery.reverseGeometryXY = function(geometry) {
	
	var geometryTypes = {
        "OpenLayers.Geometry.Point": "Point",
        "OpenLayers.Geometry.MultiPoint": "MultiPoint",
        "OpenLayers.Geometry.LineString": "LineString",
        "OpenLayers.Geometry.MultiLineString": "MultiLineString",
        "OpenLayers.Geometry.Polygon": "Polygon",
        "OpenLayers.Geometry.MultiPolygon": "MultiPolygon",
        "OpenLayers.Geometry.Collection": "GeometryCollection"
    };
	var types = {
		"Point": function(geometry,types) {
			var pointx = geometry.x;
			var pointy = geometry.y;
			var point = geometry.clone(geometry);
			point.x = pointy;
			point.y = pointx;
			return point;
		},
		"LineString": function(geometry,types) {
			var lineString = geometry.clone(geometry);
			for(var i = 0; i < lineString.components.length; i++) {
				var point = types["Point"](lineString.components[i]);
				lineString.components[i] = point;
			}
			return lineString;
		},
		"Polygon": function(geometry,types) {
			var polygon = geometry.clone(geometry);
			for(var i = 0; i < polygon.components.length; i++) {
				for(var j = 0; j <polygon.components[i].components.length - 1; j++) {
					var point = types["Point"](polygon.components[i].components[j]);
					polygon.components[i].components[j] = point;
				}
			}
			return polygon;
		}
	}
	var ageometry = types[geometryTypes[geometry.CLASS_NAME]](geometry,types);
	return ageometry;
};/*
 * ===================================================
 * WFS查询服务端分页所需类定义
 * ===================================================
 */
OpenLayers.Format.Filter.v1.prototype.writers["ogc"]["SortBy"] = function(sortProperties) {
	var node = this.createElementNSPlus("ogc:SortBy");
	for (var i=0,l=sortProperties.length;i<l;i++) {
	    this.writeNode(
	        "ogc:SortProperty",
	        sortProperties[i],
	        node
	    );
	}
	return node;
},
/*
 * ===================================================
 * 注意，以下是对Format/WFST/v1.js文件的修改
 * 增加：
 * resultType: options && options.resultType,
 * startPosition: options && options.startPosition,
 * ===================================================
 */

OpenLayers.Format.WFST.v1.prototype.writers.wfs.GetFeature = function(options) {
    var node = this.createElementNSPlus("wfs:GetFeature", {
        attributes: {
            service: "WFS",
            version: this.version,
            outputFormat: options && options.outputFormat,
            resultType: options && options.resultType,
            startPosition: options && options.startPosition,
            maxFeatures: options && options.maxFeatures,
            "xsi:schemaLocation": this.schemaLocationAttr(options)
        }
    });
    if (typeof this.featureType == "string") {
        this.writeNode("Query", options, node);
    } else {
        for (var i=0,len = this.featureType.length; i<len; i++) { 
            options.featureType = this.featureType[i]; 
            this.writeNode("Query", options, node); 
        } 
    }
    return node;
}
OpenLayers.Format.Filter.v1.prototype.writers["ogc"]["SortProperty"] = function(sortProperty) {
	var node = this.createElementNSPlus("ogc:SortProperty");
	this.writeNode(
	    "ogc:PropertyName",
	    sortProperty,
	    node
	);
	this.writeNode(
	    "ogc:SortOrder",
	    (sortProperty.order == 'DESC') ? 'DESC' : 'ASC',
	    node
	);
	return node;
},

OpenLayers.Format.Filter.v1.prototype.writers["ogc"]["SortOrder"] = function(value) {
    var node = this.createElementNSPlus("ogc:SortOrder", {
        value: value
    });
    return node;
},


//查询服务出错时给出错误提示
OpenLayers.Protocol.WFS.v1.prototype.parseResponse  = function(request, options) {
    var doc = request.responseXML;
        if(!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        if(!doc || doc.length <= 0) {
            return null;
        }
        var result=null;
        try{
        	result = (this.readFormat !== null) ? this.readFormat.read(doc) : 
            this.format.read(doc, options);
        }catch(e){
        	var error = "程序运行异常："+e.name + "，"+e.message;
        	alert(error);
//        	throw e;
        }
        if (!this.featureNS) {
            var format = this.readFormat || this.format;
            this.featureNS = format.featureNS;
            // no need to auto-configure again on subsequent reads
            format.autoConfig = false;
            if (!this.geometryName) {
                this.setGeometryName(format.geometryName);
            }
        }
        return result;
},

//OpenLayers.Format.WFST. v1_0_0/v1_1_0 .prototype.writers补丁包，添加时间版本和是否追溯的属性
OpenLayers.Format.WFST.v1_0_0.prototype.writers = OpenLayers.Format.WFST.v1_1_0.prototype.writers = {
    "wfs": OpenLayers.Util.applyDefaults({
        "Query": function(options) {
            options = OpenLayers.Util.extend({
                featureNS: this.featureNS,
                featurePrefix: this.featurePrefix,
                featureType: this.featureType,
                srsName: this.srsName,
                srsNameInQuery: this.srsNameInQuery
            }, options);
			
            var node = this.createElementNSPlus("wfs:Query", {
                attributes: {
	                typeName: (options.featureNS ? options.featurePrefix + ":" : "") +
	                    options.featureType,
					time: options && options.time, //可选的。版本时间，此参数只针对多时态矢量数据集。默认为查询最新版本时间
					userecent: options && options.userecent //可选的。是否追溯(取值范围：true或false，true为返回最近匹配，false则精确匹配，默认值为true)
	            }
            });
            if(options.srsNameInQuery && options.srsName) {
                node.setAttribute("srsName", options.srsName);
            }
            if(options.featureNS) {
                node.setAttribute("xmlns:" + options.featurePrefix, options.featureNS);
            }
            if(options.propertyNames) {
                for(var i=0,len = options.propertyNames.length; i<len; i++) {
                    this.writeNode(
                        "ogc:PropertyName", 
                        {property: options.propertyNames[i]},
                        node
                    );
                }
            }
            if(options.filter) {
                this.setFilterProperty(options.filter);
                this.writeNode("ogc:Filter", options.filter, node);
            }
            if (options.sortBy) {
                this.writeNode("ogc:SortBy", options.sortBy, node);
            }
            return node;
        }
    }, OpenLayers.Format.WFST.v1.prototype.writers["wfs"]),
    "gml": OpenLayers.Format.GML.v2.prototype.writers["gml"],
    "feature": OpenLayers.Format.GML.v2.prototype.writers["feature"],
    "ogc": OpenLayers.Format.Filter.v1_0_0.prototype.writers["ogc"]
},

Geo.Query.WFSQuery.prototype.sortBy =  null,

//增加featureType_属性，让gml解析器能解析多个图层的数据。
OpenLayers.Format.GML.Base.prototype.setFeatureType_ = function(featureType) {
	this.featureType_ = featureType;
}, 
//覆盖ol2.13的方法，ol提供的gml.v3和gmlv2解析器只支持解析一个图层的数据，但是实际应用场景中，会解析多个图层的数据。
//增加本方法的目的是让解析器同时能解析服务返回的多个图层的数据
OpenLayers.Format.GML.Base.prototype.readers["feature"]["*"] = function(node, obj) {
    // The node can either be named like the featureType, or it
    // can be a child of the feature:featureType.  Children can be
    // geometry or attributes.
    var name;
    var local = node.localName || node.nodeName.split(":").pop();
    // Since an attribute can have the same name as the feature type
    // we only want to read the node as a feature if the parent
    // node can have feature nodes as children.  In this case, the
    // obj.features property is set.
    if (obj.features) {
        if (!this.singleFeatureType &&
            (OpenLayers.Util.indexOf(this.featureType, local) !== -1)) {
            name = "_typeName";
        } else if(local === this.featureType) {
            name = "_typeName";
			//this.featureType_属性是补丁中新增的属性，目的是让解析器能解析多个图层的数据。
        }else if(OpenLayers.Util.isArray(this.featureType_)) {
			for(var i = 0; i < this.featureType_.length;i++) {
				if(this.featureType_[i] === local) {
					name = "_typeName";
					break;
				}
			}
		}
    } else {
        // Assume attribute elements have one child node and that the child
        // is a text node.  Otherwise assume it is a geometry node.
        if(node.childNodes.length == 0 ||
           (node.childNodes.length == 1 && node.firstChild.nodeType == 3)) {
            if(this.extractAttributes) {
                name = "_attribute";
            }
        } else {
            name = "_geometry";
        }
    }
    if(name) {
        this.readers.feature[name].apply(this, [node, obj]);
    }
},

OpenLayers.Format.WFSHits = OpenLayers.Class(OpenLayers.Format.XML,{

  wfsns: "http://www.opengis.net/wfs",

  featureCollection: "FeatureCollection",

  read:function(data){
    if(typeof data == "string") { 
        data = OpenLayers.Format.XML.prototype.read.apply(this, [data]);
    }
    var featureCollectionNodes = data.documentElement;
    var numberOfFeatures = parseInt(featureCollectionNodes.getAttribute("numberOfFeatures"));
    return {numberOfFeatures:numberOfFeatures}
  }
});


Geo.Query.WFSQuery.prototype.resultType = "Results";

Geo.Query.WFSQuery.prototype.startPosition = null;

//查询总数据的总条数
Geo.Query.WFSQuery.prototype.queryTotalNumber = function(filter,successFn,failFn){

        var hitsParser = new OpenLayers.Format.WFSHits();

		this.protocol = new OpenLayers.Protocol.WFS({
			readFormat: hitsParser,
			propertyNames: this.propertyNames,
            resultType: "hits",
			maxFeatures: this.maxFeatures,
            featurePrefix:this.featurePrefix,
            featureNS: this.featureNS,
            url: this.url,
			version: this.version,
			geometryName : this.geometryName,
            featureType: this.featureType,
			time: this.time,//多时态，时间格式：2015-5-19 12:12:01
			userecent: this.userecent//是否追溯
        });
		
        //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
        var queryFilter = filter || this.filter;
        var querySuccessFn = successFn || this.successFn;
        var queryFailFn = failFn || this.failFn;
        
		var callback = OpenLayers.Function.bind(function(result){
				
			//显示查询失败信息
			if(!result.success()){
				queryFailFn();
				return;
			}

			var hitsResult = result.features
            
			querySuccessFn(hitsResult);
			
		},this);

		this.response = this.protocol.read({
			filter: queryFilter,
			callback: callback
		});

};

/*
 * 查询当前页的内容
 */
Geo.Query.WFSQuery.prototype.queryPage = function(filter, successFn, failFn, options){
    var perPageNumber = (options && options.perPageNumber) || 15,
        pageNumber = (options && options.pageNumber) || 1;
    
    var startPosition = (pageNumber - 1) * perPageNumber + 1;
	this.protocol = new OpenLayers.Protocol.WFS({
		readFormat: this.format,
		multi:true,
        formatOptions: this.formatOptions,
		propertyNames: this.propertyNames,
        maxFeatures: perPageNumber,
        startPosition: startPosition,
        featurePrefix:this.featurePrefix,
        url: this.url,
        featureNS: this.featureNS,
		version: this.version,
		geometryName : this.geometryName,
        featureType: this.featureType,
		time: this.time,//多时态，时间格式：2015-5-19 12:12:01
		userecent: this.userecent,//是否追溯
		srsName:this.srsName
    });
	
    //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
    var queryFilter = filter || this.filter;
    var querySuccessFn = successFn || this.successFn;
    var queryFailFn = failFn || this.failFn;
    
	var callback = OpenLayers.Function.bind(function(result){
			
		//显示查询失败信息
		if(!result.success()){
			queryFailFn();
			return;
		}

		var features = result.features
        
        //根据要求进行按图层名分捡要素
        if(this.isSeparate){
            features = this._separateFeatures(features);
        }
        //对于容错给予提示的节点
        var trueNames = this._read_trueName(result);
		features.trueNames = trueNames;
		querySuccessFn(features);
		
	},this);
	this.response = this.protocol.read({
		sortBy:this.sortBy,
//		maxFeatures: this.maxFeatures,
		filter: queryFilter,
		callback: callback
	});
};

OpenLayers.Format.WFSCapabilities.v1_1_0.prototype.readers["wfs"]["TemporalFeatureLayer"] = OpenLayers.Format.WFSCapabilities.v1_0_0.prototype.readers["wfs"]["TemporalFeatureLayer"] = function(node, featureTypeList){
    featureTypeList.temporalFeatureLayers = [];
    var temporalFeatureLayer = {};
    this.readChildNodes(node, temporalFeatureLayer);
    featureTypeList.temporalFeatureLayers.push(temporalFeatureLayer);
};
OpenLayers.Format.WFSCapabilities.v1_1_0.prototype.readers["wfs"]["Extent"] = OpenLayers.Format.WFSCapabilities.v1_0_0.prototype.readers["wfs"]["Extent"] = function(node, obj) {
	//obj.time.name= node.getAttribute("name");
	obj.defaultTime = node.getAttribute("default");
	var timeArr = this.getChildValue(node).split("/");
	obj.time = timeArr;//timeArr.splice(0, timeArr.length -1);
};
//OpenLayers.Format.WFSCapabilities.v1_1_0.prototype.readers补丁包，添加wfs:Dimension方法解析时间版本
OpenLayers.Format.WFSCapabilities.v1_1_0.prototype.readers["wfs"]["Dimension"] = function(node, obj) {
	//obj.time.name= node.getAttribute("name");
	obj.defaultTime = node.getAttribute("default");
	var timeArr = this.getChildValue(node).split("/");
	obj.time = timeArr;//timeArr.splice(0, timeArr.length -1);
};
/**
 * Class: Geo.Query.CatalogQuery
 * CSW资源目录服务查询类。
 * 
 */
Geo.Query.CatalogQuery = Geo.Class({
	
	/**
     * APIProperty: url
     * {String} CSW服务地址。
     */
	url: null,
	
	/**
     * APIProperty: failFn
     * {Function} 请求失败的回调函数，可以用自定义函数覆盖。
     */
	failFn: function(){
		alert("对不起，查询请求失败！请检查资源目录服务是否正常运行。\n" + 
				"当前服务地址为：" + this.url);
	},
	
	/**
     * Constructor: Geo.Query.CatalogQuery
     * Geo.Query.CatalogQuery类的构造函数。
     *
     * Parameters:
     * url - {String} CSW服务地址。
     * options - {Object} 相关属性的设置项，可选。
     *
     */
	initialize: function(url, options){
		this.url = url;
		OpenLayers.Util.extend(this,options);
	},
	
	//soap格式请求串模板
	_soapTemplate: 
		'<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xsi:schemaLocation="http://www.opengis.net/ows" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">' +
		   '<soapenv:Body>' +
		      '${soapBody}' +
		   '</soapenv:Body>' +
		'</soapenv:Envelope>',
	
	//查询请求串模板
	_getRecordsTemplate: 
	     '<csw:GetRecords service="CSW" version="2.0.2" outputFormat="text/xml" ' + 
		 		'resultType="results" ${outputSchema} ' + 
				'xmlns:csw="http://www.opengis.net/cat/csw" xmlns:ogc="http://www.opengis.net/ogc" ' + 
				'${customNamespaces}> ' +
	         '<csw:Query typeNames="${typeNames}">' +
	            '<csw:ElementSetName>full</csw:ElementSetName>' +
	            '${constraint}' +
	         '</csw:Query>' +
	      '</csw:GetRecords>',
	
	//查询条件模板
	_constraintTemplate:
		'<csw:Constraint version="2.0.0">' +
		   '${filter}' +
		'</csw:Constraint>',
	
    /**
     * APIMethod: getResTreeNode
     * 读取资源目录树节点。
     * 
     * Parameters:
     * parentId - {String} 要读取的资源目录树节点父类ID号，默认值为0。
     * caller - {Object} 回调函数的作用域。。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     */
	getResTreeNode: function(parentId,caller,successFn,failFn){
		if(parentId){
			parentId = 0;
		}
		
		//请求相关设置
		var customNamespaces = 'xmlns:geoglobe="http://www.geostar.com.cn/geoglobe"';
		var outputSchema = 'outputSchema="geoglobe:ResourceType"';
		var typeNames = "geoglobe:ResourceType";
		
		//生成查询条件过滤器
		var kindFilter = new Geo.Filter.Comparison({
	        type: Geo.Filter.Comparison.EQUAL_TO,
	        property: "/geoglobe:ResourceType/geoglobe:kind",
	        value: "CATALOG"
	    });		
		var parentIdFilter = new Geo.Filter.Comparison({
	        type: Geo.Filter.Comparison.EQUAL_TO,
	        property: "/geoglobe:ResourceType/geoglobe:parentId",
	        value: parentId
	    });
		var constraintFilter = new Geo.Filter.Logical({
		    type: Geo.Filter.Logical.AND,
		    filters: [kindFilter,parentIdFilter]
		});
		var constraintString = this._makerFilterString(constraintFilter);
		
		//生成查询请求串
		var requestString = OpenLayers.String.format(this._getRecordsTemplate,{
			customNamespaces: customNamespaces,
			constraint: constraintString,
			outputSchema: outputSchema,
			typeNames: typeNames
		});
		
		requestString = this._wrapToSoapRequest(requestString);
		
		//发送查询请求
		if(!(failFn instanceof Function)){
			failFn = this.failFn;
		}
		
		var successHandler = OpenLayers.Function.bind(function(result){
			var result = this._getBodyFromSoapResponse(result.responseText);
			var successHandler = OpenLayers.Function.bind(successFn,this);
			successHandler(result);
		},this);
		
		var xhr = new OpenLayers.Ajax.Request(
			this.url, 
			{
				contentType:"application/xml", method:"post",
				postBody: requestString,
				onSuccess: successHandler,
				onFailure: failFn
			}
		);
	},
	
	//输入关键字等条件查询所需服务元数据，对queryMetaData方法的封装，方便使用
	searchServices: function(options,caller,successFn,failFn){
		
		
	},

    /**
     * APIMethod: queryMetaData
     * 查询服务元数据。
     * 
     * Parameters:
     * filter - {<Geo.Filter>} 查询条件，如果不指定（值为null）则返回所有服务元数据记录。
     * caller - {Object} 指定回调函数的作用域。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     */
	queryMetaData: function(filter,caller,successFn,failFn){
		
		//查询资源目录用到的XML名字空间
		var customNamespaces = ' xmlns:smmd="http://data.sbsm.gov.cn/smmd/2007"';
		var outputSchema= ' outputSchema="smmd:Metadata"';
		var typeNames = "smmd:Metadata";
		
		var constraintString = this._makerFilterString(filter);
		
		//生成查询请求串
		var requestString = OpenLayers.String.format(this._getRecordsTemplate,{
			customNamespaces: customNamespaces,
			constraint: constraintString,
			outputSchema: outputSchema,
			typeNames: typeNames
		});
		
		requestString = this._wrapToSoapRequest(requestString);
		
		//发送查询请求
		if(!(failFn instanceof Function)){
			failFn = this.failFn;
		}
		
		var successHandler = OpenLayers.Function.bind(function(result){
			var result = this._getBodyFromSoapResponse(result.responseText);
			var successHandler = OpenLayers.Function.bind(successFn,this);
			successHandler(result);
		},this);
		var xhr = new OpenLayers.Ajax.Request(
			this.url, 
			{
				contentType:"application/xml", method:"post",
				postBody: requestString,
				onSuccess: successHandler,
				onFailure: failFn
			}
		);
	},
	
	//加上SOAP请求包
	_wrapToSoapRequest:function(string){
		var requestString = OpenLayers.String.format(this._soapTemplate,{
			soapBody: string
		});
		return requestString;
	},
	
	//从SOAP响应结果中获取实际内容
	_getBodyFromSoapResponse:function(data){
		if(typeof data == "string") { 
            data = Geo.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
		
		//如果是SOAP响应，从中取出内容，如果不是直接返回内容。
		if(data.nodeName == "SOAP-ENV:Envelope"){
			return data.childNodes[0].childNodes[0];
		}
		return data;
	},
	
	//生成过滤器字符串
	_makerFilterString: function(filter){
		if(!filter){
			filter = new Geo.Filter.Comparison({
                type: Geo.Filter.Comparison.LIKE,
                property: "/smmd:Metadata/smmd:mdFileID",
                value: "*"
            });
		}
		var parser = new Geo.Format.Filter();
		var filterString = parser.write(filter).xml;
		constraintString = OpenLayers.String.format(this._constraintTemplate, {
			filter: filterString
		});
		return constraintString;
	},
	
	CLASS_NAME: "Geo.Query.CatalogQuery"
});

/**
 * 继承并修改自Geo.Format.CSWGetRecords.v2_0_2类，
 * 增加对CSW2.0.0以及国家资源目录标准的支持。
 */
Geo.Format.CSWGetRecords.v2_0_0 = Geo.Class(Geo.Format.CSWGetRecords.v2_0_2, {

    namespaces: {
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        csw: "http://www.opengis.net/cat/csw",
        dc: "http://purl.org/dc/elements/1.1/",
        dct: "http://purl.org/dc/terms/",
        ows: "http://www.opengis.net/ows",
		geoglobe: "http://www.geostar.com.cn/geoglobe",
		smmd: "http://data.sbsm.gov.cn/smmd/2007"
    },

    version: "2.0.0",
	
    schemaLocation: "http://www.opengis.net/cat/csw http://schemas.opengis.net/csw/CSW-discovery.xsd",

    readers: {
        "csw": {
            "GetRecordsResponse": function(node, obj) {
                obj.records = [];
                this.readChildNodes(node, obj);
                var version = this.getAttributeNS(node, "", 'version');
                if (version != "") {
                    obj.version = version;
                }
            },
            "RequestId": function(node, obj) {
                obj.RequestId = this.getChildValue(node);
            },
            "SearchStatus": function(node, obj) {
                obj.SearchStatus = {};
                var timestamp = this.getAttributeNS(node, "", 'timestamp');
                if (timestamp != "") {
                    obj.SearchStatus.timestamp = timestamp;
                }
            },
            "SearchResults": function(node, obj) {
                this.readChildNodes(node, obj);
                var attrs = node.attributes;
                var SearchResults = {};
                for(var i=0, len=attrs.length; i<len; ++i) {
                    if ((attrs[i].name == "numberOfRecordsMatched") ||
                        (attrs[i].name == "numberOfRecordsReturned") ||
                        (attrs[i].name == "nextRecord")) {
                        SearchResults[attrs[i].name] = parseInt(attrs[i].nodeValue);
                    } else {
                        SearchResults[attrs[i].name] = attrs[i].nodeValue;
                    }
                }
                obj.SearchResults = SearchResults;
            }
        },
        "dc": {
            "*": function(node, obj) {
                var name = node.localName || node.nodeName.split(":").pop();
                if (!(Geo.Util.isArray(obj[name]))) {
                    obj[name] = new Array();
                }
                var dc_element = {};
                var attrs = node.attributes;
                for(var i=0, len=attrs.length; i<len; ++i) {
                    dc_element[attrs[i].name] = attrs[i].nodeValue;
                }
                dc_element.value = this.getChildValue(node);
                obj[name].push(dc_element);
            }
        },
        "dct": {
            "*": function(node, obj) {
                var name = node.localName || node.nodeName.split(":").pop();
                if (!(Geo.Util.isArray(obj[name]))) {
                    obj[name] = new Array();
                }
                obj[name].push(this.getChildValue(node));
            }
        },
        "ows": {
            "WGS84BoundingBox": function(node, obj) {
                if (!(Geo.Util.isArray(obj.BoundingBox))) {
                    obj.BoundingBox = new Array();
                }
                var lc = this.getChildValue(
                    this.getElementsByTagNameNS(
                        node,
                        this.namespaces["ows"],
                        "LowerCorner"
                    )[0]
                ).split(' ', 2);
                var uc = this.getChildValue(
                    this.getElementsByTagNameNS(
                        node,
                        this.namespaces["ows"],
                        "UpperCorner"
                    )[0]
                ).split(' ', 2);

                var boundingBox = {
                    value: [
                        parseFloat(lc[0]),
                        parseFloat(lc[1]),
                        parseFloat(uc[0]),
                        parseFloat(uc[1])
                    ]
                };
                var attrs = node.attributes;
                for(var i=0, len=attrs.length; i<len; ++i) {
                    boundingBox[attrs[i].name] = attrs[i].nodeValue;
                }
                obj.BoundingBox.push(boundingBox);
            },

            "BoundingBox": function(node, obj) {
                this.readers['ows']['WGS84BoundingBox'].apply(this, [node, obj]);
            }
        },
		
		//增加自定义记录类型
		"geoglobe": {
			"ResourceType": function(node, obj){
				var record = {type: "ResourceType"};
                this.readChildNodes(node, record);
                obj.records.push(record);
				
			},
			"*": function(node, obj){
				var name = node.localName || node.nodeName.split(":").pop();
                obj[name] = this.getChildValue(node);
			}
		},
		"smmd": {
			"Metadata": function(node, obj){
				var record = {type: "Metadata"};
                this.readChildNodes(node, record);
                obj.records.push(record);
			},
			"*": function(node, obj){
				var name = node.localName || node.nodeName.split(":").pop();
                obj[name] = this.getChildValue(node);
			}
		}
    },

	CLASS_NAME: "OpenLayers.Format.CSWGetRecords.v2_0_0" 
});/**
 * Class: Geo.Query.ModelQuery
 * 三维地图模型服务查询类。
 * 本类支持：1.鼠标点击模型查询模型信息;2.根据矩形范围查询模型信息。
 */
Geo.Query.ModelQuery = Geo.Class({
	
    /**
     * Property: url
     * {String} 服务地址。
     */
//	url: null,
	
    /**
     * APIProperty: maxFeatures
     * {Number} 最大结果数。
     */	
	maxFeatures: 10,

    /**
     * APIProperty: format
     * {<Geo.Format>} 用于对查询操作返回结果进行解析的格式解析器，默认为XML解析器。
     */
	format: null,
    
    /**
     * APIProperty: modelLayer
     * {<Geo.View3d.Layer.ModelLayer>} 查询的模型图层对象。
     */
    modelLayer : null,
    
    /**
     * APIProperty: map
     * {<Geo.View3D.Map>} 三维地图对象。 
     */
    map : null,
    
    /**
     * APIProperty: enumLayerPropertyName
     * <Object>} 图层属性对象。
     */
	enumLayerPropertyName :
	{
		layerName : 0,
		layerVisible : 1,
		layerTransparency : 2,
		layerFullEnvelope : 3,
		wmslayerInfo : 4,
		wmtslayerInfo : 5,
		EnableSelection : 6
	},
	/**
	 * Constructor: Geo.Query.ModelQuery
	 * Geo.Query.ModelQuery类构造函数。
	 * 
	 * Parameters:
	 * options - {Object} 相关属性的设置项，可选。
	 */	
	initialize: function(modelLayer,options){
		//this.url = url;
		this.modelLayer = modelLayer;
		this.format = new Geo.Util.Format.XML2JSON();
		OpenLayers.Util.extend(this, options);
	},

	/**
	 * APIMethod: query
	 * 开始查询。
	 * 
	 * Parameters:
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
	 * (end)
	 */
	query: function(successFn,failFn){
		if(this.modelLayer == null){
			return;
		}
		var map = this.modelLayer.map;
		var globe = map.activexObj; 
		//打开SelectionBox的选择功能，打开图层的选择功能
		globe.SelectionBox.EnableSelection = true;
		var layerOp = globe.LayerBox.CreateLayerOperate(this.modelLayer._layerData);
		layerOp.ChangeLayerProperty(this.enumLayerPropertyName.EnableSelection, true);
		//监听鼠标事件,在鼠标事件中执行选择命令
		var querySuccessFn = successFn || this.successFn;
		var queryFailFn = failFn || this.failFn;
		this.queryHandler = OpenLayers.Function.bind(function(eventObj,successFn,failFn){
	        this._queryHandler(eventObj,querySuccessFn,queryFailFn);
	    }, this);
		//调用SelectionBox的选择方法,输入参数是屏幕坐标
	//	globe.attachEvent("OnMouseEvent", this.queryHandler);
		if (globe.attachEvent){
			globe.attachEvent("OnMouseEvent",this.queryHandler);        
		}else if (globe.addEventListener){
			globe.addEventListener("MouseEvent",this.queryHandler,false);      
		}	
	},
	
	//点击查询
	 _queryHandler : function(e,successFn,failFn){
    	var map = this.modelLayer.map;
		var globe = map.activexObj; 
		//监听鼠标单击事件
		if(e.MouseButton === 1 && e.MouseState === 0){
			globe.SelectionBox.SelectByScreenPoint(e.ScreenX, e.ScreenY);
			if(!e){
				failFn();
				return;
			}
			//alert(""+e.ScreenX+","+ e.ScreenY);
			//获取选中的模型ID,根据选择集中的索引，获取模型ID
			var modelId = globe.SelectionBox.QuerySelectedID(0);
			if(globe.SelectionBox.Count == 0){
				return;
			}
			//创建一个请求属性数据的对象
			var AttributeOperater = globe.ObjectFactory.CreateObjectFromParameter("eGMDLAttributeOperater", "");
			var strAtt = AttributeOperater.QueryAttributeFromServerID(this.modelLayer.url, modelId);
			var attXml = this.format.read(strAtt);
			if(attXml){
				var feature = attXml.Feature;
				if(feature){
					var x = feature.X ? feature.X : "";
					var y = feature.Y ? feature.Y : "";
					var z = feature.Z ? feature.Z : "";
					var minX = feature.GEOSTAR_MIN_X ? feature.GEOSTAR_MIN_X : "";
					var minY = feature.GEOSTAR_MIN_Y ? feature.GEOSTAR_MIN_Y : "";
					var maxX = feature.GEOSTAR_MAX_X ? feature.GEOSTAR_MAX_X : "";
					var maxY = feature.GEOSTAR_MAX_X ? feature.GEOSTAR_MAX_X : "";
					var name = feature.NAME ? feature.NAME :"";
					var featureObject = {
						longitude: null,
			            latitude: null,
			            altitude: null,
			            name: null,
			            bounds: null
					}; 
					featureObject.longitude = x;
					featureObject.latitude = y;
					featureObject.altitude = z;
					featureObject.name = name;
					featureObject.bounds = new Geo.Bounds(minX, minY, maxX, maxY);
					//调用回调函数
					successFn(featureObject);
				}
			}
		}
    },
    /**
     * 删除查询模型监听 
     */
    removeQuery: function(){
    	var map = this.modelLayer.map;
    	var globe = map.activexObj; 
	//	globe.detachEvent("OnMouseEvent", this.queryHandler);
		if (globe.detachEvent){
			globe.detachEvent("OnMouseEvent",this.queryHandler);        
		}else if (globe.removeEventListener){
			globe.removeEventListener("MouseEvent",this.queryHandler,false);      
		}	
    },
    
	CLASS_NAME: "Geo.Query.ModelQuery"
});
/**
 * Class: Geo.Query.MapServiceQuery
 * MapService服务查询类，可以查询指定图层或表的要素结果，支持几何查询和属性查询两种方式.
 */
Geo.Query.MapServiceQuery = Geo.Class({
	
	/**
	 *  APIProperty: url
	 * {String} 服务地址。
	 */
	url: null,
	
	/**
	 * Constructor: Geo.Query.MapServiceQuery
	 * 构造函数。
	 * 
	 * Parameters:
	 * url - {String} 服务地址
	 * options - {Object} 可选项，目前没有可设置的参数
	 */	
	initialize: function(url,options){
		var location = url.indexOf("/",url.length - 1);
		if(location != -1) {
			this.url = url + "query";
		}else {
			this.url = url + "/" + "query";
		}
		var format = new Geo.Util.Format.MapServiceQuery();
		this.jsonp = new OpenLayers.Protocol.Script({
			format:format
		});
		OpenLayers.Util.extend(this, options);
	},
	
	/**
	 * APIMethod: query
	 * 查询
	 * 
	 * Parameters:
	 * queryParameter - {<Geo.Query.MapServiceQueryParameters>}查询参数
	 * successFn - {Function} 请求成功的回调函数。
	 * failFn - {Function} 请求失败的回调函数。
	 *      (code)
	 *      例如：
	 *      var url = "http://sampleserver1.arcgisonline.com/ArcGIS/rest/services/Specialty/ESRI_StateCityHighway_USA/MapServer/1";
 	 *     	var queryObj = new Geo.Query.MapServiceQuery(url);
	 *		var params = new Geo.Query.MapServiceQueryParameters();
	 *		params.where="STATE_NAME='Florida'",
	 *		params.geometry=new Geo.Bounds(-180,-90,180,90),
	 *		params.spatialRel="esriSpatialRelEnvelopeIntersects",
	 *		params.inSR="4326",
	 *		params.outSR="4326"
	 *		queryObj.query(params,function(result) {
	 *			vectorLayer.addFeatures(result.features);	
	 *		});
	 *      (end)
	 */
	query: function(queryParameter ,successFn, failFn) {
		var params = this._getParamsFromQueryParameter(queryParameter);	
		var DEFAULT_PARAMS = {
			f:"json",
			pretty:true
		}
		OpenLayers.Util.applyDefaults(
	        params, DEFAULT_PARAMS
	    );
		this.jsonp.createRequest(this.url,params, OpenLayers.Function.bind(function(result){
			var failFn = failFn || this.failFn;
			if(result.error) {
				failFn(result.error);
				return;
			}
			var features = this.jsonp.format.read(result);
			var queryResult =  new Geo.Query.MapServiceQueryResult();
			queryResult.features = features;
			queryResult.displayFieldName = result["displayFieldName"];
			queryResult.fieldAliases = result["fieldAliases"];
			queryResult.geometryType = result["geometryType"];
			queryResult.spatialReference = result["spatialReference"];
			successFn(queryResult);
		},this));

	},
	
	queryForIds: function(queryParameter ,successFn, failFn) {
		var params = this._getParamsFromQueryParameter(queryParameter);	
		var DEFAULT_PARAMS = {
			f:"json",
			returnIdsOnly:true,
			pretty:true
		}
		OpenLayers.Util.applyDefaults(
	        params, DEFAULT_PARAMS
	    );
		this.jsonp.createRequest(this.url,params, OpenLayers.Function.bind(function(result){
			var queryResult = {
				objectIdFieldName:result["objectIdFieldName"],
				objectIds:result["objectIds"]
			}
			successFn(queryResult);
		},this));
	},
	
	_getParamsFromQueryParameter: function(queryParameter) {
		var params = {};
		for(var param in queryParameter) {
			if(queryParameter[param] !== null) {
				params[param] = queryParameter[param];
			}
		}
		
		if(params.geometry instanceof Geo.Geometry || params.geometry instanceof Geo.Bounds) {
			if(params.serviceType == "ArcgisRest") {
				params.geometryType = "esri" + this._getGeometryType(params.geometry);
			}else {
				params.geometryType = this._getGeometryType(params.geometry);
			}
			params.geometry = this._getGeometryRepresentation(params.geometry);//this.jsonp.format._getGeometryRepresentation
		}
		
		if(params.timeExtent) {
			if(params.timeExtent.startTime instanceof Date && params.timeExtent.endTime instanceof Date) {
				var startTime = Date.parse(params.timeExtent.startTime);
				var endTime = Date.parse(params.timeExtent.endTime);
				params.time = startTime + "," + endTime;
				delete params.timeExtent;
			}
		}
		
		if(params.spatialRel && params.serviceType == "ArcgisRest") {
			params.spatialRel = "esri" + params.spatialRel;
		}
		delete params.serviceType;
		return params;
	},
	
	/**
	 * Method: 得到与该几何信息相对应的arcgis几何类型
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_getGeometryType: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryType = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryType = "GeometryEnvelope";
				break;
			case "OpenLayers.Geometry.Point":
				geometryType = "GeometryPoint";
				break;
			case "OpenLayers.Geometry.MultiLineString":
				geometryType = "GeometryPolyline";
				break;	
			case "OpenLayers.Geometry.Polygon":
				geometryType = "GeometryPolygon";
				break;	
		}
		return geometryType;
	},
	
	/**
	 * Method: 得到arcgis可以理解的几何表示法
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_getGeometryRepresentation: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryStr = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryStr = geometry.toBBOX();
				break;
			case "OpenLayers.Geometry.Point":
				geometryStr = geometry.x + "," + geometry.y;
				break;
			case "OpenLayers.Geometry.Polygon":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {rings:json.coordinates};
				geometryStr = OpenLayers.Format.JSON.prototype.write.apply(this.jsonp.format,
                                                              [jsonObj]);
				break;	
			case "OpenLayers.Geometry.MultiLineString":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {paths:json.coordinates};
				geometryStr = OpenLayers.Format.JSON.prototype.write.apply(this.jsonp.format,
                                                              [jsonObj]);
				break;		
		}
		return geometryStr;
	},
	
	/**
     * Property: extract
     * Object with properties corresponding to the GeoJSON types.
     *     Property values are functions that do the actual value extraction.
     */
    extract: { 
        'geometry': function(geometry) {
            if (geometry == null) {
                return null;
            }                     
            var geometryType = geometry.CLASS_NAME.split('.')[2];
            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);
            var json;
            json = {
                "type": geometryType,
                "coordinates": data
            };
            return json;
        },

        'point': function(point) {
            return [point.x, point.y];
        },

        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
            }
            return array;
        },
        
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array;
        },

        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
            }
            return array;
        },
        
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
            }
            return array;
        }
    },
	
	/**
	 * Method: 将几何信息的json表示转换成
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new OpenLayers.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new OpenLayers.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new OpenLayers.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
	
	/**
	 * APIMethod: failFn
	 * 查询失败响应方法，默认提示"对不起,查询失败,请查询服务是否正常"，用户可以根据需要覆盖此方法。
	 */
	failFn: function(error){
		alert("对不起,查询失败,请查询服务是否正常。");
    },

	CLASS_NAME: "Geo.Query.MapServiceQuery"
});/**
 * Class: Geo.Query.MapServiceQueryParameters
 * 本对象支持服务类型：OGC_Geo_MapService_Rest、Arcgis_MapService_Rest
 */
Geo.Query.MapServiceQueryParameters = Geo.Class({
	
	/**
	 * APIProperty: serviceType
	 * 服务类型，默认值：MapserviceRest
	 * 可供选择的值：MapserviceRest，ArcgisRest
	 * 其中MapserviceRest表示OGC 地图服务查询接口，
	 * ArcgisRest表示Arcgis地图服务查询接口
	 * 
	 */
	serviceType:"MapserviceRest",

	/**
	 * APIProperty: geometry
	 * {<Geo.Bounds> || <Geo.Geometry>}geometry} 作为空间过滤条件。
	 * 如果要使用空间范围作为查询条件则使用本属性，如果不需要空间范围作为条件则本属性可忽略。
	 * 本属性支持的服务类型：OGC_Geo_MapService_Rest、Arcgis_MapService_Rest
	 * 本属性支持的Geo.Geometry类型包括：
	 * Geo.Geometry.Point,Geo.Geometry.MultiPoint,Geo.Geometry.MultiLineString,Geo.Geometry.Polygon
	 * 其他Geo.Geometry类型不支持。
	 */
	geometry:null,
	
	/**
	 * APIProperty: objectIds
	 * {String} 
	 * 查询的要素ID。默认可不填。取值举例：objectIds:"1,2",本属性就像一个过滤器，会过滤掉要素id不为1或2的要素。
	 * 
	 */
	objectIds:null,
	
	/**
	 * APIProperty: orderByFields
	 * {Array(String)} 查询排序字段。Arcgis 10.1 以后才支持。默认可不填。
	 */
	orderByFields:null,
	
	/**
	 * APIProperty: outFields
	 *  {Array(String)} 输出字段。如果不需要定制输出的字段，默认可不填。
	 */
	outFields:null,
	
	/**
	 * APIProperty: inSR
	 * {Integer} 输入几何对象的投影类型编号。不填则按服务默认的投影类型解析geometry参数
	 */
	inSR:null,
	
	/**
	 * APIProperty: outSR
	 * {Integer} 输出几何对象的投影类型编号。不填则按服务默认的投影类型输出结果
	 */
	outSR:null,
	
	/**
	 * APIProperty: maxAllowableOffset
	 *  定义Find操作返回的几何对象的最大允许偏移值。本属性主要用于对线和面进行抽稀
	 *  maxAllowableOffset的单位与空间参考单位一致。
	 *  如果sr值未定义，maxAllowableOffset的单位与地图的空间参考单位一致。
	 *  如：maxAllowableOffset=2
	 */
	maxAllowableOffset: null,
	
	/**
	 * APIProperty: returnGeometry
	 * 	{Boolean} 返回结果中是否包含几何信息。不填则服务默认其值为true
	 */
	returnGeometry:null,
	
	/**
	 * APIProperty: spatialRelationship
	 * {String} 空间查询条件。不填则默认值为"SpatialRelIntersects"。
	 */
	spatialRel:null,
	
	/**
	 * APIProperty: timeExtent
	 * {Object} 请求指定时间段内的瓦片。默认可不填
	 */
	timeExtent:null,
	
	/**
	 * APIProperty: where
	 * {String} 属性查询条件，sql语句格式
	 */
	where:null,
	
	/**
	 * APIProperty: text
	 * {String} 根据服务的displayField字段进行查询；
	 *  value参数是对where <displayField> like '%<text>%' 的where子句的速记。
	 *  文本是区分大小写的。如果指定了where参数，该参数会被忽略。
	 */
	text:null,
	
	/**
	 * Constructor: Geo.Query.MapServiceQueryParameters
	 * 构造函数。
	 * 
	 */	
	initialize: function(options){
		OpenLayers.Util.extend(this, options);
	}
});
/**
 * Class: Geo.Query.MapServiceQueryResult
 * Geo.Query.MapServiceQuery 地图服务查询类结果操作对象。本对象支持服务类型：OGC_Geo_MapService_Rest、Arcgis_MapService_Rest
 * 说明：地名服务查询对象调用query方法进入成功回调后，回调函数返回的就是本对象。
 */
Geo.Query.MapServiceQueryResult = Geo.Class({
	/**
     * APIProperty: displayFieldName
     * {String} 字段名称：
     */
	displayFieldName:null,
	
	/**
	 * APIProperty: features
	 * Array({<Geo.Feature.Vector>}) 要素对象集合
	 */
	features:null,
	
	/**
     * APIProperty: fieldAliases
     * {String} 字段别名
     */
	fieldAliases:null,
	
	/**
     * APIProperty: geometryType
     * {String} 几何对象类型 ("GeometryPoint" / "GeometryMultiPoint" / "GeometryPolyline" / "GeometryPolygon" / "GeometryEnvelope")，缺省"GeometryPoint"。如：geometryType=GeometryPolygon。
     */
	geometryType:null,
	
	/**
     * APIProperty: spatialReference
     * {String} 空间参考
     */
	spatialReference:null,
	
	/**
	 * Constructor: Geo.Query.MapServiceQueryResult
	 * 构造函数。
	 * 
	 */	
	initialize: function(options){
		OpenLayers.Util.extend(this, options);
	}
});
/**
 * Class: Geo.Query.MapServiceIdentify
 * MapService服务空间查询类，以空间关系做查询条件进行要素查询。
 */
Geo.Query.MapServiceIdentify = Geo.Class({
	
    /**
	 * APIProperty: url
	 * {String} 服务地址。
	 */
	url: null,
	
	/**
	 * Constructor: Geo.Query.MapServiceIdentify
	 * 构造函数。
	 * 
	 * Parameters:
	 * url - {String} 服务地址
	 * options - {Object} 可选项，目前没有可用参数
	 */	
	initialize: function(url,options){
		this.url = url + "/identify";
		this.format = new OpenLayers.Format.JSON();
		this.jsonp = new OpenLayers.Protocol.Script({
			format:this.format
		});
		OpenLayers.Util.extend(this, options);
	},
	
	/**
	 * APIMethod: query
	 * 查询
	 * 
	 * Parameters:
	 * queryParameter - {<Geo.Query.MapServiceIdentifyParameters>}查询参数
	 * successFn - {Function} 请求成功的回调函数。
	 * failFn - {Function} 请求失败的回调函数。 	
	 *      (code)
	 *      例如：
 	 *     	var queryObj = new Geo.Query.MapServiceIdentify("http://192.168.42.75:7777/wkDT/MapServer/identify");
	 *		var params = new Geo.Query.MapServiceIdentifyParameters();
	 *		params.geometryType = "GeometryEnvelope",
	 *		params.layers = "all:4",
	 *		params.geometry = "75,10,130,50",
	 *		params.imageDisplay = "600,550,96",
	 *		queryObj.query(params,function(result) {
	 *			for(var i = 0,len = result.length; i < len; i++){
	 *	    		vectorLayer.addFeatures(result[i].feature);
	 *	    	}	
	 *		});
	 *      (end)
	 */
	query: function(queryParameter ,successFn, failFn) {
		var params = this._getParamsFromQueryParameter(queryParameter);	
		var DEFAULT_PARAMS = {
			f:"json"
		}
		OpenLayers.Util.applyDefaults(
	        params, DEFAULT_PARAMS
	    )
	    this.jsonp.createRequest(this.url,params, OpenLayers.Function.bind(function(result){
	    	if(result.error) {
				if(failFn){
					failFn(result.error);
	    		}
				return;
			}
			var results = this._getResult(result);
			successFn(results);
		},this));
	},
	
	/**
	 * Method: 获取查询结果的json表示法
	 * 
	 * Parameters:
	 * {Object} result
	 */	
	_getResult : function(result){
		var results = [];
		if(result.results) {
			for(var i = 0,j = result.results.length; i < j; i++) {
				var olGeometry = this._getGeometry(result.results[i].geometry);
				var attributes = this._getAttribute(result.results[i].attributes);
				var feature = new OpenLayers.Feature.Vector(olGeometry,attributes);
				var identifyResult = new Geo.Query.MapServiceIdentifyResult();
				identifyResult.layerId = result.results[i].layerId;
				identifyResult.layerName = result.results[i].layerName;
				identifyResult.displayFieldName = result.results[i].displayFieldName;
				identifyResult.feature = feature;
				identifyResult.geometryType = result.results[i].geometryType;
				results.push(identifyResult);
			}
		}
		return results;
	},
	
	_getParamsFromQueryParameter: function(queryParameter) {
		var params = {};
		for(var param in queryParameter) {
			if(queryParameter[param] !== null) {
				params[param] = queryParameter[param];
			}
		}
		
		if(params.geometry instanceof Geo.Geometry || params.geometry instanceof Geo.Bounds) {
			params.geometry = this._getGeometryRepresentation(params.geometry);
		}
		
		if(params.spatialRel && params.serviceType == "ArcgisRest") {
			params.spatialRel = "esri" + params.spatialRel;
		}
		if(params.geometryType && params.serviceType == "ArcgisRest") {
			params.geometryType = "esri" + this._getGeometryType(params.geometry);
		}
		delete params.serviceType;
		return params;
	},
	
	/**
	 * Method: 得到与该几何信息相对应的arcgis几何类型
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_getGeometryType: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryType = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryType = "GeometryEnvelope";
				break;
			case "OpenLayers.Geometry.Point":
				geometryType = "GeometryPoint";
				break;
			case "OpenLayers.Geometry.MultiLineString":
				geometryType = "GeometryPolyline";
				break;	
			case "OpenLayers.Geometry.Polygon":
				geometryType = "GeometryPolygon";
				break;	
		}
		return geometryType;
	},
	
	/**
	 * Method: 得到arcgis可以理解的几何表示法
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_getGeometryRepresentation: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryStr = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryStr = geometry.toBBOX();
				break;
			case "OpenLayers.Geometry.Point":
				geometryStr = geometry.x + "," + geometry.y;
				break;
			case "OpenLayers.Geometry.Polygon":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {rings:json.coordinates};
				geometryStr = this.format.write(jsonObj);
				break;	
			case "OpenLayers.Geometry.MultiLineString":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {paths:json.coordinates};
				geometryStr = this.format.write(jsonObj);
				break;		
		}
		return geometryStr;
	},
	
	/**
     * Property: extract
     * Object with properties corresponding to the GeoJSON types.
     *     Property values are functions that do the actual value extraction.
     */
    extract: { 
        'geometry': function(geometry) {
            if (geometry == null) {
                return null;
            }                     
            var geometryType = geometry.CLASS_NAME.split('.')[2];
            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);
            var json;
            json = {
                "type": geometryType,
                "coordinates": data
            };
            return json;
        },

        'point': function(point) {
            return [point.x, point.y];
        },

        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
            }
            return array;
        },
        
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array;
        },

        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
            }
            return array;
        },
        
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
            }
            return array;
        }
    },
	
	/**
	 * Method: 获取查询结果的json表示法
	 * 
	 * Parameters:
	 * {Object} result
	 */	
	_getJson: function(result) {
		var resultObj = this.format.read(result.responseText);
		return resultObj;
	},
	
	/**
	 * Method: 得到openlayers几何对象
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_getGeometry: function(geometry) {
		for(var pro in geometry) {
			//TODO：服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new OpenLayers.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				 var geometry = new OpenLayers.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
			}else {
				var geometry = this._geometryType[pro](geometry[pro]);
			}
			return geometry;
		}
	},

	/**
	 * Method: 得到要素的属性信息
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_getAttribute: function(attrs) {
		var attributes = {};
		if(attrs && !(Geo.Util.isArray(attrs))) {
			attrs = [attrs];
		}
		if(Geo.Util.isArray(attrs)) {
			for(var i = 0; i < attrs.length; i++) {
				 OpenLayers.Util.applyDefaults(attributes,attrs[i]);
			}
		}
		return attributes;
	},
	
	/**
	 * Method: 将几何信息的json表示转换成
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new OpenLayers.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new OpenLayers.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new OpenLayers.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
	
	CLASS_NAME: "Geo.Query.MapServiceIdentify"
});
/**
 * Class: Geo.Query.MapServiceIdentifyParameters
 * Identify空间查询参数，rest服务的空间查询参数。本对象须结合Geo.Query.MapServiceIdentify对象使用，Geo.Query.MapServiceIdentify对象的query方法的第一个参数传入是本对象。支持服务：OGC_Geo_MapService_Rest。
 */
Geo.Query.MapServiceIdentifyParameters = Geo.Class({
	
    /**
     * APIProperty: geometry
     * {<Geo.Geometry>} Geo.Geometry对象。
     */
	geometry: null,
	
    /**
     * APIProperty: geometryType
     * {String} 几何对象类型 ("GeometryPoint" / "GeometryMultiPoint" / "GeometryPolyline" / "GeometryPolygon" / "GeometryEnvelope")，缺省"GeometryPoint"。如：geometryType=GeometryPolygon。
     */	
	geometryType: "",
	
    /**
     * APIProperty: layers
     * {String} 执行Identify操作的图层 有三种方式定义哪 些图层执行Identify操作：
	 * top:仅指定位置最上层的图层。
	 * visible:在指定位置的所有可见图层。
	 * all:在指定位置的所有图层。
	 * 缺省为"top"即最顶层图层。如：layers= visible:2,5。
     */	
	layers: "",
	
    /**
     * APIProperty: imageDisplay
     * {<Geo.Filter>} 地图的屏幕图像显示参数（width, height和 dpi）。mapExtent和imageDisplay参数由服务用于决定当前范围的图层可见性。它们也用于计算地图上的基于屏幕像素值的搜索距离容差。如：imageDisplay=600,550,96。
     */
	imageDisplay: "",
    
    /**
     * APIProperty: returnGeometry
     * {String} 如果为true，结果集中包含每个结果相关的几何对象，缺省为“true” 。如：returnGeometry=false。
     */
    returnGeometry: true,	
    /**
     * APIProperty: layerDefs
     * {String} 附加参数，允许在地图输出中分别对各个图层进行条件过滤，通过对这些图层指定表达方式的方式。每个图层的过滤器表达示应用于选择显示在地图中的图层的相关要素。如：0:POP2000 > 1000000;5:AREA > 100000 (文本形式){"0":"POP2000 > 1000000","5":"AREA > 100000"} (JSON形式)。
     */	
	layerDefs: "",
	
	/**
	 * Constructor: Geo.Query.MapServiceIdentifyParameters
	 * 构造函数。
	 */	
	initialize: function(){
	},
    	
	CLASS_NAME: "Geo.Query.MapServiceIdentifyParameters"
});
/**
 * Class: Geo.Query.MapServiceIdentifyResult
 * Identify空间查询结果操作对象。本对象须结合Geo.Query.MapServiceIdentify对象使用，Geo.Query.MapServiceIdentify对象的query方法的第二个参数返回的结果。支持服务：OGC_Geo_MapService_Rest。
 */
Geo.Query.MapServiceIdentifyResult = Geo.Class({
	
    /**
     * APIProperty: layerId
     * {Number} 图层ID。
     */
	layerId: null,
	
    /**
     * APIProperty: layerName
     * {String} 图层名称
     */	
	layerName: "",
	
    /**
     * APIProperty: displayFieldName
     * {String} 字段名称：
     */	
	displayFieldName: "",
	
    /**
     * APIProperty: feature
     * {<Geo.Feature.Vector>} 要素对象
     */
	feature: null,
	
	 /**
     * APIProperty: geometryType
     * {String} 几何对象类型 ("GeometryPoint" / "GeometryMultiPoint" / "GeometryPolyline" / "GeometryPolygon" / "GeometryEnvelope")，缺省"GeometryPoint"。如：geometryType=GeometryPolygon。
     */	
	geometryType: "",
	
	/**
	 * Constructor: Geo.Query.MapServiceIdentifyResult
	 * 构造函数。
	 */	
	initialize: function(){
	},
    
    	
	CLASS_NAME: "Geo.Query.MapServiceIdentifyResult"
});
/**
 * Class: Geo.Query.MapServiceDataFeatures
 * MapService服务要素查询，查询指定图层中的单个要素信息。
 */
Geo.Query.MapServiceDataFeatures = Geo.Class({
	
   /**
	 * APIProperty: url
	 * {String} 服务地址。
	 */
	url: null,
	
	/**
	 * Constructor: Geo.Query.MapServiceDataFeatures
	 * 构造函数。
	 * 
	 * Parameters:
	 * url - {String} 服务地址
	 * options - {Object} 可选项，目前没有可用参数
	 */	
	initialize: function(url,options){
		this.url = url;
		this.format = new OpenLayers.Format.JSON();
		this.jsonp = new OpenLayers.Protocol.Script({
			format:this.format
		});
		OpenLayers.Util.extend(this, options);
	},
	
	/**
	 * APIMethod: query
	 * 查询
	 * 
	 * Parameters:
	 * queryParameter - {<Geo.Query.MapServiceDataFeaturesParameters>}查询参数
	 * successFn - {Function} 请求成功的回调函数。
	 * failFn - {Function} 请求失败的回调函数。
	 *      (code)
	 *      例如：
 	 *     	var queryObj = new Geo.Query.MapServiceDataFeatures("http://192.168.42.75:7777/wkDT/MapServer");
	 *		var params = new Geo.Query.MapServiceDataFeaturesParameters();
	 *		params.layerOrTableId="4",
	 *		params.featureId="3",
	 *		queryObj.query(params,function(result) {
	 *			vectorLayer.addFeatures(result.feature);	
	 *		});
	 *      (end)
	 */
	query: function(queryParameter ,successFn, failFn) {
		if(!queryParameter.layerOrTableId){
			return;
		}
		if(!queryParameter.featureId){
			return;
		}
		this.accessUrl = this.url + "/" + queryParameter.layerOrTableId + "/" + queryParameter.featureId;
		var DEFAULT_PARAMS = {
			f:"json"
		}
		var params = queryParameter;
		OpenLayers.Util.applyDefaults(
	        params, DEFAULT_PARAMS
	    )
	    this.jsonp.createRequest(this.accessUrl,params, OpenLayers.Function.bind(function(result){
	    	if(result.error) {
				if(failFn){
					failFn(result.error);
	    		}
				return;
			}
			var feature = null;
			var featuresResult = new Geo.Query.MapServiceDataFeaturesResult();
			if(result.feature.geometry){
				feature = this._getFeatures(result);
			}
			featuresResult.feature = feature;
			successFn(featuresResult);
		},this));
	},
	
	_getParamsFromQueryParameter: function(queryParameter) {
		var params = {};
		for(var param in queryParameter) {
			if(queryParameter[param] !== null) {
				params[param] = queryParameter[param];
			}
		}
		if(params.geometry instanceof Geo.Geometry || params.geometry instanceof Geo.Bounds) {
			params.geometry = this._getGeometryRepresentation(params.geometry);
		}
		
		if(params.spatialRel && params.serviceType == "ArcgisRest") {
			params.spatialRel = "esri" + params.spatialRel;
		}
		if(params.geometryType && params.serviceType == "ArcgisRest") {
			params.geometryType = "esri" + this._getGeometryType(params.geometry);
		}
		delete params.serviceType;
		return params;
	},
	
	/**
	 * Method: 得到与该几何信息相对应的arcgis几何类型
	 * 
	 * Parameters:
	 * {Object} geometry
	 */
	_getGeometryType: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryType = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryType = "GeometryEnvelope";
				break;
			case "OpenLayers.Geometry.Point":
				geometryType = "GeometryPoint";
				break;
			case "OpenLayers.Geometry.MultiLineString":
				geometryType = "GeometryPolyline";
				break;	
			case "OpenLayers.Geometry.Polygon":
				geometryType = "GeometryPolygon";
				break;	
		}
		return geometryType;
	},
	
	/**
	 * Method: 得到arcgis可以理解的几何表示法
	 * 
	 * Parameters:
	 * {Object} geometry
	 */
	_getGeometryRepresentation: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryStr = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryStr = geometry.toBBOX();
				break;
			case "OpenLayers.Geometry.Point":
				geometryStr = geometry.x + "," + geometry.y;
				break;
			case "OpenLayers.Geometry.Polygon":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {rings:json.coordinates};
				geometryStr = this.format.write(jsonObj);
				break;	
			case "OpenLayers.Geometry.MultiLineString":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {paths:json.coordinates};
				geometryStr = this.format.write(jsonObj);
				break;		
		}
		return geometryStr;
	},
	
	/**
     * Property: extract
     * Object with properties corresponding to the GeoJSON types.
     *     Property values are functions that do the actual value extraction.
     */
    extract: { 
        'geometry': function(geometry) {
            if (geometry == null) {
                return null;
            }                     
            var geometryType = geometry.CLASS_NAME.split('.')[2];
            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);
            var json;
            json = {
                "type": geometryType,
                "coordinates": data
            };
            return json;
        },

        'point': function(point) {
            return [point.x, point.y];
        },

        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
            }
            return array;
        },
        
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array;
        },

        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
            }
            return array;
        },
        
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
            }
            return array;
        }
    },
	
	/**
	 * Method: 获取查询结果的json表示法
	 * 
	 * Parameters:
	 * {Object} result
	 */
	_getJson: function(result) {
		var resultObj = this.format.read(result.responseText);
		return resultObj;
	},
	
	/**
	 * Method: 获取查询结果的要素
	 * 
	 * Parameters:
	 * {Object} result
	 */
	_getFeatures:function(result) {
		var feature = null;
		if(result.feature) {
			var olGeometry = this._getGeometry(result.feature.geometry);
			var attributes = this._getAttribute(result.feature.attributes);
			var f = new OpenLayers.Feature.Vector(olGeometry,attributes);
			feature = f;
		}
		return feature;
	},
	
	/**
	 * Method: 得到openlayers几何对象
	 * 
	 * Parameters:
	 * {Object} geometry
	 */
	_getGeometry: function(geometry) {
		for(var pro in geometry) {
			//TODO：服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new OpenLayers.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				 var geometry = new OpenLayers.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
			}else {
				var geometry = this._geometryType[pro](geometry[pro]);
			}
			return geometry;
		}
	},
	
	/**
	 * Method: 得到要素的属性信息
	 * 
	 * Parameters:
	 * {Object} geometry
	 */
	_getAttribute: function(attrs) {
		var attributes = {};
		if(attrs && !(Geo.Util.isArray(attrs))) {
			attrs = [attrs];
		}
		if(Geo.Util.isArray(attrs)) {
			for(var i = 0; i < attrs.length; i++) {
				 OpenLayers.Util.applyDefaults(attributes,attrs[i]);
			}
		}
		return attributes;
	},
	
	/**
	 * Method: 将几何信息的json表示转换成
	 * 
	 * Parameters:
	 * {Object} geometry
	 */
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new OpenLayers.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new OpenLayers.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new OpenLayers.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
    	
	CLASS_NAME: "Geo.Query.MapServiceDataFeatures"
});
/**
 * Class: Geo.Query.MapServiceDataFeaturesParameters
 * DataFeatures要素查询参数，rest服务的地图服务要素查询参数。本对象须结合Geo.Query.MapServiceDataFeatures对象使用，Geo.Query.MapServiceDataFeatures对象的query方法的第一个参数传入是本对象。支持服务：OGC_Geo_MapService_Rest。
 */
Geo.Query.MapServiceDataFeaturesParameters = Geo.Class({
	
    /**
     * APIProperty: layerOrTableId
     * {Number} 图层或表 id。
     */
	layerOrTableId: 0,
	
    /**
     * APIProperty: featureId
     * {Number} 要素id
     */	
	featureId: 0,
	
	/**
	 * Constructor: Geo.Query.MapServiceDataFeaturesParameters
	 * 构造函数。
	 */	
	initialize: function(){
	},
    	
	CLASS_NAME: "Geo.Query.MapServiceDataFeaturesParameters"
});
/**
 * Class: Geo.Query.MapServiceDataFeaturesResult
 * DataFeatures要素查询结果操作对象。本对象须结合Geo.Query.MapServiceDataFeatures对象使用，Geo.Query.MapServiceDataFeatures对象的query方法的第二个参数返回的结果。支持服务：OGC_Geo_MapService_Rest。
 */
Geo.Query.MapServiceDataFeaturesResult = Geo.Class({
	
	 /**
     * APIProperty: feature
     * {<Geo.Vector.Feature>} 要素对象
     */
	feature: null,
	/**
	 * Constructor: Geo.Query.MapServiceDataFeaturesResult
	 * 构造函数。
	 */	
	initialize: function(){
	},
     	
	CLASS_NAME: "Geo.Query.MapServiceDataFeaturesResult"
});/**
 * Class: Geo.Query.MapServiceFind
 * MapService服务搜索类，在一或多个图层中，查询搜索指定文本。
 */
Geo.Query.MapServiceFind = Geo.Class({
	
   /**
	 * APIProperty: url
	 * {String} 服务地址。
	 */
	url: null,
	
	/**
	 * Constructor: Geo.Query.MapServiceFind
	 * 构造函数。
	 * 
	 * Parameters:
	 * url - {String} 服务地址
	 * options - {Object} 可选项，目前没有可用参数
	 */	
	initialize: function(url,options){
		this.url = url + "/find";
		this.format = new OpenLayers.Format.JSON();
		this.jsonp = new OpenLayers.Protocol.Script({
			format:this.format
		});
		OpenLayers.Util.extend(this, options);
	},
	
	/**
	 * APIMethod: query
	 * 查询
	 * 
	 * Parameters:
	 * queryParameter - {<Geo.Query.MapServiceFindParameters>}查询参数
	 * successFn - {Function} 请求成功的回调函数。
	 * failFn - {Function} 请求失败的回调函数。
	 *      (code)
	 *      例如：
 	 *     	var queryObj = new Geo.Query.MapServiceFind("http://192.168.42.75:7777/wkDT/MapServer/find");
	 *		var params = new Geo.Query.MapServiceFindParameters();
	 *		params.searchText = "1";
	 *		params.searchFields = "NAME";
	 * 		params.layers = "0,1,2,4";
	 *		params.returnGeometry = "true";
	 *		queryObj.query(params,function(result) {
	 *		    for(var i = 0,len = result.length; i < len; i++){
	 *	    		vectorLayer.addFeatures(result[i].feature);
	 *	    	}	
	 *		});
	 *      (end)
	 */
	query: function(queryParameter ,successFn, failFn) {
		var params = this._getParamsFromQueryParameter(queryParameter);	
		var DEFAULT_PARAMS = {
			f:"json",
			pretty:true
		}
		OpenLayers.Util.applyDefaults(
	        params, DEFAULT_PARAMS
	    )
	    this.jsonp.createRequest(this.url,params, OpenLayers.Function.bind(function(result){
	    	if(result.error) {
				if(failFn){
					failFn(result.error);
	    		}
				return;
			}
			var results = this._getResult(result);
			successFn(results);
		},this));
	},
	
	/**
	 * Method: 获取查询结果的json表示法
	 * 
	 * Parameters:
	 * {Object} result
	 */
	_getResult : function(result){
		var results = [];
		if(result.results) {
			for(var i = 0,j = result.results.length; i < j; i++) {
				var olGeometry = this._getGeometry(result.results[i].geometry);
				var attributes = this._getAttribute(result.results[i].attributes);
				var feature = new OpenLayers.Feature.Vector(olGeometry,attributes);
				var identifyResult = new Geo.Query.MapServiceIdentifyResult();
				identifyResult.layerId = result.results[i].layerId;
				identifyResult.layerName = result.results[i].layerName;
				identifyResult.displayFieldName = result.results[i].displayFieldName;
				identifyResult.feature = feature;
				identifyResult.geometryType = result.results[i].geometryType;
				identifyResult.foundFieldName = result.results[i].foundFieldName;
				results.push(identifyResult);
			}
		}
		return results;
	},
	
	_getParamsFromQueryParameter: function(queryParameter) {
		var params = {};
		for(var param in queryParameter) {
			if(queryParameter[param] !== null) {
				params[param] = queryParameter[param];
			}
		}
		
		if(params.geometry instanceof Geo.Geometry || params.geometry instanceof Geo.Bounds) {
			params.geometry = this._getGeometryRepresentation(params.geometry);
		}
		
		if(params.spatialRel && params.serviceType == "ArcgisRest") {
			params.spatialRel = "esri" + params.spatialRel;
		}
		if(params.geometryType && params.serviceType == "ArcgisRest") {
			params.geometryType = "esri" + this._getGeometryType(params.geometry);
		}
		delete params.serviceType;
		return params;
	},
	
	/**
	 * Method: 得到与该几何信息相对应的arcgis几何类型
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_getGeometryType: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryType = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryType = "GeometryEnvelope";
				break;
			case "OpenLayers.Geometry.Point":
				geometryType = "GeometryPoint";
				break;
			case "OpenLayers.Geometry.MultiLineString":
				geometryType = "GeometryPolyline";
				break;	
			case "OpenLayers.Geometry.Polygon":
				geometryType = "GeometryPolygon";
				break;	
		}
		return geometryType;
	},
	
	/**
	 * Method: 得到arcgis可以理解的几何表示法
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_getGeometryRepresentation: function(geometry) {
		var name = geometry.CLASS_NAME;
		var geometryStr = "";
		switch(name) {
			case "OpenLayers.Bounds": 
				geometryStr = geometry.toBBOX();
				break;
			case "OpenLayers.Geometry.Point":
				geometryStr = geometry.x + "," + geometry.y;
				break;
			case "OpenLayers.Geometry.Polygon":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {rings:json.coordinates};
				geometryStr = this.format.write(jsonObj);
				break;	
			case "OpenLayers.Geometry.MultiLineString":
				var json = this.extract['geometry'].apply(this, [geometry]);
				var jsonObj = {paths:json.coordinates};
				geometryStr = this.format.write(jsonObj);
				break;		
		}
		return geometryStr;
	},
	
	/**
     * Property: extract
     * Object with properties corresponding to the GeoJSON types.
     *     Property values are functions that do the actual value extraction.
     */
    extract: { 
        'geometry': function(geometry) {
            if (geometry == null) {
                return null;
            }                     
            var geometryType = geometry.CLASS_NAME.split('.')[2];
            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);
            var json;
            json = {
                "type": geometryType,
                "coordinates": data
            };
            return json;
        },

        'point': function(point) {
            return [point.x, point.y];
        },

        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
            }
            return array;
        },
        
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array;
        },

        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
            }
            return array;
        },
        
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
            }
            return array;
        }
    },
	
	/**
	 * Method: 得到openlayers几何对象
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_getGeometry: function(geometry) {
		for(var pro in geometry) {
			//TODO：服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new OpenLayers.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				 var geometry = new OpenLayers.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
			}else {
				var geometry = this._geometryType[pro](geometry[pro]);
			}
			return geometry;
		}
	},
	
	/**
	 * Method: 得到要素的属性信息
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_getAttribute: function(attrs) {
		var attributes = {};
		if(attrs && !(Geo.Util.isArray(attrs))) {
			attrs = [attrs];
		}
		if(Geo.Util.isArray(attrs)) {
			for(var i = 0; i < attrs.length; i++) {
				 OpenLayers.Util.applyDefaults(attributes,attrs[i]);
			}
		}
		return attributes;
	},
	
	/**
	 * Method: 将几何信息的json表示转换成
	 * 
	 * Parameters:
	 * {Object} geometry
	 */		
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new OpenLayers.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new OpenLayers.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new OpenLayers.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
	
	CLASS_NAME: "Geo.Query.MapServiceFind"
});
/**
 * Class: Geo.Query.MapServiceFindParameters
 * Find搜索参数，rest服务的搜索参数。本对象须结合Geo.Query.MapServiceFind对象使用，Geo.Query.MapServiceFind对象的query方法的第一个参数传入的是本对象。支持服务：OGC_Geo_MapService_Rest。
 */
Geo.Query.MapServiceFindParameters = Geo.Class({
	
    /**
     * APIProperty: searchText
     * {String} 搜索文本。本参数值是跨图层和用户指定字段的文本。如：searchText=Los.
     */
	searchText: "",
	
    /**
     * APIProperty: contains
     * {Boolean} 输出数据格式，缺省为“true” 。如：contains=false
     */	
	contains: true,
	
	/**
     * APIProperty: searchFields
     * {String} 要搜索的字段的名称。字段以一个逗号分隔的图层资源中返回的字段列表的形式定义，缺省搜索多个字段。如：searchFields=AREANAME,SUB_REGION
     */	
	searchFields: "",
	
	/**
     * APIProperty: layers
     * {String} 执行Find操作的多个图层。以逗号分隔的地图服务根资源中返回的图层ID列表指定。如：layers=2,4,7
     */	
	layers: "",
	
	/**
     * APIProperty: returnGeometry
     * {Boolean} 如果为true，结果集包含每个结果相关的几何对象，缺省为“true”。如：returnGeometry=false
     */	
	returnGeometry: true,
	
	/**
	 * Constructor: Geo.Query.MapServiceFindParameters
	 * 构造函数。
	 */	
	initialize: function(){
	},
    	
	CLASS_NAME: "Geo.Query.MapServiceFindParameters"
});
/**
 * Class: Geo.Query.MapServiceFindResult
 * Find文本搜索结果操作对象。本对象须结合Geo.Query.MapServiceFind对象使用，Geo.Query.MapServiceFind对象的query方法的第二个参数返回的结果。支持服务：OGC_Geo_MapService_Rest。
 */
Geo.Query.MapServiceFindResult = Geo.Class({
	
    /**
     * APIProperty: layerId
     * {Number} 图层ID。
     */
	layerId: null,
	
    /**
     * APIProperty: layerName
     * {String} 图层名称
     */	
	layerName: "",
	
    /**
     * APIProperty: displayFieldName
     * {String} 字段名称：
     */	
	displayFieldName: "",
	
    /**
     * APIProperty: feature
     * {Geo.Vector.Feature} 要素对象
     */
	feature: null,
	
	 /**
     * APIProperty: geometryType
     * {String} 几何对象类型 ("GeometryPoint" / "GeometryMultiPoint" / "GeometryPolyline" / "GeometryPolygon" / "GeometryEnvelope")，缺省"GeometryPoint"。如：geometryType=GeometryPolygon。
     */	
	geometryType: "",
	
	 /**
     * APIProperty: foundFieldName
     * {String} 查找的字段名称
     */
	foundFieldName: "",
	
	/**
	 * Constructor: Geo.Query.MapServiceFindResult
	 * 构造函数。
	 */	
	initialize: function(){
	},
    
    	
	CLASS_NAME: "Geo.Query.MapServiceFindResult"
});
/**
 * Class: Geo.Query.GeoCodingQuery
 * 地址匹配查询类。默认版本是1.0.0。
 *
 * 例子:
 * (code)
 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
 *			version:"1.1.0"
 *		});
 * (end)
 */
Geo.Query.GeoCodingQuery = function(url, options) {
    options = OpenLayers.Util.applyDefaults(
        options, Geo.Query.GeoCodingQuery.DEFAULTS
    );
    var cls = Geo.Query.GeoCodingQuery["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "不支持的地址匹配服务版本: " + options.version;
    }
    return new cls(url, options);
};

Geo.Query.GeoCodingQuery.DEFAULTS = {
    "version": "1.0.0"
};/**
 * Class: Geo.Query.GeoCodingQuery.v1
 * 地址匹配服务查询接口的抽象类,抽象类不能实例化。
 */
Geo.Query.GeoCodingQuery.v1 = Geo.Class({
	
	/**
	 * APIProperty: version
	 * 服务版本，默认值是"1.0.0"。
	 */
	version:"1.0.0",
	
	/**
     * APIProperty: url
     * {String}服务地址。
     */
	url: null,
	
	/**
     * Constructor: Geo.Query.GeoCodingQuery.v1
     * Geo.Query.GeoCodingQuery.v1类的构造函数。
     *
     * Parameters:
     * url - {String} 服务地址。
     * options - {Object} 相关属性的设置项，可选。
     * 
     * options请求参数属性可为:
     * version - {String} 服务版本。
     */
	initialize: function(url, options){
		this.url = url;
		OpenLayers.Util.extend(this,options);
		this.format = new Geo.Format.JSON();
	},
	
	/**
	 * Method: getCommonParams
	 * 获取公共的参数
	 * 
	 * Parameters:
	 * 	options
	 */
	getCommonParams: function(options) {
		var params = {
			request: "GetCategory",
			service:"GeoCoding",
			version:this.version,
			output:"json"
		};
		OpenLayers.Util.extend(params,options);
		return params;
	},
	
	/**
	 * APIMethod: getCategoryByName
	 * 根据类别名称查询类别及子类别。
	 * 
	 * Parameters:
	 * name - {String} 类别名称。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：GetCategory.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 */
	getCategoryByName:function(name,successFn,failFn) {
		var params = this.getCommonParams();
		if(typeof name === "string" && name.length !== 0) {
			params.categoryName = name;
		}
		var failFn = failFn || this.failFn;
		OpenLayers.Function.bind(this._requestCategory,this)(params,successFn,failFn);
	},

	/**
	 * APIMethod: getCategoryByCode
	 * 根据类别编码查询类别及子类别。
	 * 
	 * Parameters:
	 * code - {Number}类别编码。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：GetCategory.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * Example:
	 * (code)
	 *      //根据范围和地址进行查询：
	 * 		var coding = new Geo.Query.GeoCodingQuery("http://192.168.42.76:7021/GeoCoding/geocoding");
	 * 		coding.getCategoryByCode(1012001008000000,
	 * 		function(GeoCoding){},function(){});
	 * (end)
	 */
	getCategoryByCode: function(code,successFn,failFn) {
		var params = this.getCommonParams();
		if(typeof code === "number") {
			params.categoryCode = code;
		}
		OpenLayers.Function.bind(this._requestCategory,this)(params,successFn,failFn);
	},
	
	/**
	 * APIMethod: getAllCategory
	 * 查询所有类别信息。
	 * 
	 * Parameters:
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：GetCategory.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 */
	getAllCategory: function(successFn,failFn) {
		var params = this.getCommonParams();
		OpenLayers.Function.bind(this._requestCategory,this)(params,successFn,failFn);
	},
	
	/**
	 * Method: _requestCategory
	 * 执行get请求操作
	 * 
	 * Parameters:
	 * 	params
	 *  successFn
	 *  failFn
	 */
	_requestCategory:function(params,successFn,failFn) {
		var failFn = failFn || this.failFn;
		OpenLayers.loadURL(this.url,params,this,function(result) {
			try{
				var category = this.format.read(result.responseText);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(category);
		},failFn);
	},
	
	/**
	 * Method: _analysis_GeoCodeResult
	 * 解析返回的结果，getCoder接口查询结果第一级结构
	 * 
	 * Parameters:
	 * 	json
	 */
	_analysis_GeoCodeResult: function(json) {
		var queryResult = {
			status:json.status
		};
		switch(json.status) {
			case "OK":
				var results = json.results;
				if(results) {
					queryResult.results = this._analysis_GeoCodeResult_results(results);
				}
			break;
			case "INVALID_REQUEST":
				
			break;
			case "NO_RESULTS":
				
			break;
			case "UNKNOWN_ERROR":
				
			break;
			default:
				queryResult = {
					requestKeyWord:json.requestKeyWord,
					count:json.count,
					statisticsLevel:json.statisticsLevel,
					statisticsLevelName:json.statisticsLevelName
				};

				if(json && json.count > 0){
					var results = json.results;
					if(results) {
						queryResult.results = this._analysis_GeoCodeResult_statistics(results);
					}
				}
			break;
		}
		return queryResult;
	},
	
	/**
	 * Method: _analysis_GeoCodeResult_results
	 * getCoder接口查询结果第二级结构
	 * 
	 * Parameters:
	 * 	results
	 */
	_analysis_GeoCodeResult_results: function(results) {
		var aresults = [];
		//如果存在results节点，那么它就是一个数组
		if(Geo.Util.isArray(results)) {
			for(var i = 0,j = results.length; i < j;i++) {
				var result = {};
				result.requestKeyWord = results[i].requestKeyWord;
				if(results[i].errorCorrectionTips) {
					result.errorCorrectionTips = results[i].errorCorrectionTips;
				}
				//匹配结果总数
				result.count = results[i].count;
				if(results[i].result) {
					result.result = this._analysis_GeoCodeResult_results_result(results[i].result);
				}
				aresults.push(result);
			}
			return aresults;
		}
	},

	/**
	 * Method: _analysis_GeoCodeResult_statistics
	 * getCoder接口按行政区划统计结果值第二级结构
	 * 
	 * Parameters:
	 * 	results
	 */
	_analysis_GeoCodeResult_statistics: function(results) {
		var aresults = [];
		//如果存在results节点，那么它就是一个数组
		if(Geo.Util.isArray(results)) {
			for(var i = 0,j = results.length; i < j;i++) {
				var result = {};
				if(results[i].errorCorrectionTips) {
					result.errorCorrectionTips = results[i].errorCorrectionTips;
				}

				if(results[i]) {
					result.name = results[i].name;
					result.value = results[i].value;
					result.remark = results[i].remark;
				}
				aresults.push(result);
			}
			return aresults;
		}
	},
	
	/**
	 * Method: _analysis_GeoCodeResult_results_result
	 * getCoder接口查询结果第三级结构
	 * 
	 * Parameters:
	 * 	result
	 */
	_analysis_GeoCodeResult_results_result: function(result) {
		var addresss = [];
		for(var i = 0,j = result.length; i < j;i++) {
			var address = {};
			//匹配结果的类型
			address.resultType = result[i].resultType;
			//匹配地址是否为精确地址
			address.precise = result[i].precise;
			//该条匹配结果是否为摘要信息
			address.isBrief = result[i].isBrief;
			//匹配结果与请求关键字的匹配度，值域为1到100，值越大匹配度就越高
			address.score = result[i].score;
			if(address.isBrief == false) {
				address.addressComponent = this._analysis_GeoCodeResult_results_result_address(result[i].addressComponent,address.resultType);
			}
			address.poiArray = this._analysispoiArray(result[i].poiArray);
			if(result[i].location) {
				address.location = result[i].location;
			}
			//TODO:referenceAddressArray
			if(address.precise == 0) {
				address.referenceAddressArray = result[i].referenceAddressArray;
			}
			addresss.push(address);
		}
		return addresss;
	},
	
	/**
	 * Method: _analysis_GeoCodeResult_results_result_address
	 * getCoder接口查询结果第四级结构，当前匹配结果的地址详细信息
	 * 
	 * Parameters:
	 * 	addressComponent
	 *	resultType
	 */
	_analysis_GeoCodeResult_results_result_address:function(addressComponent,resultType) {
		var addressC = {
			country: addressComponent.country
		};
		//行政区划的第二级-省、直辖市、自治区
		if(addressComponent.province) {
			addressC.province = addressComponent.province;
		}
		//行政区划第三级-市
		if(addressComponent.city) {
			addressC.city = addressComponent.city;
		}
		//行政区划第四级-区或县
		if(addressComponent.district) {
			addressC.district = addressComponent.district;
		}
		//行政区划第五级-乡镇
		if(addressComponent.town) {
			addressC.town = addressComponent.town;
		}
		if(addressComponent.street) {
			addressC.street = {
				name:addressComponent.street.name
			};
			
			if(resultType === "street") {
				//需要增加对线的json串的解析
				if(addressComponent.street.geometry) {
					//var sgeometry = addressComponent.street.geometry;
					var sgeometry = this.format.read(addressComponent.street.geometry);
					var streetGeometry = null;
					if(sgeometry["paths"]) {
						//这个需要做测试，这里的几何信息一般来说是线，不过也有可能不是线
						streetGeometry = this._getGeometry(sgeometry);
						addressC.street.geometry = streetGeometry;
					}else if(sgeometry["rings"]){
						streetGeometry = this._getGeometry(sgeometry);
						addressC.street.geometry = streetGeometry;
					}else if(sgeometry["x"] && sgeometry["y"]){
						streetGeometry = this._getGeometry(sgeometry);
						addressC.street.geometry = streetGeometry;
					}
				}
			}
		}
		if(addressComponent.streetNumber) {
			addressC.streetNumber = addressComponent.streetNumber;
		}
		if(addressComponent.buildingNumber) {
			addressC.buildingNumber = addressComponent.buildingNumber;
		}
		if(resultType === "adminArea") {
			//当前匹配最小级行政区划的空间信息,本属性需要被转换成Geo.Geometry类型
			if(addressComponent.geometry) {
				//var geometry = addressComponent.geometry;
				var geometry = this.format.read(addressComponent.geometry);
				var areaGeometry = null;
				//如果它是面，我们解析它
				if(geometry["rings"]) {
					areaGeometry = this._getGeometry(geometry);
					addressC.geometry = areaGeometry;
				}else if(geometry["paths"]) {
					areaGeometry = this._getGeometry(geometry);
					addressC.geometry = areaGeometry;
				}else if(typeof geometry["x"] === "number" && typeof geometry["y"] === "number") {
					addressC.geometry = this._getGeometry(geometry);
				}
			}
			//当前匹配最小级行政区划下属的其它行政区划名称，多个以逗号隔开
			if(addressComponent.subordinate) {
				addressC.subordinate = addressComponent.subordinate;
			}
			//行政区的邮政编码
			if(addressComponent.zipCode) {
				addressC.zipCode = addressComponent.zipCode;
			}
			//电话长途区划
			if(addressComponent.callingCode) {
				addressC.callingCode = addressComponent.callingCode;
			}
		}
		return addressC;
	},
	
	/**
	 * Method: _analysispoiArray
	 * result节点的儿子节点
	 * 
	 * Parameters:
	 * 	poiArray
	 */
	_analysispoiArray: function(poiArray) {
		var pointFeatures = [];
		for(var i = 0,j = poiArray.length; i < j;i++) {
			var point = {};
			for(var pro in poiArray[i]) {
				point[pro] = poiArray[i][pro];
			}
			if("" != point.geometry && undefined != point.geometry){
				var geometry = this.format.read(point.geometry);
				point.geometry = this._getGeometry(geometry);
			}
			pointFeatures.push(point);
		}
		return pointFeatures;
	},
	
	/**
	 * Method: _analysisLocation
	 * result节点的儿子节点
	 * 
	 * Parameters:
	 * 	location
	 */
	_analysisLocation:function(location) {
		
	},
	
	/**
	 * Method: _getGeometry
	 * 得到openlayers几何对象
	 * 
	 * Parameters:
	 * {Object} geometry
	 */
	_getGeometry: function(geometry) {
		for(var pro in geometry) {
			//服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new OpenLayers.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				var geometry = new OpenLayers.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
				//需要增加多点类型
			}else {
				var geometry = this._geometryType[pro](geometry[pro]);
			}
			return geometry;
		}
	},
	
	/**
	 * Method: _geometryType
	 * 将几何信息的json表示转换成
	 * 
	 * Parameters:
	 * {Object} geometry
	 */	
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new OpenLayers.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new OpenLayers.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(OpenLayers.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new OpenLayers.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new OpenLayers.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new OpenLayers.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
	
	/**
     * APIProperty: failFn
     * {Function} 请求失败的回调函数，可以用自定义函数覆盖。
     */
	failFn: function(error) {
		if(typeof error == "string") {
			alert(error);
		}
		alert("对不起，查询请求失败！请检查地址匹配服务是否正常运行。\n" + 
				"当前服务地址为：" + this.url);
	},

	CLASS_NAME: "Geo.Query.GeoCodingQuery.v1" 
});/**
 * Class: Geo.Query.GeoCodingQuery.v1_0_0 
 * 地址匹配服务查询接口1.0.0版本，本类可以实现如下功能：
 * 
 * > 1.根据地址(例如：湖北省武汉市江夏区武大园一路9号)获取地理坐标(例如纬度29.58123和经度113.41321)或者执行反向转换。
 * > 2.根据地理坐标获取地址信息。
 * > 3.可以根据地名地址分类名称或者地名地址分类编码获取地名地址分类信息。
 * > 说明:本类提供的五个接口的成功回调的返回内容存在两种情况：第一：是返回json对象，第二：是返回xml串。如果返回xml串，
 * > 表示服务器内部发生错误或者客户端解析服务返回的结果时，发生了错误。
 *
 *	Inherits from:
 *  	- <Geo.Query.GeoCodingQuery.v1>
 */
Geo.Query.GeoCodingQuery.v1_0_0 = Geo.Class(Geo.Query.GeoCodingQuery.v1, {
	
	/**
     * Constructor: Geo.Query.GeoCodingQuery.v1_0_0
     * Geo.Query.GeoCodingQuery.v1_0_0类的构造函数。
     *
     * Parameters:
     * url - {String} 服务地址。
     * options - {Object} 相关属性的设置项，可选。
     * 
     * options请求参数属性可为:
     * version - {String} 服务版本。
     */
	
	/**
	 * APIMethod: addressesToLocations
	 * 根据地址匹配查询参数查询匹配的地址信息。
	 * 
	 * Parameters:
	 * options: - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * address - {String || Array(String)} (必选) 查询的地址名称集合。
	 * categoryCode - {Integer} (可选) 类别编码，该编码值可以通过获取分类的接口获取。
	 * extent - {<Geo.Bounds> | <Geo.Geometry.Polygon>} (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * fuzzyMatch - {Boolean} (可选) 是否模糊匹配，true表示精确匹配，false表示模糊匹配。默认值为false。
	 * resultType - {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * maxCount - {Integer} (可选) ：查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * startPosition - {Integer} (可选) ： 从第几条开始查询，缺省值是1。
	 * 无customWeight参数 ，1.0.0版本当前只按匹配度排序。
	 * 
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.0.0"
	 *		});
	 * 		coding.addressesToLocations({
	 *			extent:Geo.Bounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {},function() {});
	 * (end)
	 */
	addressesToLocations: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		if(typeof options.address === "string") {
			params.address = options.address;
		}else if(Geo.Util.isArray(options.address)) {
			var address = "";
			for(var i = 0; i < options.address.length;i++) {
				address += (options.address[i] + ",");
			}
			address = address.substr(0, address.length - 1);
			params.address = address;
		}else if(options.address == undefined || options.address == null) {
			throw "address是必选参数！";
		}
		if(typeof options.categoryCode === "number") {
			params.categoryCode  = options.categoryCode;
		}
		if(options.extent instanceof Geo.Bounds) {
			params.bbox = options.extent.toBBOX(null,true);
		} else if(options.extent instanceof Geo.Geometry.Polygon) {
			//params.bbox = options.extent.getComponentsString();
			var polygon = options.extent;
			var strings = [];
			for(var i=0, len=polygon.components.length; i<len; i++) {
				var items = polygon.components[i].components;
				for(var j = 0; j < items.length; j++){
					strings.push(items[j].toShortString());
				}
			}
			params.bbox = strings.join(",");
		}
		if(typeof options.fuzzyMatch === "boolean") {
			params.fuzzyMatch = options.fuzzyMatch;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
		OpenLayers.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				var GeoCodingResult = this._analysis_GeoCodeResult(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
		
	},
	
	/**
	 * APIMethod: locationToAddresses
	 * 根据位置查找匹配的地址信息。
	 * 
	 * Parameters:
	 * options: - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * lonlat - {Geo.LonLat} (必选) 位置。
	 * tolerance - {Number} (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * unit - {String} (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * resultType - {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * startPosition - {Integer} (可选) 从第几条开始查询，缺省值是1。
	 * 
	 * Example:
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.0.0"
	 *		});
	 * 		coding.locationToAddresses({
	 *			lonlat:new Geo.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			
	 *		},function() {});
	 * (end)
	 */
	locationToAddresses: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		if(options.lonlat instanceof Geo.LonLat) {
			params.latlng = options.lonlat.lat+","+options.lonlat.lon;
		}else  {
			throw "address是必选参数！请填写正确的数据类型！";
		}
		if(typeof options.tolerance === "number") {
			params.tolerance  = options.tolerance;
		}
		if(typeof options.unit === "string") {
			params.unit  = options.unit;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
		OpenLayers.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				var GeoCodingResult = this._analysis_GeoCodeResult(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
	},
	
	/**
	 * APIMethod: getLocations
	 * 根据地址匹配查询参数查询匹配的地址信息。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，{ Geo.Feature.Vector } – 地址信息要素。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * address - {String|| Array(String)} (可选) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * categoryCode - {Integer} (可选) 类别编码，该编码值可以通过获取分类的接口获取。
	 * extent - {<Geo.Bounds>} (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * resultType - {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * startPosition - {Integer} (可选) 从第几条开始查询，缺省值是1。
	 * semanticAnalysis - {Boolean} (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC" 
	 * filter - {Geo.Filter}(可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。 
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getLocations({
	 *			extent:Geo.Bounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {
	 			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 		},function() {});
	 * (end)
	 */
	getLocations: function(options, successFn, failFn){
		this.addressesToLocations(options, OpenLayers.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult,total));
		}, this), failFn)
	},
	
	/**
	 * APIMethod: getLocationsByPage
	 * 根据地址匹配查询参数查询匹配的地址信息-分页查询。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，{ Geo.Feature.Vector } – 地址信息要素。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * address - {String|| Array(String)} (可选) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * categoryCode - {Integer} (可选) 类别编码，该编码值可以通过获取分类的接口获取。
	 * extent - {<Geo.Bounds>} (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * semanticAnalysis - {Boolean} (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC" 
	 * filter - {Geo.Filter}(可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。 
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getLocationsByPage({
	 *			extent:Geo.Bounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {
	 			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 		},function() {});
	 * (end)
	 */
	getLocationsByPage: function(options, successFn, failFn){
		options.resultType = "hits";
		this.addressesToLocations(options, OpenLayers.Function.bind(function(queryResult){
			if(queryResult.status == "OK"){
				options.resultType = "result";
				var total = queryResult.results[0].count;
				if(options.maxCount == undefined || options.maxCount == null){
					options.maxCount = 3;
				}
				options.startPosition = (options.startPosition - 1) * options.maxCount + 1;
				this.addressesToLocations(options, OpenLayers.Function.bind(function(queryResult){
					successFn(this._parseQueryResultToFeature(queryResult,total));
				}, this), failFn)
			}else{
				alert("没有查询到任何数据");
				return;
			}
		}, this), failFn);
	},
	
	/**
	 * APIMethod: getAddresses
	 * 根据位置查找匹配的地址信息。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，{ Geo.Feature.Vector } – 地址信息要素。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * lonlat - {Geo.LonLat} (必选) 位置。
	 * tolerance - {Number} (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * unit - {String} (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * resultType - {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * startPosition - {Integer} (可选) 从第几条开始查询，缺省值是1。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * Example:
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getAddresses({
	 *			lonlat:new Geo.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getAddresses: function(options, successFn, failFn){
		this.locationToAddresses(options, OpenLayers.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult,total));
		}, this), failFn);
	},
	
	/**
	 * APIMethod: getAddressesByPage
	 * 根据位置查找匹配的地址信息-分页查询。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，{ Geo.Feature.Vector } – 地址信息要素。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * lonlat - {Geo.LonLat} (必选) 位置。
	 * tolerance - {Number} (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * unit - {String} (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * Example:
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getAddressesByPage({
	 *			lonlat:new Geo.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getAddressesByPage: function(options, successFn, failFn){
		options.resultType = "hits";
		this.locationToAddresses(options, OpenLayers.Function.bind(function(queryResult){
			if(queryResult.status == "OK"){
				options.resultType = "result";
				var total = queryResult.results[0].count;
				if(options.maxCount == undefined || options.maxCount == null){
					options.maxCount = 3;
				}
				options.startPosition = (options.startPosition - 1) * options.maxCount + 1;
				this.locationToAddresses(options, OpenLayers.Function.bind(function(queryResult){
					successFn(this._parseQueryResultToFeature(queryResult,total));
				}, this), failFn)
			}else{
				alert("没有查询到任何数据");
				return;
			}
		}, this), failFn);
	},
	
	/**
	 * Method: _parseQueryResultToFeature
	 * 根据地址/坐标匹配查询结果解析为包含状态和feature数组的对象
	 * 
	 * Parameters:
	 * params {Object} 键值对
	 *
	 * Returns:
	 * {Object} 包含状态和feature数组的对象
	 */
	_parseQueryResultToFeature: function(queryResult){
		var features = [];
		if(queryResult.status == "OK"){
			if(queryResult.results){
				for(var i = 0; i < queryResult.results.length; i++){
					var result = queryResult.results[i].result;
					if(result){
						for(var j = 0; j < result.length; j++){
							var attribute = {};
							var geometry = null;
							attribute.requestKeyWord = queryResult.results[i].requestKeyWord;
							
							if(Geo.Util.isArray(result[j].poiArray)){
								for(var k = 0; k < result[j].poiArray.length; k++){
									attribute.CONTINENT = result[j].poiArray[k].CONTINENT;
									attribute.GBCODE = result[j].poiArray[k].GBCODE;
									attribute.STANDARDNAME = result[j].poiArray[k].STANDARDNAME;
									attribute.name = result[j].poiArray[k].name;
								}
							}
							if(result[j].addressComponent){
								var addressComponent = result[j].addressComponent;
								attribute.address = this._getAddress(addressComponent, attribute.name);
								attribute.country = result[j].addressComponent.country;
								attribute.province = result[j].addressComponent.province;
								attribute.city = result[j].addressComponent.city;
								attribute.district = result[j].addressComponent.district;
								if(result[j].addressComponent.street){
									attribute.streetName = result[j].addressComponent.street.name;
								}else{
									attribute.streetName = "";
								}
								attribute.streetNumber = result[j].addressComponent.streetNumber;
							}
							if(result[j].location){
								if(result[j].location.lng){
									attribute.lng = result[j].location.lng;
								}
								if(result[j].location.lat){
									attribute.lat = result[j].location.lat;
								}
								geometry = new Geo.Geometry.Point(result[j].location.lng, result[j].location.lat);
							}
							
							attribute.isBrief = result[j].isBrief;
							attribute.precise = result[j].precise;
							attribute.resultType = result[j].resultType;
							attribute.score = result[j].score;
							//创建feature
							var feature = new Geo.Feature.Vector(geometry,attribute);
							features.push(feature);
						}
					}
				}
			}
		}
		return {
			status: queryResult.status,
			features: features
		};
	},
	
	/**
     * Method: _getAddress
     * 拼装详细地址。
     *
     * Parameters: 
	 * addressComponent - {Object} 地址对象。
     * name - {String} 名称。
     *
     * Returns:
     * {String} 详细地址。
     */
	_getAddress: function(addressComponent, name){
		var address = "";
		if(addressComponent["country"]){
			address += addressComponent["country"];
		}
		if(addressComponent["province"]){
			address += addressComponent["province"];
		}
		if(addressComponent["city"]){
			address += addressComponent["city"];
		}
		if(addressComponent["district"]){
			address += addressComponent["district"];
		}
		if(addressComponent["street"]){
			if(addressComponent["street"]["name"]){
				address += addressComponent["street"]["name"];
			}
			/*if(addressComponent["street"]["streetNumber"]){
				address += addressComponent["street"]["streetNumber"]+"号";//门牌号
			}*/
			if(addressComponent["streetNumber"]){
				address += addressComponent["streetNumber"]+"号";//门牌号
			}
		}
		if(name){ //名称
			address += name;
		}
		return address
	},
	
	CLASS_NAME: "Geo.Query.GeoCodingQuery.v1_0_0" 
});/**
 * Class: Geo.Query.GeoCodingQuery.v1_1_0
 * 地址匹配服务查询接口1.1.0版本，本类可以实现如下功能：
 * 
 * > 1.根据地址(例如：湖北省武汉市江夏区武大园一路9号)获取地理坐标(例如纬度29.58123 和经度113.41321)或者执行反向转换。
 * > 2.根据地理坐标获取地址信息。
 * > 3.可以根据地名地址分类名称或者地名地址分类编码获取地名地址分类信息。
 * > 4.可以根据多个地址信息查询到地理坐标信息。
 * > 5.可以根据多个地理坐标值获取地址信息。
 * > 说明:本类提供的五个接口的成功回调的返回内容存在两种情况：第一：是返回json对象，第二：是返回xml串。如果返回xml串，
 * > 表示服务器内部发生错误或者客户端解析服务返回的结果时，发生了错误。
 *
 *	Inherits from:
 *  	- <Geo.Query.GeoCodingQuery.v1>
 */
Geo.Query.GeoCodingQuery.v1_1_0 = Geo.Class(Geo.Query.GeoCodingQuery.v1, {
	
	/**
	 * APIProperty: method
	 * 数据请求方式，默认值是"get"。
	 */
	method: "get",
	
	/**
     * Constructor: Geo.Query.GeoCodingQuery.v1_1_0
     * Geo.Query.GeoCodingQuery.v1_1_0类的构造函数。
     *
     * Parameters:
     * url - {String} 服务地址。
     * options - {Object} 相关属性的设置项，可选。
     * 
     * options请求参数属性可为:
     * version - {String} 服务版本。
     */
	initialize: function(url, options){
		OpenLayers.Util.extend(this,options);
		this.filterFormat = new OpenLayers.Format.Filter();
		Geo.Query.GeoCodingQuery.v1.prototype.initialize.apply(this, arguments);  
	},
	
	/**
	 * APIMethod: addressesToLocations
	 * 根据地址匹配查询参数查询匹配的地址信息。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * address - {String|| Array(String)} (可选，address和categoryCode必选一) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * categoryCode - {Integer} (可选，address和categoryCode必选一) 类别编码，该编码值可以通过获取分类的接口获取。
	 * extent - {<Geo.Bounds> | <Geo.Geometry.Polygon>} (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * resultType - {String} (可选) 返回匹配结果的类型。 可供选择的值：(1)hits：返回匹配结果的总数；(2)result：返回匹配结果；(3)statistics：统计结果值。缺省值：result。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * startPosition - {Integer} (可选) 从第几条开始查询，缺省值是1。
	 * semanticAnalysis - {Boolean} (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC" 
	 * filter - {Geo.Filter}(可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。 
	 * statisticsLevel - {Integer} (可选) 统计级别。可供选择的值：1(省级)；2(市(县)级)；3(区级)。默认值为2。
	 * customWeight - {Boolean} (可选) 是否启动自定义权重排序，缺省为true。如设置为false，则按匹配度排序。
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.addressesToLocations({
	 *			extent:Geo.Bounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {},function() {});
	 * (end)
	 */
	addressesToLocations: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		params.reverseMatch = false;
		if(typeof options.address === "string") {
			params.keyword = options.address;
		}
		if(typeof options.categoryCode === "number") {
			params.categoryCode  = options.categoryCode;
		}
		if((options.address == undefined || options.address == null) && 
				(options.categoryCode == undefined || options.categoryCode == null)) {
			throw "address是必选参数！";
		}
		if(options.extent instanceof Geo.Bounds) {
			params.bbox = options.extent.toBBOX(null,true);
		} else if(options.extent instanceof Geo.Geometry.Polygon) {
			//params.bbox = options.extent.getComponentsString();
			var polygon = options.extent;
			var strings = [];
			for(var i=0, len=polygon.components.length; i<len; i++) {
				var items = polygon.components[i].components;
				for(var j = 0; j < items.length; j++){
					strings.push(items[j].toShortString());
				}
			}
			params.bbox = strings.join(",");
		}
		if(options.filter instanceof Geo.Filter) {
			var domFilter = this.filterFormat.write(options.filter);
			var filterStr = OpenLayers.Format.XML.prototype.write.apply(
				this.filterFormat, [domFilter]
			);
			params.filter = filterStr;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(options.resultType == "statistics") {
			params.statisticsLevel = options.statisticsLevel;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
		if(typeof options.semanticAnalysis  === "boolean") {
			params.semanticAnalysis = options.semanticAnalysis;
		}
		if(typeof options.customWeight  === "boolean") {
			params.customWeight = options.customWeight;
		}
		this._setGeoCoderCommonProperty(params,options);
		this._getCodingRequest(params,successFn,failFn);
		
	},
	
	/**
	 * Method: _getCodingRequest
	 * 
	 * Parameters:
	 * 	params {Object} 键值对
	 * 	successFn {Function} 成功回调
	 * 	failFn {Function} 失败回调
	 */
	_getCodingRequest: function(params,successFn,failFn) {
		if(this.method == "get") {
			OpenLayers.loadURL(this.url,params,this,function(result) {
				try{
					var json = this.format.read(result.responseText);
					var GeoCodingResult = this._analysis_GeoCodeResult(json);
				}catch(e) {
					successFn(result.responseText);
					return;
				}
				successFn(GeoCodingResult);
			},this.failFn);
		}else {
			var paramsStr = OpenLayers.Util.getParameterString(params);
			OpenLayers.Request.POST({
	            url: this.url,
	            data: paramsStr,
	            success: function(result) {
					try{
						var json = this.format.read(result.responseText);
						var GeoCodingResult = this._analysis_GeoCodeResult(json);
					}catch(e) {
						successFn(result.responseText);
						return;
					}
					successFn(GeoCodingResult);
				},
	            failure: this.failFn,
	            scope: this
	        });
		}
	},
	
	/**
	 * Method: _setGeoCoderCommonProperty
	 * 
	 * Parameters:
	 * 	params {Object} 键值对
	 * 	options
	 */
	_setGeoCoderCommonProperty: function(params,options) {
		if(typeof options.sortFields  === "string") {
			params.sortFields = options.sortFields;
		}
		if(typeof options.scoreFilter  === "string") {
			params.scoreFilter = options.scoreFilter;
		}
	},
	
	/**
	 * APIMethod: locationToAddresses
	 * 根据位置查找匹配的地址信息。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * lonlat - {<Geo.LonLat>} (必选) 位置。
	 * tolerance - {Number} (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * unit - {String} (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * resultType - {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * startPosition - {Integer} (可选) 从第几条开始查询，缺省值是1。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * 
	 * Example:
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.locationToAddresses({
	 *			lonlat:new Geo.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			
	 *		},function() {});
	 * (end)
	 */
	locationToAddresses: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		params.reverseMatch = true;
		if(options.lonlat instanceof Geo.LonLat) {
			params.keyword = options.lonlat.lat+","+options.lonlat.lon;
		}else  {
			throw "address是必选参数！请填写正确的数据类型！";
		}
		if(typeof options.tolerance === "number") {
			params.tolerance  = options.tolerance;
		}
		if(typeof options.unit === "string") {
			params.unit  = options.unit;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(options.resultType == "statistics") {
			params.statisticsLevel = options.statisticsLevel;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
		if(typeof options.customWeight  === "boolean") {
			params.customWeight = options.customWeight;
		}
		this._setGeoCoderCommonProperty(params,options);
		this._getCodingRequest(params,successFn,failFn);
	},
	
	/**
	 * APIMethod: batchAddressesToLocations
	 * 根据一到多个地址查询坐标位置信息。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * address - {Array(String)} (必选) 查询的地址名称集合。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"
	 * filter - {<Geo.Filter>}(可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95
	 * singleKeywordResultCount - {Integer} (可选) 单个关键字匹配地址个数，用于限制服务返回的匹配结果数,默认值为1。
	 * 
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.batchAddressesToLocations({
	 *			address:["小学"],
	 *			singleKeywordResultCount:2,
	 *			sortFields:"address.desc",
	 *			scoreFilter:"0<=score<=88"
	 *		
	 *		},function(GeoCodingResult) {
	 *			
	 *		},function() {});
	 * (end)
	 */
	batchAddressesToLocations: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "BatchGeoCoder",
			service:"GeoCoding"
		});
		params.reverseMatch = false;
		if(Geo.Util.isArray(options.address)) {
			var address = "";
			for(var i = 0; i < options.address.length;i++) {
				address += (options.address[i] + ",");
			}
			address = address.substr(0, address.length - 1);
			params.keywords = address;
		}else if(options.address == undefined || options.address == null) {
			throw "address是必选参数！";
		}
		if(typeof options.singleKeywordResultCount === "number") {
			params.singleKeywordResultCount  = options.singleKeywordResultCount;
		}
		if(options.filter instanceof Geo.Filter) {
			var domFilter = this.filterFormat.write(options.filter);
			var filterStr = OpenLayers.Format.XML.prototype.write.apply(
				this.filterFormat, [domFilter]
			);
			params.filter = filterStr;
		}
		this._setGeoCoderCommonProperty(params,options);
		this._getCodingRequest(params,successFn,failFn);
		/*
		OpenLayers.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				var GeoCodingResult = this._analysis_GeoCodeResult(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
		*/
	},
	
	/**
	 * APIMethod: batchLocationToAddresses
	 * 根据多个坐标位置查找匹配的地址信息。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * lonlats - {Array(<Geo.LonLat>)} (必选) 坐标位置数组。
	 * tolerance - {Number} (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * unit - {String} (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * singleKeywordResultCount - {Integer} (可选) 单个关键字匹配地址个数，用于限制服务返回的匹配结果数,默认值为1。
	 *   
	 * Example:
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.batchLocationToAddresses({
	 *			lonlats:[new Geo.LonLat(123.43888042, 41.759929371),new Geo.LonLat(123.423848649, 41.771748608)],
	 *			singleKeywordResultCount:2,
	 *			tolerance:0.5,
	 *			unit:"degree",
	 *			sortFields:"address.desc",
	 *			scoreFilter:"0<=score<=88"
	 *		
	 *		},function(GeoCodingResult) {
	 *
	 *		},function() {});
	 * (end)
	 */
	batchLocationToAddresses: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "BatchGeoCoder",
			service:"GeoCoding"
		});
		params.reverseMatch = true;
		if(options.lonlats instanceof Geo.LonLat) {
			options.lonlats = [options.lonlats];
		//	params.keywords = options.lonlat.lat+","+options.lonlat.lon;
		}else  if(!OpenLayers.Util.isArray(options.lonlats)) {
			throw "address是必选参数！请填写正确的数据类型！";
		}
		if(Geo.Util.isArray(options.lonlats)) {
			var lonlatsStr = "";
			for(var i = 0; i < options.lonlats.length;i++) {
				lonlatsStr += options.lonlats[i].lat+","+options.lonlats[i].lon+";";
			}
			lonlatsStr = lonlatsStr.substr(0, lonlatsStr.length - 1);
			params.keywords = lonlatsStr;
		}
		if(typeof options.tolerance === "number") {
			params.tolerance  = options.tolerance;
		}
		if(typeof options.unit === "string") {
			params.unit  = options.unit;
		}
		if(typeof options.singleKeywordResultCount === "number") {
			params.singleKeywordResultCount  = options.singleKeywordResultCount;
		}
		this._setGeoCoderCommonProperty(params,options);
		this._getCodingRequest(params,successFn,failFn);
		/*
		OpenLayers.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				var GeoCodingResult = this._analysis_GeoCodeResult(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
		*/
	},
	
	/**
     * Method: _getAddress
     * 拼装详细地址。
     *
     * Parameters: 
	 * addressComponent - {Object} 地址对象。
     * name - {String} 名称。
     *
     * Returns:
     * {String} 详细地址。
     */
	_getAddress: function(addressComponent, name){
		var address = "";
		if(addressComponent["country"]){
			address += addressComponent["country"];
		}
		if(addressComponent["province"]){
			address += addressComponent["province"];
		}
		if(addressComponent["city"]){
			address += addressComponent["city"];
		}
		if(addressComponent["district"]){
			address += addressComponent["district"];
		}
		if(addressComponent["street"]){
			if(addressComponent["street"]["name"]){
				address += addressComponent["street"]["name"];
			}
			/*if(addressComponent["street"]["streetNumber"]){
				address += addressComponent["street"]["streetNumber"]+"号";//门牌号
			}*/
			if(addressComponent["streetNumber"]){
				address += addressComponent["streetNumber"]+"号";//门牌号
			}
		}
		if(name){ //名称
			address += name;
		}
		return address
	},
	
	
	/**
	 * APIMethod: getLocations
	 * 根据地址匹配查询参数查询匹配的地址信息。成功回调返回的结果数据为地址信息要素({<Geo.Feature.Vector>})。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，{<Geo.Feature.Vector>} – 地址信息要素。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * address - {String|| Array(String)} (可选，address和categoryCode必选一) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * categoryCode - {Integer} (可选，address和categoryCode必选一) 类别编码，该编码值可以通过获取分类的接口获取。
	 * extent - {<Geo.Bounds>} (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * resultType - {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * startPosition - {Integer} (可选) 从第几条开始查询，缺省值是1。
	 * semanticAnalysis - {Boolean} (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC" 
	 * filter - {<Geo.Filter>}(可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。 
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getLocations({
	 *			extent:Geo.Bounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getLocations: function(options, successFn, failFn){
		this.addressesToLocations(options, OpenLayers.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult,total));
		}, this), failFn)
	},
	
	/**
	 * APIMethod: getLocationsByPage
	 * 根据地址匹配查询参数查询匹配的地址信息-分页查询。成功回调返回的结果数据为地址信息要素({<Geo.Feature.Vector>})。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，{<Geo.Feature.Vector>} – 地址信息要素。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * address - {String|| Array(String)} (可选，address和categoryCode必选一) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * categoryCode - {Integer} (可选，address和categoryCode必选一) 类别编码，该编码值可以通过获取分类的接口获取。
	 * extent - {<Geo.Bounds>} (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * semanticAnalysis - {Boolean} (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC" 
	 * filter - {<Geo.Filter>}(可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。 
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getLocationsByPage({
	 *			extent:Geo.Bounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getLocationsByPage: function(options, successFn, failFn){
		options.resultType = "hits";
		this.addressesToLocations(options, OpenLayers.Function.bind(function(queryResult){
			if(queryResult.status == "OK"){
				options.resultType = "result";
				var total = queryResult.results[0].count;
				if(options.maxCount == undefined || options.maxCount == null){
					options.maxCount = 3;
				}
				options.startPosition = (options.startPosition - 1) * options.maxCount + 1;
				this.addressesToLocations(options, OpenLayers.Function.bind(function(queryResult){
					successFn(this._parseQueryResultToFeature(queryResult,total));
				}, this), failFn)
			}else{
				alert("没有查询到任何数据");
				return;
			}
		}, this), failFn);
	},
	
	/**
	 * APIMethod: getAddresses
	 * 根据位置查找匹配的地址信息。成功回调返回的结果数据为地址信息要素({<Geo.Feature.Vector>})。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，{<Geo.Feature.Vector>} – 地址信息要素。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * lonlat - {<Geo.LonLat>} (必选) 位置。
	 * tolerance - {Number} (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * unit - {String} (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * resultType - {String} (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * startPosition - {Integer} (可选) 从第几条开始查询，缺省值是1。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * Example:
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getAddresses({
	 *			lonlat:new Geo.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getAddresses: function(options, successFn, failFn){
		this.locationToAddresses(options, OpenLayers.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult,total));
		}, this), failFn);
	},
	
	/**
	 * APIMethod: getAddressesByPage
	 * 根据位置查找匹配的地址信息-分页查询。成功回调返回的结果数据为地址信息要素({<Geo.Feature.Vector>})。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，{<Geo.Feature.Vector>} – 地址信息要素。
	 * failFn - {Function} 请求失败的回调函数。 
	 * 
	 * options请求参数属性可为:
	 * lonlat - {<Geo.LonLat>} (必选) 位置。
	 * tolerance - {Number} (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * unit - {String} (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * maxCount - {Integer} (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * Example:
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getAddressesByPage({
	 *			lonlat:new Geo.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getAddressesByPage: function(options, successFn, failFn){
		options.resultType = "hits";
		this.locationToAddresses(options, OpenLayers.Function.bind(function(queryResult){
			if(queryResult.status == "OK"){
				options.resultType = "result";
				var total = queryResult.results[0].count;
				if(options.maxCount == undefined || options.maxCount == null){
					options.maxCount = 3;
				}
				options.startPosition = (options.startPosition - 1) * options.maxCount + 1;
				this.locationToAddresses(options, OpenLayers.Function.bind(function(queryResult){
					successFn(this._parseQueryResultToFeature(queryResult,total));
				}, this), failFn)
			}else{
				alert("没有查询到任何数据");
				return;
			}
		}, this), failFn);
	},
	
	/**
	 * APIMethod: batchGetAddresses
	 * 根据多个坐标位置查找匹配的地址信息。成功回调返回的结果数据为地址信息要素({<Geo.Feature.Vector>})。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，{<Geo.Feature.Vector>} – 地址信息要素。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * lonlats - {Array(<Geo.LonLat>)} (必选) 坐标位置数组。
	 * tolerance - {Number} (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * unit - {String} (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * singleKeywordResultCount - {Integer} (可选) 单个关键字匹配地址个数，用于限制服务返回的匹配结果数,默认值为1。
	 *   
	 * Example:
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.batchGetAddresses({
	 *			lonlats:[new Geo.LonLat(123.43888042, 41.759929371),new Geo.LonLat(123.423848649, 41.771748608)],
	 *			singleKeywordResultCount:2,
	 *			tolerance:0.5,
	 *			unit:"degree",
	 *			sortFields:"address.desc",
	 *			scoreFilter:"0<=score<=88"
	 *		
	 *		},function(GeoCodingResult) {
	 *			//返回值 GeoCodingResult - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	batchGetAddresses: function(options, successFn, failFn){
		this.batchLocationToAddresses(options, OpenLayers.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult));
		}, this), failFn);
	},
	
	/**
	 * APIMethod: batchGetLocations
	 * 根据一到多个地址查询坐标位置信息。成功回调返回的结果数据为地址信息要素({<Geo.Feature.Vector>})。
	 * 
	 * Parameters:
	 * options - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，{ Geo.Feature.Vector } – 地址信息要素。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * address - {Array(String)} (必选) 查询的地址名称集合。
	 * sortFields - {String} (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"
	 * filter - {<Geo.Filter>}(可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * scoreFilter - {String} (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95
	 * singleKeywordResultCount - {Integer} (可选) 单个关键字匹配地址个数，用于限制服务返回的匹配结果数,默认值为1。
	 * 
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new Geo.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.batchGetLocations({
	 *			address:["小学"],
	 *			singleKeywordResultCount:2,
	 *			sortFields:"address.desc",
	 *			scoreFilter:"0<=score<=88"
	 *		
	 *		},function(GeoCodingResult) {
	 *			//返回值 GeoCodingResult - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	batchGetLocations: function(options, successFn, failFn){
		this.batchAddressesToLocations(options, OpenLayers.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult));
		}, this), failFn);
	},
	
	/**
	 * Method: _parseQueryResultToFeature
	 * 根据地址/坐标匹配查询结果解析为包含状态和feature数组的对象。
	 * 
	 * Parameters:
	 * params {Object} 键值对
	 *
	 * Returns:
	 * {Object} 包含状态和feature数组的对象
	 */
	_parseQueryResultToFeature: function(queryResult){
		var features = [];
		if(queryResult.status == "OK"){
			if(queryResult.results){
				for(var i = 0; i < queryResult.results.length; i++){
					var result = queryResult.results[i].result;
					if(result){
						for(var j = 0; j < result.length; j++){
							var attribute = {};
							var geometry = null;
							attribute.requestKeyWord = queryResult.results[i].requestKeyWord;
							
							if(Geo.Util.isArray(result[j].poiArray)){
								for(var k = 0; k < result[j].poiArray.length; k++){
									attribute.CONTINENT = result[j].poiArray[k].CONTINENT;
									attribute.GBCODE = result[j].poiArray[k].GBCODE;
									attribute.STANDARDNAME = result[j].poiArray[k].STANDARDNAME;
									attribute.name = result[j].poiArray[k].name;
								}
							}
							if(result[j].addressComponent){
								var addressComponent = result[j].addressComponent;
								attribute.address = this._getAddress(addressComponent, attribute.name);
								attribute.country = result[j].addressComponent.country;
								attribute.province = result[j].addressComponent.province;
								attribute.city = result[j].addressComponent.city;
								attribute.district = result[j].addressComponent.district;
								if(result[j].addressComponent.street){
									attribute.streetName = result[j].addressComponent.street.name;
								}else{
									attribute.streetName = "";
								}
								attribute.streetNumber = result[j].addressComponent.streetNumber;
							}
							if(result[j].location){
								if(result[j].location.lng){
									attribute.lng = result[j].location.lng;
								}
								if(result[j].location.lat){
									attribute.lat = result[j].location.lat;
								}
								geometry = new Geo.Geometry.Point(result[j].location.lng, result[j].location.lat);
							}
							
							attribute.isBrief = result[j].isBrief;
							attribute.precise = result[j].precise;
							attribute.resultType = result[j].resultType;
							attribute.score = result[j].score;
							//创建feature
							var feature = new Geo.Feature.Vector(geometry,attribute);
							features.push(feature);
						}
					}
				}
			}
		}
		return {
			status: queryResult.status,
			features: features
		};
	},
	
	CLASS_NAME: "Geo.Query.GeoCodingQuery.v1_1_0" 
});/**
 * Class: Geo.Query.GEFSQuery
 * 地理实体融合查询服务类。默认版本是1.0.0。
 *
 * 例子:
 * (code)
 *     	var coding = new Geo.Query.GEFSQuery("http://192.168.235.142:20009/ronghefuwu2045/gefs", {
 *			version:"1.1.0"
 *		});
 * (end)
 */
Geo.Query.GEFSQuery = function(url, options) {
    options = OpenLayers.Util.applyDefaults(
        options, Geo.Query.GEFSQuery.DEFAULTS
    );
    var cls = Geo.Query.GEFSQuery["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "不支持的地理实体融合查询服务版本: " + options.version;
    }
    return new cls(url, options);
};

Geo.Query.GEFSQuery.DEFAULTS = {
    "version": "1.0.0"
};/**
 * Class: Geo.Query.GEFSQuery.v1
 * 吉奥地理实体融合服务查询接口的抽象类。
 */
Geo.Query.GEFSQuery.v1 = Geo.Class({
	
	/**
	 * APIProperty: version
	 * 服务版本，默认值是"1.0.0"。
	 */
	version: "1.0.0",
	
	/**
     * APIProperty: url
     * {String}服务地址。
     */
	url: null,
	
	/**
     * APIProperty: serviceName
     * {String}服务地址。
     */
	serviceName: "GeoEntityFuseService",
	
	/**
     * Constructor: Geo.Query.GEFSQuery.v1
     * Geo.Query.GEFSQuery.v1类的构造函数。
     *
     * Parameters:
     * url - {String} 服务地址。
     * options - {Object} 相关属性的设置项，可选。
     * 
     * options请求参数属性可为:
     * version - {String} 服务版本。
     */
	initialize: function(url, options){
		this.url = url;
		OpenLayers.Util.extend(this,options);
		this.format = new Geo.Format.JSON();
	},
	
	/**
	 * Method: getCommonParams
	 * 获取公共的参数
	 * 
	 * Parameters:
	 * 	options
	 */
	getCommonParams: function(options) {
		var params = {
			request: ""
			//service: "GeoCoding",
			//version: this.version,
			//output: "json"
		};
		OpenLayers.Util.extend(params,options);
		return params;
	},
	
	/**
     * APIProperty: failFn
     * {Function} 请求失败的回调函数，可以用自定义函数覆盖。
     */
	failFn: function(error) {
		if(typeof error == "string") {
			alert(error);
		}
		alert("对不起，查询请求失败！请检查地理实体融合查询服务是否正常运行。\n" + 
				"当前服务地址为：" + this.url);
	},

	CLASS_NAME: "Geo.Query.GEFSQuery.v1" 
});/**
 * Class: Geo.Query.GEFSQuery.v1_0_0 
 * 地理实体融合服务查询类
 *
 *	Inherits from:
 *  	- <Geo.Query.GEFSQuery.v1>
 */
Geo.Query.GEFSQuery.v1_0_0 = Geo.Class(Geo.Query.GEFSQuery.v1, {
	
	x2jsFormat: null,
	
	gmlFormat: null,
	
	/**
     * Constructor: Geo.Query.GEFSQuery.v1_0_0
     * Geo.Query.GEFSQuery.v1_0_0类的构造函数。
     *
     * Parameters:
     * url - {String} 服务地址。
     * options - {Object} 相关属性的设置项，可选。
     * 
     * options请求参数属性可为:
     * version - {String} 服务版本。
     */
	initialize: function(url, options){
		OpenLayers.Util.extend(this, options);
		this.x2jsFormat = new Geo.Util.Format.X2JS();
		this.gmlFormat = new Geo.Format.GML();
		Geo.Query.GEFSQuery.v1.prototype.initialize.apply(this, arguments);  
	},
	
	/**
	 * APIMethod: queryEntity
	 * 根据地理实体查询参数查询出地理实体信息。
	 * 
	 * Parameters:
	 * options: - {Object} 请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，TODO。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * address - {String} (可选) 查询的标准地址。与extent参数不能一起联合查询（服务接口对应的参数名为：Address）
	 * entityCode - {String} (可选) 实体编码。与extent参数可一起联合查询（服务接口对应的参数名为：EntityCode）
	 * entityName - {String} (可选) 实体名称。该参数暂时无效。（服务接口对应的参数名为：EntityName）
	 * extent - {<Geo.Bounds>} (可选) 查询的空间坐标范围。缺省情况无查询范围限制。（使用extent参数，则不能使用address进行查询）（服务接口对应的参数名为：BBox。//1,2,5,6 Xmin,Ymin,Xmax,Ymax顺序）
	 * startIndex - {Integer} (可选) ：从索引为第几条开始查询，缺省值是0。（服务接口对应的参数名为：StartIndex）
	 * maxCount - {Integer} (可选) ：查询多少条数据。缺省情况是查询满足条件的10条结果。（服务接口对应的参数名为：EndIndex）
	 * 
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new Geo.Query.GEFSQuery("http://192.168.235.142:20009/ronghefuwu2045/gefs", {
	 *			version:"1.0.0"
	 *		});
	 * 		coding.queryEntity({
	 *			extent: Geo.Bounds.fromString("114.34976995289436,30.52757410050006,114.35976995289436,30.53757410050006"),
	 *			entityName: "群光广场"
	 *		},function(result) {},function() {});
	 * (end)
	 */
	queryEntity: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GetGeoEntityInfo"
		});
		if(typeof options.address === "string") {
			params.address = options.address;
		}
		if(typeof options.entityCode === "string") {
			params.entityCode  = options.entityCode;
		}
		if(options.extent instanceof Geo.Bounds) {
			params.bbox = options.extent.toBBOX(null);
		}
		if(typeof options.startIndex  === "number") {
			params.startIndex = options.startIndex;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		//处理请求的参数，转为XML字符串
		var json = this._buildQEQueryJsonParam(params);
		var paramsXMLStr = this.x2jsFormat.json2xml_str(json);
		OpenLayers.Request.POST({
            url: this.url + "?REQUEST=" + params.request,
            data: paramsXMLStr,
            success: function(result) {
				if(result.responseText !== ""){
					var json = this.x2jsFormat.xml_str2json(result.responseText);
					if (!OpenLayers.Util.isArray(json.entitys.entity)) {
						//不存在则为空数组
						if(!json.entitys.entity){
							json.entitys.entity = [];
						}else{
							json.entitys.entity = [json.entitys.entity];
						}
					}
					var responseJson = json.entitys;
					successFn(responseJson);
				}else{
					successFn(result.responseText);
				}
			},
            failure: this.failFn,
            scope: this
        });
	},
	
	/**
	 * APIMethod: queryEntityByLonLat
	 * 根据坐标对组参数查询出地理实体信息。
	 * 
	 * Parameters:
	 * options: - {Object} 请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，TODO。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * lonlat - {Geo.LonLat | Array(<Geo.LonLat>)} (必选) 位置。（服务接口对应的参数名为：Coordinates）
	 * pids - {String | Array(<String>)} (可选) 与参数lonlat个数相同，用于关联lonlat参数内的坐标对象。服务返回的数据也会包含与此pid，目的是关联参数中的某个坐标。
	 * distance - {Float} (可选) ：缺省值是0.001。（服务接口对应的参数名为：Distance）
	 * startIndex - {Integer} (可选) ：从索引为第几条开始查询，缺省值是0。（服务接口对应的参数名为：StartIndex）
	 * maxCount - {Integer} (可选) ：查询多少条数据。缺省情况是查询满足条件的10条结果。（服务接口对应的参数名为：EndIndex）
	 * 
	 * Example:
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new Geo.Query.GEFSQuery("http://192.168.235.142:20009/ronghefuwu2045/gefs", {
	 *			version:"1.0.0"
	 *		});
	 * 		coding.queryEntityByLonLat({
	 *			lonlat: new Geo.LonLat("114.34976995289436,30.52757410050006"),
	 *			startIndex: 0,
	 *			maxCount: 20
	 *		},function(result) {},function() {});
	 * (end)
	 */
	queryEntityByLonLat: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GetGeoEntityInfo"
		});
		//处理lonlat参数
		if(options.lonlat == undefined || options.lonlat == null) {
			//alert("lonlat是必选参数！");
			throw "lonlat是必选参数！";
		}
		if (!(OpenLayers.Util.isArray(options.lonlat))) {
            options.lonlat = [options.lonlat];
        }
		if(options.lonlat.length == 0){
			throw "lonlat必需包含至少有一个Geo.LonLat类型的对象！";
		}
		if(options.lonlat[0] instanceof Geo.LonLat) {
			params.lonlat = options.lonlat;
		}else{
			throw "lonlat必需是Geo.LonLat类型！";
		}
		//if(!options.lonlat[0].lon || !options.lonlat[0].lat){
		//	throw "lonlat参数对应的Geo.LonLat对象坐标值不能为空值！";
		//}
		
		//处理pids参数
		if (!(OpenLayers.Util.isArray(options.pids))) {
            options.pids = [options.pids];
        }
		params.pids = options.pids;
		
		//处理distance参数
		if(typeof options.distance  === "number") {
			params.distance = options.distance;
		}
		//处理startIndex参数
		if(typeof options.startIndex  === "number") {
			params.startIndex = options.startIndex;
		}
		//处理maxCount参数
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		//处理请求的参数，转为XML字符串
		var json = this._buildQEByLonLatQueryJsonParam(params);
		var paramsXMLStr = this.x2jsFormat.json2xml_str(json);
		OpenLayers.Request.POST({
            url: this.url + "?REQUEST=" + params.request,
            data: paramsXMLStr,
            success: function(result) {
				var json = this.x2jsFormat.xml_str2json(result.responseText);
				if (!OpenLayers.Util.isArray(json.entitys.entity)) {
					//不存在则为空数组
					if(!json.entitys.entity){
						json.entitys.entity = [];
					}else{
						json.entitys.entity = [json.entitys.entity];
					}
				}
				var responseJson = json.entitys;
				successFn(responseJson);
			},
            failure: this.failFn,
            scope: this
        });
	},
	
	/**
	 * APIMethod: queryFuseTheme
	 * 根据地理实体查询参数查询地理实体融合信息。
	 * 
	 * Parameters:
	 * options: - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * entityCode - {String} (必选) 实体编码。与extent参数可一起联合查询（服务接口对应的参数名为：EntityCode）
	 * extent - {<Geo.Bounds>} (可选) 查询的空间坐标范围。缺省情况无查询范围限制。（服务接口对应的参数名为：BBox。//1,2,5,6 Xmin,Ymin,Xmax,Ymax顺序）
	 * startIndex - {Integer} (可选) ：从索引为第几条开始查询，缺省值是0。（服务接口对应的参数名为：StartIndex）
	 * maxCount - {Integer} (可选) ：查询多少条数据。缺省情况是查询满足条件的10条结果。（服务接口对应的参数名为：EndIndex）
	 * 
	 * Example:
	 * (code)
	 * 
	 * (end)
	 */
	queryFuseTheme: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GetGeoEntityFuseInfo"
		});
		
		//处理entityCode参数
		if(typeof options.entityCode === "string" && options.entityCode !== "") {
			params.entityCode = options.entityCode;
		}else {
			throw "entityCode是必选参数！请填写正确的数据类型<string>！";
		}
		//处理extent参数
		if(options.extent instanceof Geo.Bounds) {
			params.bbox = options.extent.toBBOX(null);
		}
		//处理startIndex参数
		if(typeof options.startIndex  === "number") {
			params.startIndex = options.startIndex;
		}
		//处理maxCount参数
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		//处理请求的参数，转为XML字符串
		var json = this._buildQFTQueryJsonParam(params);
		var paramsXMLStr = this.x2jsFormat.json2xml_str(json);
		OpenLayers.Request.POST({
            url: this.url + "?REQUEST=" + params.request,
            data: paramsXMLStr,
            success: function(result) {
				var json = this.x2jsFormat.xml_str2json(result.responseText);
				if (!OpenLayers.Util.isArray(json.themes.theme)) {
					//不存在则为空数组
					if(!json.themes.theme){
						json.themes.theme = [];
					}else{
						json.themes.theme = [json.themes.theme];
					}
		        }
				var responseJson = json.themes;
				successFn(responseJson);
			},
            failure: this.failFn,
            scope: this
        });
	},
	
	/**
	 * APIMethod: queryFuseThemeFeatures
	 * 根据地理实体专题名称，查询地理实体融合信息。
	 * 
	 * Parameters:
	 * options: - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * theme - {String} (必选) 主题名称。与extent参数可一起联合查询（服务接口对应的参数名为：Theme）
	 * entityCode - {String} (可选) 实体编码。（服务接口对应的参数名为：EntityCode）
	 * startIndex - {Integer} (可选) ：从索引为第几条开始查询，缺省值是0。（服务接口对应的参数名为：StartIndex）
	 * maxCount - {Integer} (可选) ：查询多少条数据。缺省情况是查询满足条件的10条结果。（服务接口对应的参数名为：EndIndex）
	 * 
	 */
	queryFuseThemeFeatures: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GetGeoEntityFuseInfo"
		});
		
		//处理theme参数
		if(typeof options.theme  === "string" && options.theme !== "") {
			params.theme = options.theme;
		}else {
			throw "theme是必选参数！请填写正确的数据类型<string>！";
		}
		//处理entityCode参数
		if(typeof options.entityCode === "string") {
			params.entityCode = options.entityCode;
		}
		//处理startIndex参数
		if(typeof options.startIndex  === "number") {
			params.startIndex = options.startIndex;
		}
		//处理maxCount参数
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		//处理请求的参数，转为XML字符串
		var json = this._buildQFTFQueryJsonParam(params);
		var paramsXMLStr = this.x2jsFormat.json2xml_str(json);
		OpenLayers.Request.POST({
            url: this.url + "?REQUEST=" + params.request,
            data: paramsXMLStr,
            success: function(result) {
				var json = this.x2jsFormat.xml_str2json(result.responseText);
				if (!OpenLayers.Util.isArray(json.themes.theme)) {
					//不存在则为空数组
					if(!json.themes.theme){
						json.themes.theme = [];
					}else{
						json.themes.theme = [json.themes.theme];
					}
		        }
				
				var responseJson = null;
				if(json.themes.theme.length > 0){
					if (!OpenLayers.Util.isArray(json.themes.theme[0].feature.featureMember)) {
						//不存在则为空数组
						if(!json.themes.theme[0].feature.featureMember){
							json.themes.theme[0].feature.featureMember = [];
						}else{
							json.themes.theme[0].feature.featureMember = [json.themes.theme[0].feature.featureMember];
						}
					}
					//根据featureMember数组对象获取features
					var features = this._buildFeaturesByfm(json.themes.theme[0].feature.featureMember);
					//返回给二次开发用户的数据
					responseJson = {
						themName: json.themes.theme[0]._name,
						features: features,
						featureCount: json.themes.theme[0].featureCount,
						totalCount: json.themes.theme[0].totalCount
					}
				}
				successFn(responseJson);
			},
            failure: this.failFn,
            scope: this
        });
	},
	
	/**
	 * APIMethod: queryMultiEntity
	 * 根据地理实体查询参数查询多时态地理实体信息。
	 * 
	 * Parameters:
	 * options: - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * time - {String} (必选) 时态信息。格式如：“2001-01-01”（服务接口对应的参数名为：BornTime）
	 * address - {String} (可选) 查询的标准地址。与extent参数不能一起联合查询（服务接口对应的参数名为：Address）
	 * entityCode - {String} (可选) 实体编码。与extent参数可一起联合查询（服务接口对应的参数名为：EntityCode）
	 * entityName - {String} (可选) 实体名称。该参数暂时无效。（服务接口对应的参数名为：EntityName）
	 * extent - {<Geo.Bounds>} (可选) 查询的空间坐标范围。缺省情况无查询范围限制。（使用extent参数，则不能使用address进行查询）（服务接口对应的参数名为：BBox。//1,2,5,6 Xmin,Ymin,Xmax,Ymax顺序）
	 * startIndex - {Integer} (可选) ：从索引为第几条开始查询，缺省值是0。（服务接口对应的参数名为：StartIndex）
	 * maxCount - {Integer} (可选) ：查询多少条数据。缺省情况是查询满足条件的10条结果。（服务接口对应的参数名为：EndIndex）
	 * 
	 */
	queryMultiEntity: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GetMultipleTenseGeoEntity"
		});
		//处理time参数
		if(typeof options.time  === "string" && options.time !== "") {
			params.time = options.time;
		}else {
			throw "time是必选参数！请填写正确的数据类型<string>！格式为：2000-01-01";
		}
		
		if(typeof options.address === "string") {
			params.address = options.address;
		}
		if(typeof options.entityCode === "string") {
			params.entityCode  = options.entityCode;
		}
		if(options.extent instanceof Geo.Bounds) {
			params.bbox = options.extent.toBBOX(null);
		}
		if(typeof options.startIndex  === "number") {
			params.startIndex = options.startIndex;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		//处理请求的参数，转为XML字符串
		var json = this._buildQMEQueryJsonParam(params);
		var paramsXMLStr = this.x2jsFormat.json2xml_str(json);
		OpenLayers.Request.POST({
            url: this.url + "?REQUEST=" + params.request,
            data: paramsXMLStr,
            success: function(result) {
				if(result.responseText !== ""){
					var json = this.x2jsFormat.xml_str2json(result.responseText);
					if (!OpenLayers.Util.isArray(json.entitys.entity)) {
						//不存在则为空数组
						if(!json.entitys.entity){
							json.entitys.entity = [];
						}else{
							json.entitys.entity = [json.entitys.entity];
						}
					}
					
					var responseJson = null;
					if (json.entitys.entity.length > 0) {
						//根据entity数组对象获取features
						var features = this._buildFeaturesByfm(json.entitys.entity);
						responseJson = {
							features: features,
							queryCount: json.entitys.queryCount,
							totalCount: json.entitys.totalCount
						};
					}
					successFn(responseJson);
				}else{
					successFn(result.responseText);
				}
			},
            failure: this.failFn,
            scope: this
        });
	},
	
	/**
	 * APIMethod: queryMultiTheme
	 * 根据地理实体编码和时间，查询地理实体融合专题种类。
	 * 
	 * Parameters:
	 * options: - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * time - {String} (必选) 时态信息。格式如：“2001-01-01”（服务接口对应的参数名为：BornTime）
	 * entityCode - {String} (必选) 实体编码。与extent参数可一起联合查询（服务接口对应的参数名为：EntityCode）
	 * extent - {<Geo.Bounds>} (可选) 查询的空间坐标范围。缺省情况无查询范围限制。（服务接口对应的参数名为：BBox。//1,2,5,6 Xmin,Ymin,Xmax,Ymax顺序）
	 * startIndex - {Integer} (可选) ：从索引为第几条开始查询，缺省值是0。（服务接口对应的参数名为：StartIndex）
	 * maxCount - {Integer} (可选) ：查询多少条数据。缺省情况是查询满足条件的10条结果。（服务接口对应的参数名为：EndIndex）
	 * 
	 * Example:
	 * (code)
	 * 
	 * (end)
	 */
	queryMultiTheme: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GetMultipleTenseFuse"
		});
		
		//处理time参数
		if(typeof options.time  === "string" && options.time !== "") {
			params.time = options.time;
		}else {
			throw "time是必选参数！请填写正确的数据类型<string>！格式为：2000-01-01";
		}
		//处理entityCode参数
		if(typeof options.entityCode === "string" && options.entityCode !== "") {
			params.entityCode = options.entityCode;
		}else {
			throw "entityCode是必选参数！请填写正确的数据类型<string>！";
		}
		//处理extent参数
		if(options.extent instanceof Geo.Bounds) {
			params.bbox = options.extent.toBBOX(null);
		}
		//处理startIndex参数
		if(typeof options.startIndex  === "number") {
			params.startIndex = options.startIndex;
		}
		//处理maxCount参数
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		//处理请求的参数，转为XML字符串
		var json = this._buildQMTQueryJsonParam(params);
		var paramsXMLStr = this.x2jsFormat.json2xml_str(json);
		OpenLayers.Request.POST({
            url: this.url + "?REQUEST=" + params.request,
            data: paramsXMLStr,
            success: function(result) {
				var json = this.x2jsFormat.xml_str2json(result.responseText);
				if (!OpenLayers.Util.isArray(json.themes.theme)) {
					//不存在则为空数组
					if(!json.themes.theme){
						json.themes.theme = [];
					}else{
						json.themes.theme = [json.themes.theme];
					}
		        }
				var responseJson = json.themes;
				successFn(responseJson);
			},
            failure: this.failFn,
            scope: this
        });
	},
	
	/**
	 * APIMethod: queryMultiThemeFeatures
	 * 根据地理实体专题名称和时间，查询地理实体融合要素信息。
	 * 
	 * Parameters:
	 * options: - {Object}请求参数。
	 * successFn - {Function} 请求成功的回调函数。
	 * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * time - {String} (必选) 时态信息。格式如：“2001-01-01”（服务接口对应的参数名为：BornTime）
	 * theme - {String} (必选) 主题名称。与extent参数可一起联合查询（服务接口对应的参数名为：Theme）
	 * entityCode - {String} (可选) 实体编码。（服务接口对应的参数名为：EntityCode）
	 * startIndex - {Integer} (可选) ：从索引为第几条开始查询，缺省值是0。（服务接口对应的参数名为：StartIndex）
	 * maxCount - {Integer} (可选) ：查询多少条数据。缺省情况是查询满足条件的10条结果。（服务接口对应的参数名为：EndIndex）
	 * 
	 */
	queryMultiThemeFeatures: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GetMultipleTenseFuse"
		});
		
		//处理time参数
		if(typeof options.time  === "string" && options.time !== "") {
			params.time = options.time;
		}else {
			throw "time是必选参数！请填写正确的数据类型<string>！格式为：2000-01-01";
		}
		//处理theme参数
		if(typeof options.theme  === "string" && options.theme !== "") {
			params.theme = options.theme;
		}else {
			throw "theme是必选参数！请填写正确的数据类型<string>！";
		}
		//处理entityCode参数
		if(typeof options.entityCode === "string") {
			params.entityCode = options.entityCode;
		}
		//处理startIndex参数
		if(typeof options.startIndex  === "number") {
			params.startIndex = options.startIndex;
		}
		//处理maxCount参数
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		
		//处理请求的参数，转为XML字符串
		var json = this._buildQMTFQueryJsonParam(params);
		var paramsXMLStr = this.x2jsFormat.json2xml_str(json);
		OpenLayers.Request.POST({
            url: this.url + "?REQUEST=" + params.request,
            data: paramsXMLStr,
            success: function(result) {
				var json = this.x2jsFormat.xml_str2json(result.responseText);
				if (!OpenLayers.Util.isArray(json.themes.theme)) {
					//不存在则为空数组
					if(!json.themes.theme){
						json.themes.theme = [];
					}else{
						json.themes.theme = [json.themes.theme];
					}
		        }
				
				var responseJson = null;
				if(json.themes.theme.length > 0){
					if (!OpenLayers.Util.isArray(json.themes.theme[0].feature.featureMember)) {
						//不存在则为空数组
						if(!json.themes.theme[0].feature.featureMember){
							json.themes.theme[0].feature.featureMember = [];
						}else{
							json.themes.theme[0].feature.featureMember = [json.themes.theme[0].feature.featureMember];
						}
					}
					//根据featureMember数组对象获取features
					var features = this._buildFeaturesByfm(json.themes.theme[0].feature.featureMember);
					//返回给二次开发用户的数据
					responseJson = {
						themName: json.themes.theme[0]._name,
						features: features,
						featureCount: json.themes.theme[0].featureCount,
						totalCount: json.themes.theme[0].totalCount
					}
				}
				successFn(responseJson);
			},
            failure: this.failFn,
            scope: this
        });
	},
	
	
	_buildQEQueryJsonParam: function(params){
		
		var json = {
		    "GetGeoEntityInfo": {
		        "EntityCode": params.entityCode || "",
		        "Address": params.address || "",
		        "EntityName": params.entityName || "",
		        "BBox": params.bbox || "",
				"StartIndex": params.startIndex || 0,
				"EndIndex": params.maxCount || 10,
		        "_version": this.version,		
		        "_service": this.serviceName
		    }
		}
		return json;
	},
	
	/**
	 * Method: _buildQEByLonLatQueryJsonParam
	 * 。
	 * 
	 * Parameters:
	 * params: - {Object}请求参数。
	 * 
	 * params请求参数为:
	 * lonlat - {Geo.LonLat | Array(<Geo.LonLat>)} (必选) 位置。（服务接口对应的参数名为：Coordinates）
	 * distance - {Float} (可选) ：缺省值是0.001。（服务接口对应的参数名为：Distance）
	 * startIndex - {Integer} (可选) ：从索引为第几条开始查询，缺省值是0。（服务接口对应的参数名为：StartIndex）
	 * maxCount - {Integer} (可选) ：查询多少条数据。缺省情况是查询满足条件的10条结果。（服务接口对应的参数名为：EndIndex）
	 * 
     * Returns:
     * {Object} 键值对JS对象。
	 */
	_buildQEByLonLatQueryJsonParam: function(params){
		var lonlatArr = params.lonlat;
		var pids = params.pids;
		var coordinates = [];
		for(var i = 0; i < lonlatArr.length; i++){
			var coordinate = {};
			coordinate.pid = pids[i] || "";//如果没有则自动生成一个pid
			coordinate.lon = lonlatArr[i].lon;
			coordinate.lat = lonlatArr[i].lat;
			coordinates.push(coordinate);
		}
		var json = {
		    "GetGeoEntityInfo": {
		        "Coordinates": {
		        	"Distance": params.distance || 0.001,//容差范围，如何取值还不确定
		        	"Coordinate": coordinates
		        },				
				"StartIndex": params.startIndex || 0,
				"EndIndex": params.maxCount || 10,
		        "_version": this.version,		
		        "_service": this.serviceName
		    }
		}
		return json;
	},
	
	/**
	 * Method: _buildQFTQueryJsonParam
	 * 
     * Returns:
     * {Object} 键值对JS对象。
	 */
	_buildQFTQueryJsonParam: function(params){
		var json = {
		    'GetGeoEntityFuseInfo': {
		        //'OId': '',
				//'IndexStr': '',
				//'Theme': '',
				'EntityCode': params.entityCode || '',
				//'LayerName': '',
				"BBox": params.bbox || "",
				"StartIndex": params.startIndex || 0,
				"EndIndex": params.maxCount || 1000,
		        '_version': this.version,		
		        '_service': this.serviceName
		    }
		}
		return json;
	},
	
	/**
	 * Method: _buildQFTFQueryJsonParam
	 * 
     * Returns:
     * {Object} 键值对JS对象。
	 */
	_buildQFTFQueryJsonParam: function(params){
		var json = {
		    'GetGeoEntityFuseInfo': {
		        //'OId': '',
				//'IndexStr': '',
				'Theme': params.theme || '',
				'EntityCode': params.entityCode || '',
				//'LayerName': '',
				//"BBox": params.bbox || "",
				"StartIndex": params.startIndex || 0,
				"EndIndex": params.maxCount || 1000,
		        '_version': this.version,		
		        '_service': this.serviceName
		    }
		}
		return json;
	},
	
	//多时态实体查询
	_buildQMEQueryJsonParam: function(params){
		var json = {
		    "GetMultipleTenseGeoEntity": {
				"BornTime": params.time || "",
		        "EntityCode": params.entityCode || "",
		        "Address": params.address || "",
		        "EntityName": params.entityName || "",
		        "BBox": params.bbox || "",
				"StartIndex": params.startIndex || 0,
				"EndIndex": params.maxCount || 10,
		        "_version": this.version,		
		        "_service": this.serviceName
		    }
		}
		return json;
	},
	
	/**
	 * Method: _buildQMTQueryJsonParam
	 * 
     * Returns:
     * {Object} 键值对JS对象。
	 */
	_buildQMTQueryJsonParam: function(params){
		var json = {
		    'GetMultipleTenseFuse': {
		        //'OId': '',
				//'IndexStr': '',
				//'Theme': '',
				"BornTime": params.time || "",
				'EntityCode': params.entityCode || '',
				//'LayerName': '',
				"BBox": params.bbox || "",
				"StartIndex": params.startIndex || 0,
				"EndIndex": params.maxCount || 1000,
		        '_version': this.version,		
		        '_service': this.serviceName
		    }
		}
		return json;
	},
	
	/**
	 * Method: _buildQMTFQueryJsonParam
	 * 
     * Returns:
     * {Object} 键值对JS对象。
	 */
	_buildQMTFQueryJsonParam: function(params){
		var json = {
		    'GetMultipleTenseFuse': {
		        //'OId': '',
				//'IndexStr': '',
				"BornTime": params.time || "",
				'Theme': params.theme || '',
				'EntityCode': params.entityCode || '',
				//'LayerName': '',
				//"BBox": params.bbox || "",
				"StartIndex": params.startIndex || 0,
				"EndIndex": params.maxCount || 1000,
		        '_version': this.version,
		        '_service': this.serviceName
		    }
		}
		return json;
	},
	
	/**
	 * Method: _buildFeaturesByfm
	 * 根据featureMember数组对象获取features
	 * 
     * Returns:
     * {<Geo.Feature.Vector>} 键值对JS对象。
	 */
	_buildFeaturesByfm: function(featureMembers){
		//组成所需的gml格式，进行解析。
		var preStr = '<gml:featureMember xmlns:gml="http://www.opengis.net/gml">';
		preStr += '<gefsQueryLayer fid="${index}" xmlns="http://www.geostar.com.cn/geoglobe">';
		
		var sufStr = '</gefsQueryLayer>';
		sufStr += '</gml:featureMember>';
		var features = [];
		for(var i = 0; i < featureMembers.length; i++){
			var fmItem = featureMembers[i];
			var xmlStr = this.x2jsFormat.json2xml_str(fmItem);
			var newPreStr = preStr.replace(/\${index}/g, i);
			var fmXmlStr = newPreStr + xmlStr + sufStr;
			var fmXmlNode = OpenLayers.Format.XML.prototype.read.apply(this, [fmXmlStr]);
			var feature = this.gmlFormat.parseFeature(fmXmlNode.firstChild);
			features.push(feature);
		}
		return features;
	},
	
	CLASS_NAME: "Geo.Query.GEFSQuery.v1_0_0" 
});/**
 * Class: Geo.Strategy.AttributeCluster
 * 基于要素属性的聚合策略。
 *
 * Inherits from:
 *  - <Geo.Strategy.Cluster>
 */
Geo.Strategy.AttributeCluster = Geo.Class(Geo.Strategy.Cluster, {
	
    /**
     * APIProperty: attributes
     * 用于比较的一组属性。
     */
    attributes: [],
	
    /**
     * Method: shouldCluster
     * 判断要素是否被包含在一个要素簇内。
     *
     * Parameters:
     * cluster - {<Geo.Feature.Vector>} 一个要素簇。
     * feature - {<Geo.Feature.Vector>} 一个要素。
     *
     * Returns:
     * {Boolean} 返回布尔值，表示要素是否被包含在一个要素簇内。
     */
    shouldCluster: function(cluster, feature){
		var bool = false;
        for (var i = 0; i < this.attributes.length; i++) {
            var attribute = this.attributes[i];
            var cc_attrval = cluster.cluster[0].attributes[attribute];
            var fc_attrval = feature.attributes[attribute];
            bool = (cc_attrval === fc_attrval);
			if(!bool){
				break;
			}
        }
		var superProto = Geo.Strategy.Cluster.prototype;
		return bool && superProto.shouldCluster.apply(this, arguments);
    },
	
    CLASS_NAME: "OpenLayers.Strategy.AttributeCluster"
});﻿﻿/**
 * Class: Geo.Strategy.GeoTextXYZ
 * >文字服务策略类，继承自策略基类Geo.Strategy。
 * >本类定义请求文字服务的方式，包括：
 * >1.当地图缩放的时候请求文字服务。
 * >2.当拖动地图超出一定范围时请求文字服务。
 * 
 *  Inherits from:
 *  - <Geo.Strategy>
 */
Geo.Strategy.GeoTextXYZ = OpenLayers.Class(OpenLayers.Strategy, {
    
    /**
     * Property: bounds
     * {<OpenLayers.Bounds>} 请求矢量数据的范围。
     */
    bounds: null,
    
    /** 
     * Property: resolution 
     * {Float} 地图当前的分辨率。
     */ 
    resolution: null,
	
    /**
     * APIProperty: ratio
     * {Number} 扩展范围与当前视野范围的比率。
     * 扩展范围是指：中心点和当前可视范围中心点相同，长、宽是当前可视范围长、宽1.5倍比率的区域。比率值由用户通过radio属性设置，默认值为1.5。
     */
    ratio: 1,
	
	/** 
     * Property: zoom 
     * {Float} 图层请求数据的级别。
     */
	zoom: 0,

    /** 
     * Property: resFactor 
     * {Float} 地图当前分辨率与地图前一次级别的分辨率的比值。
     */ 
    resFactor: null, 
    
    /**
     * Property: response
     * {<OpenLayers.Protocol.Response>} 协议类查询成功后返回的结果对象。
     */
    response: null,

    /**
     * Constructor: Geo.Strategy.GeoTextXYZ
     * 创建文字服务的策略类的实例。
     */
	
    /**
     * Method: activate
     * 激活策略对象。
     * 
     * Returns:
     * {Boolean} 如果成功激活，则返回true。
     */
    activate: function() {
        var activated = OpenLayers.Strategy.prototype.activate.call(this);
        if(activated) {
            this.layer.events.on({
                "moveend": this.update,
                "refresh": this.update,
                scope: this
            });
			this.layer.map.events.on({
	            "zoomend":function(){
					this.zoom = this.layer.map.getZoom();
					this.layer.removeFeatures();
				},
	            scope: this
	        });
			
			
            this.update();
        }
        return activated;
    },
    
    /**
     * Method: deactivate
     * 取消激活策略对象。
     * 
     * Returns:
     * {Boolean} 如果成功取消激活，则返回true。
     */
    deactivate: function() {
        var deactivated = OpenLayers.Strategy.prototype.deactivate.call(this);
        if(deactivated) {
            this.layer.events.un({
                "moveend": this.update,
                scope: this
            });
			this.layer.map.events.un({
				"zoomend":function(){
					this.layer.removeFeatures();
					this.start();
				},
	            scope: this
	        });
        }
        return deactivated;
    },

    /**
     * Method: update
     * 触发图层"moveend" 或者 "refresh"事件后执行本方法。
     *
     * Parameters:
     * options - {Object} 可选项。
     */
    update: function(options) {
		var mapZoom = this.layer.map.getZoom();
		var zoomChanged = false;
		if(mapZoom !== this.zoom) {
			zoomChanged = true
		}
		
			//延迟4秒关闭
			this.timerId1 = window.setTimeout(
	            OpenLayers.Function.bind(function() {
		        var mapBounds = this.getMapBounds();
		        if (mapBounds !== null && ((options && options.force) ||
		          (this.layer.visibility && this.layer.calculateInRange()&& this.invalidBounds(mapBounds) && !zoomChanged))) {
					//放大缩小的时候隐藏图层，查询到数据后再显示图层。
				    this.calculateBounds(mapBounds);
		            this.resolution = this.layer.map.getResolution(); 
		            this.triggerRead(options);
					//TODO:待完善
		        }else  if ( (options && options.force) ||
		          (this.layer.visibility && this.layer.calculateInRange() && zoomChanged === true)) {
				  		//清空线面键值对
						this.layer.formatFeatures.cleanCommonFeatures();
				  		this.layer.display(false);
						this.calculateBounds(mapBounds);	
						this.resolution = this.layer.map.getResolution(); 
			    		this.triggerRead(options);  
			         
				  }
	    }, this),
            1
        ); 
	},
    
    /**
     * Method: getMapBounds
     * 得到与图层相同投影的地图可视范围。
     *
     * Returns:
     * {<OpenLayers.Bounds>} 地图范围。
     */
    getMapBounds: function() {
        if (this.layer.map === null) {
            return null;
        }
        var bounds = this.layer.map.getExtent();
        if(bounds && !this.layer.projection.equals(
                this.layer.map.getProjectionObject())) {
            bounds = bounds.clone().transform(
                this.layer.map.getProjectionObject(), this.layer.projection
            );
        }
        return bounds;
    },

    /**
     * Method: invalidBounds
     * 地图当前范围是否超出查询定义的范围。
     *
     * Parameters:
     * mapBounds - {<OpenLayers.Bounds>} 地图可视范围。
     *
     * Returns:
     * {Boolean} 
     */
    invalidBounds: function(mapBounds) {
        if(!mapBounds) {
            mapBounds = this.getMapBounds();
        }
        var invalid = !this.bounds || !this.bounds.containsBounds(mapBounds);
        if(!invalid && this.resFactor) {
            var ratio = this.resolution / this.layer.map.getResolution();
            invalid = (ratio >= this.resFactor || ratio <= (1 / this.resFactor));
        }
        return invalid;
    },
 
    /**
     * Method: calculateBounds
     * 感觉地图范围计算当前请求数据的范围。
     * 
     * Parameters:
     * mapBounds - {<OpenLayers.Bounds>} 地图范围。
     */
    calculateBounds: function(mapBounds) {
        if(!mapBounds) {
            mapBounds = this.getMapBounds();
        }
        var center = mapBounds.getCenterLonLat();
        var dataWidth = mapBounds.getWidth() * this.ratio ;
        var dataHeight = mapBounds.getHeight() * this.ratio ;
        this.bounds = new OpenLayers.Bounds(
            center.lon - (dataWidth / 2),
            center.lat - (dataHeight / 2),
            center.lon + (dataWidth / 2),
            center.lat + (dataHeight / 2)
        );
    },
    
    /**
     * Method: triggerRead
     * 缩放地图或刷新图层后执行本操作。
     * 
     * Parameters:
     * options - {Object} 可选项。
     *
     * Returns:
     * {<OpenLayers.Protocol.Response>} 协议对象查询成功后返回的结果对象。
     */
    triggerRead: function(options) {
        if (this.response && !(options && options.noAbort === true)) {
          //  this.layer.protocol.abort(this.response);
            this.layer.events.triggerEvent("loadend");
        }
      	var evt = {filter: {}};
		var layer = this.layer;
        layer.events.triggerEvent("loadstart", evt);
		var bounds = layer.map.getExtent();
		var dataWidth = bounds.getWidth() * this.ratio;
        var dataHeight = bounds.getHeight() * this.ratio;
		var center = bounds.getCenterLonLat();
        bounds = new OpenLayers.Bounds(
            center.lon - (dataWidth / 2),
            center.lat - (dataHeight / 2),
            center.lon + (dataWidth / 2),
            center.lat + (dataHeight / 2)
        );
		var leftTop = new Geo.LonLat(bounds.left,bounds.top);
		var pyramid = layer.pyramid;
		var rightBottom = new Geo.LonLat(bounds.right,bounds.bottom);
		var level = pyramid.getLevelForResolution(layer.map.getResolution());
		//最小行列号
		var minXY = pyramid.getTileIndex(leftTop,level);
		//最大行列号
		var maxXY = pyramid.getTileIndex(rightBottom,level);
		this.getTextDateForGridIndex(minXY, maxXY, level);
    },
	
	 /**
     * Method: getTextDateForGridIndex
     * 根据行列号和层级请求数据。
     * 
     * Parameters:
     * minXY - {Integer} 最小行列号。
     * maxXY - {Integer} 最大行列号。
     * level - {Integer} 层级。
     */
	getTextDateForGridIndex: function(minXY, maxXY, level) {
		this.queue = [];
		if(level >= 10) {
			this.layer.textCounter = (maxXY.col - minXY.col + 1) * (maxXY.row - minXY.row + 1);
			//根据行列号请求文字服务
			for(var i = minXY.col; i <= maxXY.col; i++) {
				for(var j = minXY.row; j <= maxXY.row;j++) {
					var lxy = (level + "," + i + "-" + i + "," + j + "-" + j);
			       this.readText(lxy);
				}
			}
		}
	},
	
	/**
     * Method: readText
     * 请求文字服务。
     * 
     * Parameters:
     * lxy - {String} 层级与行列号
     */
	readText: function(lxy) {
		this.response = this.layer.read({
			lxyArray: lxy,
			callback: this.merge,
			scope:this
		});
	},
	
	/**
     * Method: merge
     * 返回结果。
     *
     * Returns:
     * {<OpenLayers.Protocol.Response>} 返回结果。
     */
	merge: function(resp) {
		if(!resp.error) {
			this.layer.display(true);
			var features = resp.features;
			this.layer.update(features);
			this.response = null;
	        this.layer.events.triggerEvent("loadend", {response: resp});
		}
	},
 
    CLASS_NAME: "Geo.Strategy.GeoTextXYZ" 
});/**
 * Class: Geo.Service
 * 服务类。本类是服务类的基类，需要由子类去实现。
 */
Geo.Service = Geo.Class({
	
	/**
     * APIProperty: name
     * {String} 服务名称。
     */
	name: null,
	
	/**
     * APIProperty: url
     * {String} 服务地址。
     */	
	url: null,
	
	/**
     * APIProperty: version
     * {String} 服务版本号。
     */		
	version: null,

	
	/**
     * APIProperty: userid
     * {String} 用户名。
     */			
	userid: "test@liferay.com",
	
	/**
     * Constructor: Geo.Service.Bus
     * Geo.Service.Bus类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		this.name = name;
		this.url = url;
		OpenLayers.Util.extend(this, options);
	},


	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息，由子类实现。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */		
	getCapabilities: function(successFn,failFn){
		//由子类实现
	},

	/**
     * APIMethod: isExist
     * 检查服务是否存在，由子类实现。
     */		
	isExist: function(){
		//由子类实现
	},


	/**
     * APIMethod: failFn
     * 服务操作失败响应回调函数。
     * 
     * operate - 失败的操作类型。
     */		
	failFn: function(operate){
		alert("服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" + 
			"请求地址：" + this.url + "\n操作类型：" + operate);
	},

	//将结果解析成XML
	_parseToXML: function(result){
		var doc = result.responseXML;
        if(!doc || !doc.documentElement) {
            doc = result.responseText;
        }
		var xmlParser = new OpenLayers.Format.XML();
		return xmlParser.read(doc);
	},
	
	//对返回结果进行检查，是否为错误信息
	_checkIsError: function(xmlString){
		var xmlparser = new OpenLayers.Format.XML();
		var xml = xmlparser.read(xmlString);
		var exceptions = xml.selectNodes("ServiceExceptionReport");
        if(exceptions.length > 0){
            return this._parseToJSON(xmlString);
        }
        return null;
	},
	
	//对解析后的JSON对象进行判断是否为服务抛出的异常
	_isException:function(result){
		if(result && result.ServiceExceptionReport){
			return true;
		}
		return false;
		
	},
	
	_parseToJSON: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	CLASS_NAME: "Geo.Service"
	
});/**
 * Class: Geo.Service.GlobeTile
 * 吉奥瓦片服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.GlobeTile = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.GlobeTile
     * Geo.Service.GlobeTile类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
	getCapabilities: function(successFn,failFn){
		var request = "GetCapabilities";
		var url = this.url + "/" + request;
		
		if(!failFn){
			failFn = function(){
				this.failFn(request);
			};
		}
		OpenLayers.loadURL(url,null,this,function(result){
			successFn(result);
		},failFn);
	},
	
	
	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */	
	isExist: function(){
		var isExist = false;
		var request = "GetCapabilities";
		var url = this.url + "/" + request;
		var xhr = OpenLayers.Request.GET({
            url: url,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},

	CLASS_NAME: "Geo.Service"
});/**
 * Class: Geo.Service.Bus
 * 公交服务类。
 * 
 * Inherits from:
 *  - <Geo.Service>
 */
Geo.Service.Bus = Geo.Class(Geo.Service,{
	
	/**
	 * APIProperty: networkName
	 * 网络名称。
	 */
	networkName: null,
	
	/**
	 * APIProperty: transferScheme
	 * 换乘方案信息。
	 */
	transferScheme: null,
	
	/**
     * Constructor: Geo.Service.Bus
     * Geo.Service.Bus类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     * 
     * Example:
     * (code)
     *  var url = "http://map.geostar.com.cn:9001/bus_sdk_new/bus";
     *  var busService = new Geo.Service.Bus("公交服务", url);
     * (end)
     */
	initialize: function(name, url,  options){ 
		this.name = name;
		this.url = url;
		OpenLayers.Util.extend(this, options);
	},

	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var params = {
           REQUEST: "GetCapabilities"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("公交服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + this.url + "\n操作类型：GetCapabilities");
            };
        }
        OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },
	
	/**
     * APIMethod: isExist
     * 将向服务发送"GetCapabilities"同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */	
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};		
		var xhr = OpenLayers.Request.GET({
            url: url,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},	
	
	/**
     * APIMethod: queryStation
     * 站点查询操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
	 * options请求参数属性可为:
     * networkName - {String} (必选) 网络模型名称。
     * stationName - {String} (可选) 站点名称。
     * stationId - {Integer} (可选) 站点ID  必须为正整型。
     * lineId - {Integer} (可选) 线路ID。
     * lineName - {String}  (可选) 线路名称。
     * coordinate - {String} (可选) 站点位置  用逗号分隔XY轴坐标如(X,Y)。
     * bbox - {String} (可选) 矩形范围。
	 *     
     * Example:
     * (code)
     *  //示例1 根据站点名称查询:
     *  busService.queryStation({
     *      networkName: "BusChangeModule",
     *      stationName: encodeURIComponent('口'),
     *  }
     *  //示例2 根据站点ID查询:
     *  busService.queryStation({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     *  //示例3 根据矩形范围查询:
     *  busService.queryStation({
     *      networkName: "BusChangeModule",
     *      bbox : '-1,-1,1,1'
     *  }
     *  (end)
     */	
    queryStation:function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryStation"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.stationId !== null && options.stationId !== undefined){
            params.STATIONID = options.stationId;
        }
		
        if(options.stationName !== null && options.stationName !== undefined){
            params.STATIONNAME = options.stationName;
        }
		
        if(options.lineId !== null && options.lineId !== undefined){
            params.LINEID = options.lineId;
        }
		
		if(options.lineName !== null && options.lineName !== undefined){
            params.LINENAME = options.lineName;
        }
		
		if(options.coordinate !== null && options.coordinate !== undefined){
        	params.COORDINATE = options.coordinate;
        }   
		
        if(options.bbox !== null && options.bbox !== undefined){
            params.BOX = options.bbox;
        }
        
        var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
                
                var features = this._parserFeatures(result.responseText);
                successFn(features);
            },
            failure: failFn
        });

    },

	/**
     * APIMethod: queryLine
     * 线路查询操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
	 * options请求参数属性可为:
     * networkName - {String} (必选) 网络模型名称。
     * lineName - {String} (可选) 线路名称。
     * lineId - {Integer} (可选) 线路ID。
     * stationName - {String} (可选) 站点名称。
     * stationId - {Integer} (可选) 站点ID。
     * coordinate - {String} (可选) 站点位置。
     * bbox - {String} (可选) 矩形范围。
     *       
     * Example:
     * (code)
     *  //示例1 根据站点名称查询
     *  busService.queryLine({
     *      networkName: "BusChangeModule",
     *      stationName: encodeURIComponent('口'),
     *  }
     * //示例2 根据站点ID查询
     *  busService.queryLine({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     * //示例3 根据路线名称查询
     *  busService.queryLine({
     *      networkName: "BusChangeModule",
     *      lineName : '4'
     *  }
     *  (end)
     */	
    queryLine: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryLine"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.lineName !== null && options.lineName !== undefined){
            params.LINENAME = options.lineName;
        }
        
        if(options.lineId !== null && options.lineId !== undefined){
            params.LINEID = options.lineId;
        }
        
        if(options.stationName !== null && options.stationName !== undefined){
            params.STATIONNAME = options.stationName;
        }    
        
        if(options.stationId !== null && options.stationId !== undefined){
            params.STATIONID = options.stationId;
        }    
                
        if(options.coordinate !== null && options.coordinate !== undefined){
            params.COORDINATE = options.coordinate;
        }   
                     
        if(options.bbox !== null && options.bbox !== undefined){
            params.BOX = options.bbox;
        }
        var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
                
                var features = this._parserFeatures(result.responseText);
                successFn(features);
            },
            failure: failFn
        });

    },
    
	/**
     * APIMethod: queryChange
     * 公交换乘方案查询操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * options请求参数属性可为:
     * networkName - {String} (必选) 网络模型名称。
     * startStationId - {Integer} (可选) 起始站点ID。
     * endStationId - {Integer} (可选) 终止站点ID。
     * startCoordinate - {String} (可选) 起始站点坐标。
     * endCoordinate - {String} (可选) 起始站点坐标。
     * maxDepth - {Integer}(可选) 最大边数范围,正整型参数,没有则默认值为5。
     * maxCost - {Float} (可选) 最大权值范围,正双精度符点型参数,没有则默认为100.0。
     * maxSolutions - {Integer} (可选) 最多解决方案数量,正整型参数,没有则默认为5。
     * orderType - {String}(可选) 值为LeastCost时表示较快捷，值为LeastWalk时表示少步行，值为LeastChange时表示少换乘。
     * 
     * Example:
     * (code)
     *  busService.queryChange({
     *      networkName: "BusChangeModule",
     *        startStationId: "238",
     *        endStationId: "25",
	 *		  maxDepth:5,
	 *		  maxCost:100.0,
	 *		  maxSolutions:5,
	 *		  //orderType表示换乘的类型。LeastCost表示较快捷，用户还可以选择LeastWalk或LeastChange，LeastWalk表示少步行，值为LeastChange时表示少换乘
	 *		  orderType:"LeastCost" 
     *  })
     *  (end)
     */	
    queryChange: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryChange"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.startStationId !== null && options.startStationId !== undefined){
            params.STARTSTATIONID = options.startStationId;
        }
        
        if(options.endStationId !== null && options.endStationId !== undefined){
            params.ENDSTATIONID = options.endStationId;
        }
		
		if(options.orderType !== null && options.orderType !== undefined){
            params.ORDERTYPE = options.orderType;
        }
        
        if(options.startCoordinate !== null && options.startCoordinate !== undefined){
            params.STARTCOORDINATE = options.startCoordinate;
        }    
        
        if(options.endCoordinate !== null && options.endCoordinate !== undefined){
            params.ENDCOORDINATE = options.endCoordinate;
        }  
		
		if(options.maxDepth !== null && options.maxDepth !== undefined){
            params.MAXDEPTH = options.maxDepth;
        } 
		
		if(options.maxCost !== null && options.maxCost !== undefined){
            params.MAXCOST = options.maxCost;
        }  
		
		if(options.maxSolutions !== null && options.maxSolutions !== undefined){
            params.MAXSOLUTIONS = options.maxSolutions;
        }  
		if (options.ChangeCount !== null && options.ChangeCount !== undefined) {
			params.CHANGECOUNT = options.ChangeCount;
        }
		  
        var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
            	var  featureCollection = [];
				var resXML;//= result.responseXML;
				if (!result.responseXML.documentElement) {
					resXML = format.read(result.responseText);
				}
				else {         
					resXML = result.responseXML;
				}       

				var docElement = resXML.selectNodes("/Features/FeatureCollection");
				
            	var xmlparser = new OpenLayers.Format.XML();
				
            	for(var i = 0; i < docElement.length; i++) {
					//获取FeatureCollection元素节点的属性
					var featureCollectionElement = docElement[i];
					var attArray = ['cost','price','walkingDistance','transferTimes'];
					var attributionObj = this._getAttibutionOfNode(featureCollectionElement, attArray);
					
					var str = xmlparser.write(docElement[i]);
					var features = this._parserFeatures(str);
					//features或featureCollectionElement相当于一个FeatureCollection
					features.attributes= attributionObj;
					var featureMember = featureCollectionElement.selectNodes("featureMember");
					for(var j = 0; j < featureMember.length; j++) {
						var road = featureMember[j].selectNodes("Road");
						//线路添加是否步行属性：isOnFoot
						features[j]["isOnFoot"] = road[0].getAttribute("isOnFoot");
					}
	            	featureCollection.push(features);
            	}

                successFn(featureCollection);
            },
            failure: failFn
        });

    },
	
	//根据节点得到节点的属性
	_getAttibutionOfNode: function(node, keyArray) {
		//获取FeatureCollection属性信息
		var fcAttibution = {};
		if(node.tagName){
			for(var i = 0; i < keyArray.length; i++) {
				fcAttibution[keyArray[i]] = node.getAttribute(keyArray[i])
			}
	    }
		return fcAttibution;
	},
   
    _getGeometryType: function(geometry){
        var maping = {
            "OpenLayers.Geometry.Point": "point",
            "OpenLayers.Geometry.LineString": "line",
            "OpenLayers.Geometry.Polygon": "polygon"
        };
        return "polygon";
    },
    
    _pagingToString: function(curPage,maxPerPage){
        maxPerPage = maxPerPage || this.maxPerPage;
        curPage = curPage || 1;
        return "<numPerPage>" + maxPerPage + "</numPerPage>"+
                "<curPage>" + curPage + "</curPage>";
    },
    
    _orderByToString: function(property,type){
        var str = "<orderBy>"+
    	            "<PropertyName>" + property + "</PropertyName>"+
    	        "</orderBy>";
        return property ? str : "";
    },
    
    _geometryToString: function(geometry){
        return '<geometry>'+
                    '<Polygon>'+
                        '<outerBoundaryIs>'+
                            '<LinearRing>'+
                                '<coordinates decimal="." cs="," ts=" ">20,30 21,41 52,42 53,33 20,30</coordinates>'+
                            '</LinearRing>'+
                        '</outerBoundaryIs>'+
                    '</Polygon>'+
                '</geometry>';
    },
    
    _stringToGeometry: function(string){
        return Geo.Geometry.Polygon.createRegularPolygon(
            new Geo.Geometry.Point( Math.random()*360 - 160, 
                                           Math.random()*90 - 70 ),
            Math.round(Math.random()*20),
            Math.round(Math.random()*10)
        );
    },
	
    _parserFeatures: function(resultString){
        var parser = new OpenLayers.Format.GML();
        parser.gmlns = "*";
        var features = parser.read(resultString);
        return features;
    },
	
	// 把节点名称所在的节点外套上<featureMember></featureMember>
	_parserResponseText: function(resultString, nodeName){
		if(nodeName){
			var re1 = new RegExp("<" + nodeName + ">", ["g"]);
	        var re2 = new RegExp("</" + nodeName + ">", ["g"]);
			
	        resultString = resultString.replace(re1, "<featureMember><" + nodeName + ">");
	        resultString = resultString.replace(re2, "</" + nodeName + "></featureMember>");
		}
		
		resultString = resultString.replace(/<gml:LineString>/g,"<gml:LineString><gml:coordinates>");
		resultString = resultString.replace(/<\/gml:LineString>/g,"</gml:coordinates></gml:LineString>");
		resultString = resultString.replace(/<gml:Point>/g,"<gml:Point><gml:coordinates>");
		resultString = resultString.replace(/<\/gml:Point>/g,"</gml:coordinates></gml:Point>");
		return resultString;
	},
	
	_parserFeaturesNew: function(resultString, featureName){
		var parser = new OpenLayers.Format.GML();
        parser.gmlns = "*";
		if(featureName){
			parser.featureName = featureName;
		}
        var features = parser.read(resultString);
        return features;
    },
    
	_parserSuccessResult: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	_parseToXML: function(result){
		var doc = result.responseXML;
        if(!doc || !doc.documentElement) {
            doc = result.responseText;
        }
		var xmlParser = new OpenLayers.Format.XML();
		return xmlParser.read(doc);

	},
	
	_parseToJSON: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	/**
	 * APIMethod: queryTransferScheme
	 * 根据始终点的空间坐标或一组起始站点ID和一组终止站点的ID，查询公交换乘的文字信息，必要时也查询出第一条方案的几何信息。（公交2.0）
	 * 
	 * Parameters:
	 * options - {Object} 请求参数。
	 * successFn - {Function}请求成功的回调函数。
	 * failFn - {Function}请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * networkName {String} (必选) 网络模型名称。
	 * transferMode - {Integer} (必选) 换乘模式  ,有三种值：0-较快捷   1-少换乘  2-少步行。
	 * startInput - {String} (必选) 始点信息，可以是坐标信息也可也是ID类型（坐标类型,格式为:x y。分隔符为空格符；ID类型,格式为:id,… ,id。分隔符为逗号）。
	 * endInput - {String} (必选)终点信息支持坐标与ID类型:坐标类型,格式为:x y。分隔符为空格符ID类型,格式为:id,… ,id。分隔符为逗号。
	 * inputMode - {Integer}(可选)始终点输入模式,值为0|1|2: 0-坐标,1-车站外部唯一编号,2-车站内部唯一编号（当前服务没有外部唯一编号）。
	 * ComputeModel	
	 * transferSubset
	 * existGoTime
	 * startTime
	 * specificSubset
	 * maxSearchDistance
	 * computeSort
	 * transferPolicy
	 * resultSort
	 * prioritySubset
	 * existAbsolutePriority
	 * lagSubset
	 * outputPage
	 * pageSize
	 * changeCount
	 */
	queryTransferScheme: function(options, successFn, failFn) {
		var params = {
			request: "QueryTransferScheme",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
		//四个必选参数
		var required = {
			networkName:true,
            transferMode: true,
            startInput: true,
			endInput: true
        };
        for (var prop in required) {
            if (!(prop in options)) {
                throw new Error("缺少必选属性：'" + prop + "'。");
            }
        }
		params.networkName = options.networkName;
		
		//这样判断的原因是为了避免0,1这样的值在进行if判断的时候被当做false把参数给过滤掉；""串不需要被过滤，这个已经向服务组确认
        if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		if(options.transferMode !== null && options.transferMode !== undefined) {
			params.TRANSFERMODE = options.transferMode;
        }
		if(options.startInput !== null && options.startInput !== undefined) {
			params.STARTINPUT = options.startInput;
        }
		if(options.endInput !== null && options.endInput !== undefined) {
			params.ENDINPUT = options.endInput;
        }
		if(options.inputMode !== null && options.inputMode !== undefined) {
			params.INPUTMODEL = options.inputMode;
        }
		if (options.ExistGoTime !== null && options.ExistGoTime !== undefined) {
			params.EXISTGOTIME = options.ExistGoTime;
        }
		if (options.StartTime !== null && options.StartTime !== undefined) {
			params.STARTTIME = options.StartTime;
        }
		if (options.MaxSearchDistance !== null && options.MaxSearchDistance !== undefined) {
			params.MAXSEARCHDISTANCE = options.MaxSearchDistance;
		}
		if (options.PrioritySubset !== null && options.PrioritySubset !== undefined) {
			params.PRIORITYSUBSET = options.PrioritySubset;
        }
		if (options.ExistAbsolutePriority !== null && options.ExistAbsolutePriority !== undefined) {
			params.EXISTABSOLUTEPRIORITY = options.ExistAbsolutePriority;
        }
		if (options.LagSubset !== null && options.LagSubset !== undefined) {
			params.LAGSUBSET = options.LagSubset;
        }
		if (options.OutputPage !== null && options.OutputPage !== undefined) {
			params.OUTPUTPAGE = options.OutputPage;
        }
		if (options.PageSize !== null && options.PageSize !== undefined) {
			params.PAGESIZE = options.PageSize;
        }
		if (options.ChangeCount !== null && options.ChangeCount !== undefined) {
			params.CHANGECOUNT = options.ChangeCount;
        }
		
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            async: false,//true表示异步，false表示同步
            scope: this,
            success: OpenLayers.Function.bind(function(result){
				var resXML = result.responseXML;
                var features = {
                    startPoint: [],
                    transferScheme: [],
                    endPoint: []
                };	
				if(!resXML) {
					successFn(features);
					return features;
				}
				var xmlparser = new OpenLayers.Format.XML();
				var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
				//没有查询到数据的情况
				if(errorTemp && errorTemp.length > 0) {
					successFn(features);
					return features;
				}
				
				var element = resXML.selectNodes("/QueryTransferSchemeResponse");	
				var elementXMLStr = xmlparser.write(element[0]);
				// XML解析成json对象
				var jsonObj = this._parseToJSON(elementXMLStr);
				var startPoint = jsonObj.QueryTransferSchemeResponse.StartPoint;
				if (!OpenLayers.Util.isArray(startPoint)) {
		            startPoint = [startPoint];
		        }
				var endPoint = jsonObj.QueryTransferSchemeResponse.EndPoint;
				if (!OpenLayers.Util.isArray(endPoint)) {
		            endPoint = [endPoint];
		        }
				var transferScheme = jsonObj.QueryTransferSchemeResponse.TransferScheme;
				
				// 起点要素
                var startPointGeometry = this._getPointGeometryByGMLPointStr(startPoint[0].Geometry.gml_Point);
            	var startPointFeature = new Geo.Feature.Vector(startPointGeometry);
				// 终点要素
                var endPointGeometry = this._getPointGeometryByGMLPointStr(endPoint[0].Geometry.gml_Point);
            	var endPointFeature = new Geo.Feature.Vector(endPointGeometry);
				// 换乘要素
				var transferSchemeFeatures = this._parserTransferScheme(transferScheme);
				
                features = {
                    startPoint: startPointFeature,
                    transferScheme: transferSchemeFeatures,
                    endPoint: endPointFeature
                };
				successFn(features);
            },this)
			,
            failure: failFn
        });
	},
	
	// 解析换乘要素
    _parserTransferScheme: function(transferSchemeObjs){
		if (!OpenLayers.Util.isArray(transferSchemeObjs)) {
            transferSchemeObjs = [transferSchemeObjs];
        }
        var transferSchemeFeatures = new Array();
        for (var i = 0; i < transferSchemeObjs.length; i++) {
			var transferSchemeObj = transferSchemeObjs[i];
			// 解析片段信息
			var SectionInfo = this._parserSectionInfo(transferSchemeObj.SectionInfo);
			// 解析片段步行
			var SectionRoutingFeatures = this._parserSectionRouting(transferSchemeObj.SectionRouting);
            
			var transferSchemeFeature = {
                Cost: transferSchemeObjs[i].Cost,
                SectionInfo: SectionInfo,
                SectionRouting: SectionRoutingFeatures,
                TotalDistance: transferSchemeObjs[i].TotalDistance,
                TransferCount: transferSchemeObjs[i].TransferCount
            };
            transferSchemeFeatures.push(transferSchemeFeature);
        }
        return transferSchemeFeatures;
    },
	
	// 解析片段信息
    _parserSectionInfo: function(sectionInfoObjs){
		if (!OpenLayers.Util.isArray(sectionInfoObjs)) {
            sectionInfoObjs = [sectionInfoObjs];
        }
		var sectionInfos = new Array();
		for (var i = 0; i < sectionInfoObjs.length; i++) {
			
			// 上车点要素
			var fromStationFeature = this._getPointFeatureByObj(sectionInfoObjs[i].FromStation);
			if (sectionInfoObjs[i].FromStation.PassagewayRouting) {
                var passagewayRoutingFeature = this._getPointFeatureByObj(sectionInfoObjs[i].FromStation.PassagewayRouting);
				if(passagewayRoutingFeature.SectionRouting){
                    passagewayRoutingFeature.attributes.SectionRouting = passagewayRoutingFeature.data.SectionRouting = this._parserSectionRouting(passagewayRoutingFeature.SectionRouting);
				}
                fromStationFeature.attributes.PassagewayRouting = fromStationFeature.data.PassagewayRouting = passagewayRoutingFeature;
            }
			
			// 下车点要素
			var toStationFeature = this._getPointFeatureByObj(sectionInfoObjs[i].ToStation);
			if (sectionInfoObjs[i].ToStation.PassagewayRouting) {
                var passagewayRoutingFeature = this._getPointFeatureByObj(sectionInfoObjs[i].ToStation.PassagewayRouting);
                if(passagewayRoutingFeature.SectionRouting){
                    passagewayRoutingFeature.attributes.SectionRouting = passagewayRoutingFeature.data.SectionRouting = this._parserSectionRouting(passagewayRoutingFeature.SectionRouting);
				}
				toStationFeature.attributes.PassagewayRouting = toStationFeature.data.PassagewayRouting = passagewayRoutingFeature;
            }
			
			// 线路要素
			var sectionLine = this._parserSectionLines(sectionInfoObjs[i].SectionLines.SectionLine);
			var sectionRouting = this._parserSectionRouting(sectionInfoObjs[i].SectionRouting);
			
			sectionInfos.push({
				FromStation: fromStationFeature,
				SectionLine: sectionLine,
				ToStation: toStationFeature,
				SectionRouting: sectionRouting
			});
		}
		return sectionInfos;
	},
	
	// 解析片段信息内的片段线路
    _parserSectionLines: function(sectionLineObjs){
        if (!OpenLayers.Util.isArray(sectionLineObjs)) {
            sectionLineObjs = [sectionLineObjs];
        }
		var sectionLineFeatures = new Array();
		for (var i = 0; i < sectionLineObjs.length; i++) {
            var sectionLineFeature = new Geo.Feature.Vector(null, sectionLineObjs[i]);
			sectionLineFeatures.push(sectionLineFeature);
		}
		return sectionLineFeatures;
	},
	
	// 解析片段步行
    _parserSectionRouting: function(sectionRoutingObjs){
		// TODO
        if (!OpenLayers.Util.isArray(sectionRoutingObjs)) {
            sectionRoutingObjs = [sectionRoutingObjs];
        }
		var sectionRoutingFeatures = new Array();
		for (var i = 0; i < sectionRoutingObjs.length; i++) {
			sectionRoutingFeatures.push(sectionRoutingObjs[i]);
		}
		return sectionRoutingFeatures;
	},
	
	// -----根据点串得到点对象
	_getPointGeometryByGMLPointStr: function(pointStr) {
		var pointArr = pointStr.split(",");
		var point = new Geo.Geometry.Point(parseFloat(pointArr[0]),parseFloat(pointArr[1]));
		return point;
	},
	
	// 解析站点或出入口点的要素
    _getPointFeatureByObj: function(pointInfoObj){
        var pointGeometry = null;
        if (pointInfoObj.Geometry && pointInfoObj.Geometry.gml_Point) {
            pointGeometry = this._getPointGeometryByGMLPointStr(pointInfoObj.Geometry.gml_Point);
        }
        var pointFeature = new Geo.Feature.Vector(pointGeometry, pointInfoObj);
        return pointFeature;
    },
	
	// -----根据id等信息获取geometry串并生成geometry对象
    _getLineGeometryByGMLLineStr: function(geometryStr){
        if (!geometryStr) {
            return null;
        }
        var pointStrArr = geometryStr.split(" ");
        var pointArr = [];
        for (var i = 0, j = pointStrArr.length; i < j; i++) {
            var pointGeometry = this._getPointGeometryByGMLPointStr(pointStrArr[i]);
            pointArr.push(pointGeometry);
        }
        var lineGeometry = new OpenLayers.Geometry.LineString(pointArr);
        return lineGeometry;
    },
	
	/**
	 * APIMethod: queryTransferGeometry
	 * 根据线路ID或者步行ID来获取相应的线要素（公交2.0。注意：这些线要素不包含属性信息）。
	 * 
     * Parameters:
	 * options - {Object} 请求参数。
	 * 
	 * options请求参数属性可为:
	 * networkName - {String} (必选) 网络模型名称。
	 * parameterInfo - {Arrays} 取值格式：[[geometryTypeID,geometryInfoID,FromOrdinal,ToOrdinal]]例如[[0,10,22,24]]。
	 * geometryTypeID - {Integer} (必选) 0-线路内部ID,1-步行路由内部ID。如果这个属性的值为1，那么FromOrdinal和ToOrdinal这两个属性的的值就都为0。
	 * geometryInfoID - {Integer}几何信息 的ID。
	 * FromOrdinal -  {Integer} (必选) 起点序号。
	 * ToOrdinal -  {Integer} (必选) 终点序号。
	 */
	queryTransferGeometry: function(options, successFn, failFn) {
		var params = {
			request: "QueryTransferGeometry",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
		if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.parameterInfo === null || options.parameterInfo === undefined || options.parameterInfo === ""){
            throw "Error!Not parameterInfo for bus query.";
            return;
        }
		params.networkName = options.networkName;
		params.PARAMETERINFO = "";
        for (var i = 0; i < options.parameterInfo.length; i++) {
            params.PARAMETERINFO += options.parameterInfo[i].toString();
            if (i != options.parameterInfo.length - 1) {
                params.PARAMETERINFO += "_";
            }
        }
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: OpenLayers.Function.bind(function(result){
				var features = this._parseQueryTransferGeometryResult(result);
				successFn(features);
            },this)
			,
            failure: failFn
        });
	},
	
	//解析QueryTransferGeometry接口返回结果 -----获取线路要素
	_parseQueryTransferGeometryResult: function(result) {
		resXML = result.responseXML;
		var features = [];
		if(!resXML) {
			return features;
		}
		var xmlparser = new OpenLayers.Format.XML();
		var geometrysStrTemp = resXML.selectNodes("/QueryTransferGeometryResponse");	
		//没有查询到数据的情况
		if(geometrysStrTemp && geometrysStrTemp.length <= 0) {
			return features;
		}
		var geometrysXMLStr = xmlparser.write(geometrysStrTemp[0]);
		var geometrysXMLObj = this._parseToJSON(geometrysXMLStr);
		var geometrys = geometrysXMLObj.QueryTransferGeometryResponse.SectionGeometry;	
		
		if(geometrys) {
			if(!OpenLayers.Util.isArray(geometrys)) {
				geometrys = [geometrys];
			}
			//得到一个个站点
			for(var i = 0 ;i < geometrys.length; i++)  {
				//得到几何对象
				var geometryTemp = this._getLineGeometryByGMLLineStr(geometrys[i].Geometry.gml_LineString);
				//得到线要素
                var lineFeature = new Geo.Feature.Vector(geometryTemp, {
                    ID: geometrys[i].ID
                });
				features.push(lineFeature);
			}
		}
		return features;
	},
	
	/**
	 * APIMethod: queryKeyWord
	 * 根据关键字来获取线路信息或者站点信息或者出入口信息。（公交2.0）
	 * 
     * Parameters:
	 * options - {Object} 请求参数。
	 * 
	 * options请求参数属性可为:
	 * networkName - {String} (必选) 网络模型名称。
	 * keyWord - {String} (必选)查询关键字。
	 * searchType - {Integer} (可选) 查询类型，默认值为 2，查询类型，其值为0|1|2:0-完全配匹，1-模糊查询，2-先完全后模糊默认值为2。
	 * keyWordType - {Integer} (可选) 查询关键字类型，默认值为 -1，可供选择的值为-1|0|1|2:-1:先查线路，然后查车站，最后查出入口0-查线路，1-查车站，2-查出入口。
	 *     
	 * Returns:
	 * {Array(Geo.Feature.Vector)} 返回的是出入口、站点、线路要素。
	 */
	queryKeyWord: function(options, successFn, failFn) {
		var params = {
			REQUEST: "QueryKeyWord",
			SERVICE: "BUS",
			VERSION: "1.0.0",
			SEARCHTYPE: 2
		};
		if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.keyWord === null || options.keyWord === undefined || options.keyWord === ""){
            throw "Error!Not keyWord for bus query.";
            return;
        }
		params.NETWORKNAME = options.networkName;
		params.KEYWORD = options.keyWord;
		
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		if (options.searchType !== null && options.searchType !== undefined) {
        	params.SEARCHTYPE = options.searchType;
        }
		if (options.keyWordType !== null && options.keyWordType !== undefined) {
        	params.KEYWORDTYPE = options.keyWordType;
        }
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            async: false,//true表示异步，false表示同步
            scope: this,
            success: OpenLayers.Function.bind(function(result){
				var features = this._parserQueryKeyWordResult(result,options.keyWordType);
				successFn(features);
            },this)
			,
            failure: failFn
        });
	},
	
	//解析queryKeyWord接口返回结果 -----获取站点或出入口或线路文字描述信息
	_parserQueryKeyWordResult: function(result,keyWordType) {
		var resXML = result.responseXML;
		var features = [];	
		if(!resXML) {
			return features;
		}
		var xmlparser = new OpenLayers.Format.XML();
		var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
		//没有查询到数据的情况
		if(errorTemp && errorTemp.length > 0) {
			return features;
		}
		var objectsStrTemp = resXML.selectNodes("/QueryKeyWordResponse");	
		var objectsXMLStr = xmlparser.write(objectsStrTemp[0]);
		var objectsXMLObj = this._parseToJSON(objectsXMLStr);
		
		// 0-查线路，1-查车站，2-查出入口
        if (keyWordType === 1) {
            var stations = objectsXMLObj.QueryKeyWordResponse.Stations.Station;
			if (stations && !(Geo.Util.isArray(stations))) {
				stations = [stations];
			}
            for (var i = 0; i < stations.length; i++) {
                var pointFeature = this._getPointFeatureByObj(stations[i]);
                features.push(pointFeature);
            }
        } else if (keyWordType === 2) {
            var passageways = objectsXMLObj.QueryKeyWordResponse.Passageways.Passageway;
			if (passageways && !(Geo.Util.isArray(passageways))) {
				passageways = [passageways];
			}
            for (var i = 0; i < passageways.length; i++) {
                var pointFeature = this._getPointFeatureByObj(passageways[i]);
                features.push(pointFeature);
            }
        } else {
            var lines = objectsXMLObj.QueryKeyWordResponse.Lines.Line;
			if (lines && !(Geo.Util.isArray(lines))) {
				lines = [lines];
			}
            for (var i = 0; i < lines.length; i++) {
                var lineFeature = new Geo.Feature.Vector(null,lines[i]);
                features.push(lineFeature);
            }
        }
		return features;
	},
	
	/**
     * APIMethod: queryStationInfo
     * 站点查询操作。（公交2.0）
     * 
     * Parameters:
     * options - {Object} 请求参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
	 * options请求参数属性可为:
     * networkName - {String} (必选) 网络模型名称。
     * stationId - {Integer} (必选) 站点ID  必须为正整型。
     *   
     *       
     * Example:
     * (code)
     *  busService.queryStationInfo({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     *  (end)
     */	
    queryStationInfo:function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryStationInfo",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.stationId === null || options.stationId === undefined || options.stationId === ""){
            throw "Error!Not stationId for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		
        if(options.stationId !== null && options.stationId !== undefined){
            params.STATIONID = options.stationId;
        }
        
        var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				resXML = result.responseXML;
				if(!resXML) {
					var features = {
						lines:[],
						passageways:[]
					};
	                successFn(features);
					return;
				}
				var xmlparser = new OpenLayers.Format.XML();
				
				//根据节点名字，解析成对象
				var lines = this._parserQueryStationInfoNode("Lines", xmlparser, resXML);
				var passageways = this._parserQueryStationInfoNode("Passageways", xmlparser, resXML);
                
				//解析后转feature
				var passagewaysFeature = new Array();
                for (var i = 0; i < passageways.length; i++) {
					var pointFeature = this._getPointFeatureByObj(passageways[i]);
					passagewaysFeature.push(pointFeature);
                }
		
				var features = {
					lines: lines,
					passageways: passagewaysFeature
				};
                successFn(features);
            },
            failure: failFn
        });

    },
	
	//解析queryStationInfo接口返回的结果中的xml串
    _parserQueryStationInfoNode: function(nodeName, xmlparser, resXML){
		switch (nodeName) {
            case "Lines":
                //解析lines
	            var element = resXML.selectNodes("/QueryStationInfoResponse/StationInfo/Lines");
	            var lines = new Array();
	            if (element.length > 0) {
	                var xmlObj = xmlparser.write(element[0]);
	                var jsonObj = this._parseToJSON(xmlObj);
	                lines = jsonObj.Lines.Line;
	                if (!(Geo.Util.isArray(lines))) {
	                    lines = [lines];
	                }
	            }
	            return lines;
                break;
            case "Passageways":
                //解析Passageways
	            var element = resXML.selectNodes("/QueryStationInfoResponse");
	            var passageways = new Array();
	            if (element.length > 0) {
	                var xmlObj = xmlparser.write(element[0]);
	                var jsonObj = this._parseToJSON(xmlObj);
					var passagewaysJson = jsonObj.QueryStationInfoResponse.StationInfo.Passageways;
					if(passagewaysJson){
						passageways = passagewaysJson.Passageway;
		                if (!(Geo.Util.isArray(passageways))) {
		                    passageways = [passageways];
		                }
					}
	            }
	            return passageways;
                break;
            default:
				return [];
                break;
        }
    },
    
    /**
     * APIMethod: queryLineInfo
     * 线路查询操作。（公交2.0）
     * 
     * Parameters:
     * options - {Object} 请求参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
	 * options请求参数属性可为:
     * networkName - {String} (必选) 网络模型名称。
     * lineId - {Integer} (必选) 线路ID。
     * STARTNODENUMBER - {String} (可选) 线路中某一个站点的序号。多个序号采用逗号分割。
     * ENDNODENUMBER - {String} (可选) 线路中某一个站点的序号。多个序号采用逗号分割。
     * 
     * Example:      
     * (code)
     *  busService.queryLineInfo({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     *  (end)
     */
    queryLineInfo: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryLineInfo",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.lineId === null || options.lineId === undefined || options.lineId === ""){
            throw "Error!Not lineId for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
        
        if(options.lineId !== null && options.lineId !== undefined){
            params.LINEID = options.lineId;
        }
        
        if(options.startNodeNumber !== null && options.startNodeNumber !== undefined){
            params.STARTNODENUMBER = options.startNodeNumber;
        }    
                
        if(options.endNodeNumber !== null && options.endNodeNumber !== undefined){
            params.ENDNODENUMBER = options.endNodeNumber;
        }   
                     
        var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
//				// 传入包含gml的结点名称
//				var resultString = this._parserResponseText(result.responseText, "Line");
//				var features = this._parserFeaturesNew(resultString);
//				
//				// 线路所包含的站点要素
//				var resultStationString = this._parserResponseText(result.responseText, "Station");
//				var stationFeatures = this._parserFeaturesNew(resultStationString);
//                features[0].attributes.Stations = features[0].data.Stations = stationFeatures;
//				
//				successFn(features);
//				return;
				
				var features = [];
				var resXML = null;
				if(result.responseXML) {         
					resXML = result.responseXML;
					var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
					//没有查询到数据的情况
					if(errorTemp && errorTemp.length > 0) {
						successFn(features);
						return;
					}
					var xmlparser = new OpenLayers.Format.XML();
					//根据节点名字，解析成对象
					var line = this._parserQueryLineInfoNode("Line", xmlparser, resXML);
					//解析后转feature
					var lineFeatures = new Array();
	                for (var i = 0; i < line.length; i++) {
						//线路内站点信息转要素
						var stationFeatures = new Array();
	                    for (var j = 0; j < line[i].VIAStations.Station.length; j++) {
							//得到点要素
	                    	var stationFeature = this._getPointFeatureByObj(line[i].VIAStations.Station[j]);
							stationFeatures.push(stationFeature);
	                    }
						line[i].Stations = stationFeatures;
						//得到线几何对象
						var lineGeometry = this._getLineGeometryByGMLLineStr(line[i].Geometry.gml_LineString);
						//得到线要素
	                    var lineFeature = new Geo.Feature.Vector(lineGeometry, line[i]);
						lineFeatures.push(lineFeature);
	                }
			
					features = lineFeatures;
				}
				successFn(features);
            },
            failure: failFn
        });

    },
	//解析queryStationInfo接口返回的结果中的xml串
    _parserQueryLineInfoNode: function(nodeName, xmlparser, resXML){
		switch (nodeName) {
            case "Line":
                //解析line
	            var element = resXML.selectNodes("/QueryLineInfoResponse");
				var xmlObj = xmlparser.write(element[0]);
                var jsonObj = this._parseToJSON(xmlObj);
				var l = jsonObj.QueryLineInfoResponse.Line;
				
	            var lines = new Array();
                if (l && !(Geo.Util.isArray(l))) {
                    lines = [l];
                }else{
					lines = l;
				}
	            return lines;
                break;
            default:
				return [];
                break;
        }
    },
	
	/**
     * APIMethod: queryPassagewayInfo
     * 根据出入口ID获取与此出入口有关的站点信息，包括出入口所对应的车站信息。（公交2.0）
     * 
     * Parameters:
     * options - {Object} 请求参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * options请求参数属性可为:
     * networkName - {String} (必选) 网络模型名称。
     * passagewayId - {Integer} (必选) 出入口ID。
     * 
     * Example:      
     * (code)
     *  busService.queryPassagewayInfo({
     *      networkName: "BusChangeModule",
     *      passagewayId : 2
     *  }
     *  (end)
     */
    queryPassagewayInfo: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryPassagewayInfo",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.passagewayId === null || options.passagewayId === undefined || options.passagewayId === ""){
            throw "Error!Not passagewayId for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
        
        if(options.passagewayId !== null && options.passagewayId !== undefined){
            params.PASSAGEWAYID = options.passagewayId;
        }
        var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				var resXML = result.responseXML;
				var features = [];	
				if(!resXML) {
					successFn(features);
					return features;
				}
				var xmlparser = new OpenLayers.Format.XML();
				var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
				//没有查询到数据的情况
				if(errorTemp && errorTemp.length > 0) {
					successFn(features);
					return features;
				}
				var responseText = this._parserResponseText(result.responseText);
				features = this._parserFeaturesNew(responseText, "Stations");
				successFn(features);
            }
        });
	},
	
	
	/**
     * method: _queryByName
     * 根据起点终点名称得到对应的坐标信息
     * 根据坐标信息请求_queryTransferScheme查询换乘方案信息
     *
     * Parameters:
     * startName - {String} 起点名称。
     * endName - {String} 终点名称。
     * transferMode - {String} 选择方式
     *
     * Returns:
     * {Object}换乘方案信息
     * 
     * 返回对象属性包含：
     * startPoint 起点要素
     * transferScheme 所有换乘方案信息
     * endPoint 终点要素
     */
    _queryByName: function(startName,endName,transferMode){
    	var that = this;
    	var featuresInfo = null;
    	 //查询起点信息
         that.queryKeyWord({
             networkName: that.networkName,
             keyWord: startName,
             keyWordType: 1,// 0-查线路，1-查车站，2-查出入口//-1:先查线路，然后查车站，最后查出入口
             SEARCHTYPE: 2//查询类型，其值为0|1|2:0-完全配匹，1-模糊查询，2-先完全后模糊,默认值为2；
         }, function(feature){
               if (feature.length == 0) {
				   alert("没有查询到起点");
	               return;
               }
			   var startPoint = feature[0].geometry.x + " " +feature[0].geometry.y;
			   //查询终点信息
			   that.queryKeyWord({
	               networkName: that.networkName,
	               keyWord: endName,
	               keyWordType: 1,// 0-查线路，1-查车站，2-查出入口//-1:先查线路，然后查车站，最后查出入口
	               SEARCHTYPE: 2//查询类型，其值为0|1|2:0-完全配匹，1-模糊查询，2-先完全后模糊,默认值为2；
       		  }, function(feature){
		            if (feature.length == 0) {
						alert("没有查询到终点");
		           		return;
		      		}
		   			var endPoint = feature[0].geometry.x + " " + feature[0].geometry.y;
		   			featuresInfo = that._queryTransferScheme(startPoint,endPoint,transferMode);//查询换乘方案信息
		    	});
			});
			return featuresInfo;
    },
	
	/**
     * APIMethod: queryBus
     * 根据parameter1、parameter2、transferMode查询公交换乘方案。
     * 请求url，响应返回capabilities的XML文档信息，解析该XML文档，获得服务的networkName。
     * 根据得到的参数请求_queryTransferScheme方法得到换乘方案信息 
     *
     * Parameters:
     * parameter1 - {<Geo.Geometry.Point> | String} 起点坐标或者起点名称。
     * parameter2 - {<Geo.Geometry.Point> | String} 终点坐标或者终点名称。
     * transferMode - {String} 选择方式 0-较快捷   1-少换乘  2-少步行
     *
     * Returns:
     * {Object}换乘方案信息
     * {flag:服务正常返回换乘信息为true,否则为false,featuresInfo：换乘方案信息}
     *
     */
    queryBus: function(parameter1, parameter2,transferMode){
    	var that = this;
    	var features = null;
    	var lineFeatures = null;
    	that.getCapabilities(OpenLayers.Function.bind(function(result){
			//响应返回capabilities的XML文档信息
            var data = result.responseXML;
            if (!data || !data.documentElement) {
                data = result.responseText;
            }
            var format = new Geo.Util.Format.BusCapabilities();
            var capabilities = format.read(data);
            var layerName = capabilities.capability.networks[0];
            that.networkName = layerName;
            if(typeof(parameter1) == "string" && typeof(parameter2) == "string"){//站点名称查询
            	features = that._queryByName(parameter1,parameter2,transferMode);
            }else{//坐标查询
            	var startPoint = parameter1.lon + " " +parameter1.lat;
            	var endPoint = parameter2.lon + " " + parameter2.lat;
            	featuresInfo = that._queryTransferScheme(startPoint,endPoint,transferMode);//查询换乘方案信息
            }
        }, this),
		function(){
            alert("公交服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
        });
        var featureData = {
        	flag:featuresInfo ? true : false,
        	featuresInfo:featuresInfo
        }
        return featureData;
    },
    
    
    failFn: function(){
		alert("公交服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
	},
	
	 /**
	  * Method: _queryTransferScheme
	  * 查询换乘方案信息
	  * 根据startPoint、endPoint、transferMode、networkName查询公交换乘方案。
	  *
      * Parameters:
      * url - {String} 公交服务地址。
      * startPoint - {<Geo.Geometry.Point>} 起点坐标。
      * endPoint - {<Geo.Geometry.Point>} 终点坐标。
      * transferMode - {String} 选择方式 0-较快捷   1-少换乘  2-少步行
      *
      * Returns:
      * {Object}换乘方案信息
      * 
      * 返回对象属性包含：
      * startPoint 起点要素
      * transferScheme 所有换乘方案信息
      * endPoint 终点要素
	  *
	  */
	_queryTransferScheme: function(startPoint,endPoint,transferMode){
		var lineFeatures =  null;
        this.queryTransferScheme({
	         networkName: this.networkName,
	         transferMode: transferMode ? transferMode : 0,//0-较快捷   1-少换乘  2-少步行
	         inputMode: 0,//默认为0。0：传坐标。2：传ID。
	         startInput: startPoint,
	         endInput: endPoint
	    }, function(features){
	     	featuresInfo = features;
	    });
	    this.transferScheme = featuresInfo.transferScheme;
	    return featuresInfo;
	},
	
	/**
	 *
	 * APIMethod: queryBusTransferSchemeByIndex
	 * 根据sortIndex查询单条换乘方案几何信息。
	 *
     * Parameters:
     * sortIndex - {String} 换乘方案索引值。
     *
     * Returns:
     * {Object}换乘方案几何信息
     * {lineFeatures:方案线要素 ,stationFeatures:换乘方案的起始点要素}
	 *
	 */
	queryBusTransferSchemeByIndex: function(sortIndex){
		var busSer = null;
		var lineData = null;
		var sortIdx = parseInt(sortIndex);
        var transferScheme = this.transferScheme[sortIdx];
        var sectionInfo = transferScheme.SectionInfo;
        
        //查询参数。
        var parameterInfo = new Array();
        var transferPointFeatures = new Array();
        for (i = 0; i < sectionInfo.length; i++) {
            var type = 0;
            var lineFeature = sectionInfo[i].SectionLine[0];
            var lineId = lineFeature.data.ID;
            var fromOrdinal = lineFeature.data.FromOrdinal;
            var toOrdinal = lineFeature.data.ToOrdinal;
            
            parameterInfo.push([type, lineId, fromOrdinal, toOrdinal]);
            transferPointFeatures.push(sectionInfo[i].FromStation);
            transferPointFeatures.push(sectionInfo[i].ToStation);
        }
        
        this.queryTransferGeometry({
            networkName: this.networkName,
            //单条几何信息的ID的类型(0或者1)，几何信息的ID(line:LID)，起点序号(upStation:NodeNumber)，终点序号(downStation:NodeNumber)；
            parameterInfo: parameterInfo//[[0, 67, 24, 60], [0, 221, 31, 85]]
        }, function(features){
            var lineFeatures = features;
            var data = {
            	lineFeatures:lineFeatures,
            	stationFeatures: transferPointFeatures
            }
            lineData = data;
        });
        return lineData;
	},
	
	
	
	CLASS_NAME: "Geo.Service.Bus"
});

//FF,chrome兼容selectNodes,selectSingleNode
(function xmlNodesTool(){
    if (document.implementation.hasFeature("XPath", "3.0")) {
        // prototying the XMLDocument 
        XMLDocument.prototype.selectNodes = function(cXPathString, xNode){
            if (!xNode) {
                xNode = this;
            }
            //name space resolver defined  
            function nsResolver(prefix){
                var ns = {
                    'csw': 'http://www.opengis.net/cat/csw',
                    'smmd': 'http://data.sbsm.gov.cn/smmd/2007',
                    'wfs': 'http://www.opengis.net/wfs',
                    'gml': 'http://www.opengis.net/gml',
                    'geoglobe': 'http://www.geostar.com.cn/geoglobe'
                };
                return ns[prefix] || null;
            }
            //var oNSResolver = this.createNSResolver(this.documentElement||this.ownerDocument.documentElement)||nsResolver;
            var aItems = this.evaluate(cXPathString, xNode, nsResolver, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
            var aResult = [];
            for (var i = 0; i < aItems.snapshotLength; i++) {
                aResult[i] = aItems.snapshotItem(i);
            }
            return aResult;
        };
        
        // prototying the Element 
        Element.prototype.selectNodes = function(cXPathString){
            if (this.ownerDocument.selectNodes) {
                return this.ownerDocument.selectNodes(cXPathString, this);
            }
            else {
                throw "For XML Elements Only";
            }
        };
        
    }
    if (document.implementation.hasFeature("XPath", "3.0")) {
        // prototying the XMLDocument 
        XMLDocument.prototype.selectSingleNode = function(cXPathString, xNode){
            if (!xNode) {
                xNode = this;
            }
            var xItems = this.selectNodes(cXPathString, xNode);
            if (xItems.length > 0) {
                return xItems[0];
            }
            else {
                return null;
            }
        };
        
        // prototying the Element 
        Element.prototype.selectSingleNode = function(cXPathString){
            if (this.ownerDocument.selectSingleNode) {
                return this.ownerDocument.selectSingleNode(cXPathString, this);
            }
            else {
                throw "For XML Elements Only";
            }
        };
    }
})();/**
 * Class: Geo.Service.Plot
 * 标绘服务类。
 * 
 * Inherits from:
 *  - <Geo.Service>
 */
Geo.Service.Plot = Geo.Class(Geo.Service,{
	
    
	/**
     * APIProperty: maxPerPage
     * {Integer} 每页的最大条数。
     */	
    maxPerPage: 100,
	
	/**
     * Constructor: Geo.Service.Plot
     * Geo.Service.Plot类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url, options){
		this.name = name;
		this.url = url;
		OpenLayers.Util.extend(this, options);
	},

	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息操作。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn, failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};
		OpenLayers.loadURL(url,params,this,function(result){
			result = this._parseToXML(result);
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: addClasses
     * 添加标绘分类操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   className -{String} 必填,分类名称,该名称不能重复。
     *   parentId -{String}   可填,父类ID。
     *   description -{String} 可填,描述信息。
     *   pictureUrl -{String} 可填,图片地址。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * 
     * (code)
     * plotService.addClasses({
	 *		className: "names",
	 *		parentId:"df",
	 *		description:"asdfsdfsdfsd",
	 *		pictureUrl:"fasdfasdfs"
	 *	});
	 * (end)
     */	
	addClasses: function(options, successFn, failFn){
		var params = {
			REQUEST: "AddClasses",
			userid: this.userid
		};
		var url = this.url;
		//name标签为必须
		var requestTemplate = 
			"<AddClasses>"+
				"<Feature>"+
					"<name>${className}</name>"+
					"<parentid>${parentId}</parentid>"+
					"<description>${description}</description>"+
					"<pictureurl>${pictureUrl}</pictureurl>"+
				"</Feature>"+
			"</AddClasses>";
		var className = options.className;
		var parentId = options.parentId;
		var description = options.description;
		var pictureUrl = options.pictureUrl;
		var requestString = OpenLayers.String.format(requestTemplate,{
			className: className,
			parentId: parentId,
			description: description,
			pictureUrl: pictureUrl
		});
		
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},
	
	/**
     * APIMethod: deleteClasses
     * 删除分类操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   id	- {String} 类别ID,必填。
     * 
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * (code)
     * 	plotService.deleteClasses({
	 *				classId:"1101"
	 *			},function(result){
	 *			  //doSomeThing...
	 *			});
	 * (end)
     */
	deleteClasses: function(options, successFn, failFn){
		var params = {
			REQUEST: "DeleteClasses",
			userid: this.userid
		};
		var requestTemplate = 
			"<FeatureCollection>"+
			    "<Feature>"+
			        "<id>${classId}</id>"+
			    "</Feature>"+
			"</FeatureCollection>";
		var classId = options.classId;
		var requestString = OpenLayers.String.format(requestTemplate,{
			classId: classId
		});
		
		var url = this.url + "?" + OpenLayers.Util.getParameterString(params);
		
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},

	
	/**
     * APIMethod: updateClasses
     * 修改分类操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   classId - {String}类别id,必填。唯一标识。
     *   description - {String} 可填,更新的分类描述。
     *   name - {String} 可填,图片的ID。
     *   pictureUrl - {String} 可填,图片地址。
     *   status - {String} 可填,分类状态。
     *   
     *   
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * (code)
     * plotService.updateClasses({
	 *			classId:classid,
     *          description: name,
     *          name: name,
     *          pictureUrl: "超市",
     *          status: "1"
	 *		},function(result){
	 *         //doSomeThing...
	 *      });
	 * (end)
     */	
	updateClasses: function(options, successFn, failFn){
		var params = {
			REQUEST: "UpdateClasses",
			userid: this.userid
		};
		var requestTemplate = 
    		"<FeatureCollection>"+
        		"<Feature>"+
        			"<id>${classId}</id>"+                    
        			"${name}"+
        			"${description}"+
        			"${pictureUrl}"+
        		"</Feature>"+
    		"</FeatureCollection>";
		var classId = options.classId;
        var name = options.name;
        var description = options.description;
        var pictureUrl = options.pictureUrl;
        var status = options.status;
        
		var requestString = OpenLayers.String.format(requestTemplate,{
			classId: classId,
            name:function(){
                return (name === null || name === undefined) ? 
                        "" : "<name>" + name + "</name>";
            },
            description:function(){
                return (description === null || description === undefined) ? 
                        "" : "<description>" + description + "</description>";
            },
            pictureUrl:function(){
                return (pictureUrl === null || pictureUrl === undefined) ? 
                        "" : "<pictureurl>" + pictureUrl + "</pictureurl>";
            }
            
		});
		
		var xhr = OpenLayers.Request.POST({
            url: this.url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},
	
	/**
     * APIMethod: queryClasses
     * 查询分类操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *     options的请求参数包括:
     *         requestType - 对象查询类型,必填(private私有,public公开,pending绑定,all所有)。
     *         filters - [],可以有零到多个 
     *     			例如：filters : [{type:'PropertyIsEqueTo',propertyName : "classcode",propertyValue : currentClassid}
	 *					            ],
     *         orderBy - {Object} 排序类型 例如： orderBy : {property:'EDITTIME',type:'desc'}
     *         		orderBy的请求参数包括 property和type。
     *         
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * (code)
     * plotService.queryClasses({
	 *				className:"class123",
	 *				filter : [{type:'PropertyIsNotEqualTo',propertyName : "parentid",propertyValue : 'A'},
	 *			  	{type:'PropertyIsLike',propertyName : "classname",propertyValue : 'on'}
	 *					],
	 *			},function(result){
	 *				//doSomeThing...
	 *			});
	 *(end)
     */		
	queryClasses: function(options, successFn, failFn){
		var params = {
			REQUEST: "QueryClasses",
			userid: this.userid
		};
		var url = this.url;
		
		var requestTemplate = 
			"<FeatureCollection>"+
			    "<Query>"+
			        "${pagingInfo}"+
					"${filter}" +
					"${orderBy}" +
			    "</Query>"+
			"</FeatureCollection>";
        var filterString = this._filterToString(options.filter);    
        var requestString = OpenLayers.String.format(requestTemplate,{
			pagingInfo: OpenLayers.Function.bind(function(){
                return this._pagingToString(options.maxPerPage,options.currentPage);
            },this),
			filter:filterString,
			orderBy: OpenLayers.Function.bind(function(){
				if(options.orderBy === undefined) {
					return "";
				}
                return this._orderByToString(options.orderBy.property,options.orderBy.type);
            },this)
		});

	
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
			
	},
	
	/**
     * APIMethod: publishFeatures
     * 发布要素操作。
     * 
     * Parameters:
     * options - {Object} json格式的请求参数。
     *   bookmarkId - {String} 对象的唯一标识。必填。如果数据库中已存在,那么为更新操作,如果没有,则为新增操作。
     *   type - {String} 对象类型，必填。（点，线，面，point,line,polygon）。
     * 
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * 
     * (code)
     * plotService.publishFeatures({
     *					bookmarkId: "3455-345345-234234-3454",
     *                  type: "point"
     * },function(result){
	 *		//doSomeThing...
     * }); 
     * (end)
     */		
	publishFeatures: function(options, successFn, failFn){
		var requestTemplate = 
			"<FeatureCollection>"+
				"<Feature>"+
					"<BOOKMARKID>${bookmarkId}</BOOKMARKID>"+
					"<TYPE>${type}</TYPE>"+
				"</Feature>"+
			"</FeatureCollection>";
			
		var params = {
			REQUEST: "PublishFeatures",
			userid: this.userid
		};
		var url = this.url;
		
        var requestString = OpenLayers.String.format(requestTemplate,{
			bookmarkId: options.bookmarkId,
            type: options.type
		});
		
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},

	/**
     * APIMethod: approvalFeatures
     * 审核要素操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   bookmarkId - {String} 对象的唯一标识。必填。如果数据库中已存在,那么为更新操作,如果没有,则为新增操作。
     *   type - {String} 对象类型，必填。（点，线，面，point,line,polygon）。
     *   
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * 
     * (code)
     *  plotService.approvalFeatures({
     *	   bookmarkId: "3455-345345-234234-3454",
     *     type: "point"
     *	},function(result){
	 *		//doSomeThing...
     *  }); 
     * (end)
     */		
	approvalFeatures: function(options, successFn, failFn){
		var requestTemplate = 
			"<FeatureCollection>"+
				"<Feature>"+
					"<BOOKMARKID>${bookmarkId}</BOOKMARKID>"+
					"<TYPE>${type}</TYPE>"+
				"</Feature>"+
			"</FeatureCollection>";
			
		var params = {
			REQUEST: "ApprovalFeatures",
			userid: this.userid,
			passresult:"pass"
		};
		var url = this.url;
		
        var requestString = OpenLayers.String.format(requestTemplate,{
			bookmarkId: options.bookmarkId,
            type: options.type
		});
		
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},

	/**
     * APIMethod: addFeatures
     * 添加要素操作。
     *   
     * Parameters:
     * options - {Object} 请求参数。
     *   featureId - {String} 可填,对象ID。
     *   sortId - {String} 可填,标绘分类ID。
     *   sortType - {String} 可填,标绘分类码。
     *   bookmarkId - {String} 对象的唯一标识。必填。（如果数据库中已存在,那么为更新操作,如果没有,则为新增操作）。
     *   title - {String} 可填,标题。
     *   status - {String} 可填,要素的状态  "1"表示私有，"2"，表示发布，"3"表示审核。
     *   height - {String} 可填,高度。
     *   pitching - {String} 可填,投影。
     *   brief - {String} 可填，图片。
     *   type - {String} 对象类型，必填。(点,线,面,point,line,polygon)。
     *   linecolor - {String} 可填,线颜色。
     *   iconpath - {String}可填,图标路径。
     *   linewidth - {String} 可填,线宽度。
     *   fillcolor - {String} 可填,填充色。
     *   opacity - {String} 可填,是否透明。
     *   geometry - {<Geo.Geometry.LineString>} 必填 要素的几何属性。
     *  bookmarkId - {String} 对象的唯一标识。必填。如果数据库中已存在,那么为更新操作,如果没有,则为新增操作。
     *  sortType - {String} 分类ID  可填,标绘分类ID。
     *  
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * 
     * (code)
     *      plotService.addFeatures({
     *          title:title,
     *          sortType:classid,
	 *			type:'line',
     *          geometry:new Geo.Geometry.LineString([
	 *              new Geo.Geometry.Point(114.4,30.6),
	 *              new Geo.Geometry.Point(113.9,34.7),
	 *              new Geo.Geometry.Point(116.2,40.1),
	 *              new Geo.Geometry.Point(111.5,40.8)
	 *          ])
     *          },function(result){
     *             //doSomeThing...
     *          });
     *  (end)
     */		
    addFeatures: function(options, successFn, failFn){

        if(options.sortType === null && options.sortType === undefined){
            throw "Error!Not sortType of class.";
            return;
        }
        var uuid = Geo.Math.uuid();
        options.bookmarkId = uuid;
        
        this.updateFeatures(options,successFn,failFn);
    },

	/**
     * APIMethod: updateFeatures
     * 更新要素操作。
     *   
     * Parameters:
     * options - {Object} 请求参数。
     *   type - {String} 对象类型，必填。(点，线，面，point，line，polygon)
     *   bookmarkId - {String} 对象的唯一标识。必填。（如果数据库中已存在，那么为更新操作，如果没有，则为新增操作）
     *   featureId - {String} 可填，对象ID。
     *   sortId - {String} 可填，标绘分类ID。
     *   sortType - {String} 可填，标绘分类码。
     *   title - {String} 可填，标题。
     *   status - {String} 可填，要素的状态  "1"表示私有，"2"，表示发布，"3"表示审核。
     *   height - {String} 可填，高度。
     *   pitching - {String} 可填，投影。
     *   brief - {String} 可填，图片。
     *   linecolor - {String} 可填，线颜色。
     *   iconpath - {String}可填，图标路径。
     *   linewidth - {String} 可填，线宽度。
     *   fillcolor - {String} 可填，填充色。
     *   opacity - {String} 可填，是否透明。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * 
     * (code)
     * plotService.updateFeatures({
     * 	      bookmarkId:"234234-234234-234234-234234",
     *        type:"point",
     *        title:"招商银行"
     *  },function(result){
     *     //doSomeThing...
     *	}); 
     * (end)
     */		
	updateFeatures: function(options, successFn, failFn){
        
        var fOptions = options;
        
		var requestTemplate = 
		    '<Feature>'+
		        '${featureId}'+
		        '${sortId}'+
                '${sortType}'+
		        '${bookmarkId}'+
		        '${type}'+
		        '${iconpath}'+
		        '${brief}'+
		        '${linecolor}'+
		        '${linewidth}'+
		        '${fillcolor}'+
		        '${opacity}'+
		        '${title}'+
		        '${status}'+
		        '${height}'+
		        '${pitching}'+
		        '${geometry}'+
		    '</Feature>';
		var requestString = OpenLayers.String.format(requestTemplate,{
            featureId: function(){
                return (fOptions.featureId === null || fOptions.featureId === undefined) ? 
                        "" : "<FEATUREID>" + fOptions.featureId + "</FEATUREID>";
            },
            sortId: function(){
                return (fOptions.sortId === null || fOptions.sortId === undefined) ? 
                        "" : "<SORTID>" + fOptions.sortId + "</SORTID>";
            },
            sortType: function(){
                return (fOptions.sortType === null || fOptions.sortType === undefined) ? 
                        "" : "<SORTTYPE>" + fOptions.sortType + "</SORTTYPE>";
            },
            bookmarkId: function(){
                return (fOptions.bookmarkId === null || fOptions.bookmarkId === undefined) ? 
                        "" : "<BOOKMARKID>" + fOptions.bookmarkId + "</BOOKMARKID>";
            },
            title: function(){
                return (fOptions.title === null || fOptions.title === undefined) ? 
                        "" : "<TITLE>" + fOptions.title + "</TITLE>";
            },
            status: function(){
                return (fOptions.status === null || fOptions.status === undefined) ? 
                        "" : "<STATUS>" + fOptions.status + "</STATUS>";
            },
            height: function(){
                return (fOptions.height === null || fOptions.height === undefined) ? 
                        "" : "<HEIGHT>" + fOptions.height + "</HEIGHT>";
            },
            pitching: function(){
                return (fOptions.pitching === null || fOptions.pitching === undefined) ? 
                        "" : "<PITCHING>" + fOptions.pitching + "</PITCHING>";
            },
            brief: OpenLayers.Function.bind(function(){
                return (fOptions.brief === null || fOptions.brief === undefined) ? 
                        "" : "<BRIEF>" + fOptions.brief + "</BRIEF>";
            },this),
            type: OpenLayers.Function.bind(function(){
                return (fOptions.type === null || fOptions.type === undefined) ? 
                        "" : "<TYPE>" + fOptions.type + "</TYPE>";
            },this),
            linecolor: OpenLayers.Function.bind(function(){
                return (fOptions.linecolor === null || fOptions.linecolor === undefined) ? 
                        "" : "<LINECOLOR>" + fOptions.linecolor + "</LINECOLOR>";
            },this),
            iconpath: OpenLayers.Function.bind(function(){
                return (fOptions.iconpath === null || fOptions.iconpath === undefined) ? 
                        "" : "<ICONPATH>" + fOptions.iconpath + "</ICONPATH>";
            },this),
            linewidth: OpenLayers.Function.bind(function(){
                return (fOptions.linewidth === null || fOptions.linewidth === undefined) ? 
                        "" : "<LINEWIDTH>" + fOptions.linewidth + "</LINEWIDTH>";
            },this),
            fillcolor: OpenLayers.Function.bind(function(){
                return (fOptions.fillcolor === null || fOptions.fillcolor === undefined) ? 
                        "" : "<FILLCOLOR>" + fOptions.fillcolor + "</FILLCOLOR>";
            },this),
         	opacity: OpenLayers.Function.bind(function(){
                return (fOptions.opacity === null || fOptions.opacity === undefined) ? 
                        "" : "<OPACITY>" + fOptions.opacity + "</OPACITY>";
            },this),
            geometry: OpenLayers.Function.bind(function(){
                return (fOptions.geometry === null || fOptions.geometry === undefined) ? 
                        "" : this._geometryToString(fOptions.geometry);
            },this)
        });
        requestString = '<FeatureCollection>' + requestString + '</FeatureCollection>';
		
        var params = {
			REQUEST: "UpdateFeatures",
			userid: this.userid
		};
        
        var xhr = OpenLayers.Request.POST({
            url: this.url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},

	/**
     * APIMethod: deleteFeatures
     * 删除要素操作。
     *   
     * Parameters:
     * options - {Object} 请求参数。
     * 	bookmarkId - {String} 对象的唯一标识。必填。
     *  type - {String} 对象类型，必填。（点，线，面，point,line,polygon）
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * (code)
     *   plotService.deleteFeatures({
	 *		 bookmarkId: "23434-3434-23234-1234",
	 *       type: "line"
	 *   },function(result){
	 *      //doSomeThing...
     *   });
     *   (end)
     */		
	deleteFeatures: function(options, successFn, failFn){
		var requestTemplate = 
			"<FeatureCollection>"+
				"<Feature>"+
					"<BOOKMARKID>${bookmarkId}</BOOKMARKID>"+
					"<TYPE>${type}</TYPE>"+
				"</Feature>"+
			"</FeatureCollection>";
			
		var params = {
			REQUEST: "DeleteFeatures",
			userid: this.userid
		};
		var url = this.url;
		
        var requestString = OpenLayers.String.format(requestTemplate,{
			bookmarkId: options.bookmarkId,
            type: options.type
		});
		
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var resultObj = this._parseToJSON(result.responseText);
                successFn(resultObj);
            },
            failure: failFn
        });
	},
    
	/**
     * APIMethod: queryFeatures
     * 查询要素操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   requestType - 对象查询类型,必填(private私有,public公开,pending绑定,all所有)。
     *   filters - [],可以有零到多个。
     *			例如：filters : [{type: 'PropertyIsEqueTo',propertyName: "plotclass",propertyValue: currentClassid},
	 *				  	{type: 'PropertyIsLike',propertyName: "TITLE",propertyValue: 'ATM'}
	 *				  ],
     *   orderBy - {Object} 排序类型 例如： orderBy : {property: 'EDITTIME',type: 'desc'}
     *    		orderBy的请求参数包括 property和type。
     *   
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 方法使用举例:
     * (code)
     * plotService.queryFeatures({
	 *		requestType:"public",
	 *		filters: [{type: 'PropertyIsEqueTo',propertyName: "plotclass",propertyValue: currentClassid},
	 *			{type: 'PropertyIsLike',propertyName: "TITLE",propertyValue: 'ATM'}
	 *		],
	 *		orderBy: {property: 'EDITTIME',type: 'desc'}
	 *	},function(features){
	 *     //doSomeThing...
	 *  }); 
	 * (end)
     */		
	queryFeatures: function(options, successFn, failFn){
        
		var params = {
			REQUEST: "QueryFeatures",
			userid: this.userid
		};
		var url = this.url;
        	
		var requestTemplate = 
			"<FeatureCollection>"+
			    "<Query>"+
                    "${pagingInfo}"+
			        "<requestType>${requestType}</requestType>"+
			        "${orderBy}"+
					"${filter}"+
			    "</Query>"+
			"</FeatureCollection>";
        var requestString = OpenLayers.String.format(requestTemplate,{
            pagingInfo: OpenLayers.Function.bind(function(){
                return this._pagingToString(options.maxPerPage,options.currentPage);
            },this),
            classcode: options.classcode,
			filter : OpenLayers.Function.bind(function(){
                return this._filterToString(options.filters);
            },this),
            orderBy:OpenLayers.Function.bind(function(){
				if(options.orderBy === undefined) {
					return "";
				}
                return this._orderByToString(options.orderBy.property,options.orderBy.type);
            },
            this), requestType:options.requestType
		});
        				
        var xhr = OpenLayers.Request.POST({
            url: url,
            params: params,
            scope: this,
            data: requestString,
            success: function(result){
                var features = this._parserFeatures(result.responseText);
                successFn(features);
            },
            failure: failFn
        });
	},
    
    _getGeometryType: function(geometry){
        var maping = {
            "OpenLayers.Geometry.Point": "point",
            "OpenLayers.Geometry.LineString": "line",
            "OpenLayers.Geometry.Polygon": "polygon"
        };
        return maping[geometry.CLASS_NAME];
    },
	
	_filterToString:function(filters){
		if(!filters) {
			return "";
		}
		var filterString = "";
		if(!(Geo.Util.isArray(filters))) {
			filters = [filters];
		} 
		for(var i = 0; i < filters.length; i++) {
				filterString +=  "<Filter>"+
	            "<"+filters[i].type+">"+
	            "<PropertyName>"+filters[i].propertyName+"</PropertyName>"+
	            "<Literal>"+filters[i].propertyValue+"</Literal>"+
	            "</"+filters[i].type+">";
		        filterString += "</Filter>";
		}
		
		return filterString;
	},
    
    _pagingToString: function(curPage, maxPerPage){
        maxPerPage = maxPerPage || this.maxPerPage;
        curPage = curPage || 1;
        return "<numPerPage>" + maxPerPage + "</numPerPage>"+
                "<curPage>" + curPage + "</curPage>";
    },
    
    _orderByToString: function(property, type){
        var str = "<orderBy>"+
    	            "<PropertyName>" + property + "</PropertyName>"+
					"<OrderType>" + type + "</OrderType>"+
    	        "</orderBy>";
        return property ? str : "";
    },
    
    _geometryToString: function(geometry){
        var parser = new OpenLayers.Format.GML();
        var xmlnode = parser.buildGeometryNode(geometry);
        return '<geometry>' + xmlnode.xml + '</geometry>';
    },
    
	//解析器
	_parserGetcapabilities:  function(result){
			return result;
	},
    
    _parserFeatures: function(resultString){
        var parser = new OpenLayers.Format.GML();
        parser.gmlns = "*";
        parser.featureName = "featureMember";
        var features = parser.read(resultString);
        return features;
    },
    
	_parserSuccessResult: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	_parseToXML: function(result){
        var xmlParser = new OpenLayers.Format.XML();
		return xmlParser.read(result.responseText);

	},
	
	_parseToJSON: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		return parser.read(result);
	},

	CLASS_NAME: "Geo.Service.Plot"
});/**
 * Class: Geo.Service.ShortestPath
 * 最短路径服务类。GeoGlobe 不支持本服务的创建，该类已废弃。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.ShortestPath = Geo.Class(Geo.Service, {

	
	/**
     * Constructor: Geo.Service.ShortestPath
     * Geo.Service.ShortestPath类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		this.name = name;
		this.url = url;
		OpenLayers.Util.extend(this, options);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};
		OpenLayers.loadURL(url,params,this,successFn,failFn);
	},
	
	/**
     * APIMethod: shortestPath
     * 最短路径查询操作。
     * 
     * Parameters:
     * options - {Object} 请求参数。
     *   start - {String} 起点坐标。
     *   end - {String}终点坐标。
     *   network - {String}网络模型名称。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例：
     * var service = new Geo.Service.ShortestPath();
     * service.shortestPath({
     *         start: "113,29",
     *         end: "116,39",
     *         network: "RouteModelDis"
     *     },function(features){
     *         //doSomeThing
     *     });
     */	
	shortestPath: function(options, successFn, failFn){
		var url = this.url;
        var startcoord = options.start;
        var endcoord = options.end;
        var network = options.network;
		var params = {
			REQUEST:"ShortestPath",
			STARTCOORD: startcoord,
			ENDCOORD: endcoord,
			NETWORKNAME: network
		};
		OpenLayers.loadURL(url,params,this,function(result){
            var features = this._parseShortestPath(result);
            successFn(features);
        },failFn);
	},
    
    //解析最短路径结果
    _parseShortestPath: function(result){
		var xmlParser = new OpenLayers.Format.XML();
		if(!result.responseXML){
			result.responseXML = xmlParser.read(result.responseText);
		}
        var parser = new OpenLayers.Format.GML();
        parser.gmlns = "*";
        var features = parser.read(result.responseXML);
        return features;
    },
    
	//解析服务能力描述信息
	_parseCapabilities: function(xml){
		
	},
	
	/*
	 * APIMethod:findRoute
	 * 返回请求起始坐标对应路网模型的导航链路信息
	 */
	findRoute: function(options, successFn, failFn) {
		var params = {
			REQUEST: "FindRoute",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
        var required = {
            data: true,
            orig: true,
            dest: true
        };
        for (var prop in required) {
            if (!(prop in config)) {
                throw new Error("Missing property '" + prop + "'");
            }
        }
		params.DATA = options.data;
		params.ORIG = options.orig;
		params.DEST = options.dest;
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
	  	if(options.radius !== null && options.radius !== undefined){
            params.RADIUS = options.radius;
        }
        
        if(options.queryType !== null && options.queryType !== undefined){
            params.QUERYTYPE = options.queryType;
        }
		
		if(options.midpos !== null && options.midpos !== undefined){
            params.MIDPOS = options.midpos;
        }
		if(options.avoidPos !== null && options.avoidPos !== undefined){
            params.AVOIDPOS = options.avoidPos;
        }
		if(options.filterRoute !== null && options.filterRoute !== undefined){
            params.FILTERROUTE = options.filterRoute;
        }
		if(options.resultCount !== null && options.resultCount !== undefined){
            params.RESULTCOUNT = options.resultCount;
        }
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
                var Routes = this._parseFindRouteResult(result);
                successFn(Routes);
            },
            failure: failFn
        });
	},
	
	_parseToJSON: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		return parser.read(result.responseText);
	},
	
	_parseFindRouteResult: function(result) {
		var routesTemp =  this._parseToJSON(result);
		this._parserFeatures(routesTemp);
		var Routes = {
			Route:routesTemp.Routes.Route
		}
		return Routes;
	},
	
	_parserFeatures: function(data) {
		var route = data.Routes.Route;
		if(route) {
			if(!(Geo.Util.isArray(route))) {
				route = [route];
				data.Routes.Route = route;
			}
			for(var i = 0,j = route.length; i < j;i++) {
				var item = route[i].Item;
				var features = [];
				if(item) {
					if(!(Geo.Util.isArray(item))) {
						item = [item];
					}
					for(var m = 0, n = item.length; m < n; m++) {
						var feature = this._getFeatureForFindRoute(item[m]);
						features.push(feature);
					}
				}
				route[i].Item = features;
			}
		}
	},
	
	_getFeatureForFindRoute: function(attribute) {
		if(!attribute || !attribute.Geometry) {
			throw "FindRoute查询中，查询结果缺少item或Geometry";
			return;
		}
		var geometry = attribute.Geometry;
		if(geometry.gml_Point) {
			geometry = this._geometryForFindRoute["point"](geometry.gml_Point);
		}else if(geometry.gml_LineString) {
			geometry = this._geometryForFindRoute["line"](geometry.gml_LineString);
		}
		
		var feature = new Geo.Feature.Vector(geometry,attribute);
		return feature;
	},
	
	_geometryForFindRoute : {
		point: function(pointStr) {
			var pointArr = pointStr.split(",");
			var point = new Geo.Geometry.Point(parseFloat(pointArr[0]),parseFloat(pointArr[1]));
			return point;
		},
		line: function(lineStr) {
			if(lineStr) {
				var pointStrArr = lineStr.split(" ");
				var pointArr = [];
				for(var i = 0,j = pointStrArr.length; i < j; i++) {
					var pointGeometry = _geometryForFindRoute["point"](pointStrArr[i]);
					pointArr.push(pointGeometry);
				}
				var lineGeometry = new OpenLayers.Geometry.LineString(pointArr);
				return lineGeometry;
			}else {
				return null;
			}
		}
	},
	
	/**
	 * APIMethod:getRouteInfo
	 * 返回请求编号查询到路段的详细信息。
	 */
	getRouteInfo: function(options, successFn, failFn) {
		var params = {
			REQUEST: "GetRouteInfo",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
		if(!options.data || !options.id){
            throw "Error!Not data and id for bus query.";
            return;
        }
		params.DATA = options.data;
		params.ID = options.id;
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				var features = this._parserFeaturesForRouteInfo(result);
            	successFn(features);
            },
            failure: failFn
        });
	},	
	
	_parserFeaturesForRouteInfo: function(resultString){
        var resultJson = this._parseToJSON(resultString);
		var RouteInfo = this._getFeaturesForRouteInfo(resultJson);
		return RouteInfo;
    },
	
	_getFeaturesForRouteInfo: function(data) {
		var route = data.RouteInfo.Route;
		if(route) {
			if(!Geo.Util.isArray(route)) { 
				route = [route];
				data.RouteInfo.Route = route;
			}
			var features = [];
			for(var i = 0,j = route.length; i < j;i++) {
				var routeTemp = route[i];
				var feature = this._getFeatureForFindRoute(routeTemp);
				features.push(feature);
			}
			data.RouteInfo.Route = features;
		}
		var RouteInfo = {
			Route:data.RouteInfo.Route
		}
		return RouteInfo;
	},
    
	CLASS_NAME: "Geo.Service.ShortestPath"
});/**
 * Class: Geo.Service.Route
 * 最短路径服务类。该类已废弃。请使用Geo.Service.GeoRoute。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.Route = Geo.Class(Geo.Service, {

	
	/**
     * Constructor: Geo.Service.Route
     * Geo.Service.Route类的构造函数
     *
     * Parameters:
     * name - {String} 服务名称
     * url - {String} 服务地址
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		this.name = name;
		this.url = url;
		OpenLayers.Util.extend(this, options);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};
		OpenLayers.loadURL(url,params,this,successFn,failFn);
	},
	
	/*
	 * APIMethod:findRoute
	 * 返回请求起始坐标对应路网模型的导航链路信息
	 * Parameters:
	 * options - {Object} 请求参数
	 * 		data - {String} （必选）路网名称
	 * 		orig - {String} （必选）起点坐标   例如："120,30"
	 * 		dest -  {String} （必选）终点坐标
	 * 		radius — {Number}(可选) 抓取起点与终点距离有效道路的半径范围，单位为米，默认值为10米
	 * 		queryType - {Number} (可选)导航查询类型。0表示最快时间；1表示最短路径，默认为按最短路径查询
	 * 		midpos - {String}(可选) 途径点坐标集，多个坐标之间以分号分隔，XY坐标之间以逗号分隔。（如：x1,y1;x2,y2）
	 * 		avoidPos - {String}(可选) 规避点坐标集，多个坐标之间以分号分隔，XY坐标之间以逗号分隔。（如：x1,y1;x2,y2）
	 *      filterRoute - {Number}(可选) 导航查询的途径路段类型过滤，可选值：0 – 不进行过滤；1 – 过滤高速公路；2 – 过滤小路；默认值为0
	 *      resultCount - {Number}返回导航查询的最大解决方案数量，参数值必须为正整数,默认值为1
	 *   (code) 
	 *   	//创建路网查询对象
	 *   	var ShortestPath =new  Geo.Service.ShortestPath("shortPath","http://10.4.6.248:7009/Route_L/route");
	 *   	ShortestPath.findRoute({
	 *				data:"XZ",
	 *				id:"706,347"
	 *			},function(routes){
	 *				debugger;
	 *			});
	 *   (end)
	 */
	findRoute: function(options, successFn, failFn) {
		var params = {
			REQUEST: "FindRoute",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
        var required = {
            data: true,
            orig: true,
            dest: true
        };
        for (var prop in required) {
            if (!(prop in options)) {
                throw new Error("Missing property '" + prop + "'");
            }
        }
		params.DATA = options.data;
		params.ORIG = options.orig;
		params.DEST = options.dest;
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
	  	if(options.radius !== null && options.radius !== undefined){
            params.RADIUS = options.radius;
        }
        
        if(options.queryType !== null && options.queryType !== undefined){
            params.QUERYTYPE = options.queryType;
        }
		
		if(options.midpos !== null && options.midpos !== undefined){
            params.MIDPOS = options.midpos;
        }
		if(options.avoidPos !== null && options.avoidPos !== undefined){
            params.AVOIDPOS = options.avoidPos;
        }
		if(options.filterRoute !== null && options.filterRoute !== undefined){
            params.FILTERROUTE = options.filterRoute;
        }
		if(options.resultCount !== null && options.resultCount !== undefined){
            params.RESULTCOUNT = options.resultCount;
        }
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
                var Routes = this._parseFindRouteResult(result);
                successFn(Routes);
            },
            failure: failFn
        });
	},
	
	_parseToJSON: function(result){
		var parser = new Geo.Util.Format.XML2JSON();
		var xml = result.responseXML.xml;
		return parser.read(xml);
	},
	
	_parseFindRouteResult: function(result) {
		var routesTemp =  this._parseToJSON(result);
		var rTemp = this._parserFeatures(routesTemp);
		var Routes = {
			Route:rTemp
		}
		return Routes;
	},
	
	_parserFeatures: function(data) {
		if(!data.Routes) {
			return {};
		}
		var route = data.Routes.Route;
		if(route) {
			if(!(Geo.Util.isArray(route))) {
				route = [route];
				data.Routes.Route = route;
			}
			for(var i = 0,j = route.length; i < j;i++) {
				var item = route[i].Item;
				var features = [];
				if(item) {
					if(!(Geo.Util.isArray(item))) {
						item = [item];
					}
					for(var m = 0, n = item.length; m < n; m++) {
						var feature = this._getFeatureForFindRoute(item[m]);
						features.push(feature);
					}
				}
				route[i].Item = features;
			}
		}
		return route;
	},
	
	_getFeatureForFindRoute: function(attribute) {
		if(!attribute || !attribute.Geometry) {
			throw "FindRoute查询中，查询结果缺少item或Geometry";
			return;
		}
		var geometry = attribute.Geometry;
		if(geometry.gml_Point) {
			geometry = this._geometryForFindRoute["point"](geometry.gml_Point);
		}else if(geometry.gml_LineString) {
			geometry = this._geometryForFindRoute["line"](geometry.gml_LineString);
		}
		
		var feature = new Geo.Feature.Vector(geometry,attribute);
		return feature;
	},
	
	_geometryForFindRoute : {
		point: function(pointStr) {
			var pointArr = pointStr.split(",");
			var point = new Geo.Geometry.Point(parseFloat(pointArr[0]),parseFloat(pointArr[1]));
			return point;
		},
		line: function(lineStr) {
			if(lineStr) {
				var pointStrArr = lineStr.split(" ");
				var pointArr = [];
				for(var i = 0,j = pointStrArr.length; i < j; i++) {
					var pointGeometry = Geo.Service.Route.prototype._geometryForFindRoute["point"](pointStrArr[i]);
					pointArr.push(pointGeometry);
				}
				var lineGeometry = new OpenLayers.Geometry.LineString(pointArr);
				return lineGeometry;
			}else {
				return null;
			}
		}
	},
	
	/*
	 * APIMethod:getRouteInfo
	 * 返回请求编号查询到路段的详细信息
	 * 	Parameters:
	 * 		options - {Object} 请求参数
	 * 			data - {String} （必选）路网名称
	 *   (code) 
	 *   	//创建路网查询对象
	 *   	var ShortestPath =new  Geo.Service.ShortestPath("shortPath","http://10.4.6.248:7009/Route_L/route");
	 *   	ShortestPath.getRouteInfo({
	 *				data:"XZ",
	 *				id:"706,347"
	 *			},function(routes){
	 *				debugger;
	 *			});
	 *   (end)
	 */
	getRouteInfo: function(options, successFn, failFn) {
		var params = {
			REQUEST: "GetRouteInfo",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
		if(!options.data || !options.id){
            throw "Error!Not data and id for bus query.";
            return;
        }
		params.DATA = options.data;
		params.ID = options.id;
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				var features = this._parserFeaturesForRouteInfo(result);
            	successFn(features);
            },
            failure: failFn
        });
	},	
	
	_parserFeaturesForRouteInfo: function(result){
        var resultJson = this._parseToJSON(result);
		var RouteInfo = this._getFeaturesForRouteInfo(resultJson);
		return RouteInfo;
    },
	
	_getFeaturesForRouteInfo: function(data) {
		var routeInfoTemp = data.RouteInfo;
		if(!routeInfoTemp || !routeInfoTemp.Route) {
			var RouteInfo = {
				Route:{}
			}
			return RouteInfo;
		}
		var route = routeInfoTemp.Route;
		if(route) {
			if(!(Geo.Util.isArray(route))) {
				route = [route];
				routeInfoTemp.Route = route;
			}
			var features = [];
			for(var i = 0,j = route.length; i < j;i++) {
				var routeTemp = route[i];
				var feature = this._getFeatureForFindRoute(routeTemp);
				features.push(feature);
			}
			routeInfoTemp.Route = features;
		}
		var RouteInfo = {
			Route:routeInfoTemp.Route
		}
		return RouteInfo;
	},
    
	CLASS_NAME: "Geo.Service.Route"
	
});/**
 * Class: Geo.Service.TAS
 * 地形分析服务类。
 *
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.TAS = Geo.Class(Geo.Service, {

    /**
     * Constructor: Geo.Service.TAS
     * Geo.Service.TAS 类的构造函数。
     *
     * Parameters:
     * 	name - {String} 服务名称。
     * 	url - {String} 服务地址。
     * 	options - {Object} 实例的选项设置，此参数可选。
     *
     */
    initialize: function(name, url, options){
        this.name = name;
        this.url = url;
        OpenLayers.Util.extend(this, options);
    },
    
    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * 	successFn - {Function} 请求成功的回调函数。
     * 	failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            VERSION: "1.0.0",
            SERVICE: "TAS"
        };
        OpenLayers.loadURL(url, params, null, successFn, failFn);
    },
    
    /**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     *
     * Returns:
     * {Boolean} 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            VERSION: "1.0.0",
            SERVICE: "TAS"
        };
        var xhr = OpenLayers.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },
    
    /**
     * APIMethod: pointAltitude
     * 地形高程查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.pointAltitude({
     *      layerLevel: 3,
     *      pointCount: 1,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049",
     *      subjoin : 10
     *  })
     *  (end)
     */
    pointAltitude: function(options, successFn, failFn){
        this._sendRequest("PointAltitude", options, successFn, failFn);
    },
    
    /**
     * APIMethod: pointSlope
     * 坡度查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.pointSlope({
     *      layerLevel: 3,
     *      pointCount: 1,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049",
     *      subjoin : 10
     *  })
     *  (end)
     */
    pointSlope: function(options, successFn, failFn){
        this._sendRequest("PointSlope", options, successFn, failFn);
    },
    
    /**
     * APIMethod: pointAspect
     * 坡向查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.pointAspect({
     *      layerLevel: 3,
     *      pointCount: 1,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049",
     *      subjoin : 10
     *  }
     *  (end)
     */
    pointAspect: function(options, successFn, failFn){
        this._sendRequest("PointAspect", options, successFn, failFn);
    },
    
    /**
     * APIMethod: surfaceArea
     * 表面面积查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.surfaceArea({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    surfaceArea: function(options, successFn, failFn){
        this._sendRequest("SurfaceArea", options, successFn, failFn);
    },
    
    /**
     * APIMethod: volume
     * 体积查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.volume({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    volume: function(options, successFn, failFn){
        this._sendRequest("Volume", options, successFn, failFn);
    },
    
    /**
     * APIMethod: surfaceDistance
     * 表面矩离查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.surfaceDistance({
     *      layerLevel: 3,
     *      pointCount: 2,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061123,25.293686487049",
     *      subjoin : 10
     *  }
     *  (end)
     */
    surfaceDistance: function(options, successFn, failFn){
        this._sendRequest("SurfaceDistance", options, successFn, failFn);
    },
    
    /**
     * APIMethod: profileAnalysis
     * 剖面分析操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.profileAnalysis({
     *      layerLevel: 3,
     *      pointCount: 2,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061123,25.293686487049",
     *      subjoin : 10
     *  }
     *  (end)
     */
    profileAnalysis: function(options, successFn, failFn){
        this._sendRequest("ProfileAnalysis", options, successFn, failFn);
    },
    
    /**
     * APIMethod: contourAnalysis
     * 等高线分析操作
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.contourAnalysis({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    contourAnalysis: function(options, successFn, failFn){
        this._sendRequest("ContourAnalysis", options, successFn, failFn);
    },
    
    /**
     * APIMethod: topPoint
     * 顶点查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.topPoint({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    topPoint: function(options, successFn, failFn){
        this._sendRequest("TopPoint", options, successFn, failFn);
    },
    
    /**
     * APIMethod: singlePointVisiable
     * 单点可视查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.singlePointVisiable({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    singlePointVisiable: function(options, successFn, failFn){
        this._sendRequest("SinglePointVisiable", options, successFn, failFn);
    },
    
    /**
     * APIMethod: floodAnalysis
     * 洪水淹沿分析操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.floodAnalysis({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    floodAnalysis: function(options, successFn, failFn){
        this._sendRequest("FloodAnalysis", options, successFn, failFn);
    },
    
    /**
     * APIMethod: topLowPoint
     * 最高点与最低点的查询操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   layerLevel   {Integer} (必选) 图层等级  必须为正整型。
     *   pointCount   {Integer} (必选) 点数目。
     *   layerName    {String}  (必选) 服务里图层的名称。
     *   coordinates  {String} (必选) 地图上量算点的位置数组，用逗号分隔XY轴坐标如(X,Y)。
     *   subjoin 	  {Integer} (可选)。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     *  tasService.topLowPoint({
     *      layerLevel: 3,
     *      pointCount: 3,
     *      layerName : "china100m",
     *      coordinates :"103.87006248379,24.293686487049,104.061,25.293686487049,104.4542,23.558429",
     *      subjoin : 10
     *  }
     *  (end)
     */
    topLowPoint: function(options, successFn, failFn){
        this._sendRequest("TopLowPoint", options, successFn, failFn);
    },
    
    /**
     * APIMethod: getMetaData
     * 元数据查询操作。
     *
     * Parameters:
     * caller - {Object}
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getMetaData: function(caller, successFn, failFn){
        this._sendRequest("GetMetaData", options, successFn, failFn);
    },
    
    //发送请求
    _sendRequest: function(action, options, successFn, failFn){
        var url = this.url;
        var layerLevel = options.layerLevel;
        var layerName = options.layerName;
        var pointCount = options.pointCount;
        var coordinates = this._convertRadian(options.coordinates);
        var subjoin = options.subjoin || 0;
        var params = {
            REQUEST: action,
            LAYERLEVEL: layerLevel,
            LAYERNAME: layerName,
            POINTCOUNT: pointCount,
            COORDINATES: coordinates,
            SUBJOIN: subjoin
        };
        OpenLayers.loadURL(url, params, this, function(result){
            var resultObj = this._parseResult(result);
            successFn(resultObj);
        }, failFn);
    },
    
    //经纬度转弧度
    _convertRadian: function(coordinates){
        var arr = coordinates.split(",");
        for (var i = 0; i < arr.length; i++) {
            arr[i] = arr[i] * 3.1415926 / 180;
        }
        return arr.join(",");
    },
    
    _countCoord: function(pointString){
        var arr = pointString.split(",");
        return arr.length / 2;
    },
    
    _parseResult: function(result){
        var errorResult = this._checkIsError(result.responseText);
        if (!errorResult) {
            var parser = new Geo.Util.Format.XML2JSON();
            var resultObj = parser.read(result.responseText);
            return resultObj;
        }
        return errorResult;
    },
    
    CLASS_NAME: "Geo.Service.TAS"
});
/**
 * Class: Geo.Service.WPS
 * OGC-WPS服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.WPS = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.WPS
     * Geo.Service.WPS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var request = "GetCapabilities";
		var url = this.url + "/" + request;
		
		if(!failFn){
			failFn = function(){
				this.failFn(request);
			};
		}
		OpenLayers.loadURL(url,null,this,function(result){
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */
	isExist: function(){
		var isExist = false;
		var request = "GetCapabilities";
		var url = this.url + "/" + request;
		var xhr = OpenLayers.Request.GET({
            url: url,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},
	
	/**
     * APIMethod: describeProcess
     * 获取指定Process描述信息。
     * 
     * Parameters:
     * process - {String} Process名称。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例：
     * (code)
     * serviceObj.describeProcess("buffer", function(result){
     *     alert(result.reponseText);
     * });
     * (end)
     */	
	describeProcess: function(process,successFn,failFn){
		var requestTemplate = 
			'<DescribeProcess xmlns="http://www.opengis.net/wps/1.0.0" ' +
							  'xmlns:ows="http://www.opengis.net/ows/1.1" ' +
							  'xmlns:xlink="http://www.w3.org/1999/xlink" ' +
							  'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ' +
							  'xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 ../wpsDescribeProcess_request.xsd" ' +
							  'service="WPS" ' +
							  'version="1.0.0" ' +
							  'language="en-CA">' +
			    '<ows:Identifier>' +
			        '${process}' +
			    '</ows:Identifier>' +
			'</DescribeProcess>';
		var postStr = OpenLayers.String.format(
			requestTemplate,
			{process:process}
		);
		
		var request = "DescribeProcess";
		var url = this.url + "/" + request;
		
		if(!failFn){
			failFn = function(){
				this.failFn(request);
			};
		}
		
		var xhr = new OpenLayers.Request.POST({
			url: url,
			data: postStr,
			scope: this,
			success:successFn,
			failure:failFn
		});
	},
	
	/**
     * APIMethod: execute
     * 执行分析操作。
     * 
     * Parameters:
     * content - {String} 分析操作请求内容。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * (code)
     *       var requestStr = '<wps:Execute service="WPS" version="1.0.0" 
     *       xmlns:gml="http://www.opengis.net/gml" 
     *       xmlns:wps="http://www.opengis.net/wps/1.0.0" 
     *       xmlns:ows="http://www.opengis.net/ows/1.1" 
     *       xmlns:wfs="http://www.opengis.net/wfs" 
     *       xmlns:xlink="http://www.w3.org/1999/xlink" 
     *       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
     *       xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 ../wpsExecute_request.xsd">' +
     *           '<ows:Identifier>Intersection</ows:Identifier>' +
     *           '<wps:DataInputs>' +
     *           '<wps:Input>' +
     *           '<ows:Identifier>InputPolygon</ows:Identifier>' +
     *           '<wps:Data>' +
     *           '<wps:ComplexData schema="http://foo.bar/MyComplexValueSchema.xsd" mimeType="text/xml" encoding="UTF-8">' +
     *           '<wfs:FeatureCollection xmlns:wfs="http://www.opengis.net/wfs">' +
     *           '<gml:featureMember xmlns:gml="http://www.opengis.net/gml">' +
     *           '<feature:features xmlns:feature="http://mapserver.gis.umn.edu/mapserver" fid="Geo.Feature.Vector_112">' +
     *           '<feature:geometry>' +
     *           '<gml:LineString>' +
     *           '<gml:coordinates decimal="." cs="," ts=" ">100.40625,12.09765625 110.10546875,45.83203125</gml:coordinates>' +
     *           '</gml:LineString>' +
     *           '</feature:geometry>' +
     *           '</feature:features>' +
     *           '</gml:featureMember>' +
     *           '</wfs:FeatureCollection>' +
     *           '<wfs:FeatureCollection xmlns:wfs="http://www.opengis.net/wfs">' +
     *           '<gml:featureMember xmlns:gml="http://www.opengis.net/gml">' +
     *           '<feature:features xmlns:feature="http://mapserver.gis.umn.edu/mapserver" fid="Geo.Feature.Vector_118">' +
     *           '<feature:geometry>' +
     *           '<gml:LineString>' +
     *           '<gml:coordinates decimal="." cs="," ts=" ">100.40625,30.09765625 110.10546875,30.83203125</gml:coordinates>' +
     *           '</gml:LineString>' +
     *           '</feature:geometry>' +
     *           '</feature:features>' +
     *           '</gml:featureMember>' +
     *           '</wfs:FeatureCollection>' +
     *           '</wps:ComplexData>' +
     *           '</wps:Data>' +
     *           '</wps:Input>' +
     *           '</wps:DataInputs>' +
     *           '<wps:ResponseForm>' +
     *           '<wps:RawDataOutput>' +
     *           '<ows:Identifier>BufferedPolygon</ows:Identifier>' +
     *           '</wps:RawDataOutput>' +
     *           '</wps:ResponseForm>' +
     *           '</wps:Execute>';
     *           
     *           serviceObj.execute(requestStr, function(result){});
     * (end)
     */	
	execute: function(content,successFn,failFn){
		var request = "Execute";
		var url = this.url + "/" + request;
		
		if(!failFn){
			failFn = function(){
				this.failFn(request);
			};
		}
		
		var xhr = new OpenLayers.Request.POST({
			url: url,
			data: content,
			scope: this,
			success:successFn,
			failure:failFn
		});
	},

	CLASS_NAME: "Geo.Service.WPS"
});/**
 * Class: Geo.Service.WFS
 * OGC-WFS服务类。
 * 说明：本类也适用于聚合网络要素服务（Aggregation Web Feature Service简称AWFS）
 * 和地名地址要素服务（Web Feature Service Gazetteer简称WFS-G）。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.WFS = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.WFS
     * Geo.Service.WFS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WFS",
			VERSION: "1.0.0"
		};
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},

	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */	
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WFS"
		};
		var xhr = OpenLayers.Request.GET({
            url: url,
			params: params,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},
	
	/**
     * APIMethod: describeFeatureType
     * 获取要素类型描述操作。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     *   params有三个参数(service,version,request)默认可以不填，其中version默认值是1.0.0，如果要设置其他版本请设置version参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例：
     * (code)
     * serviceObj.describeFeatureType({
     *     TypeName: "RES1_T_PN"
     * }, showResult);
     * (end)
     */	
	describeFeatureType: function(params,successFn,failFn){
		var url = this.url;
		var DEFAULT_PARAMS = { 
			service: "WFS",
			version: "1.0.0",
			request: "DescribeFeatureType"
		};
		OpenLayers.Util.applyDefaults(params,DEFAULT_PARAMS);
		
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: getFeature
     * 获取要素操作。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     * 	TypeName - {String} 必选 类型名称。
     * 	version - {String} 版本，默认值是1.0.0,如果用户请求的服务版本不是1.0.0，请设置该参数。
     *  MaxFeatures - {Integer} 可选 查询的返回的结果总数。
     *  filter - {Geo.Filter} 可选 过滤器。
     *  以上是常用的属性，其他属性请参考OGC-WFS标准。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例:
     * (code)
     * 	 serviceObj.getFeature({
     *      TypeName: "RES1_T_PN",
     *      MaxFeatures: 10
     *   }, function(){});
     * (end)
     */	
	getFeature: function(params,successFn,failFn){
		var url = this.url;
		var DEFAULT_PARAMS = { 
			service: "WFS",
			version: "1.0.0",
			request: "GetFeature"
		};
		OpenLayers.Util.applyDefaults(params,DEFAULT_PARAMS);
		
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},

	CLASS_NAME: "Geo.Service.WFS"
	
});/**
 * Class: Geo.Service.WFST
 * OGC-WFST服务类。Web要素服务-T（Web Feature Service-Transaction简称WFST）遵循OGC的WFS1.0.0规范，
 * 本服务提供对要素的增加、修改、删除等事务操作。
 *
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.WFST = Geo.Class(Geo.Service, {
	
    /**
     * APIProperty: xy
     * {Boolean} 值为true时，为(x,y)顺序。值为false时，为(y,x)顺序。
     */ 
    xy: true,

    /**
     * Constructor: Geo.Service.WFST
     * Geo.Service.WFST类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     */
    initialize: function(name, url, options){
        Geo.Service.prototype.initialize.apply(this, arguments);
    },
    
    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WFS",
            VERSION: "1.0.0"
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        OpenLayers.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },
    
    /**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     *
     * Returns:
     * {Boolean} 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WFS"
        };
        var xhr = OpenLayers.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },
    
    /**
     * APIMethod: describeFeatureType
     * 获取要素类型描述操作。
     *
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     *   params有三个参数(service,version,request)默认可以不填，其中version默认值是1.0.0，如果要设置其他版本请设置version参数。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例：
     * (code)
     * serviceObj.describeFeatureType({
     *     TypeName: "RES1_T_PN"
     * }, showResult);
     * (end)
     */
    describeFeatureType: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            SERVICE: "WFS",
            VERSION: "1.0.0",
            REQUEST: "DescribeFeatureType"
        };
        OpenLayers.Util.applyDefaults(params, DEFAULT_PARAMS);
        
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        
        OpenLayers.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },
    
    /**
     * APIMethod: getFeature
     * 获取要素操作。
     *
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     * 	TypeName - {String} 必选 类型名称。
     * 	version - {String} 版本，默认值是1.0.0,如果用户请求的服务版本不是1.0.0，请设置该参数。
     *  MaxFeatures - {Integer} 可选 查询的返回的结果总数。
     *  filter - {Geo.Filter} 可选 过滤器。
     *  以上是常用的属性，其他属性请参考OGC-WFS标准。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     *
     * 示例:
     * (code)
     * 	 serviceObj.getFeature({
     *      TypeName: "RES1_T_PN",
     *      MaxFeatures: 10
     *   }, function(){});
     * (end)
     */
    getFeature: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            SERVICE: "WFS",
            VERSION: "1.0.0",
            REQUEST: "GetFeature"
        };
        OpenLayers.Util.applyDefaults(params, DEFAULT_PARAMS);
        
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        
        OpenLayers.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },
    
    /**
     * APIMethod: lockFeature
     * 锁定要素操作。
     *
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     * 	typeName - {String} 必选 指定操作的图层类型名称。
     * 	version - {String} 可选 版本号，默认值是1.0.0，如果用户请求的服务版本不是1.0.0，请设置该参数。
     *  expiry - {Number} 可选 锁定的分钟数，如果没有则默认为1分钟。
     *  lockAction - {String} 可选 指定如何获得锁，如果没有则默认为"ALL"。
     *  filter - {Geo.Filter} 可选 操作要素的条件过滤器。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    lockFeature: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            service: "WFS",
            version: "1.0.0",
            request: "LockFeature",
            expiry: 1,
            lockAction: "ALL"
        };
        OpenLayers.Util.applyDefaults(params, DEFAULT_PARAMS);
        
		//解析filter对象，转换为XML字符串。
		var filterXMLString = this._parserFilterToString(params.filter);
        
        var requestStringTemplate = '<?xml version="1.0" encoding="UTF-8"?>' +
        '<LockFeature version="${version}" service="${service}" lockAction="${lockAction}" expiry="${expiry}" ' +
	        'xmlns:wfs=" http://www.opengis.net/wfs" ' +
	        'xmlns:gml=" http://www.opengis.net/gml" ' +
	        'xmlns:myns=" http://www.someserver.com/myns" ' +
	        'xmlns:ogc=" http://www.opengis.net/ogc" ' +
	        'xmlns:xsi=" http://www.w3.org/2001/XMLSchema-instance" ' +
	        'xsi:schemaLocation="http://www.opengis.net/wfs ../wfs/1.1.0/WFS.xsd">' +
	        '<Lock typeName="${typeName}">' +
		        '${filterXMLString}' +
	        '</Lock>' +
        '</LockFeature>';
        
        var requestString = OpenLayers.String.format(requestStringTemplate, {
            version: params.version,
            service: params.service,
            lockAction: params.lockAction,
            expiry: params.expiry,
            typeName: params.typeName,
            filterXMLString: filterXMLString
        });
        
        
        if (!failFn) {
            failFn = function(){
                this.failFn(params.request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
        
        //        OpenLayers.loadURL(url, params, this, function(result){
        //            successFn(result);
        //        }, failFn);
    },
    
    /**
     * APIMethod: transaction
     * 要素的事务操作，可以对服务中的要素内容进行增加、删除和修改操作。
     *
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WFS标准。
     * 	version {String} 可选 版本号，默认值是1.0.0，如果用户请求的服务版本不是1.0.0，请设置该参数。
     * 	releaseAction {String} 可选 指定如何释放锁，提供有"ALL"和"SOME"两种方式，默认值是"ALL"。
     *             在做更新或删除要素的时候，releaseAction="ALL"或"SOME"决定LockId对应的所有要素是否全部释放。
     *             如果是"ALL",表示LockId对应的所有要素全部解锁释放。
     *             如果是"SOME",表示LockId只对正在操作的要素解锁释放，其他要素还是保持锁定状态。
     *  lockId {String} 可选 锁定编号。
     * inserts - {Object} 添加要素的请求参数。
     *  features {Array(<Geo.Feature.Vector>)} 必选 一系列要素的集合。
     *  typeName {String} 必选 指定操作的图层类型名称。
     * updates - {Object} 修改要素的请求参数。
     *  feature {<Geo.Feature.Vector>} 必选 要素对象。
     *  typeName {String} 必选 指定操作的图层类型名称。
     *  filter {Geo.Filter} 可选 操作要素的条件过滤器。
     * deletes - {Object} 删除要素的请求参数。
     *  typeName {String} 必选 指定操作的图层类型名称。
     *  filter {Geo.Filter} 可选 操作要素的条件过滤器。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    transaction: function(params, inserts, updates, deletes, successFn, failFn){
		var url = this.url;
		//默认参数
        var DEFAULT_PARAMS = {
            service: "WFS",
            version: "1.0.0",
            request: "Transaction",
            releaseAction: "ALL"
        };
		//合并默认参数，获得实际请求参数
		OpenLayers.Util.applyDefaults(params, DEFAULT_PARAMS);
		
		//定义post请求模板
		var requestStringTemplate = '<?xml version="1.0" encoding="UTF-8"?>' +
        '<wfs:Transaction releaseAction="${releaseAction}" handle="Transaction 01" version="${version}" service="${service}" '+
		'xmlns="http://www.someserver.com/myns" ' +
		'xmlns:gml="http://www.opengis.net/gml" ' +
		'xmlns:ogc="http://www.opengis.net/ogc" ' +
		'xmlns:wfs="http://www.opengis.net/wfs" ' +
		'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">' +
	        '${lockIdString}' +
	        '${transactionString}' +
        '</wfs:Transaction>';
		
		//lockId的请求标签
        var lockId = params.lockId;
		var lockIdString = "";
		if(lockId){
			lockIdString += '<LockId>' + lockId + '</LockId>';
		}
		
		var transactionString = "";
		//添加
        if (inserts) {
            transactionString += this._getInsertString(inserts);
        }
		//修改
		if(updates){
			transactionString += this._getUpdateString(updates);
		}
		//删除
		if(deletes){
			transactionString += this._getDeleteString(deletes);
		}
		
		//根据模板，获得post请求串
        var requestString = OpenLayers.String.format(requestStringTemplate, {
            releaseAction: params.releaseAction,
            version: params.version,
            service: params.service,
            lockIdString: lockIdString,
            transactionString: transactionString
        });
		
		//请求失败的回调函数
		if (!failFn) {
            failFn = function(){
                this.failFn(params.request);
            };
        }
		
		//发送post请求
		var xhr = new OpenLayers.Request.POST({
            url: url,
            data: requestString,
            scope: this,
            success: successFn,
//          success: function(result){
//				if(typeof successFn == "function"){
//	            	successFn(this._parseTransactionResult(result));
//	            }
//			},
            failure: failFn
        });
	},
	
	/**
     * APIMethod: parseTransactionResult
     * 解析服务返回的要素事务操作的响应结果。 
     * 
     * Parameters:
     * result - {object} 服务返回的要素事务操作的响应结果。
     *
     * Returns:
     * {object} 返回要素事务操作的JSON返回结果。
	 */
    parseTransactionResult: function(result){
	    var format = new Geo.Util.Format.XML2JSON();
	    var obj = format.read(result.responseText);
	    var res = new Array();
	    var wfs_Status = this._objToArray(obj.wfs_WFS_TransactionResponse.wfs_TransactionResult.wfs_Status);
	    var wfs_InsertResults = this._objToArray(obj.wfs_WFS_TransactionResponse.wfs_InsertResults);
	    for (var i = 0; i < wfs_Status.length; i++) {
	        if (wfs_Status[i].wfs_SUCCESS !== undefined) {
	            res.push({
	                status: "SUCCESS",
	                fid: wfs_InsertResults ? wfs_InsertResults[i].ogc_FeatureId.fid : null
	            });
	        }
	        else {
	            res.push({
	                status: "FAILED",
	                fid: null
	            });
	        }
	    }
	    return res;
	},
	
	/**
     * Method: _objToArray
     * 对象转数组。 
     * 
     * Parameters:
     * obj - {object} 对象。
     *
     * Returns:
     * {Array} 返回数组。
	 */
    _objToArray: function(obj){
		if (obj && !(obj instanceof Array)) {
	        obj = [obj];
	    }
	    return obj;
	},
	
	/**
     * Method: _getInsertString
     * 获取插入的XML字符串。 
     * 
     * Parameters:
     * insert - {object} 添加要素的参数对象。
     *
     * Returns:
     * {String} 返回插入的XML字符串。
	 */
    _getInsertString: function(inserts){
		var features = inserts.features;
		var typeName = inserts.typeName;
		var insertStr = "";
        for (var i = 0; i < features.length; i++) {
            var feature = features[i];
            insertStr += '<wfs:Insert handle="Insert ' + i + '">' +
			this._getInsertFeatureString(feature, typeName) +
			'</wfs:Insert>';
        };
		return insertStr;
	},
	
	/**
     * Method: _getInsertFeatureString
     * 获取保存要素所需的外部属性串。 
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 要素。
     * typeName - {String} 指定操作的图层类型名称。
     *
     * Returns:
     * {String} 返回保存要素所需的外部属性串。
	 */
    _getInsertFeatureString: function(feature, typeName){
			        
        var str = "";
        
        var featureTemplate = '<${typeName}>${content}</${typeName}>';
        var geoTemplate = "<GEOMETRY>${geometry}</GEOMETRY>";
        
        var attrTemplate = "<${tag}><![CDATA[${value}]]></${tag}>"
        
        for (var item in feature.data) {
            if (item == "OID") {
                continue;
            }
            str += OpenLayers.String.format(attrTemplate, {
                value: (feature.data[item] ? feature.data[item] : ""),
                tag: item
            });
        }
        str += OpenLayers.String.format(geoTemplate, {
            geometry: this._getGeometryStringByFeature(feature)
        });
        
        str = OpenLayers.String.format(featureTemplate, {
            typeName: typeName,
            content: str
        });
        return str;
    },
	
	/**
     * Method: _getUpdateString
     * 获取插入的XML字符串。 
     * 
     * Parameters:
     * updates - {object} 修改要素的参数对象。
     *
     * Returns:
     * {String} 返回XML字符串。
	 */
    _getUpdateString: function(updates){
        var filter = updates.filter;
        var typeName = updates.typeName;
        var feature = updates.feature;
        
        //要素的要修改的属性和值的XML字符串
        var propertyString = this._getUpdatePropertyString(feature);
        //解析filter对象，转换为XML字符串。
        var filterXMLString = this._parserFilterToString(filter);
        var updateStr = '<wfs:Update typeName="' + typeName + '" handle="Update 1">' +
	        propertyString +
	        filterXMLString +
        '</wfs:Update>';
        
        return updateStr;
    },
	
	/**
     * Method: _getUpdatePropertyString
     * 获取修改的要素属性的XML字符串。 
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 要素。
     *
     * Returns:
     * {String} 返回修改的要素属性的XML字符串。
	 */
    _getUpdatePropertyString: function(feature){
        var str = "";
        for (var item in feature.data) {
            if (item == "OID") {
                continue;
            }
            str += '<wfs:Property>' +
	            '<wfs:Name><![CDATA[' +
	            item +
	            ']]></wfs:Name>' +
	            '<wfs:Value><![CDATA[' +
	            (feature.data[item] ? feature.data[item] : "") +
	            ']]></wfs:Value>' +
            '</wfs:Property>';
        }
        str += '<wfs:Property>' +
	        '<wfs:Name>Geometry</wfs:Name>' +
	        '<wfs:Value>' +
	        this._getGeometryStringByFeature(feature) +
	        '</wfs:Value>' +
        '</wfs:Property>';
        return str;
    },
	
	/**
     * Method: _getGeometryStringByFeature
     * 获取修改的要素geometry的XML字符串。 
     * 
     * Parameters:
     * feature - {<Geo.Feature.Vector>} 要素。
     *
     * Returns:
     * {String} 返回修改的要素geometry的XML字符串。
	 */
	_getGeometryStringByFeature: function(feature){
		var gmlFormat = new OpenLayers.Format.GML({xy: this.xy});
        gmlFormat.buildCoordinatesNode = OpenLayers.Function.bind(function(geometry){
			var coordinatesNode = this.createElementNS(this.gmlns, "gml:coordinates");
            coordinatesNode.setAttribute("decimal", ".");
            coordinatesNode.setAttribute("cs", ",");
            coordinatesNode.setAttribute("ts", " ");
            
            var parts = [];
            
            if (geometry instanceof OpenLayers.Bounds) {
                if (this.xy) {
                    parts.push(geometry.left + "," + geometry.bottom);
                    parts.push(geometry.right + "," + geometry.top);
                }
                else {
                    parts.push(geometry.bottom + "," + geometry.left);
                    parts.push(geometry.top + "," + geometry.right);
                }
            }
            else {
                var points = (geometry.components) ? geometry.components : [geometry];
                for (var i = 0; i < points.length; i++) {
                    if (this.xy) {
                        parts.push(points[i].x + "," + points[i].y);
                    }
                    else {
                        parts.push(points[i].y + "," + points[i].x);
                    }
                }
            }
            
            var txtNode = this.createTextNode(parts.join(" "));
            coordinatesNode.appendChild(txtNode);
            
            return coordinatesNode;
			
        }, gmlFormat);
        
		//DOMElement. A GML polygon node.
		var gmlDOMElement = gmlFormat.buildGeometryNode(feature.geometry);
		//gmlDOMElement.setAttribute("srsName", "urn:ogc:def:crs:EPSG:6.9:4326");
		var xmlParser = new OpenLayers.Format.XML();
		var geometrtXmlStr = xmlParser.write(gmlDOMElement);
		return geometrtXmlStr;
    },
	
	/**
     * Method: _getDeleteString
     * 获取插入的XML字符串。 
     * 
     * Parameters:
     * deletes - {object} 删除要素的参数对象。
     *
     * Returns:
     * {String} 返回插入的XML字符串。
	 */
    _getDeleteString: function(deletes){
        var filter = deletes.filter;
        var typeName = deletes.typeName;
        
        //解析filter对象，转换为XML字符串。
        var filterXMLString = this._parserFilterToString(filter);
        
        var deleteStr = "";
        deleteStr += '<wfs:Delete typeName="' + typeName + '" handle="Delete 1">';
        deleteStr += filterXMLString;
        deleteStr += '</wfs:Delete>';
        return deleteStr;
    },
	
	/**
     * Method: _parserFilterToString
     * 解析filter对象，转换为XML字符串。
     * 
     * Parameters:
     *  filter - {<Geo.Filter>} 可选 操作要素的条件过滤器。
     *
     * Returns:
     * {String} 过滤器字符串。
	 */
    _parserFilterToString: function(filter){
		//解析filter对象，转换为XML字符串。
		var filterXMLString = "";
        if (filter) {
            var filterFormatter = new Geo.Format.Filter.v1();
            var result = filterFormatter.write(filter);//{DOMElement} An ogc:Filter element.
			var xmlParser = new OpenLayers.Format.XML();
			filterXMLString = xmlParser.write(result);
			return filterXMLString;
        }
		return filterXMLString;
	},
	
    CLASS_NAME: "Geo.Service.WFST"
});
/**
 * Class: Geo.Service.WMS
 * OGC-WMS服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.WMS = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.WMS
     * Geo.Service.WMS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WMS"
		};
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WMS"
		};
		var xhr = OpenLayers.Request.GET({
            url: url,
			params: params,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},
	
	/**
     * APIMethod: getMap
     * 获取地图内容操作。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WMS标准。
     * 	version - {String} 版本，默认值是1.1.1。
     *  layers - {String} 图层名称。
     *  styles - {String}  样式，默认是空串。
     *  srs -  - {String} 默认值是"EPSG:4326"。
     *  width - {Integer} 必选 宽。
     *  height - {Integer} 必选 长。
     *  format - {String} 默认值是"image/jpeg"。
     *  bbox  - {String} 必选 范围。
     * Returns:
 	 * {String} 地图内容图片地址。
 	 * 
 	 * 示例:
 	 * (code)
 	 * var url = wmsService.getMap({
     *     layers: "basic",
     *     bbox: "-180,-90,180,270",
     *     width: 256,
     *     height: 256
     * });
     * (end)         
     */	
	getMap: function(params){
		var url = this.url;
		var DEFAULT_PARAMS = { 
			service: "WMS",
			version: "1.1.1",
			request: "GetMap",
			styles: "",
			srs:"EPSG:4326",
			exceptions: "application/vnd.ogc.se_inimage",
			format: "image/jpeg"
		};
		OpenLayers.Util.applyDefaults(params,DEFAULT_PARAMS);
		var paramsString = OpenLayers.Util.getParameterString(params);
		return OpenLayers.Util.urlAppend(url, paramsString);
	},

	CLASS_NAME: "Geo.Service.WMS"
});/**
 * Class: Geo.Service.WMTS
 * OGC-WMTS服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.WMTS = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.WMTS
     * Geo.Service.WMTS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WMTS"
		};
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WMTS"
		};
		var xhr = OpenLayers.Request.GET({
            url: url,
			params: params,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},
	
	/**
     * APIMethod: getTile
     * 获取瓦片内容操作。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WMTS标准。
 	 * service - {String} 默认值是"WMTS"。
 	 * version - {String} 默认值是"1.0.0"。
 	 * layer - {String} 必选 图层标示。
 	 * style - {String} 必选 图层样式标示。
 	 * format - {String} 默认值是"image/png"。
 	 * TileMatrixSet - {String} 必选 矩阵集。
 	 * TileMatrix - {String} 必选 矩阵。
 	 * TileRow - {Integer} 必选 瓦片行号。
 	 * TileCol - {Integer} 必选 瓦片列号。
     * 
     * Returns:
 	 * {String} 瓦片内容图片地址。
 	 * 
 	 * 示例：
 	 * (code)
     * var url = wmtsService.getTile({
     *     layer: "dgdom0624",
     *     style: "dgdom0624",
     *     TileMatrixSet: "Matrix_0",
     *     TileMatrix: "12",
     *     TileRow: 761,
     *     TileCol: 3342
     * });
 	 * (end)
     */	
	getTile:function(params){
		var url = this.url;
		var DEFAULT_PARAMS = { 
			service: "WMTS",
			version: "1.0.0",
			request: "GetTile",
			format: "image/png"
		};
		OpenLayers.Util.applyDefaults(params,DEFAULT_PARAMS);
		var paramsString = OpenLayers.Util.getParameterString(params);
		return OpenLayers.Util.urlAppend(url, paramsString);
	},
	
	/**
     * APIMethod: getCapabilitiesForRest
     * WMTS-RESTful的获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilitiesForRest: function(successFn, failFn){
		var version = "1.0.0";
		var docName = "WMTSCapabilities.xml";
		var path = version + "/" + docName;
        var url = this.url;
        if (!url.match(/\/$/)) {
            url = url + "/";
        }
		url = url + path;
		
        if (!failFn) {
            failFn = function(){
                this.failFn("GetCapabilities");
            };
        }
		
        OpenLayers.loadURL(url, null, this, function(result){
            successFn(result);
        }, failFn);
	},
	
	/**
     * APIMethod: getTileForRest
     * WMTS-RESTful的获取瓦片内容操作。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WMTS标准。
     * 
     * Returns:
 	 * {String} 瓦片内容图片地址。
 	 * 	layer - {String} 必选 图层标示。
 	 * 	style - {String} 必选 图层样式标示。
 	 * 	format - {String} 必选 瓦片图片格式。默认值是"image/png"。
 	 * 	TileMatrixSet - {String} 必选 矩阵集。
 	 * 	TileMatrix - {String} 必选 矩阵。
 	 * 	TileRow - {Integer} 必选 瓦片行号。
 	 * 	TileCol - {Integer} 必选 瓦片列号。
 	 * 
 	 * 示例：
 	 * (code)
     * var url = wmtsService.getTile({
     *     layer: "dgdom0624",
     *     style: "dgdom0624",
     *     TileMatrixSet: "Matrix_0",
     *     TileMatrix: "12",
     *     TileRow: 761,
     *     TileCol: 3342
     * });
 	 * (end)
     */	
    getTileForRest: function(params){
		var layer = params.layer;
		var style = params.style;
		var tileMatrixSet = params.tileMatrixSet;
		var tileMatrix = params.tileMatrix;
		var tileRow = params.tileRow;
		var tileCol = params.tileCol;
		
		var formatSuffix = null;
		var format = params.format ? params.format : "image/png";
        var formatSuffixMap = {
            "image/png": "png",
            "image/png8": "png",
            "image/png24": "png",
            "image/png32": "png",
            "png": "png",
            "image/jpeg": "jpg",
            "image/jpg": "jpg",
            "jpeg": "jpg",
            "jpg": "jpg"
        };
		if (!formatSuffix) {
            formatSuffix = formatSuffixMap[format] || format.split("/").pop();            
        }
		
		var path = layer + "/" + style + "/" + tileMatrixSet + 
		"/" + tileMatrix + "/" + tileRow + "/" + tileCol + "." + formatSuffix;
        var url = this.url;
        if (!url.match(/\/$/)) {
            url = url + "/";
        }
		url = url + path;
        return url;
    },

	CLASS_NAME: "Geo.Service.WMTS"
});/**
 * Class: Geo.Service.GeoWMTS
 * 武大吉奥WMTS服务类，该服务类基于OGC-WMTS服务类，并在OGC-WMTS服务类的基础上做了扩展，
 * 实现了获取多时相WMTS服务的时间版本信息的接口
 * 
 * Inherits from:
 * - <Geo.Service.WMTS>
 */
Geo.Service.GeoWMTS = Geo.Class(Geo.Service.WMTS, {
	
	/**
     * Constructor: Geo.Service.GeoWMTS
     * Geo.Service.GeoWMTS类的构造函数
     *
     * Parameters:
     * name - {String} 服务名称
     * url - {String} 服务地址
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url, options){
		Geo.Service.WMTS.prototype.initialize.apply(this, arguments);
	},
	
	/**
	 * APIMethod: getVersions
	 * 得到服务的版本信息
	 * 
     * Parameters:
     *  params:
     * 	  layer - {String} 图层名称
     *    tileMatrix - {String} 图层层级
     *    tileMatrixSet - {String} 矩阵集名称
     *    tileBox - {String} 行列号范围，格式为“最小列,最小行,最大列,最大行” 如“3,6,7,12”表示获取3-7列、6-12行中所有的瓦片版本ID与名称。
     *    
     * 	options：
     *    content -  {String} 服务返回数据的详细程度 ，当值为"brief"时，返回信息中仅包含版本名称和版本ID；当值为"detail"时，返回信息中会
     *    包含更加详细的版本相关信息，如数据的生产时间，生产单位以及服务的提供单位等信息。当值为"full"时，返回所有信息。默认值是"full"
     *    version - {String} 服务的版本，默认值是"1.0.0"  
     *     
     *  successFn - {Function} 请求成功的回调函数
     *  failFn - {Function} 请求失败的回调函数。
     *  (code)
     *  var serviceObj = new Geo.Service.GeoWMTS("GeoWMTS服务", "http://10.4.6.49:7001/wmts_time_wuhan/wmts");
     *  serviceObj.getVersions({
     *      layer: "wuhan",
     *      tileMatrix: 5,
     *      tileBox: "24,4,27,6",
     *      tileMatrixSet: "Matrix_0" 
     *  }, {
     *      content: "full"
     *  }, function(request){
     *   	alert(request.responseText);  
     *  });
     *  (end)
	 */
	getVersions: function(params, options, successFn, failFn) {
		var url = this.url;
		//下面请求参数中需要增加CONTENT属性
		var DEFAULT_OPTIONS = { 
			content: "full",
			service: "WMTS",
			version: "1.0.0",
			request: "GetVersions"
		};
		OpenLayers.Util.applyDefaults(options, DEFAULT_OPTIONS);
		
		if(!failFn){
			failFn = function(){
				this.failFn(options.request);
			};
		}
		
		OpenLayers.loadURL(url, {
			request: options.request,
			layer: params.layer,
			tileMatrixSet: params.tileMatrixSet,
			tileMatrix: params.tileMatrix,
			tileBox: params.tileBox,
			content: options.content,
			service: options.service,
			version: options.version
			
		}, this, 
		function(request){
			successFn(request);
		},failFn);
	},
	
	/**
	 * APIMethod: GetVersionInfo
	 * 得到服务的版本信息
	 *  说明：getVersions方法也是得到用户版本信息，它是根据行列号范围等参数得到时间版本信息，而GetVersionInfo是根据版本名称等参数得到时间版本信息
	 * 
     * Parameters:
     *  params:
     * 	  layer - {String} 图层名称
     *    versionNames - {String} 多时相版本名称
     *    tileMatrixSet - {String} 矩阵集名称
     *    
     *  options：
     *    content -  {String} 服务返回数据的详细程度 ，当值为"brief"时，返回信息中仅包含版本名称和版本ID；当值为"detail"时，返回信息中会
     *    包含更加详细的版本相关信息，如数据的生产时间，生产单位以及服务的提供单位等信息。当值为"full"时，返回所有信息。默认值是"full"
     *    version - {String} 服务的版本，默认值是"1.0.0"  
     *    
     *  successFn - {Function} 请求成功的回调函数
     *  failFn - {Function} 请求失败的回调函数。
	 */
	getVersionInfo: function(params, options, successFn, failFn) {
		var url = this.url;
		//下面请求参数中需要增加CONTENT属性
		var DEFAULT_OPTIONS = { 
			content: "brief",
			service: "WMTS",
			version: "1.0.0",
			request: "GetVersionInfo"
			
		};
		OpenLayers.Util.applyDefaults(options, DEFAULT_OPTIONS);
		
		OpenLayers.loadURL(url, {
			layer: params.layer,
			versionNames: params.versionNames,
			tileMatrixSet: params.tileMatrixSet,
			content: options.content,
			service: options.service,
			version: options.version,
			request: options.request
		}, this, 
		function(request){
			successFn(request);
		},failFn);
	},
	
	/**
	 * APIMethod: getTimeVersions
	 * 请求服务，返回WMTS时相数据信息。
	 *
     * Parameters:
     * 	map - {object} 地图对象
     * 	successFn - {Function} 请求成功的回调函数
     *
     * return {Object}
     * 返回数组对象包含属性：
     * 	versionName：时间版本，
     *	extendedAttributes：时间对应的描述信息
	 */
	getTimeVersions: function(map,successFn){
		var wmtsLayer = map.getLayersByClass("Geo.View2D.Layer.GeoWMTS")[0];
		var parser = new Geo.Util.Format.VwmtsGetVersions();
		var formatXML = new Geo.Format.XML();
		var pyramid = map.pyramid;
		var level = pyramid.getLevelForResolution(wmtsLayer.resolutions);
        var rolRow = pyramid.getTileInfoFromBounds(wmtsLayer.tileFullExtent, level);
        var tileBox = rolRow.mincol + "," + rolRow.minrow + "," + rolRow.maxcol + "," + rolRow.maxrow;
		this.getVersionInfo({
            layer: wmtsLayer.layer,
            tileMatrix: level,
            tileBox: tileBox,
            tileMatrixSet: wmtsLayer.matrixSet
        }, {
            content: "FULL"
        }, function(request){
        	var xmlStr = "";
           	if(null == request.responseXML){
           		if(null == request.responseText || "" == request.responseText){
           			alert("服务参数获取失败，请检查服务运行是否正常。");
					return;
           		}else{
           			xmlStr = request.responseText;
           		}
			}else{
				xmlStr = formatXML.write(request.responseXML);
			}
			if("" != xmlStr){
				//解析返回的WMTS时相瓦片数据信息。
				var jsonOnj = parser.read(xmlStr);
                var versionArr = [];
                if (jsonOnj.Versions) {
                    var versions = jsonOnj.Versions.Version;
					if(versions instanceof Array) {
						for (var i = 0; i < versions.length; i++) {
							var versionObj = {};
							var extendedAttributes = [];
							var versionContents = versions[i].VersionContent;
							if(versionContents instanceof Array) {
								for(var j = 0; j < versionContents.length; j++) {
									var attrs = versionContents[j].ExtendedAttributes;
									extendedAttributes.push(attrs);
								}
							}else {
								var attrs = versionContents.ExtendedAttributes;
								extendedAttributes.push(attrs);
							}
							versionObj.versionName = versions[i].VersionName;
							versionObj.extendedAttributes = extendedAttributes;
							versionArr.push(versionObj);
	                    }
					}else {
						var versionObj = {};
						var extendedAttributes = [];
						var versionContents = versions.VersionContent;
						if(versionContents instanceof Array) {
							for(var j = 0; j < versionContents.length; j++) {
								var attrs = versionContents[j].ExtendedAttributes;
								extendedAttributes.push(attrs);
							}
						}else {
							var attrs = versionContents.ExtendedAttributes;
							extendedAttributes.push(attrs);
						}
						versionObj.versionName = versions.VersionName;
						versionObj.extendedAttributes = extendedAttributes;
						versionArr.push(versionObj);
					}
                }
                successFn(versionArr);		
			}
        });
	},

	/**
	 * 
	 */
	CLASS_NAME: "Geo.Service.GeoWMTS"
	
});/**
 * Class: Geo.Service.WCS
 * OGC-WCS服务类。仅支持OGC标准的WCS1.0.0规范。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.WCS = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.WCS
     * Geo.Service.WCS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn, failFn){
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WCS"
		};
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities",
			SERVICE:"WCS"
		};
		var xhr = OpenLayers.Request.GET({
            url: url,
			params: params,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},
	
	/**
     * APIMethod: describeCoverage
     * 获取Coverage的描述信息。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WCS标准。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例：
     * (code)
     * wcsService.describeCoverage(
     *     {identifiers: "Cov1,Cov2,Cov3"},
     *     function(result){
     *         alert(result.responseText);
     *     }
     * );
     * (end)
     * 
     */	
	describeCoverage: function(params, successFn, failFn){
		var url = this.url;
		var DEFAULT_PARAMS = { 
			SERVICE: "WCS",
			VERSION: "1.0.0",
			REQUEST: "DescribeCoverage"
		};
		OpenLayers.Util.applyDefaults(params,DEFAULT_PARAMS);
		
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},
	
	/**
     * APIMethod: getCoverage
     * 获取Coverage内容。
     * 
     * Parameters:
     * params - {Object} 请求参数，具体内容参考OGC-WCS标准。
     *   identifier - {String} 必选 请求标示。
     *   BoundingBox - {String} 必选 请求范围。
     *   format - {String} 必选  数据格式。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * 示例：
     * (code)
     * wcsService.getCoverage(
     *     { identifier:"Cov123",
     *       BoundingBox: "-71,47,-66,51,urn:ogc:def:crs:OGC:2:84"
     *       format: "image/netcdf"
     *     },
     *     function(result){
     *         //do something...
     *     }
     * );
     * (end)
     */	
	getCoverage: function(params,successFn,failFn){
		var url = this.url;
		var DEFAULT_PARAMS = { 
			SERVICE: "WCS",
			VERSION: "1.1.2",
			REQUEST: "GetCoverage"
		};
		OpenLayers.Util.applyDefaults(params,DEFAULT_PARAMS);
		
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		
		OpenLayers.loadURL(url,params,this,function(result){
			successFn(result);
		},failFn);
	},
	
	CLASS_NAME: "Geo.Service.WCS"
});/**
 * Class: Geo.Service.CSW
 * OGC-CSW服务类。
 *
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.CSW = Geo.Class(Geo.Service, {

    /**
     * Constructor: Geo.Service.CSW
     * Geo.Service.CSW类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
    initialize: function(name, url, options){
        Geo.Service.prototype.initialize.apply(this, arguments);
    },
    
    /**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     *
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var content = '<csw:GetCapabilities service="CSW" xmlns:csw="http://www.opengis.net/cat/csw" xmlns:ows="http://www.opengis.net/ows">' +
        '<ows:AcceptVersions>' +
        '<ows:Version>2.0.2' +
        '</ows:Version>' +
        '</ows:AcceptVersions>' +
        '<ows:AcceptFormats>' +
        '<ows:OutputFormat>text/xml</ows:OutputFormat>' +
        '</ows:AcceptFormats>' +
        '</csw:GetCapabilities>';
        
        content = OpenLayers.String.format(this._soapTemplate, {
            soapBody: content
        });
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: content,
            scope: this,
            success: successFn,
            failure: failFn
        });
    },
    
    /**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     *
     * Returns:
     * {Boolean} 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "CSW"
        };
        var xhr = OpenLayers.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },
    
    /**
     * APIMethod: getRecords
     * 获取服务元数据记录。
     *
     * Parameters:
     * content - {String} CSW服务POST请求串，具体格式参考OGC关于CSW服务文档。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */
    getRecords: function(content, successFn, failFn){
    
        content = OpenLayers.String.format(this._getRecordsTemplate, {});
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: content,
            scope: this,
            success: successFn,
            failure: failFn
        });
    },
    
    //查询请求串模板
    _getRecordsTemplate: '<?xml version="1.0" encoding="UTF-8"?>' +
    '<csw:GetRecords service="CSW" version="2.0.2" xmlns:csw="http://www.opengis.net/cat/csw" xmlns:ogc="http://www.opengis.net/ogc" xmlns:smmd="http://data.sbsm.gov.cn/smmd/2007" outputFormat="text/xml" resultType="results" outputSchema="smmd:Metadata" startPosition="1" maxRecords="10">' +
    '<csw:Query typeNames="smmd:Metadata">' +
    ' <csw:ElementSetName>full</csw:ElementSetName>' +
    ' <csw:Constraint version="2.0.0">' +
    '<ogc:Filter>' +
    ' <ogc:PropertyIsLike wildCard="*" singleChar="_" escape="\\\">' +
    '<ogc:PropertyName>/smmd:Metadata/smmd:mdFileID</ogc:PropertyName>' +
    '<ogc:Literal>*</ogc:Literal>' +
    '</ogc:PropertyIsLike>' +
    '</ogc:Filter>' +
    '</csw:Constraint>' +
    '</csw:Query>' +
    '</csw:GetRecords>',
    
    //soap格式请求串模板
    _soapTemplate: '<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xsi:schemaLocation="http://www.opengis.net/ows" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">' +
    '<soapenv:Body>' +
    '${soapBody}' +
    '</soapenv:Body>' +
    '</soapenv:Envelope>',
    
    /**
     * APIMethod: GetRecordById
     * 根据元数据ID查询服务元数据。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   request -{String} 必填,请求名称。值必须为"getRecordById",不区分大小写。
     *   id -{String} 必填,请求检索的元数据ID。例如：ee90cbea-dc5e-4c8d-8225-03b06f5788b1。
     *   service -{String}  必填,服务名称，值必须为CSW。
     *   version -{String}  必填,服务版本号，值必须为2.0.2。
     *	 outputFormat -{String} 必须为一个Mime type ，值必须为application/xml或text/xml。
     *	 outputSchema -{String} 默认值："http://opengis.net/cat/csw/2.0.2" 请求结果的命名空间。
     *   elementSetName -{String} 默认值：summary返回的数据描述，值可为brief，summary，full。当值为brief时返回简明描述;当值为summary时返回概括描述;当值为full时返回全部的元数据信息。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     *
     * 示例:
     *
     * (code)
     * cswService.getRecordById({
     * 		request : "getRecordById",
     *		id : "ee90cbea-dc5e-4c8d-8225-03b06f5788b1",
     *		service: "CSW",
     *		version: "2.0.2",
     *		outputFormat: "Application/xml",
     *		outputSchema: "http://opengis.net/cat/csw/2.0.2",
     *		typeNames: "smmd:Metadata",
     *		elementSetName: "full"
     * });
     * (end)
     */
    getRecordById: function(options, successFn, failFn){
        var optionsTmp = {
            request: options.request ? options.request : "getRecordById",
            id: options.id ? options.id : "",
            service: options.service ? options.service : "CSW",
            version: options.version ? options.version : "2.0.2",
            outputFormat: options.outputFormat ? options.outputFormat : "Application/xml",
            outputSchema: options.outputSchema ? options.outputSchema : "http://opengis.net/cat/csw/2.0.2",
            elementSetName: options.elementSetName ? options.elementSetName : "summary"
        };
        var requestStringTemplate = '<csw:GetRecordById service="${service}" xmlns:csw="http://www.opengis.net/cat/csw" version="${version}">' +
        '<csw:Id>${id}</csw:Id>' +
        '<csw:ElementSetName typeNames="smmd:Metadata">${elementSetName}</csw:ElementSetName>' +
        '</csw:GetRecordById >';
        
        var requestString = OpenLayers.String.format(requestStringTemplate, {
            id: optionsTmp.id,
            service: optionsTmp.service,
            version: optionsTmp.version,
            elementSetName: optionsTmp.elementSetName
        });
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
    },
    
    /**
     * APIMethod: describeRecord
     * 查询服务元数据描述记录。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   request -{String} 必填,请求名称。值必须为"describeRecord",该值是不区分大小写。
     *   service -{String} 必填,服务名称，值必须为CSW。
     *   version -{String} 必填,服务版本号，值必须为2.0.2。
     *   nameSpace -{String} 字符串列表，以逗号分隔。用于指定命名空间和前缀。格式是的xmlns（[前缀]命名空间URL）。如果没有指定前缀，那么这是默认的命名空间。
     *	 typeName -{String} 字符串列表，以逗号分隔。要描述一个或多个限定的类型名称。
     *   outputFormat -{String} 显示输出文件的格式必须为一个Mime type ，值必须为application/xml或text/xml。
     *	 schemaLanguage -{String} 零个或一个（可选）默认值是XMLSCHEMA。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     *
     * 示例:
     *
     * (code)
     * cswService.describeRecord({
     * 		request : "getRecordById",
     *		service: "CSW",
     *		version: "2.0.2",
     *		typeName: "smmd:Metadata"
     * });
     * (end)
     */
    describeRecord: function(options, successFn, failFn){
        var optionsTmp = {
            request: options.request ? options.request : "describeRecord",
            service: options.service ? options.service : "CSW",
            version: options.version ? options.version : "2.0.2",
            nameSpace: options.nameSpace ? options.nameSpace : "",
            typeName: options.typeName ? options.typeName : "smmd:Metadata",
            outputSchema: options.outputSchema ? options.outputSchema : "application/xml",
            schemaLanguage: options.schemaLanguage ? options.schemaLanguage : "XMLSCHEMA"
        };
        
        var requestStringTemplate = '<csw:DescribeRecord service="${service}" xmlns:csw="http://www.opengis.net/cat/csw" version="${version}">' +
        '<csw:TypeName>${typeName}</csw:TypeName>' +
        '</csw:DescribeRecord >';
        
        var requestString = OpenLayers.String.format(requestStringTemplate, {
            service: optionsTmp.service,
            version: optionsTmp.version,
            typeName: optionsTmp.typeName
        });
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
    },
    
    /**
     * APIMethod: getDomain
     * 获得域名。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   request -{String} 必填,请求名称。值必须为"getDomain",该值是不区分大小写。
     *   service -{String} 必填,服务名称，值必须为CSW。
     *   version -{String} 必填,服务版本号，值必须为2.0.2。
     *   parameterName -{String} 字符串列表，以逗号分隔。无序列表的接口参数的名称。parameterName和propertyName只能有其中一个。
     *	 propertyName -{String} 字符串列表，以逗号分隔。无序的请求的属性名称列表。
     *							（定义信息模型）在搜索属性的情况下，使用不带任何前缀等只有普通的名称（区分大小写），
     *	 						因为这些是唯一定义。例如：分母而不是SpatialResolution.Denominator。
     *							parameterName和propertyName只能有其中一个。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     *
     * 示例:
     *
     * (code)
     * cswService.getDomain({
     * 		request : "getRecordById",
     *		service: "CSW",
     *		version: "2.0.2",
     *		propertyName: "brief"
     * });
     * (end)
     */
    getDomain: function(options, successFn, failFn){
        var optionsTmp = {
            request: options.request ? options.request : "describeRecord",
            service: options.service ? options.service : "CSW",
            version: options.version ? options.version : "2.0.2",
            propertyName: options.propertyName ? options.propertyName : "",//brief
            parameterName: options.parameterName ? options.parameterName : ""//GetRecords.ElementSetName
        };
        
        var requestStringTemplate = '<csw:GetDomain service="${service}" xmlns:csw="http://www.opengis.net/cat/csw" version="${version}">';
        if (options.propertyName) {
            requestStringTemplate += '<csw:PropertyName>${propertyName}</csw:PropertyName>';
        }
        if (options.parameterName) {
            requestStringTemplate += '<csw:ParameterName>${parameterName}</csw:ParameterName>';
        }
        requestStringTemplate += '</csw:GetDomain >';
        
        var requestString = OpenLayers.String.format(requestStringTemplate, {
            service: optionsTmp.service,
            version: optionsTmp.version,
            propertyName: optionsTmp.propertyName,
            parameterName: optionsTmp.parameterName
        });
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
    },
    
    /**
     * APIMethod: transaction
     * 事务操作。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   request -{String} 必填,请求名称。值必须为"transaction",该值是不区分大小写。
     *   service -{String} 必填,服务名称，值必须为CSW。
     *   version -{String} 必填,服务版本号，值必须为2.0.2。
     *
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     *
     * 示例:
     *
     * (code)
     * cswService.transaction({
     * 		request : "getRecordById",
     *		service: "CSW",
     *		version: "2.0.2",
     *		transactionType: "Insert"
     * });
     * (end)
     */
    transaction: function(options, successFn, failFn){
        // insert的参数md_metaData,handle
        
        // update的参数md_metaData,typeName,constraintLanguage,constraint_Language_version,constraint,handle
        
        // delete的参数typeName,constraintLanguage,constraint_Language_version,constraint,handle
        var optionsTmp = {
            request: options.request ? options.request : "transaction",// 必须
            service: options.service ? options.service : "CSW",// 必须
            version: options.version ? options.version : "2.0.2",// 必须
            transaction: options.transaction ? options.transaction : "",
            
            transactionType: options.transactionType ? options.transactionType : "", // 必须 One of “Insert”, “Update”, “Delete”
            requestId: options.requestId ? options.requestId : 0,// 0 or 1
            verboseResponse: options.verboseResponse ? options.verboseResponse : false,
            
            md_metaData: options.md_metaData ? options.md_metaData : "",// 必须
            typeName: options.typeName ? options.typeName : "", // 0 or smmd:Metadata
            constraintLanguage: options.constraintLanguage ? options.constraintLanguage : "", // "CQL_TEXT" or "FILTER"
            constraint_Language_version: options.constraint_Language_version ? options.constraint_Language_version : "",// 必须. 例：1.1.0
            constraint: options.constraint ? options.constraint : "",// 必须. 谓词表达式中指定的语言表示的约束语言参数。
            handle: options.handle ? options.handle : 0// 0 or 1 用于错误处理的目的关联的助记符名称
        };
        
        var requestStringTemplate = '';
        var requestString = "";
        switch (optionsTmp.transactionType) {
            case "Insert":
                requestStringTemplate += '<csw:Transaction xmlns:csw="http://www.opengis.net/cat/csw" version="${version}" service="${service}">' +
                '<csw:Insert xmlns:smmd="http://data.sbsm.gov.cn/smmd/2007" ' +
                'xmlns:wrs="http://www.opengis.net/cat/wrs/1.0" xmlns:gco="http://www.isotc211.org/2005/gco" ' +
                'xmlns:gmd="http://www.isotc211.org/2005/gmd" xmlns:xlink="http://www.w3.org/1999/xlink" ' +
                'xmlns:srv="http://www.isotc211.org/2005/srv" xmlns:gml="http://www.opengis.net/gml" ' +
                'xmlns:gmx="http://www.isotc211.org/2005/gmx" xmlns:rim="urn:oasis:names:tc:ebxml-regrep:xsd:rim:3.0" ' +
                'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">' +
                '${md_metaData}' +
                '</csw:Insert>' +
                '</csw:Transaction>';
                requestString = OpenLayers.String.format(requestStringTemplate, {
                    service: optionsTmp.service,
                    version: optionsTmp.version,
                    md_metaData: optionsTmp.md_metaData
                });
                break;
            case "Update":
                requestStringTemplate += '<csw:Transaction service="${service}" version="${version}" xmlns:csw="http://www.opengis.net/cat/csw">' +
                '<csw:Update xmlns:srv="http://www.isotc211.org/2005/srv" xmlns:gml="http://www.opengis.net/gml" ' +
                'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:gmd="http://www.isotc211.org/2005/gmd" ' +
                'xmlns:rim="urn:oasis:names:tc:ebxml-regrep:xsd:rim:3.0" xmlns:wrs="http://www.opengis.net/cat/wrs/1.0" ' +
                'xmlns:gco="http://www.isotc211.org/2005/gco" xmlns:gmx="http://www.isotc211.org/2005/gmx" ' +
                'xmlns:ogc="http://www.opengis.net/ogc" xmlns:smmd="http://data.sbsm.gov.cn/smmd/2007">' +
                '${md_metaData}' +
                '${constraint}' +
                '</csw:Update>' +
                '</csw:Transaction>';
                requestString = OpenLayers.String.format(requestStringTemplate, {
                    service: optionsTmp.service,
                    version: optionsTmp.version,
                    md_metaData: optionsTmp.md_metaData,
                    constraint: optionsTmp.constraint
                });
                break;
            case "Delete":
                requestStringTemplate += '<csw:Transaction service="${service}" version="${version}" xmlns:smmd="http://data.sbsm.gov.cn/smmd/2007" ' +
                'xmlns:csw="http://www.opengis.net/cat/csw" xmlns:ogc="http://www.opengis.net/ogc">' +
                '<csw:Delete typeName="${typeName}">' +
                '${constraint}' +
                '</csw:Delete>' +
                '</csw:Transaction>';
                requestString = OpenLayers.String.format(requestStringTemplate, {
                    service: optionsTmp.service,
                    version: optionsTmp.version,
                    typeName: optionsTmp.typeName,
                    constraint: optionsTmp.constraint
                });
                break;
                
        }
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
        
    },
    
    /**
     * APIMethod: harvest
     * 查询服务元数据描述记录。
     *
     * Parameters:
     * options - {Object} 请求参数。
     *   request -{String} 必填,请求名称。值必须为"harvest",该值是不区分大小写。
     *   service -{String} 必填,服务名称，值必须为CSW。
     *   version -{String} 必填,服务版本号，值必须为2.0.2。
     *   nameSpace -{String} 字符串列表，以逗号分隔。用于指定命名空间和前缀。格式是的xmlns（[前缀]命名空间URL）。如果没有指定前缀，那么这是默认的命名空间。
     *	 source -{String} 必填,URI,参考源资源收割。
     *   resourceType -{String} 必填,字符串,参考资源的类型。例如：http://www.isotc211.org/schemas/2005/gmd/。
     *	 resourceFormat -{String} 字符的字符串,表示正在收获的资源格式的MIME类型。
     *	 responseHandler -{String} 可选。
     *	 harvestInterval -{String} 可选。
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     *
     * 示例:
     *
     * (code)
     * cswService.describeRecord({
     * 		request : "harvest",
     *		service: "CSW",
     *		version: "2.0.2",
     *		source: "http://10.4.6.23:7001/CSW/csw",
     *		resourceType: "http://data.sbsm.gov.cn/smmd/2007"
     * });
     * (end)
     */
    harvest: function(options, successFn, failFn){
        var optionsTmp = {
            request: options.request ? options.request : "harvest",
            service: options.service ? options.service : "CSW",
            version: options.version ? options.version : "2.0.2",
            nameSpace: options.nameSpace ? options.nameSpace : "",//
            source: options.source ? options.source : "",//http://10.4.6.23:7001/CSW/csw
            resourceType: options.resourceType ? options.resourceType : "",//http://data.sbsm.gov.cn/smmd/2007
            resourceFormat: options.resourceFormat ? options.resourceFormat : "",//
            responseHandler: options.responseHandler ? options.responseHandler : "",//D:/
            harvestInterval: options.harvestInterval ? options.harvestInterval : ""//2012-12-22 12:12:12
        };
        
        var requestStringTemplate = '<csw:Harvest service="${service}" xmlns:csw="http://www.opengis.net/cat/csw" version="${version}">';
        requestStringTemplate += '<csw:Source>${source}</csw:Source>';
        requestStringTemplate += '<csw:ResourceType>${resourceType}</csw:ResourceType>';
        if (options.harvestInterval) {
            requestStringTemplate += '<csw:HarvestInterval>${harvestInterval}</csw:HarvestInterval>';
        }
        if (options.responseHandler) {
            requestStringTemplate += '<csw:ResponseHandler>${responseHandler}</csw:ResponseHandler>';
        }
        requestStringTemplate += '</csw:Harvest>';
        
        var requestString = OpenLayers.String.format(requestStringTemplate, {
            service: optionsTmp.service,
            version: optionsTmp.version,
            source: optionsTmp.source,
            resourceType: optionsTmp.resourceType,
            harvestInterval: optionsTmp.harvestInterval,
            responseHandler: optionsTmp.responseHandler
        });
        
        
        if (!failFn) {
            failFn = function(request){
                this.failFn(request);
            };
        }
        
        var xhr = new OpenLayers.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
    },
	
    CLASS_NAME: "Geo.Service.CSW"
});
/**
 * Class: Geo.Service.CWMS
 * CWMS服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.CWMS = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.CWMS
     * Geo.Service.CWMS类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url, options){
		Geo.Service.prototype.initialize.apply(this, arguments);
		this.format = new OpenLayers.Format.JSON();
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		if(!failFn){
			failFn = function(){
				this.failFn("GetCapabilities");
			};
		}
		OpenLayers.loadURL(this.url,null,this,function(result){
			var res = this.format.read(result.responseText);
			successFn(res);
		},failFn);
	},
	
	/**
	 * APIMethod: GetLayerInfo
	 * 本操作是获取缓存地图服务的图层（单个图层的详细信息），结果以JSON形式返回。
	 * 
	 * Parameters:
	 *   layerId - {String}图层id 必填。
	 *   successFn - {Function} 请求成功的回调函数。
     *   failFn - {Function} 请求失败的回调函数。
     *   
     *   例子:
     *   (code)
     *     serviceObj.getLayerInfo(layers[0].id,
     *        function(result) {
	 *			var obj = new OpenLayers.Format.JSON();
	 *			var res = obj.write(result);
	 *			document.getElementById("serviceCapabilities").innerText = res;
	 *		  });
     *   (end)
	 */
	getLayerInfo : function(layerId,successFn,failFn) {
		var location = this.url.indexOf("/",this.url.length - 1);
		if(location != -1) {
			var url = this.url + layerId;
		}else {
			var url = this.url + "/" + layerId;
		}
		
		if(!failFn){
			failFn = function(){
				this.failFn("GetLayerInfo");
			};
		}
		OpenLayers.loadURL(url,null,this,function(result){
			var res = this.format.read(result.responseText);
			successFn(res);
		},failFn);
				
	},
	
	/**
     * APIMethod: isExist
     * 将向服务发送同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var xhr = OpenLayers.Request.GET({
            url: url,
			params: null,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},
	
	/**
     * APIMethod: getMap
     * 获取地图内容操作。
     * 
     * Parameters:
     * 	params - {Object} 
     *    layerId - {String}图层Id 必填。
     *    mapstyleId - {String}当前请求图层样式的唯一编号 必填。
     *    srid -{String} 图层的参考坐标系 必填。
     *    sourceDate - {Date}据的最后更新日期 必填。
     *    level - {Integer}请求图层的层号 必填。
     *    formatSuffix - {String}输出图片格式 必填。
     *    col - {Integer} 瓦片列号 必填。
     *    row - {Integer} 瓦片行号 必填。
     *  
     * Returns:
 	 * {String} 地图内容图片地址。
 	 * 
 	 * 示例:
 	 * (code)
 	 * var url = serviceObj.getMap({
     *     col	: 1506,
	 *	   formatSuffix:"png",
	 *	   layerId	:"GeoGlobeMap_1",
	 *	   level:11,
	 *	   mapStyleId:"GISP:1",
	 *	   row:259	,
	 *	   sourceDate:myDate,
	 *	   srid : "EPSG:4326"
     *  });
     *   (end)
     */	
	getMap: function(params){
		var path =  encodeURIComponent(params.layerId) + "/" + encodeURIComponent(params.mapStyleId) + "/" + 
		encodeURIComponent(params.srid) + "/" +params.sourceDate.getYear() + params.sourceDate.getMonth() + params.sourceDate.getDate() + "/" +
		"L"+ params.level + "/" + params.col+ encodeURIComponent(",") + params.row + "." + params.formatSuffix;
		var location = this.url.indexOf("/",this.url.length - 1);
		if(location != -1) {
			var url = this.url + path;
		}else {
			var url = this.url + "/" + path;
		}
		return url;
	},

	CLASS_NAME: "Geo.Service.CWMS"
});/**
 * Class: Geo.Service.MapService
 * MAPSERVICE-REST服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.MapService = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.MapService
     * Geo.Service.MapService类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		Geo.Service.prototype.initialize.apply(this, arguments);
		this.format = new OpenLayers.Format.JSON();
		this.jsonp = new OpenLayers.Protocol.Script({
			format:this.format
		});
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			f:"json"
			//callback:"flightHandler"
		};
		if(!failFn){
			failFn = function(){
				this.failFn(params.REQUEST);
			};
		}
		this.jsonp.createRequest(url,params, OpenLayers.Function.bind(function(result){
			successFn(result);
		},this));
	},
	/**
	 * 获取查询结果的json表示法
	 * @param {Object} result
	 */
	_getJson: function(result) {
		var resultObj = this.format.read(result.responseText);
		return resultObj;
	},
	/**
     * APIMethod: isExist
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * 
     * Returns:
     * {Boolean} 服务是否存在。
     */
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			f:"json"
			//callback:"flightHandler"
		};
		var xhr = OpenLayers.Request.GET({
            url: url,
			params: params,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},

	CLASS_NAME: "Geo.Service.MapService"
});/**
 * Class: Geo.Service.GeoCoding
 * 地址匹配服务
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.GeoCoding = Geo.Class(Geo.Service, {
	
	/**
	 * APIProperty: version
	 * 服务版本，默认值是"1.0.0"。
	 */
	version:"1.0.0",
	
	/**
     * Constructor: Geo.Service.GeoCoding
     * Geo.Service.GeoCoding类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url, options){
		Geo.Service.prototype.initialize.apply(this, arguments);
		this.format = new OpenLayers.Format.JSON();
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		if(!failFn){
			failFn = function(){
				this.failFn("GetCapabilities");
			};
		}
		var params = {
			request:"GetCapabilities",
			output:"json",
			version:this.version,
			service:"GeoCoding"
		};
		OpenLayers.loadURL(this.url,params,this,function(result) {
			var json = this.format.read(result.responseText);
			successFn({
				result:result,
				json:json
			});
		},failFn);
	},

	CLASS_NAME: "Geo.Service.GeoCoding"
});﻿/**
 * Class: Geo.Service.GeoRoute
 * 路网导航服务类,Geo.Service.Route与Geo.Service.GeoRoute都是路网服务类，建议使用Geo.Service.GeoRoute类。
 * >说明：本类的findRoute方法以及getRouteInfo方法的成功回调中如果包含exceptionInfo节点，则表示服务查询发生异常。
 * >findRoute方法以及getRouteInfo方法成功回调中返回的异常信息包含两个节点（exceptionInfo节点和exceptionCode节点）。
 * >异常信息的数据结构举例：
 * >{
 * >	exceptionInfo:"终点附近无导航链路",
 * >	exceptionCode:"1002"
 * >} 
 * >其中exceptionInfo表示异常信息的描述;exceptionCode表示异常编码;异常编码取值说明：
 * >1000：服务逻辑或功能异常。
 * >1001：服务未配置路网数据集。（当服务未配置路网数据集并且请求FindRoute与GetRouteInfo接口将返回此异常）。
 * >1002：导航查询的两点之间无通路。（请求FindRoute接口如果无解决方案则返回此异常）。
 * >1003：无匹配的路段信息。（请求GetRouteInfo接口如果无关联请求路段ID的内容则返回此异常）。
 * >1004：请求参数内容不正确。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.GeoRoute = Geo.Class(Geo.Service, {
	
	/**
	 * Property: _format
	 * 结果解析器。
	 */
	_format: null,
	
	/**
     * Constructor: Geo.Service.GeoRoute
     * Geo.Service.Route类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称。
     * url - {String} 服务地址。
     * options - {Object} 备用参数，目前暂不使用。
     *
     */
	initialize: function(name, url,  options){
		this.name = name;
		this.url = url;
		this._format = new Geo.Util.Format.GeoRoute();
		OpenLayers.Util.extend(this, options);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn) {
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};
		OpenLayers.loadURL(url,params,this,successFn,failFn);
	},
	
	/**
	 * APIMethod:findRoute
	 * 返回请求起始坐标对应路网模型的导航链路信息。
	 * 
	 * Parameters:
	 * options - {Object} 请求参数。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     * 
     * options请求参数属性可为:
     * data - {String} （必选）路网名称。
	 * orig - {String} （必选）起点坐标。   例如："120,30"。
	 * dest -  {String} （必选）终点坐标。
	 * radius — {Number}(可选) 抓取起点与终点距离有效道路的半径范围，单位为米，默认值为10米。
	 * queryType - {Number} (可选)导航查询类型。0表示最快时间；1表示最短路径，默认为按最短路径查询。
	 * midpos - {String}(可选) 途径点坐标集，多个坐标之间以分号分隔，XY坐标之间以逗号分隔。（如：x1,y1;x2,y2）
	 * avoidPos - {String}(可选) 规避点坐标集，多个坐标之间以分号分隔，XY坐标之间以逗号分隔。（如：x1,y1;x2,y2）
	 * filterRoute - {Number}(可选) 导航查询的途径路段类型过滤，可选值：0 – 不进行过滤；1 – 过滤高速公路；2 – 过滤小路；默认值为0。
	 * resultCount - {Number}(可选) 导航查询返回的最大解决方案数目，参数值必须为正整数，参数默认值为1。
     * 
	 * Example:
	 *   (code) 
	 *   	//创建路网查询对象
	 *   	var ShortestPath =new Geo.Service.Route("shortPath","http://10.4.6.248:7009/Route_L/route");
	 *   	ShortestPath.findRoute({
	 *				data:"XZ",
	 *				id:"706,347"
	 *			},function(routes){
	 *
	 *			});
	 *   (end)
	 */
	findRoute: function(options, successFn, failFn) {
		var params = {
			REQUEST: "FindRoute",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
        var required = {
            data: true,
            orig: true,
            dest: true
        };
        for (var prop in required) {
            if (!(prop in options)) {
                throw new Error("Missing property '" + prop + "'");
            }
        }
		params.DATA = options.data;
		params.ORIG = options.orig;
		params.DEST = options.dest;
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
	  	if(options.radius !== null && options.radius !== undefined){
            params.RADIUS = options.radius;
        }
        
        if(options.queryType !== null && options.queryType !== undefined){
            params.QUERYTYPE = options.queryType;
        }
		
		if(options.midpos !== null && options.midpos !== undefined){
            params.MIDPOS = options.midpos;
        }
		if(options.avoidPos !== null && options.avoidPos !== undefined){
            params.AVOIDPOS = options.avoidPos;
        }
		if(options.filterRoute !== null && options.filterRoute !== undefined){
            params.FILTERROUTE = options.filterRoute;
        }
		if(options.resultCount !== null && options.resultCount !== undefined){
            params.RESULTCOUNT = options.resultCount;
        }
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				var routes = this._format.read(result.responseText);
				//处理异常情况，当发生异常时，直接返回异常串
				if(typeof routes.exceptionInfo === "string") {
					 successFn(routes);
					 return;
				}
				var routeInfo = new Geo.Service.GeoRoutesResult(routes);
                successFn(routeInfo);
            },
            failure: failFn
        });
	},
	
	/**
	 * APIMethod:getRouteInfo
	 * 返回请求编号查询到路段的详细信息。
	 * 
	 * Parameters:
	 * options - {Object} 请求参数。
	 * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * data - {String} （必选）路网名称
	 * id - {String} （必选）查询路段的ID名称，可以有0个或多个，多个ID之间以逗号分隔。
	 * 
	 * Example:
	 *   (code) 
	 *   	//创建路网查询对象
	 *   	var ShortestPath =new Geo.Service.Route("shortPath","http://10.4.6.248:7009/Route_L/route");
	 *   	ShortestPath.getRouteInfo({
	 *				data:"XZ",
	 *				id:"706,347"
	 *			},function(routeInfo){});
	 *   (end)
	 */
	getRouteInfo: function(options, successFn, failFn) {
		var params = {
			REQUEST: "GetRouteInfo",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
		if(!options.data || !options.id){
            throw "Error!Not data and id for bus query.";
            return;
        }
		params.DATA = options.data;
		params.ID = options.id;
		var xhr = OpenLayers.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				var routeInfo = this._format.read(result.responseText);
				//处理异常情况，当发生异常时，直接返回异常串
				if(typeof routeInfo.exceptionInfo === "string") {
					 successFn(routeInfo);
					 return;
				}
				routeInfo = new Geo.Service.GeoRouteInfoResult(routeInfo);
            	successFn(routeInfo);
            },
            failure: failFn
        });
	},	

	CLASS_NAME: "Geo.Service.GeoRoute"
	
});

/**
 * Class: Geo.Util.Format.GeoRoute
 * 路网导航查询结果解析类，本类供内部调用，用户一般无需使用。
 */
Geo.Util.Format.GeoRoute = new Geo.Class(Geo.Format.XML,{

	/**
	 * Constructor: Geo.Util.Format.GeoRoute
	 * 构造函数。
	 * 
	 * Parameters:
	 * data - {Object} 服务端生成的原始JSON数据。
	 */
    initialize: function(options) {
        OpenLayers.Format.XML.prototype.initialize.apply(this, [options]);
    },

	/**
	 * APIMethod: read
	 * 读入服务端响应的XML内容并解析为JSON对象返回。
	 * 
	 * Parameters:
	 * data - {String} 服务端响应的XML。
	 * 
     * Returns:
     * {Object | String} JSON对象
     * 说明：当返回结果为字符串时表示查询发生异常。
     */	
    read: function(data) {
        var result = {};
		var routes = [];
		var dataTemp = data;
        if(typeof data == "string") {
			//调用父类的read方法。将xml串转换为dom对象。
            data = Geo.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            routes = [];
			//获得根节点名称
			var elName = Geo.Format.XML.prototype.getChildEl.apply(this, [data]).nodeName;
			//处理异常情况：
			if("ServiceExceptionReport" === elName) {
				//var serviceException = data.getElementsByTagName("ogc:ServiceException")[0];
				var serviceException = Geo.Format.XML.prototype.getElementsByTagNameNS(data, "*", "ServiceException")[0];
				var text = Geo.Format.XML.prototype.getChildValue.apply(this, [serviceException]);
				var code = serviceException.getAttribute("code");
				return {
					exceptionInfo: text,
					exceptionCode: code
				};
			}
			
			//获取跟节点的子元素
			var nodes = data.getElementsByTagName(elName)[0].childNodes;
			//Todo 如果elName不带前缀的，取整个elName。如果elName带前缀的，则取前缀之后的名称。
			//var nodes = Geo.Format.XML.prototype.getElementsByTagNameNS(data, "*", elName)[0];
			//遍历子节点
            for(var i=0; i<nodes.length; i++){
                var node = nodes[i];
				//获取节点名称
                var nodeName = node.nodeName;
				//判断方法是否存在
                if(this._resultPaser[elName][nodeName]) {
					//使用apply方法改变调用方法的上下文环境
					this._resultPaser[elName][nodeName].apply(this, [node, routes]);
                }
            }
        }
		elName = elName.toLowerCase();
		if("routeinfo" === elName) {
			result["items"] = routes;
		}else {
			result[elName] = routes;
		}
		
        return result;
    },
	
	/**
	 * Property: _resultPaser
	 * 查询结果解析器。
	 */
    _resultPaser: {
		"RouteInfo":{
			"Item": function(node, obj) {
				var nodes = node.childNodes;
				var id = node.getAttribute("id");
	            var item = {};
				if(id) {
					item = {
						id: id
					}
				}
	            for(var i=0; i<nodes.length; i++){
	                 var node = nodes[i];
					 var nodeName = node.nodeName;
	                if(this._resultPaser["RouteInfo"][nodeName]){
						this._resultPaser["RouteInfo"][nodeName].apply(this, [node,item]);
	                }
	            }
				obj.push(item);
			},
	        "Name": function(node, obj){
				//调用父类的getChildValue方法，并且使用本对象的上下文环境。
				var name = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
	            if(name) {
	                obj.name = name;
	            }
	        },
	        "Toll": function(node, obj){
				var toll = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.toll = toll;
	        },
			"Level": function(node, obj) {
				var level = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
				obj.level = level;
			},
			"Length": function(node, obj) {
				var length = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.length = length;
			},
			"Geometry": function(node, obj) {
				//获取gml:LineString节点对象。
				//var geometryDom = node.getElementsByTagName("gml:LineString")[0];//chrome下解析不到
				var geometryDom = Geo.Format.XML.prototype.getElementsByTagNameNS(node, "*", "LineString")[0];
				if(geometryDom) {
					var text = Geo.Format.XML.prototype.getChildValue.apply(this, [geometryDom]);
					if(typeof text === "string" && text.length > 0) {
						var pointArrStr = text.split(" ");
						var points = [];
						for(var i = 0, len = pointArrStr.length; i < len; i++) {
							var pois = pointArrStr[i].split(",");
							points.push(new Geo.Geometry.Point(new Number(pois[0]),new Number(pois[1])));
						}
						var lineString = new Geo.Geometry.LineString(points);
						obj.geometry = lineString;
					}
				}
			},
			"Directions": function(node, obj) {
				obj.directions = [];
				var nodes = node.childNodes;
	            for(var i=0; i<nodes.length; i++){
	                 var node = nodes[i];
					 var nodeName = node.nodeName;
	                if(this._resultPaser["RouteInfo"][nodeName]){
	                    this._resultPaser["RouteInfo"][nodeName](node,obj.directions);
	                }
	            }
			},
			"Direction": function(node, obj) {
				var dir = {};
				var direction = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
	            dir.direction = direction;
				//获取节点的属性值
				dir.nextID = node.getAttribute("nextID");
				dir.nextItem = node.getAttribute("nextItem");
				obj.push(dir);
			}
			//TODO：是否还有可选属性没有加进来，待查
	    },
		"Routes": {
			"Route": function(node, obj) {
				var nodes = node.childNodes;
	            var route = {};
	            for(var i=0; i<nodes.length; i++){
	                var node = nodes[i];
					var nodeName = node.nodeName;
	                if(this._resultPaser["Routes"][nodeName]){
						this._resultPaser["Routes"][nodeName].apply(this, [node,route]);
	                }
	            }
				obj.push(route);
			},
			"Item": function(node, obj) {
				if(!Geo.Util.isArray(obj.items)) {
					obj.items = [];
				}
				var nodes = node.childNodes;
				var id = node.getAttribute("id");
				var item = {};
				if(id) {
					item = {
						id: id
					}
				}
	            for(var i=0; i<nodes.length; i++){
	                 var node = nodes[i];
					 var nodeName = node.nodeName;
	                if(this._resultPaser["Routes"][nodeName]){
						this._resultPaser["Routes"][nodeName].apply(this, [node,item]);
	                }
	            }
				obj.items.push(item);
			},
			"Distance": function(node, obj){
				var distance = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.distance = distance;
			},
			"Name": function(node, obj){
				var name = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
	            if(name) {
	                obj.name = name;
	            }
	        },
			"Length": function(node, obj) {
				var length = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.length = length;
			},
			"Direction": function(node, obj) {
				var dir = {};
				var direction = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
	            dir.direction = direction;
				dir.nextID = node.getAttribute("nextID");
				dir.nextItem = node.getAttribute("nextItem");
				obj.direction = dir;
			},
			"Geometry": function(node, obj) {
				//var geometryDom = node.getElementsByTagName("gml:LineString")[0];//chrome下解析不到
				var geometryDom = Geo.Format.XML.prototype.getElementsByTagNameNS(node, "*", "LineString")[0];
				if(geometryDom) {
					var text = Geo.Format.XML.prototype.getChildValue.apply(this, [geometryDom]);
					if(typeof text === "string" && text.length > 0) {
						var pointArrStr = text.split(" ");
						var points = [];
						for(var i = 0, len = pointArrStr.length; i < len; i++) {
							var pois = pointArrStr[i].split(",");
							points.push(new Geo.Geometry.Point(new Number(pois[0]),new Number(pois[1])));
						}
						var lineString = new Geo.Geometry.LineString(points);
						obj.geometry = lineString;
					}
				}
			},
			"Duration": function(node, obj) {
				var duration = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.duration = duration;
			},
			"BoundingBox": function(node, obj) {
				var nodes = node.childNodes;
	            for(var i=0; i<nodes.length; i++){
	                 var node = nodes[i];
					 var nodeName = node.nodeName;
	                if(this._resultPaser["Routes"][nodeName]){
						this._resultPaser["Routes"][nodeName].apply(this, [node,obj]);
	                }
	            }
			},
            "LowerCorner": function(node, obj) {
				var str = Geo.Format.XML.prototype.getChildValue.apply(this, [node]).replace(
                    (/^\s*|\s*$/g), "");
                str = str.replace((/\s*,\s*/g), ",");
                var pointList = str.split(",");
                obj.left = pointList[0];
                obj.bottom = pointList[1];
            },
            "UpperCorner": function(node, obj) {
				var str = Geo.Format.XML.prototype.getChildValue.apply(this, [node]).replace(
                    (/^\s*|\s*$/g), "");
                str = str.replace((/\s*,\s*/g), ",");
                var pointList = str.split(",");
                obj.right = pointList[0];
                obj.top = pointList[1];
                obj.bounds = new OpenLayers.Bounds(obj.left, obj.bottom,
                    obj.right, obj.top);
				//left,bottom,right,top只是临时使用，所以用完后需要清掉。
                delete obj.left;
                delete obj.bottom;
                delete obj.right;
                delete obj.top;
            },
			"Count": function(node, obj) {
				var count = Geo.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.count = count;
			}
		}
	}
});﻿/**
 * Class: Geo.Service.GeoRouteInfoResult
 * 路段信息结果类。用于记录路段所在道路的详细信息。
 */
Geo.Service.GeoRouteInfoResult = Geo.Class({
	
	/**
	 * APIProperty: data
	 * {Object}解析服务返回的XML后，得到的完整JSON对象。
	 */
	data: null,
	
	/**
	 * APIProperty: items
	 * {Array(Geo.Service.GeoRouteInfoItem)}
	 * 路段数组。
	 */
	items: null,
	
	/**
     * Constructor: Geo.Service.GeoRouteInfoResult
     * Geo.Service.GeoRouteInfoResult类的构造函数。
     *
     * Parameters:
     * data - {Object} JSON对象。
     */
	initialize: function(data) {
		this.items = [];
		if(data && data.items) {
			this.data = data;
			var items = data.items;
		}
		if(Geo.Util.isArray(items)){
			for(var i = 0, len = items.length;i < len; i++) {
				var routeInfoItem = new Geo.Service.GeoRouteInfoItem();
				for(var route in items[i]) {
					routeInfoItem[route] = items[i][route];
				}
				this.items.push(routeInfoItem);
			}
        }
	},

	CLASS_NAME: "Geo.Service.GeoRouteInfoResult"
	
});

/**
 * Class: Geo.Service.GeoRouteInfoItem
 * 路段对象。从出发点到目的地的路程由一个或多个路段组成。
 */
Geo.Service.GeoRouteInfoItem = Geo.Class({
	
	/**
	 * APIProperty: id
	 * {String}路段编号。
	 */
	id:  null,
	
	/**
	 * APIProperty: name
	 * {String}路段名称。
	 */
	name: null,
	
	/**
	 * APIProperty: toll
	 * {Number}路段收费信息，元素值定义：
	 *	0 – 免费路段；
	 *	1 – 部分收费路段；
	 *	2 – 收费路段。
	 *	（路段收费信息匹配路网数据库的特定属性，如果没有该属性则默认值为“0”免费路段）
	 */
	toll: null,
	
	/**
	 * APIProperty: length
	 * {Number}路段行驶的里程，单位为米。
	 */
	length: null,
	
	/**
	 * APIProperty: geometry
	 * {Geo.Geometry}线路几何信息。
	 */
	geometry: null,
	
	/**
	 * APIProperty: level
	 * {String}道路级别，由路网数据库定义。
	 *	（路段级别一般标识路段的类型；例如路段级别分为1-3级，级别1为普通小路，级别2为城镇公路，级别3为高速公路；如果路网数据库未指定路段级别则默认值为0）
	 */
	level: null,
	
	/**
	 * APIProperty: directions
	 * {Array{Object}} 
	 * 路段朝向。
	 * 
	 * 数组中的对象结构举例:
	 * [
	 * 	{
	 *  	nextID: "4211",
	 *  	nextItem: "红钢二街",
	 *  	direction: 1
	 *  }
	 * ]
	 * 
	 * 示例中节点说明：
	 * direction:方位,0代表正西方向，7代表西北方向，4代表正北方向，2代表东北方向，1代表正东方向，3代表东南方向，5代表正南方向，8代表西南方向。
	 * nextID:下一路段编号
	 * nextItem:下一路段名称
	 */
	directions: null,
	
	/**
     * Constructor: Geo.Service.GeoRouteInfoItem
     * Geo.Service.GeoRouteInfoItem类的构造函数。
     */
	initialize: function() {
		
	},

	CLASS_NAME: "Geo.Service.GeoRouteInfoItem"
	
});﻿/**
 * Class: Geo.Service.GeoRoutesResult
 * 导航链路信息结果对象。结果对象中包含起点到目的地的所有行走方案。
 */
Geo.Service.GeoRoutesResult = Geo.Class({
	
	/**
	 * APIProperty: data
	 * {Object}解析服务返回的XML后，得到的完整JSON对象。
	 */
	data: null,
	
	/**
	 * APIProperty: routes
	 * {Array(Geo.Service.GeoRouteResult)}  起点到终点的所有行走方案。
	 */
	routes: null,
	
	/**
     * Constructor: Geo.Service.GeoRoutesResult
     * Geo.Service.GeoRoutesResult类的构造函数。
     *
     * Parameters:
     * data - {Object} JSON对象
     *
     */
	initialize: function(data) {
		this.routes = [];
		var routes = null;
		if(data && data.routes) {
			this.data = data;
			routes = data.routes;
		}
		if(Geo.Util.isArray(routes)) {
			for(var i = 0, len = routes.length;i < len; i++) {
				var routeObj = new Geo.Service.GeoRouteResult();
				for(var route in routes[i]) {
					routeObj[route] = routes[i][route];
				}
				this.routes.push(routeObj);
			}
        }
	},

	CLASS_NAME: "Geo.Service.GeoRoutesResult"
	
});

/**
 * Class: Geo.Service.GeoRouteResult
 * 起到到终点的一条行走方案。
 */
Geo.Service.GeoRouteResult = Geo.Class({
	
	/**
	 * APIProperty: bounds
	 * {Geo.Bounds}两点间的一条通路的范围
	 */
	bounds: null,
	
	/**
	 * APIProperty: count
	 * {Integer}导航线路包含的路段总数。
	 */
	count: null,
	
	/**
	 * APIProperty: distance
	 * {Number}导航线路总里程，单位为米。
	 */
	distance: null,
	
	/**
	 * APIProperty: duration
	 * {Integer}导航行驶总时间，单位为分钟。
	 *	（导航行驶总时间根据由总里程换算而来，具体换算公式由服务定制）
	 */
	duration: null,
	
	/**
	 * APIProperty: geometry
	 * {Geo.Geometry}线路的几何信息。
	 */
	geometry: null,
	
	/**
	 * APIProperty: items
	 * {Array{object}} 
	 * 	路段元素，可以有零或多个；每个元素包含一个属性id，标识路段的唯一编号；
	 * 	如果路段不在道路上（如起点到某条道路），将不包含路段编号与路段名称。
	 * 
	 * 数组中的对象结构举例:
	 * {
	 * 	id:"33",
	 * 	length: "161",
	 * 	name: "玉兰路",
	 * 	geometry:值为Geo.Geometry对象,
	 * 	direction: {
	 * 		text:"4",
	 * 		nextID:"8414",
	 * 		nextItem:"佳园路"
	 * 	}
	 * }
	 * 示例中节点说明：
	 * id: 路段id
	 * name:路段名称
	 * length：路段总长，单位为米
	 * geometry:路段行走路线
	 * text:方位,0代表正西方向，7代表西北方向，4代表正北方向，2代表东北方向，1代表正东方向，3代表东南方向，5代表正南方向，8代表西南方向。
	 * nextID:下一路段编号
	 * nextItem:下一路段名称
	 * 
	 */
	items: null,
	
	/**
     * Constructor: Geo.Service.GeoRouteResult
     * Geo.Service.GeoRouteResult类的构造函数。
     */
	initialize: function() {
		
	},

	CLASS_NAME: "Geo.Service.GeoRouteResult"
	
});
﻿/**
 * Class: Geo.Service.GeoText
 * 文字服务类。
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.GeoText = Geo.Class(Geo.Service, {
	
	/**
	 * APIProperty: data
	 * {Object}文字服务能力描述信息的JSON对象（请求Geo.Service.GeoText类的对象的getCapabilities方法可以得到JSON对象）。
	 */
	data: null,
	
	/**
	 * APIProperty: version
	 * {String}服务版本。
	 */
	version:"1.0.0",
	
	/**
     * Constructor: Geo.Service.GeoText
     * Geo.Service.GeoText类的构造函数。
     *
     * Parameters:
     * name - {String} 服务名称
     * url - {String} 服务地址
     * options - {Object} 实例的选项设置，此参数可选。
     * 
     * options请求参数属性可为:
     * version - {String} 服务版本。
     */
	initialize: function(name, url, options) {
		Geo.Service.prototype.initialize.apply(this, arguments);
		this.format = new OpenLayers.Format.JSON();
		this.jsonp = new OpenLayers.Protocol.Script({
			format:this.format
		});
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn) {
		if(!failFn){
			failFn = function(){
				this.failFn("Root接口");
			};
		}
		var params = {
			f: "json",
			service:"TEXT",
			version:"1.0.0"
		};
		params.version = this.version;
		var xhr = OpenLayers.Request.GET({
            url: this.url,
			params: params,
            scope: this,
			async: false,
            success: function(result){
				var resultJson = OpenLayers.Format.JSON.prototype.read.apply(this, [result.responseText]);
                this.data = resultJson;
				successFn(resultJson);
            }
        });
	},
	
		
	/**
	 * Method:getTextStyleByTextRendition
	 * 将TextRedition标签中的部分元素转换为要素的style样式。
	 * 
	 * Parameters:
	 * textRendition {Object} 文字标注样式。
	 * 
	 * Returns:
     * {Object} 文字标注样式。
	 */
	getTextStyleByTextRendition: function(textRendition) {
		var style = {};
		var styleTemp = {};
	//	var featureStyle = Geo.Util.extend({},Geo.Feature.Vector.style['default']);
		var fontName = textRendition.FontName;
		//字体颜色
		var fontColor = textRendition.Color.Value;
		//字体透明度
		var fontOpacity = textRendition.Color.Transparent;
		//是否为粗体
		var isBold = textRendition.IsBold;
		var fontWeight = isBold ? "bold" : "normal";
		
		//TODO：文字标注背景颜色不支持
		//var bgfontColor = textRendition.BGColor.Value;
		//文字标注背景透明度不支持
		//var bgTransparent = textRendition.BGColor.Transparent;
		//字体样式
		if(textRendition.FontStyle === "Normal") {
			styleTemp.fontStyle = "normal";
		}else if(textRendition.FontStyle === "RightItalic") {
			styleTemp.fontStyle = "italic";
		}
		//TODO:字体样式倾斜角度不支持：FontStyleAngle
		//文字标注偏移
		var labelXOffset = textRendition.OffsetX;
		var labelYOffset = textRendition.OffsetY;
		//文字是否有下划线IsUnderLine，此属性目前无法不支持
		//文字是否有删除线：IsStrikeoutLine，此属性目前无法不支持
		//文字是否为粗体，此属性目前无法不支持
		//文字背景是否为透明IsBGTransparent，此属性目前无法支持；
		//这几个属性目前不支持：IsHollow，IsShadow，ShadowColor，ShadowOffsetX，ShadowOffsetY，Width，Height，HorizontalSpacing，VerticalSpacing
		//Rotation,VerticalAlign,HorizonAlign,IsBGTransparent，isvisible
		//字体宽度,高度，TODO：目前是默认宽度高度一样
		var fontSize = parseInt(textRendition.Width * 4) +"px";
		//文字标注的样式
		style = {
			fontFamily: fontName,
			fontColor: fontColor,//fontColor,//fontColor,"red"
			fontOpacity: fontOpacity,
			fontWeight: fontWeight,
			labelXOffset: labelXOffset,
			labelYOffset: labelYOffset,
			fontSize: fontSize
		}
		OpenLayers.Util.extend(style, styleTemp);
		return style;
	},
	
	/**
	 * Method: getTextStyleByLabelRenditionID
	 * 根据文字标注画法ID得到文字标注样式。
	 * 
	 * Parameters:
	 * id - {Array(String)}渲染器id
	 * 
	 * Returns:
     * {Object} 文字标注样式。
	 */
	getTextStyleByLabelRenditionID: function(id) {
		var rendition = this.data.rendition;
		for(var i = 0, len = rendition.length; i < len; i++) {
			if(rendition[i].renditionID === id) {
				var textStyle = this.getTextStyleByTextRendition(rendition[i].TextRendition);
				var maxCharactersPerLine = this.getMaxCharactersPerLine(rendition[i]);
				if(typeof maxCharactersPerLine === "number") {
					textStyle.maxCharactersPerLine = maxCharactersPerLine;
				}
				return textStyle;
			}
		}
	},
	
	/**
	 * Method: getMaxCharactersPerLine
	 * 获取图层的文字标注每行最大显示多少条。
	 * 
	 * Parameters:
	 * rendition - {Object}渲染相关参数
	 * 
	 * Returns:
     * {Integer} 每行最大显示多少字。
	 */
	getMaxCharactersPerLine: function(rendition) {
		var eachLine = null;
		if(rendition.WrapStyle && rendition.WrapStyle.MaxCharactersPerLine) {
			 eachLine = rendition.WrapStyle.MaxCharactersPerLine.enable;
		}
		return eachLine;
	},
	
	/**
	 * APIMethod:getTextStylesByLayerIds
	 * 根据图层id获取图层样式。
	 * 
 	 * Parameters:
 	 * data - 文字服务能力描述信息的JSON对象（请求本对象的getCapabilities方法可以得到JSON对象）。
	 * ids - {Array(Number)}图层ID。
	 * 
	 * Returns:
     * {Object} 图层名称与图层样式键值对。
	 */
	getTextStylesByLayerIds: function(data,ids) {
		var dataTableNames = {};
		var layers = data.layers;
		if(typeof ids === "number") {
			ids = [ids];
		}
		if(!Geo.Util.isArray(ids)) {
			return dataTableNames;
		}
		//得到图层名与图层样式id的键值对
		for(var i = 0; i < ids.length;i++) {
			for(var j = 0, len = layers.length; j < len;j++) {
				if(ids[i] === layers[j].id) {
					dataTableNames[layers[j]["dataTableName"]] = layers[j]["labelRenditionID"];
					continue;
				}
			}
		}
		var dataTableNameReditionId = {};
		//得到图层名与样式的键值对
		for(var dataTableName in dataTableNames) {
			var style = this.getTextStyleByLabelRenditionID(dataTableNames[dataTableName]);
			dataTableNameReditionId[dataTableName] = style;
		}
		return dataTableNameReditionId;
	},
	
	CLASS_NAME: "Geo.Service.GeoText"
	
});
/**
 *  Class: Geo.Service.Thematic
 *  专题图服务类
 * 
 * Inherits from:
 * - <Geo.Service>
 */
Geo.Service.Thematic = Geo.Class(Geo.Service, {
	
	/**
     * Constructor: Geo.Service.Thematic
     * Geo.Service.Thematic类的构造函数
     *
     * Parameters:
     * name - {String} 服务名称
     * url - {String} 服务地址
     * options - {Object} 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url, options) {
		this.name = name;
		this.url = url;
		this.format = new OpenLayers.Format.JSON();
		this.jsonp = new OpenLayers.Protocol.Script({
			format:this.format
		});
		OpenLayers.Util.extend(this, options);
	},
	
	/**
     * APIMethod: getCapabilities
     * 获取服务能力描述信息。
     * 
     * Parameters:
     * successFn - {Function} 请求成功的回调函数。
     * failFn - {Function} 请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn){
		var url = this.url;
		var params = {
			f:"json"
		};
		if(!failFn){
			failFn = function(){
				this.failFn();
			};
		}
		this.jsonp.createRequest(url,params, OpenLayers.Function.bind(function(result){
			successFn(result);
		},this));
	},
	
	/**
	 * APIMethod:getLegend
	 * Parameters:
	 * url - {String} 服务地址。
	 * layerID - {String} 图层ID。
	 * chartID - {String} 专题符号标识。
	 * format - {String} 返回的样式。
	 * colorSchemaID - {String} 色卡标识
	 * 
	 * Returns:
     * {String} 得到图例地址。
	 */
	getLegend: function(options) {
		//http://192.168.42.76:7021/ThematicMapService/tms/legend/0/020101.png?ColorSchemaID=3
		var location = options.url.indexOf("/",options.url.length - 1);
		if(location != -1) {
			options.url = options.url.substr(0,options.url.length - 1);
		}
		var path =  "${url}/legend/${layerID}/${chartID}.${format}";//?colorSchemaID = ${colorSchemaID}
		path = Geo.String.format(path, {
			'url': options.url, 
			'layerID': options.layerID, 
			'chartID': options.chartID,
			'format': options.format || "png"
		});
		if(typeof options.colorSchemaID === "string") {
			path += ("?colorSchemaID=" + options.colorSchemaID);
		}
		return path;
	},
	
	
	//异常
	//xxxxxx

	CLASS_NAME: "Geo.Service.Thematic"
});
/**
 * APIMethod: setProxyHost
 * 设置代理地址,根据自己的代理器地址来配置
 * 
 * Parameters:
 * proxyHost - {String} 代理地址
 * 
 */
Geo.Request.setProxyHost = function(proxyHost){
	OpenLayers.ProxyHost = proxyHost;
}

/**
 * APIMethod: getProxyHost
 * 代理地址
 *
 * Returns:
 * {String} 代理地址
 */
Geo.Request.getProxyHost = function(){
	return OpenLayers.ProxyHost;
}